{"additive_alpha.fs.glsl":"uniform lowp sampler2D _MainTex;  \r\nuniform lowp vec4 _MainColor;\r\nuniform lowp float _alpha;\r\nvarying mediump vec2 _base_uv;\r\n\r\nvoid main() \r\n{\r\n    lowp vec4 tmpvar_3 = texture2D(_MainTex, _base_uv)*_MainColor;\r\n    lowp float alpha=_alpha*tmpvar_3.a;\r\n    gl_FragData[0] =vec4(tmpvar_3.xyz,alpha);\r\n}","additive_alpha.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_MainColor('MainColor',Color) = (1,1,1,1)\",\r\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\r\n\t\t\"_alpha('alpha',float) = 1.0\"\r\n    ],\r\n    \"queue\": 0,\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"showface\": \"all\",\r\n\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"additive_alpha\",\r\n                \"fs\": \"additive_alpha\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"showface\": \"all\",\r\n\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"fog_additive_alpha\",\r\n                \"fs\": \"fog_additive_alpha\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"showface\": \"all\",\r\n\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"additive_alpha_bone_eff\",\r\n                \"fs\": \"additive_alpha\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"showface\": \"all\",\r\n\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"fog_additive_alpha_bone_eff\",\r\n                \"fs\": \"fog_additive_alpha\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","additive_alpha.vs.glsl":"attribute highp vec3 _glesVertex;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying mediump vec2 _base_uv;\r\n\r\n\r\nvoid main()\r\n{\r\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n\tgl_Position = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));\r\n}\r\n\r\n","additive_alpha_bone_eff.vs.glsl":"attribute highp vec3 _glesVertex;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform highp vec4 glstate_vec4_bones[80];\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying mediump vec2 _base_uv;\r\n\r\n\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy2 = 2.0 * quat.x * quat.y;\r\n\tfloat xz2 = 2.0 * quat.x * quat.z;\r\n\tfloat xw2 = 2.0 * quat.x * quat.w;\r\n\tfloat yz2 = 2.0 * quat.y * quat.z;\r\n\tfloat yw2 = 2.0 * quat.y * quat.w;\r\n\tfloat zw2 = 2.0 * quat.z * quat.w;\r\n\tfloat xx = quat.x * quat.x;\r\n\tfloat yy = quat.y * quat.y;\r\n\tfloat zz = quat.z * quat.z;\r\n\tfloat ww = quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(xx - yy - zz + ww)*s, (xy2 + zw2)*s, (xz2 - yw2)*s, 0,\r\n\t(xy2 - zw2)*s, (-xx + yy - zz + ww)*s, (yz2 + xw2)*s, 0,\r\n\t(xz2 + yw2)*s, (yz2 - xw2)*s, (-xx - yy + zz + ww)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz, 1.0);\r\n\r\n    int i = int(_glesBlendIndex4.x);\r\n    int i2 =int(_glesBlendIndex4.y);\r\n\tint i3 =int(_glesBlendIndex4.z);\r\n\tint i4 =int(_glesBlendIndex4.w);\r\n\r\n    mat4 mat = buildMat4(i)*_glesBlendWeight4.x\r\n\t\t\t + buildMat4(i2)*_glesBlendWeight4.y\r\n\t\t\t + buildMat4(i3)*_glesBlendWeight4.z\r\n\t\t\t + buildMat4(i4)*_glesBlendWeight4.w;\r\n\r\n    gl_Position = (glstate_matrix_mvp * mat)* tmpvar_1;\r\n}","additive_uvroll.fs.glsl":"\nprecision mediump float;\n\nvarying vec2 v_uv;\n\nuniform vec4 _TintColor;\nuniform sampler2D _MainTex;\n\nvoid main()\n{\n    gl_FragColor = 2.0 * _TintColor * texture2D(_MainTex, v_uv);\n}","additive_uvroll.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_UVSpeedX('UV SpeedX',float) = 0.0\",\n    \"_UVSpeedY('UV SpeedY',float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"additive_uvroll\",\n        \"fs\": \"additive_uvroll\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"additive_uvroll\",\n        \"fs\": \"additive_uvroll\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","additive_uvroll.vs.glsl":"\nprecision mediump float;  \n\n//坐标属性\nattribute vec3 _glesVertex;\nattribute vec2 _glesMultiTexCoord0;\n\nuniform mat4 glstate_matrix_mvp;\n\nuniform vec4 _MainTex_ST;\n\nuniform float _UVSpeedX;\nuniform float _UVSpeedY;\nuniform float glstate_timer;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\n\nvoid main() \n{\n    vec4 position = vec4(_glesVertex.xyz, 1.0);\n    //输出uv\n    v_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw + vec2(_UVSpeedX,_UVSpeedY) * glstate_timer;\n\n    //计算投影坐标\n    gl_Position = glstate_matrix_mvp * position;\n}","alphablended_uvroll.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_UVSpeedX('UV SpeedX',float) = 0.0\",\n    \"_UVSpeedY('UV SpeedY',float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"additive_uvroll\",\n        \"fs\": \"additive_uvroll\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"additive_uvroll\",\n        \"fs\": \"additive_uvroll\"\n      }\n    ],\n    \"shadowgen\": [],\n    \"bone\": [],\n    \"shadowuse\": []\n  }\n}","bloom.fs.glsl":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform sampler2D       _MainTex;//清晰图\nuniform sampler2D       _BlurTex;//模糊高光的图\nuniform highp vec4      _MainTex_TexelSize;\n\nuniform highp float     _bloomIntensity;\n// 强度 - 附加光（影响到该特效的光源）的全局光强\nuniform highp vec4     _blurSpread;\n// 模糊扩散 - Frag down sample 的偏移距离\nuniform highp float     _bloomThreshold;\n// 阈值 - 图像中亮度高于该阈值的区域将产生泛光效果\n\nvarying highp vec2      xlv_TEXCOORD0;   // 每个片元的纹素坐标\n\n#define INTENSITY       _bloomIntensity\n#define THRESHOLD       _bloomThreshold\n#define BLUR_SPREAD     vec2(_blurSpread.xy * _MainTex_TexelSize.xy)\n\n#define tex(t, uv)      texture2D((t), (uv))\n\n//texture2DEtC1Mark\n\nfloat luminance(vec3 rgb) {\n    const vec3 w = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, w);\n}\n// Blur spread 扩撒\nvec4 fragDownsample(sampler2D image, vec2 uv) {\n    vec2 uv2[4];\n    uv2[0] = uv + _MainTex_TexelSize.xy * vec2(1.5, 1.5);\n    uv2[1] = uv + _MainTex_TexelSize.xy * vec2(-1.5, 1.5);\n    uv2[2] = uv + _MainTex_TexelSize.xy * vec2(-1.5, -1.5);\n    uv2[3] = uv + _MainTex_TexelSize.xy * vec2(1.5, -1.5);\n    vec4 color;\n    color += texture2D(image, uv2[0]);\n    color += texture2D(image, uv2[1]);\n    color += texture2D(image, uv2[2]);\n    color += texture2D(image, uv2[3]);\n    return max(color/4.0 - THRESHOLD, vec4(0.0)) * INTENSITY;\n}\nvec4 fastBlur(sampler2D image, vec2 uv, vec2 netFilterWidth) {\n\n    vec4 blur = vec4(0.0);\n    vec2 _offset[7];\n    vec4 curve[7];\n    curve[0] = vec4(0.0205, 0.0205, 0.0205, 0.0);\n    curve[1] = vec4(0.0855, 0.0855, 0.0855, 0.0);\n    curve[2] = vec4(0.232, 0.232, 0.232, 0.0);\n    curve[3] = vec4(0.324, 0.324, 0.324, 1.0);\n    curve[4] = vec4(0.232, 0.232, 0.232, 0.0);\n    curve[5] = vec4(0.0855, 0.0855, 0.0855, 0.0);\n    curve[6] = vec4(0.0205, 0.0205, 0.0205, 0.0);\n    // horizontal or vertical blur, defined by netFilterWidth vector\n    _offset[0] = uv + netFilterWidth * 3.0;\n    _offset[1] = uv + netFilterWidth * 2.0;\n    _offset[2] = uv + netFilterWidth;\n    _offset[3] = uv;\n    _offset[4] = uv - netFilterWidth;\n    _offset[5] = uv - netFilterWidth * 2.0;\n    _offset[6] = uv - netFilterWidth * 3.0;\n    for(int l = 0; l < 7; l++) {\n        blur += tex(image, _offset[l]) * curve[l];\n    }\n\n    return blur;\n}\n\nvoid main () {\n    if(BLUR_SPREAD.x == 0.0 && BLUR_SPREAD.y == 0.0) {    // 不泛光, 只过滤\n        gl_FragColor = fragDownsample(_MainTex, xlv_TEXCOORD0);\n    } else if(THRESHOLD == 1.0){    // 不过滤, 只泛光\n        gl_FragColor = fastBlur(_MainTex, xlv_TEXCOORD0, BLUR_SPREAD);\n    } else {    // Final Composition\n        vec4 originColor = texture2D(_MainTex, xlv_TEXCOORD0);\n        originColor = vec4(originColor.rgb * INTENSITY, originColor.a);\n        vec4 bloomColor = texture2D(_BlurTex, xlv_TEXCOORD0);\n        gl_FragColor = originColor + bloomColor;\n    }\n\n    // vec4 c = texture2D(_MainTex, xlv_TEXCOORD0);\n    // vec4 cur_color;\n    // cur_color = fastBlur(_MainTex, xlv_TEXCOORD0,BLUR_SPREAD);\n    //\n    // c = vec4(c.rgb * INTENSITY, c.a) / 2.0;\n    // gl_FragColor = c;\n}\n","bloom.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_bloomFactor('bloomFactor',Range(0.0,1.0)) = 2.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"bloom\"\n            }\n        ],\n        \"quad\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"quad\",\n                \"fs\": \"bloom\"\n            }\n        ]\n    }\n}","custom_outLight.fs.glsl":"precision lowp float;\r\nuniform lowp float _rimPower;\r\nuniform lowp vec4 _rimColor;\r\nuniform lowp sampler2D _MainTex;\r\nuniform lowp vec4 _MainColor;\r\nuniform lowp float _AlphaCut;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n\r\n//light\r\nlowp vec4 xlv_COLOR = vec4(0.0,0.0,0.0,1.0); \r\nbool hasLight = false;\r\nlowp vec3 fixedAmbient = vec3(0.6,0.6,0.6);\r\nuniform lowp float glstate_lightcount;\r\nuniform lowp vec4 glstate_vec4_lightposs[8];\r\nuniform lowp vec4 glstate_vec4_lightdirs[8];\r\nuniform lowp float glstate_float_spotangelcoss[8];\r\nuniform lowp vec4 glstate_vec4_lightcolors[8];\r\nuniform lowp float glstate_float_lightrange[8];\r\nuniform lowp float glstate_float_lightintensity[8];\r\n\r\nvarying lowp vec3 v_N;\r\nvarying lowp vec3 v_Mpos;\r\n\r\nvarying mediump vec3 v_RimN;\r\nvarying mediump vec3 v_RimCamdir;\r\n//texture2DEtC1Mark\r\n\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color; \r\nvarying lowp float factor;\r\n#endif\r\n\r\n//calcDiffuse 计算漫反射强度函数\r\n//统一三种光源的传参方式，在函数内混合，方便就不高效\r\n//只需要方向光时另写\r\n//N 世界空间法线\r\n//worldpos 世界空间pos\r\n//lightPos 光源位置,w=0 表示方向光\r\n//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot\r\n//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来\r\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot,lowp float range )\r\n{\r\n    lowp vec3 v3 = lightPos.xyz - worldpos;\r\n    lowp float len = length(v3);\r\n    len = len > range ? range : len;\r\n    //求入射角，点光源&聚光灯\r\n    lowp vec3 L = normalize(v3); \r\n    //求张角 聚光灯 也是方向光入射角\r\n    lowp vec3 L2 = -lightDir.xyz;\r\n    lowp float dotSpot = dot(L,L2);\r\n    //漫反射强度\r\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0) * pow(1.0 - len/range,2.0); \r\n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \r\n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\r\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\r\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\r\n    return diffuse;\r\n}\r\n\r\nvoid calcCOLOR(){\r\n    int c =int(glstate_lightcount);\r\n\tif(c>0){\r\n        hasLight = true;\r\n        lowp float diff=0.0;\r\n\t\t//calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);\r\n\t\tfor(int i=0;i<8;i++)\r\n\t\t{\r\n\t\t\tif(i>=c)break;\r\n\t\t\t//diff += calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\r\n\t\t\tdiff = calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\r\n            xlv_COLOR += glstate_float_lightintensity[i] * glstate_vec4_lightcolors[i] * diff;\r\n\t\t}\r\n\t\txlv_COLOR.w = 1.0;  \r\n    }\r\n}\r\n\r\nvoid main() \r\n{\r\n    lowp vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    if(basecolor.a < _AlphaCut)\r\n        discard;\r\n    lowp vec4 fristColor=basecolor*_MainColor;\r\n    lowp vec4 emission = fristColor;\r\n\r\n    //----------------------------------------------------------\r\n    //light\r\n    calcCOLOR();\r\n    \r\n    #ifdef LIGHTMAP\r\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    emission.xyz *= decode_hdr(lightmap);\r\n    if(hasLight){ // have light\r\n        fristColor = fristColor * xlv_COLOR ;\r\n        emission = emission + mix(vec4(1.0, 1.0, 1.0, 1.0), fristColor, fristColor.wwww);\r\n    }\r\n    #else\r\n\tif(hasLight){ // have light\r\n        emission = (fristColor * xlv_COLOR) + (fristColor * vec4(fixedAmbient,1.0));\r\n    }\r\n    #endif\r\n\r\n    #ifdef FOG\r\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    #endif\r\n\r\n    //--------------------------------边缘发光处理---------------------------\r\n    // float tmpvar_6 = (1.0 - max(0.0, dot( normalize(v_RimCamdir) , normalize(v_RimN))));\r\n    float tmpvar_6 = (1.0 - max(0.0, dot( (v_RimCamdir) , (v_RimN))));\r\n    vec3 rimColor_1 = vec3(0.0, 0.0, 0.0);\r\n    if(_rimPower > 0.0)\r\n    {\r\n        rimColor_1 = ((_rimColor * pow(tmpvar_6, (1.0 / _rimPower))) * 3.0).xyz;\r\n    }\r\n\r\n    emission.xyz = (emission.xyz + rimColor_1);\r\n    //-------------------------------------------------------------------------\r\n\r\n    gl_FragData[0] = emission;\r\n}","custom_outLight.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_rimColor ('RimColor', Color) = (1,1,1,1)\",\r\n        \"_rimPower('RimPower',Range(0.0,10.0)) = 0.1\",\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\r\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\r\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"custom_outLight\",\r\n                \"fs\": \"custom_outLight\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"custom_outLight\",\r\n                \"fs\": \"custom_outLight\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"custom_outLight\",\r\n                \"fs\": \"custom_outLight\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"custom_outLight\",\r\n                \"fs\": \"custom_outLight\"\r\n            }\r\n        ]\r\n    }\r\n}","custom_outLight.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\n//light\r\nlowp mat4 blendMat ;\r\nattribute lowp vec3 _glesNormal;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_world2object;\r\nuniform lowp float glstate_lightcount;\r\nuniform highp vec4 glstate_eyepos;\r\n\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\nvarying highp vec3 v_N;\r\nvarying highp vec3 v_Mpos;\r\n\r\nvarying mediump vec3 v_RimN;\r\nvarying mediump vec3 v_RimCamdir;\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n#define conv_mxt4x4_0(mat4x4) vec4(mat4x4[0].x,mat4x4[1].x,mat4x4[2].x,mat4x4[3].x)\r\n#define conv_mxt4x4_1(mat4x4) vec4(mat4x4[0].y,mat4x4[1].y,mat4x4[2].y,mat4x4[3].y)\r\n#define conv_mxt4x4_2(mat4x4) vec4(mat4x4[0].z,mat4x4[1].z,mat4x4[2].z,mat4x4[3].z)\r\n\r\n#ifdef SKIN\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n\r\n#endif\r\n\r\nvoid calcNormal(highp vec4 pos){\r\n\t// int c =int(glstate_lightcount);\r\n\t// if(c>0){\r\n\t\t//求世界空间法线\r\n\t\t#ifdef SKIN\r\n\t\tv_N = normalize(mat3(blendMat) * _glesNormal);\r\n\t\t#else\r\n\t\tv_N = _glesNormal;\r\n\t\t#endif\r\n\t\tlowp mat3 normalmat = mat3(glstate_matrix_model);\r\n        // v_RimN = normalize(v_N * tmpvar_2) ;    //发光法线方向\r\n\t\tv_N =normalize(normalmat*v_N);\r\n\t\tv_Mpos =(glstate_matrix_model * pos).xyz;\r\n\t// }\r\n}\r\n\r\nvoid main()\r\n{\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n\t//light\r\n    calcNormal(position);\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n     //--------------------边缘外发光-----------------------------------\r\n    mediump mat3 tmpvar_2;\r\n    tmpvar_2[0] = conv_mxt4x4_0(glstate_matrix_world2object).xyz;\r\n    tmpvar_2[1] = conv_mxt4x4_1(glstate_matrix_world2object).xyz;\r\n    tmpvar_2[2] = conv_mxt4x4_2(glstate_matrix_world2object).xyz;\r\n    v_RimN = normalize(v_N * tmpvar_2) ;    //发光法线方向\r\n    v_RimCamdir = normalize(glstate_eyepos.xyz - v_Mpos); //外发光视线方向\r\n    //----------------------------------------------------------------\r\n\r\n    gl_Position = position;\r\n}","d3UI.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n\t\"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"zwrite\":\"on\",\r\n                \"ztest\":\"on\",\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"all\",\r\n                \"vs\": \"lineui\",\r\n                \"fs\": \"lineui\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","diffuse.fs.glsl":"precision lowp float;\nuniform lowp sampler2D _MainTex;\nvarying mediump vec2 xlv_TEXCOORD0;\n\nlowp vec4 f_MainColor;\nlowp float f_AlphaCut;\n#ifdef INSTANCE\nvarying lowp vec4 v_MainColor;\nvarying lowp float v_AlphaCut;\n#else\nuniform lowp vec4 _MainColor;\nuniform lowp float _AlphaCut;\n#endif\n\n\n//light\nlowp vec4 xlv_COLOR = vec4(0.0,0.0,0.0,1.0); \nbool hasLight = false;\nlowp vec3 fixedAmbient = vec3(0.6,0.6,0.6);\nuniform lowp float glstate_lightcount;\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\nuniform lowp vec4 glstate_vec4_lightcolors[8];\nuniform lowp float glstate_float_lightrange[8];\nuniform lowp float glstate_float_lightintensity[8];\n\nvarying lowp vec3 v_N;\nvarying lowp vec3 v_Mpos;\n\n//texture2DEtC1Mark\n\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\n//calcDiffuse 计算漫反射强度函数\n//统一三种光源的传参方式，在函数内混合，方便就不高效\n//只需要方向光时另写\n//N 世界空间法线\n//worldpos 世界空间pos\n//lightPos 光源位置,w=0 表示方向光\n//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot\n//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot,lowp float range )\n{\n    lowp vec3 v3 = lightPos.xyz - worldpos;\n    lowp float len = length(v3);\n    len = len > range ? range : len;\n    //求入射角，点光源&聚光灯\n    lowp vec3 L = normalize(v3); \n    //求张角 聚光灯 也是方向光入射角\n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //漫反射强度\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0) * pow(1.0 - len/range,2.0); \n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n    return diffuse;\n}\n\nvoid calcCOLOR(){\n    int c =int(glstate_lightcount);\n\tif(c>0){\n        hasLight = true;\n        lowp float diff=0.0;\n\t\t//calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);\n\t\tfor(int i=0;i<8;i++)\n\t\t{\n\t\t\tif(i>=c)break;\n\t\t\t//diff += calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\n\t\t\tdiff = calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\n            xlv_COLOR += glstate_float_lightintensity[i] * glstate_vec4_lightcolors[i] * diff;\n\t\t}\n\t\txlv_COLOR.w = 1.0;  \n    }\n}\n\nvoid main() \n{\n\n    #ifdef INSTANCE\n        f_MainColor = v_MainColor;\n        f_AlphaCut = v_AlphaCut;\n    #else\n        f_MainColor = _MainColor;\n        f_AlphaCut = _AlphaCut;\n    #endif\n\n\n    lowp vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\n    // if(basecolor.a < _AlphaCut)\n    if(basecolor.a < f_AlphaCut)\n        discard;\n    // lowp vec4 fristColor=basecolor*_MainColor;\n    lowp vec4 fristColor=basecolor*f_MainColor;\n    lowp vec4 emission = fristColor;\n\n    //----------------------------------------------------------\n    //light\n    calcCOLOR();\n    \n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    emission.xyz *= decode_hdr(lightmap);\n    if(hasLight){ // have light\n        fristColor = fristColor * xlv_COLOR ;\n        emission = emission + mix(vec4(1.0, 1.0, 1.0, 1.0), fristColor, fristColor.wwww);\n    }\n    #else\n\tif(hasLight){ // have light\n        emission = (fristColor * xlv_COLOR) + (fristColor * vec4(fixedAmbient,1.0));\n    }\n    #endif\n\n    #ifdef FOG\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    #endif\n    \n    gl_FragData[0] = emission;\n}","diffuse.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"instance\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"instance_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ]\n    }\n}","diffuse.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n//light\r\nlowp mat4 blendMat ;\r\nattribute lowp vec3 _glesNormal;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform lowp float glstate_lightcount;\r\n\r\nvarying highp vec3 v_N;\r\nvarying highp vec3 v_Mpos;\r\n\r\n#ifdef INSTANCE\r\nattribute lowp vec4 _MainColor;\r\nattribute lowp float _AlphaCut;\r\nvarying lowp vec4 v_MainColor;\r\nvarying lowp float v_AlphaCut;\r\nattribute highp vec4 instance_offset_matrix_0;\r\nattribute highp vec4 instance_offset_matrix_1;\r\nattribute highp vec4 instance_offset_matrix_2;\r\nattribute highp vec4 instance_offset_matrix_3;\r\n#endif\r\n\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n\r\n#endif\r\n\r\nvoid calcNormal(highp vec4 pos){\r\n\tint c =int(glstate_lightcount);\r\n\tif(c>0){\r\n\t\t//求世界空间法线\r\n\t\t#ifdef SKIN\r\n\t\tv_N = normalize(mat3(blendMat) * _glesNormal);\r\n\t\t#else\r\n\t\tv_N = _glesNormal;\r\n\t\t#endif\r\n\t\tlowp mat3 normalmat = mat3(glstate_matrix_model);\r\n\t\tv_N =normalize(normalmat*v_N);\r\n\t\tv_Mpos =(glstate_matrix_model * pos).xyz;\r\n\t}\r\n}\r\n\r\nvoid main()\r\n{\r\n\t#ifdef INSTANCE\r\n\t\tv_MainColor = _MainColor;\r\n\t\tv_AlphaCut = _AlphaCut;\r\n    #endif\r\n\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n\t//light\r\n    calcNormal(position);\r\n\t#ifdef INSTANCE\r\n        highp mat4 instance_offset_matrix = mat4(instance_offset_matrix_0,instance_offset_matrix_1,instance_offset_matrix_2,instance_offset_matrix_3);\r\n        position = instance_offset_matrix * position;\r\n    #endif\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n\r\n    gl_Position =position;\r\n}","diffuse_bothside.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\r\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\r\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\r\n    ],\r\n    \"passes\": {\r\n\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ],\r\n        \"lightmap\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ],\r\n        \"lightmap_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ]\r\n    }\r\n}","diffuse_nolight.fs.glsl":"precision lowp float;\r\nuniform lowp sampler2D _MainTex;\r\nuniform lowp vec4 _MainColor;\r\nuniform lowp float _AlphaCut;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n\r\n//texture2DEtC1Mark\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color; \r\nvarying lowp float factor;\r\n#endif\r\n\r\nvoid main() \r\n{\r\n    lowp vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    if(basecolor.a < _AlphaCut)\r\n        discard;\r\n    lowp vec4 fristColor=basecolor*_MainColor;\r\n    lowp vec4 emission = fristColor;\r\n\r\n    //----------------------------------------------------------\r\n    \r\n    #ifdef LIGHTMAP\r\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    emission.xyz *= decode_hdr(lightmap);\r\n    #endif\r\n\r\n    #ifdef FOG\r\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    #endif\r\n    \r\n    gl_FragData[0] = emission;\r\n}","diffuse_nolight.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\r\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\r\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\r\n    ],\r\n    \"passes\": {\r\n\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ],\r\n        \"lightmap\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ],\r\n        \"lightmap_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ]\r\n    }\r\n}","diffuse_nolight.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n\tlowp mat4 blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n\r\n    gl_Position =position;\r\n}","diffuse_nolight_bothside.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\r\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\r\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\r\n    ],\r\n    \"passes\": {\r\n\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ],\r\n        \"lightmap\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ],\r\n        \"lightmap_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"diffuse_nolight\",\r\n                \"fs\": \"diffuse_nolight\"\r\n            }\r\n        ]\r\n    }\r\n}","f14trans.fs.glsl":"uniform mediump sampler2D _Main_Tex;\r\n\r\nvarying lowp vec4 xlv_COLOR;\r\nvarying mediump vec2 xlv_TEXCOORD0;          \r\nvoid main() \r\n{\r\n    lowp vec4 basecolor = texture2D(_Main_Tex, xlv_TEXCOORD0);\r\n    gl_FragData[0] =basecolor*xlv_COLOR;\r\n    //gl_FragData[0] =vec4(1,0,0,1);\r\n}","f14trans.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;   \r\nattribute lowp vec4 _glesColor;\r\n\r\nuniform lowp vec4 _Main_Color;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _Main_Tex_ST;\r\n\r\n\r\nvarying lowp vec4 xlv_COLOR;\r\nvarying mediump vec2 xlv_TEXCOORD0;                \r\nvoid main()                                     \r\n{                                               \r\n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz,1.0);\r\n    // xlv_COLOR = _Main_Color*_glesColor;\r\n    xlv_COLOR = _Main_Color;\r\n\txlv_TEXCOORD0 =_glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\r\n                \r\n    gl_Position = (glstate_matrix_mvp *tmpvar_1);  \r\n}","f4skin.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"boneSampler('MainTex',Texture)='white'{}\",\r\n        \"boneSamplerTexelSize('boneSamplerTexelSize',float)=0.1\",\r\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\r\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\r\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\r\n    ],\r\n    \"passes\": {\r\n\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"f4skin\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"f4skin\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"f4skin\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"f4skin\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ],\r\n        \"lightmap\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"f4skin\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ],\r\n        \"lightmap_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"f4skin\",\r\n                \"fs\": \"diffuse\"\r\n            }\r\n        ]\r\n    }\r\n}","f4skin.vs.glsl":"precision highp float;\n\nattribute highp vec4 _glesVertex;\nattribute mediump vec4 _glesMultiTexCoord0;\nattribute highp vec4 _glesColor;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\n// varying mediump vec2 xlv_TEXCOORD0;\n\n// #ifdef LIGHTMAP\n// attribute mediump vec4 _glesMultiTexCoord1;\n// uniform mediump vec4 glstate_lightmapOffset;\n// // uniform mediump float glstate_lightmapUV;\n// varying mediump vec2 lightmap_TEXCOORD;\n// #endif\n\n\n// NOTE: diffuse cap\nvarying lowp vec3 v_N;\nvarying lowp vec3 v_Mpos;\nvarying mediump vec2 xlv_TEXCOORD0;\nvarying mediump vec2 lightmap_TEXCOORD;\n\n\n//texture2DEtC1Mark\n\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n#define SKIN2\n\n#define SKIN\n#ifdef SKIN\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\n\n#ifdef SKIN2\n// uniform highp mat4 glstate_matrix_bones[24];\nuniform highp sampler2D boneSampler;\nuniform highp float boneSamplerTexelSize;\nuniform highp vec4 boneSampler_TexelSize;\n\nmat4 readMatrixSampler(sampler2D smp, float index) {\n    float offset = index * 4.;\n    return mat4(\n\t\ttexture2D(smp, vec2(boneSamplerTexelSize * (offset + 0.5), 0)),\n\t\ttexture2D(smp, vec2(boneSamplerTexelSize * (offset + 1.5), 0)),\n\t\ttexture2D(smp, vec2(boneSamplerTexelSize * (offset + 2.5), 0)),\n\t\ttexture2D(smp, vec2(boneSamplerTexelSize * (offset + 3.5), 0))\n\t\t);\n}\nhighp vec4 calcVertexF4(highp vec4 srcVertex) {\n\tmat4 mat = _glesBlendWeight4[0] * readMatrixSampler(boneSampler, _glesBlendIndex4[0])\n\t\t\t+ _glesBlendWeight4[1] * readMatrixSampler(boneSampler, _glesBlendIndex4[1])\n\t\t\t+ _glesBlendWeight4[2] * readMatrixSampler(boneSampler, _glesBlendIndex4[2])\n\t\t\t+ _glesBlendWeight4[3] * readMatrixSampler(boneSampler, _glesBlendIndex4[3]);\n\treturn mat * srcVertex;\n}\n#endif\n\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tmat4 matrix = mat4(\n\t1.0-yy-zz, xy+zw, xz-yw, 0,\n\txy-zw, 1.0-xx-zz, yz + xw, 0,\n\txz + yw, yz - xw, 1.0-xx-yy, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n\tlowp mat4 blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat * srcVertex;\n}\n\n#endif\n\n// varying highp vec4 vcolor;\n\n\nvoid main()\n{\n\t//ios 问题 ，必须给默认值\n\tv_N = vec3(0,0,0);\n\tv_Mpos = vec3(0,0,0);\n\tlightmap_TEXCOORD = vec2(0,0);\n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n\tmat4 mat = _glesBlendWeight4[0] * readMatrixSampler(boneSampler, _glesBlendIndex4[0])\n\t\t\t+ _glesBlendWeight4[1] * readMatrixSampler(boneSampler, _glesBlendIndex4[1])\n\t\t\t+ _glesBlendWeight4[2] * readMatrixSampler(boneSampler, _glesBlendIndex4[2])\n\t\t\t+ _glesBlendWeight4[3] * readMatrixSampler(boneSampler, _glesBlendIndex4[3]);\n\t// mat = mat4(\n\t// \tvec4(1, 0, 0, 0),\n\t// \tvec4(0, 1, 0, 0),\n\t// \tvec4(0, 0, 1, 0),\n\t// \tvec4(0, 0, 0, 1)\n\t// \t);\n\t// mat = _glesBlendWeight4.x * glstate_matrix_bones[int(_glesBlendIndex4.x)]\n\t// \t\t+ _glesBlendWeight4.y * glstate_matrix_bones[int(_glesBlendIndex4.y)]\n\t// \t\t+ _glesBlendWeight4.z * glstate_matrix_bones[int(_glesBlendIndex4.z)]\n\t// \t\t+ _glesBlendWeight4.w * glstate_matrix_bones[int(_glesBlendIndex4.w)];\n\n\t\n\t// vcolor = vec4(texture2D(boneSampler, _glesVertex.xz / vec2(8., 0)/ 3.).rgb, 1);\n    \n\t\n\t// xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    // //----------------------------------------------------------\n    // #ifdef LIGHTMAP\n    // mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    // lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    // lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    // lightmap_TEXCOORD = vec2(u,v);\n    // #endif\n\n    #ifdef SKIN\n    // position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n\tposition = mat * position;\n    #endif\n\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n\n    gl_Position =position;\n}","fog_additive_alpha.fs.glsl":"uniform mediump sampler2D _MainTex;  \r\nuniform lowp vec4 _MainColor;\r\nuniform lowp float _alpha;\r\nvarying mediump vec2 _base_uv;\r\n\r\nuniform lowp vec4 glstate_fog_color; \r\nvarying lowp float factor; \r\nvoid main() \r\n{\r\n    lowp vec4 tmpvar_3 = texture2D(_MainTex, _base_uv)*_MainColor;\r\n    lowp float alpha=_alpha*tmpvar_3.a;\r\n    lowp vec3 afterFog = mix(vec3(0,0,0), tmpvar_3.rgb, factor);\r\n    gl_FragData[0] = vec4(afterFog,alpha);\r\n}","fog_additive_alpha.vs.glsl":"attribute highp vec3 _glesVertex;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\n\r\nvarying lowp float factor;\r\nvarying mediump vec2 _base_uv;\r\n\r\n\r\nvoid main()\r\n{\r\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n\thighp vec4 pos = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));\r\n    factor = (glstate_fog_end - abs(pos.z))/(glstate_fog_end - glstate_fog_start); \r\n    factor = clamp(factor, 0.0, 1.0);  \r\n    gl_Position = pos;\r\n}","fog_additive_alpha_bone_eff.vs.glsl":"attribute highp vec3 _glesVertex;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nvarying mediump vec2 _base_uv;\r\n\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[80];\r\n\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy2 = 2.0 * quat.x * quat.y;\r\n\tfloat xz2 = 2.0 * quat.x * quat.z;\r\n\tfloat xw2 = 2.0 * quat.x * quat.w;\r\n\tfloat yz2 = 2.0 * quat.y * quat.z;\r\n\tfloat yw2 = 2.0 * quat.y * quat.w;\r\n\tfloat zw2 = 2.0 * quat.z * quat.w;\r\n\tfloat xx = quat.x * quat.x;\r\n\tfloat yy = quat.y * quat.y;\r\n\tfloat zz = quat.z * quat.z;\r\n\tfloat ww = quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(xx - yy - zz + ww)*s, (xy2 + zw2)*s, (xz2 - yw2)*s, 0,\r\n\t(xy2 - zw2)*s, (-xx + yy - zz + ww)*s, (yz2 + xw2)*s, 0,\r\n\t(xz2 + yw2)*s, (yz2 - xw2)*s, (-xx - yy + zz + ww)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz, 1.0);\r\n\r\n    int i = int(_glesBlendIndex4.x);\r\n    int i2 =int(_glesBlendIndex4.y);\r\n\tint i3 =int(_glesBlendIndex4.z);\r\n\tint i4 =int(_glesBlendIndex4.w);\r\n\r\n    mat4 mat = buildMat4(i)*_glesBlendWeight4.x\r\n\t\t\t + buildMat4(i2)*_glesBlendWeight4.y\r\n\t\t\t + buildMat4(i3)*_glesBlendWeight4.z\r\n\t\t\t + buildMat4(i4)*_glesBlendWeight4.w;\r\n\r\n\thighp vec4 pos = (glstate_matrix_mvp * mat)* tmpvar_1;\r\n    factor = (glstate_fog_end - abs(pos.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    gl_Position = pos;\r\n}","lineui.fs.glsl":"uniform sampler2D _MainTex;\r\nvarying lowp vec4 xlv_COLOR;\r\nvarying highp vec2 xlv_TEXCOORD0;\r\nvoid main()\r\n{\r\n    lowp vec4 tmpvar_3;\r\n    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\r\n    gl_FragData[0] = tmpvar_3;\r\n}","lineui.shader.json":"{\r\n    \"layer\": \"overlay\",\r\n\t\"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\",\r\n        \"_Superimposition('Superimposition', Range(0.0, 7.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"zwrite\":\"on\",\r\n                \"ztest\":\"on\",\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"all\",\r\n                \"vs\": \"lineui\",\r\n                \"fs\": \"lineui\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","lineui.vs.glsl":"attribute vec4 _glesVertex;    \r\nattribute vec4 _glesColor;                   \r\nattribute vec4 _glesMultiTexCoord0;          \r\nuniform highp mat4 glstate_matrix_mvp;       \r\nvarying lowp vec4 xlv_COLOR;                 \r\nvarying highp vec2 xlv_TEXCOORD0;            \r\nvoid main()                                      \r\n{                                                \r\n\thighp vec4 tmpvar_1;                         \r\n\ttmpvar_1.w = 1.0;                            \r\n\ttmpvar_1.xyz = _glesVertex.xyz;              \r\n\txlv_COLOR = _glesColor;                      \r\n\txlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \r\n\tgl_Position = (glstate_matrix_mvp * tmpvar_1);   \r\n}","particlesystem.fs.glsl":"\nprecision mediump float;\n\nvarying vec2 v_uv;\n\nuniform vec4 _TintColor;\nuniform sampler2D _MainTex;\n\nvarying vec4 v_color;\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\nvoid main()\n{\n    vec4 color = 2.0 * v_color * _TintColor * texture2D(_MainTex, v_uv);\n\n    #ifdef FOG\n        color.xyz = mix(glstate_fog_color.rgb, color.rgb, factor);\n    #endif\n    \n    gl_FragColor = color;\n}","particlesystem.vs.glsl":"\nprecision mediump float;  \n\n//坐标属性\nattribute vec3 _glesVertex;\nattribute vec2 _glesMultiTexCoord0;\n\nuniform mat4 glstate_matrix_mvp;\n\nuniform vec4 _MainTex_ST;\n\nuniform float _UVSpeedX;\nuniform float _UVSpeedY;\nuniform float glstate_timer;\n\nvarying vec4 v_color;\nvarying vec2 v_uv;\n\n#ifdef INSTANCE\n    attribute vec4 a_particle_position;\n    attribute vec4 a_particle_scale;\n    attribute vec4 a_particle_rotation;\n    attribute vec4 a_particle_color;\n    attribute vec4 a_particle_tilingOffset;\n    attribute vec4 a_particle_flipUV;\n#else\n    uniform vec4 a_particle_position;\n    uniform vec4 a_particle_scale;\n    uniform vec4 a_particle_rotation;\n    uniform vec4 a_particle_color;\n    uniform vec4 a_particle_tilingOffset;\n    uniform vec4 a_particle_flipUV;\n#endif\n\nuniform mat4 u_particle_billboardMatrix;\nuniform vec4 u_particle_pivotOffset;\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\nmat3 makeParticleRotationMatrix(vec3 rotation)\n{\n    float DEG2RAD = 3.1415926 / 180.0;\n    \n    float rx = rotation.x * DEG2RAD;\n    float ry = rotation.y * DEG2RAD;\n    float rz = rotation.z * DEG2RAD;\n\n    float sinX = sin(rx);\n    float cosX = cos(rx);\n    float sinY = sin(ry);\n    float cosY = cos(ry);\n    float sinZ = sin(rz);\n    float cosZ = cos(rz);\n\n    mat3 tmp;\n    float ce = cosY * cosZ;\n    float cf = cosY * sinZ;\n    float de = sinY * cosZ;\n    float df = sinY * sinZ;\n\n    float te0 = ce + df * sinX;\n    float te4 = de * sinX - cf;\n    float te8 = cosX * sinY;\n\n    float te1 = cosX * sinZ;\n    float te5 = cosX * cosZ;\n    float te9 = - sinX;\n\n    float te2 = cf * sinX - de;\n    float te6 = df + ce * sinX;\n    float te10 = cosX * cosY;\n\n    tmp[0] = vec3(te0, te1, te2);\n    tmp[1] = vec3(te4, te5, te6);\n    tmp[2] = vec3(te8, te9, te10);\n            \n    return tmp;\n}\n\nvec4 particleAnimation(vec4 position) \n{\n    mat3 billboardMatrix = mat3(u_particle_billboardMatrix[0].xyz,u_particle_billboardMatrix[1].xyz,u_particle_billboardMatrix[2].xyz);\n    \n    position.xyz = position.xyz + u_particle_pivotOffset.xyz;\n    \n    // 计算缩放\n    position.xyz = position.xyz * a_particle_scale.xyz;\n\n    // 计算旋转\n    mat3 rMat = makeParticleRotationMatrix(a_particle_rotation.xyz);\n    position.xyz = rMat * position.xyz;\n    position.xyz = billboardMatrix * position.xyz;\n\n    // 位移\n    position.xyz = position.xyz + a_particle_position.xyz;\n\n    // 颜色\n    v_color = a_particle_color;\n\n    if(a_particle_flipUV.x > 0.5) v_uv.x = 1.0 - v_uv.x;\n    if(a_particle_flipUV.y > 0.5) v_uv.y = 1.0 - v_uv.y;\n    v_uv = v_uv * a_particle_tilingOffset.xy + a_particle_tilingOffset.zw;\n    \n    return position;\n}\n\nvoid main() \n{\n    vec4 position = vec4(_glesVertex.xyz, 1.0);\n    //输出uv\n    v_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    position = particleAnimation(position);\n\n    v_uv = v_uv + vec2(_UVSpeedX,_UVSpeedY) * glstate_timer;\n\n    //计算投影坐标\n    position = glstate_matrix_mvp * position;\n\n    #ifdef FOG\n        factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n        factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n    gl_Position = position;\n}","particlesystem_additive.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_UVSpeedX('UV SpeedX',float) = 0.0\",\n    \"_UVSpeedY('UV SpeedY',float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance_fog\": [\n      {\n        \"blendmode\": \"add\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ]\n  }\n}","particlesystem_additive_transparent_particles_standard.shader.json":"{\r\n  \"layer\": \"transparent\",\r\n  \"queue\": 0,\r\n  \"properties\": [\r\n    \"_BasicColor('Basic Color', Color) = (0.5,0.5,0.5,0.5)\",\r\n    \"_SaturatedColor('Saturated Color', Color) = (0.5,0.5,0.5,0.5)\",\r\n\r\n    \"_MainTex('Particle Texture',Texture)='white'{}\",\r\n    \"_ColorRamp('Color Ramp', Texture) = 'white' {}\",\r\n    \"_NoiseTex('Noise Texture', Texture) = 'white' {}\",\r\n\r\n    \"_EmissionSaturation('Emission saturation', Range(0.0, 8.0)) = 1.0\",\r\n    \"_OpacitySaturation('Opacity saturation', Range(0.0, 8.0)) = 1.0\",\r\n    \"_ColorMultiplier('Color multiplier', Range(0.0, 8.0)) = 1.0\",\r\n    \"_ABOffset('Alpha blend offset', Range(0.0, 8.0)) = 0.0\",\r\n    \r\n    \"_DissolveStep('DissolveStep.xy', Vector) = (0.0, 1.0, 0.0, 0.0)\",\r\n    \r\n    \"_Panning('Automatic Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\r\n\r\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\r\n    \"_GlobalAlpha('Global alpha', float) = 1.0\",\r\n    \r\n    \"_EmissivePower('Emissive Power', Range(1.0, 4.0)) = 1.0\",\r\n    \"_NoisePanning('Noise Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\r\n    \r\n    \"COLOR_RAMP('COLOR_RAMP', float) = 0.0\",\r\n    \"COLOR_TINT('COLOR_TINT', float) = 0.0\",\r\n    \"APPLY_RGB_COLOR_VERTEX('APPLY_RGB_COLOR_VERTEX', float) = 0.0\",\r\n    \"DISSOLVE_ENABLED('DISSOLVE_ENABLED', float) = 0.0\",\r\n    \"AUTOMATICPANNING('AUTOMATICPANNING', float) = 0.0\",\r\n    \"EMISSIVEPOWER('EMISSIVEPOWER', float) = 0.0\",\r\n    \"EXTENDED_PARTICLES('EXTENDED_PARTICLES', float) = 0.0\",\r\n    \"NOISE_TEXTURE('NOISE_TEXTURE', float) = 0.0\",\r\n    \"NOISE_TEXTURE_EMISSION('NOISE_TEXTURE_EMISSION', float) = 0.0\",\r\n    \"NOISE_TEXTURE_ALPHA('NOISE_TEXTURE_ALPHA', float) = 0.0\",\r\n    \"NOISE_TEXTURE_DISSOLVE('NOISE_TEXTURE_DISSOLVE', float) = 0.0\",\r\n    \"NOISEUV('NOISEUV', float) = 0.0\",\r\n    \"FLOWMAP('FLOWMAP', float) = 0.0\",\r\n    \"BlendMode('BlendMode', float) = 0.0\"\r\n  ],\r\n  \"passes\": {\r\n    \"base\": [\r\n      {\r\n        \"blendmode\": \"add\",\r\n        \"showface\": \"all\",\r\n        \"zwrite\": \"off\",\r\n        \"vs\": \"particlesystem_transparent_particles_standard\",\r\n        \"fs\": \"particlesystem_transparent_particles_standard\"\r\n      }\r\n    ],\r\n    \"base_fog\": [\r\n      {\r\n        \"blendmode\": \"add\",\r\n        \"showface\": \"all\",\r\n        \"zwrite\": \"off\",\r\n        \"vs\": \"particlesystem_transparent_particles_standard\",\r\n        \"fs\": \"particlesystem_transparent_particles_standard\"\r\n      }\r\n    ],\r\n    \"shadowgen\": [],\r\n    \"bone\": [],\r\n    \"shadowuse\": []\r\n  }\r\n}","particlesystem_alphablended.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\": 0,\n  \"properties\": [\n    \"_MainTex('MainTex',Texture)='white'{}\",\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\n    \"_UVSpeedX('UV SpeedX',float) = 0.0\",\n    \"_UVSpeedY('UV SpeedY',float) = 0.0\"\n  ],\n  \"passes\": {\n    \"base\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"base_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ],\n    \"instance_fog\": [\n      {\n        \"blendmode\": \"blend\",\n        \"showface\": \"all\",\n        \"zwrite\": \"off\",\n        \"vs\": \"particlesystem\",\n        \"fs\": \"particlesystem\"\n      }\n    ]\n  }\n}","particlesystem_alphablended_transparent_particles_standard.shader.json":"{\r\n  \"layer\": \"transparent\",\r\n  \"queue\": 0,\r\n  \"properties\": [\r\n    \"_BasicColor('Basic Color', Color) = (0.5,0.5,0.5,0.5)\",\r\n    \"_SaturatedColor('Saturated Color', Color) = (0.5,0.5,0.5,0.5)\",\r\n\r\n    \"_MainTex('Particle Texture',Texture)='white'{}\",\r\n    \"_ColorRamp('Color Ramp', Texture) = 'white' {}\",\r\n    \"_NoiseTex('Noise Texture', Texture) = 'white' {}\",\r\n\r\n    \"_EmissionSaturation('Emission saturation', Range(0.0, 8.0)) = 1.0\",\r\n    \"_OpacitySaturation('Opacity saturation', Range(0.0, 8.0)) = 1.0\",\r\n    \"_ColorMultiplier('Color multiplier', Range(0.0, 8.0)) = 1.0\",\r\n    \"_ABOffset('Alpha blend offset', Range(0.0, 8.0)) = 0.0\",\r\n    \r\n    \"_DissolveStep('DissolveStep.xy', Vector) = (0.0, 1.0, 0.0, 0.0)\",\r\n    \r\n    \"_Panning('Automatic Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\r\n\r\n    \"_TintColor ('Tint Color', Color) = (0.5,0.5,0.5,0.5)\",\r\n    \"_GlobalAlpha('Global alpha', float) = 1.0\",\r\n    \r\n    \"_EmissivePower('Emissive Power', Range(1.0, 4.0)) = 1.0\",\r\n    \"_NoisePanning('Noise Panning', Vector) = (0.0, 0.0, 0.0, 0.0)\",\r\n    \r\n    \"COLOR_RAMP('COLOR_RAMP', float) = 0.0\",\r\n    \"COLOR_TINT('COLOR_TINT', float) = 0.0\",\r\n    \"APPLY_RGB_COLOR_VERTEX('APPLY_RGB_COLOR_VERTEX', float) = 0.0\",\r\n    \"DISSOLVE_ENABLED('DISSOLVE_ENABLED', float) = 0.0\",\r\n    \"AUTOMATICPANNING('AUTOMATICPANNING', float) = 0.0\",\r\n    \"EMISSIVEPOWER('EMISSIVEPOWER', float) = 0.0\",\r\n    \"EXTENDED_PARTICLES('EXTENDED_PARTICLES', float) = 0.0\",\r\n    \"NOISE_TEXTURE('NOISE_TEXTURE', float) = 0.0\",\r\n    \"NOISE_TEXTURE_EMISSION('NOISE_TEXTURE_EMISSION', float) = 0.0\",\r\n    \"NOISE_TEXTURE_ALPHA('NOISE_TEXTURE_ALPHA', float) = 0.0\",\r\n    \"NOISE_TEXTURE_DISSOLVE('NOISE_TEXTURE_DISSOLVE', float) = 0.0\",\r\n    \"NOISEUV('NOISEUV', float) = 0.0\",\r\n    \"FLOWMAP('FLOWMAP', float) = 0.0\",\r\n    \"BlendMode('BlendMode', float) = 0.0\"\r\n  ],\r\n  \"passes\": {\r\n    \"base\": [\r\n      {\r\n        \"blendmode\": \"blend\",\r\n        \"showface\": \"all\",\r\n        \"zwrite\": \"off\",\r\n        \"vs\": \"particlesystem_transparent_particles_standard\",\r\n        \"fs\": \"particlesystem_transparent_particles_standard\"\r\n      }\r\n    ],\r\n    \"base_fog\": [\r\n      {\r\n        \"blendmode\": \"blend\",\r\n        \"showface\": \"all\",\r\n        \"zwrite\": \"off\",\r\n        \"vs\": \"particlesystem_transparent_particles_standard\",\r\n        \"fs\": \"particlesystem_transparent_particles_standard\"\r\n      }\r\n    ],\r\n    \"shadowgen\": [],\r\n    \"bone\": [],\r\n    \"shadowuse\": []\r\n  }\r\n}","particlesystem_transparent_particles_standard.fs.glsl":"precision mediump float;\r\n\r\nuniform sampler2D _MainTex;\r\n\r\nuniform vec4 u_color;\r\n\r\nuniform float EXTENDED_PARTICLES;\r\nuniform float _EmissionSaturation;\r\nuniform float _OpacitySaturation;\r\nuniform float _ColorMultiplier;\r\n\r\nuniform float COLOR_RAMP;\r\nuniform sampler2D _ColorRamp;\r\nuniform vec4 _ColorRamp_ST;\r\nuniform float COLOR_TINT;\r\nuniform vec4 _BasicColor;\r\nuniform vec4 _SaturatedColor;\r\n\r\nuniform float DISSOLVE_ENABLED;\r\nuniform vec4 _DissolveStep;\r\n\r\nuniform float NOISE_TEXTURE;\r\nuniform sampler2D _NoiseTex;\r\nuniform vec4 _TintColor;\r\n\r\nuniform float EMISSIVEPOWER;\r\nuniform float _EmissivePower;\r\n\r\nuniform float _ABOffset;\r\n\r\nuniform float _GlobalAlpha;\r\n\r\nvarying vec2 v_uv;\r\nvarying vec4 v_color;\r\n\r\nvarying vec2 v_particledata;\r\nvarying vec2 v_noiseuv;\r\n\r\nuniform float APPLY_RGB_COLOR_VERTEX;\r\nuniform float NOISE_TEXTURE_EMISSION;\r\nuniform float NOISE_TEXTURE_ALPHA;\r\nuniform float NOISE_TEXTURE_DISSOLVE;\r\n\r\nuniform float BlendMode;\r\n\r\nvoid main() \r\n{\r\n    vec4 tex = texture2D(_MainTex, v_uv);\r\n\r\n    vec4 col = vec4(1.0, 1.0, 1.0, 1.0);\r\n\r\n    vec4 vcolor = vec4(1.0, 1.0, 1.0, v_color.w);\r\n\r\n    if( EXTENDED_PARTICLES > 0.5 )\r\n    {\r\n        if( APPLY_RGB_COLOR_VERTEX > 0.5)\r\n        {\r\n            vcolor = v_color;\r\n        }\r\n\r\n        float nEmission = 1.0;\r\n        float nAlpha = 1.0;\r\n        float nDissolve = 1.0;\r\n        \r\n        if( NOISE_TEXTURE > 0.5)\r\n        {\r\n            vec3 noise = texture2D(_NoiseTex, v_noiseuv).xyz;\r\n        \r\n            if( NOISE_TEXTURE_EMISSION > 0.5)\r\n            {\r\n                nEmission = noise.x;\r\n            }\r\n            else\r\n            {\r\n                nEmission = 1.0;\r\n            }\r\n            \r\n            if( NOISE_TEXTURE_ALPHA > 0.5)\r\n            {\r\n                nAlpha = noise.y;\r\n            }\r\n            else\r\n            {\r\n                nAlpha = 1.0;\r\n            }\r\n            \r\n            if( NOISE_TEXTURE_DISSOLVE > 0.5)\r\n            {\r\n                nDissolve = noise.z;\r\n            }\r\n            else\r\n            {\r\n                nDissolve = 1.0;\r\n            }\r\n        }\r\n    \r\n        if( DISSOLVE_ENABLED > 0.5)\r\n        {\r\n            float ramp = -1.0 + (v_particledata.x * 2.0);\r\n            col.a = clamp(tex.g * smoothstep(_DissolveStep.x, _DissolveStep.y, (tex.b + ramp) * nDissolve) * _OpacitySaturation * vcolor.w * nAlpha, 0.0, 1.0);\r\n        }\r\n        else\r\n        {\r\n            col.a = clamp(tex.g * _OpacitySaturation * vcolor.w, 0.0, 1.0) * nAlpha;\r\n        }\r\n    \r\n        float lerpValue = 0.0;\r\n        if(COLOR_TINT < 0.5)\r\n        {\r\n            lerpValue = clamp(tex.r * v_particledata.y * _ColorMultiplier * nEmission, 0.0, 1.0);\r\n        }\r\n    \r\n        if( 2.5 < BlendMode && BlendMode < 3.5 ) //3\r\n        {\r\n            if( COLOR_RAMP > 0.5)\r\n            {\r\n                col.xyz = texture2D(_ColorRamp, vec2((1.0 - lerpValue), 0.0)).xyz * vcolor.xyz * _EmissionSaturation;\r\n            }\r\n            else\r\n            {\r\n                if( COLOR_TINT > 0.5)\r\n                {\r\n                    col.xyz = tex.x * _BasicColor.xyz * vcolor.xyz * nEmission * _EmissionSaturation;\r\n                }\r\n                else\r\n                {\r\n                    col.xyz = mix(_BasicColor.xyz * vcolor.xyz, _SaturatedColor.xyz, lerpValue) * _EmissionSaturation;\r\n                }\r\n            }\r\n            col.a *= _GlobalAlpha;\r\n        }\r\n        else\r\n        {\r\n            if( COLOR_RAMP > 0.5)\r\n            {\r\n                col.xyz = texture2D(_ColorRamp, vec2((1.0 - lerpValue), 0.0)).xyz * vcolor.xyz * col.a * _EmissionSaturation;\r\n            }\r\n            else\r\n            {\r\n                if( COLOR_TINT > 0.5 )\r\n                {\r\n                    col.xyz = tex.x * _BasicColor.xyz * vcolor.xyz * nEmission * _EmissionSaturation * col.a;\r\n                }\r\n                else\r\n                {\r\n                    col.xyz = mix(_BasicColor.xyz * vcolor.xyz, _SaturatedColor.xyz, lerpValue) * col.a * _EmissionSaturation;\r\n                }\r\n            }\r\n            col *= _GlobalAlpha;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if( 3.5 < BlendMode && BlendMode < 4.5 ) //4\r\n        {\r\n            tex *= _TintColor;\r\n            float luminance = clamp(dot(tex, vec4(0.2126, 0.7152, 0.0722, 0.0)) * tex.a * _ABOffset, 0.0, 1.0);\r\n            vec4 one = vec4(1, 1, 1, 1);\r\n            col = mix(2.0 * (v_color * tex), one - 2.0 * (one - v_color) * (one - tex), luminance);\r\n        }\r\n        else\r\n        {\r\n            col = v_color * tex;\r\n            col *= _TintColor;\r\n        \r\n            if( EMISSIVEPOWER > 0.5)\r\n            {\r\n                col *= _EmissivePower;\r\n            }\r\n            \r\n            if( 0.5 < BlendMode && BlendMode < 1.5 ) //1\r\n            {\r\n                col.rgb *= col.a;\r\n            }\r\n            else\r\n            {\r\n                if( 2.5 < BlendMode && BlendMode < 3.5 ) //3\r\n                {\r\n                    col *= 2.0;\r\n                }\r\n                else\r\n                {\r\n                    if( 1.5 < BlendMode && BlendMode < 2.5 ) //2\r\n                    {\r\n                        col *= 4.0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    \r\n        col *= _GlobalAlpha;\r\n\r\n    }\r\n\r\n    gl_FragColor = col;\r\n}","particlesystem_transparent_particles_standard.vs.glsl":"\r\nprecision mediump float;\r\n\r\nattribute vec3 _glesVertex;\r\nattribute vec2 _glesMultiTexCoord0;\r\nattribute vec4 _glesColor;\r\n\r\nuniform vec4 _MainTex_ST;\r\n\r\nuniform vec4 _Panning;\r\nuniform float glstate_timer;\r\n\r\nuniform vec4 _NoiseTex_ST;\r\nuniform vec4 _NoisePanning;\r\n\r\nuniform mat4 glstate_matrix_mvp;\r\n\r\nvarying vec2 v_uv;\r\nvarying vec4 v_color;\r\n\r\nuniform float EXTENDED_PARTICLES;\r\nvarying vec2 v_particledata;\r\n\r\nuniform float NOISE_TEXTURE;\r\nuniform float NOISEUV;\r\nvarying vec2 v_noiseuv;\r\n\r\n\r\n\r\nattribute vec3 a_particle_position;\r\nattribute vec3 a_particle_scale;\r\nattribute vec3 a_particle_rotation;\r\nattribute vec4 a_particle_color;\r\nattribute vec4 a_particle_tilingOffset;\r\nattribute vec2 a_particle_flipUV;\r\n\r\nuniform mat4 u_particle_billboardMatrix;\r\n\r\n\r\nmat3 makeParticleRotationMatrix(vec3 rotation)\r\n{\r\n    float DEG2RAD = 3.1415926 / 180.0;\r\n    \r\n    float rx = rotation.x * DEG2RAD;\r\n    float ry = rotation.y * DEG2RAD;\r\n    float rz = rotation.z * DEG2RAD;\r\n\r\n    float sinX = sin(rx);\r\n    float cosX = cos(rx);\r\n    float sinY = sin(ry);\r\n    float cosY = cos(ry);\r\n    float sinZ = sin(rz);\r\n    float cosZ = cos(rz);\r\n\r\n    mat3 tmp;\r\n    float ce = cosY * cosZ;\r\n    float cf = cosY * sinZ;\r\n    float de = sinY * cosZ;\r\n    float df = sinY * sinZ;\r\n\r\n    float te0 = ce + df * sinX;\r\n    float te4 = de * sinX - cf;\r\n    float te8 = cosX * sinY;\r\n\r\n    float te1 = cosX * sinZ;\r\n    float te5 = cosX * cosZ;\r\n    float te9 = - sinX;\r\n\r\n    float te2 = cf * sinX - de;\r\n    float te6 = df + ce * sinX;\r\n    float te10 = cosX * cosY;\r\n\r\n    tmp[0] = vec3(te0, te1, te2);\r\n    tmp[1] = vec3(te4, te5, te6);\r\n    tmp[2] = vec3(te8, te9, te10);\r\n            \r\n    return tmp;\r\n}\r\n\r\nvec4 particleAnimation(vec4 position) \r\n{\r\n    mat3 billboardMatrix = mat3(u_particle_billboardMatrix[0].xyz,u_particle_billboardMatrix[1].xyz,u_particle_billboardMatrix[2].xyz);\r\n    \r\n    // 计算缩放\r\n    position.xyz = position.xyz * a_particle_scale.xyz;\r\n\r\n    // 计算旋转\r\n    mat3 rMat = makeParticleRotationMatrix(a_particle_rotation.xyz);\r\n    position.xyz = rMat * position.xyz;\r\n    position.xyz = billboardMatrix * position.xyz;\r\n\r\n    // 位移\r\n    position.xyz = position.xyz + a_particle_position.xyz;\r\n\r\n    // 颜色\r\n    v_color = a_particle_color * _glesColor;\r\n\r\n    if(a_particle_flipUV.x > 0.5) v_uv.x = 1.0 - v_uv.x;\r\n    if(a_particle_flipUV.y > 0.5) v_uv.y = 1.0 - v_uv.y;\r\n    v_uv = v_uv * a_particle_tilingOffset.xy + a_particle_tilingOffset.zw;\r\n    \r\n    return position;\r\n}\r\n\r\nvoid main() \r\n{\r\n    vec4 position = vec4(_glesVertex.xyz, 1.0);\r\n\r\n    position = particleAnimation(position);\r\n    \r\n    gl_Position = glstate_matrix_mvp * position;\r\n    v_uv = _glesMultiTexCoord0 * _MainTex_ST.xy + _MainTex_ST.zw + (_Panning.xy * glstate_timer);\r\n    // v_color = _glesColor;\r\n    // v_color = vec4(1.0,1.0,1.0,1.0);\r\n\r\n    if(EXTENDED_PARTICLES > 0.5)\r\n    {\r\n        if( NOISE_TEXTURE > 0.5)\r\n        {\r\n            if( NOISEUV > 0.5)\r\n            {\r\n                v_noiseuv = _glesMultiTexCoord0 * _NoiseTex_ST.xy + _NoiseTex_ST.zw + (_NoisePanning.xy * glstate_timer);\r\n            }\r\n            else\r\n            {\r\n                v_noiseuv = _glesMultiTexCoord0 * _MainTex_ST.xy + _MainTex_ST.zw + (_NoisePanning.xy * glstate_timer);\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // v_particledata = _glesMultiTexCoord0.zw;\r\n        v_particledata = _glesMultiTexCoord0;\r\n    }\r\n}","particles_add.shader.json":"{\r\n  \"layer\": \"transparent\",\r\n  \"queue\":  0,\r\n  \"properties\": [\r\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\r\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n          {\r\n            \"blendmode\": \"add\",\r\n            \"showface\": \"all\",\r\n            \"zwrite\": \"off\",\r\n            \"vs\": \"f14trans\",\r\n            \"fs\": \"f14trans\"\r\n          }\r\n        ],\r\n        \"shadowgen\": [],  \r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","particles_add_notest.shader.json":"{\r\n  \"layer\": \"transparent\",\r\n  \"queue\":  0,\r\n  \"properties\": [\r\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\r\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n          {\r\n            \"blendmode\": \"add\",\r\n            \"showface\": \"all\",\r\n            \"zwrite\": \"off\",\r\n            \"ztest\":\"off\",\r\n            \"vs\": \"f14trans\",\r\n            \"fs\": \"f14trans\"\r\n          }\r\n        ],\r\n        \"shadowgen\": [],  \r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","particles_blend.shader.json":"{\r\n  \"layer\": \"transparent\",\r\n  \"queue\":  0,\r\n  \"properties\": [\r\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\r\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n          {\r\n            \"blendmode\": \"blend\",\r\n            \"showface\": \"all\",\r\n            \"zwrite\": \"off\",\r\n            \"vs\": \"f14trans\",\r\n            \"fs\": \"f14trans\"\r\n          }\r\n        ],\r\n        \"shadowgen\": [],  \r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","particles_blend_notest.shader.json":"{\r\n  \"layer\": \"transparent\",\r\n  \"queue\":  0,\r\n  \"properties\": [\r\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\r\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n          {\r\n            \"blendmode\": \"blend\",\r\n            \"showface\": \"all\",\r\n            \"zwrite\": \"off\",\r\n            \"ztest\":\"off\",\r\n            \"vs\": \"f14trans\",\r\n            \"fs\": \"f14trans\"\r\n          }\r\n        ],\r\n        \"shadowgen\": [],  \r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","particle_mask_add_tint.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n\t\"properties\": [\r\n        \"_Main_Tex('MainTex',Texture)='white'{}\",\r\n        \"_Mask('Mask',Texture)='white'{}\",\r\n        \"_Main_Tex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\r\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\r\n        \"_Main_Color('Main_Color', Color) = (1,1,1,1)\",\r\n        \"_mixAlphaRate('mixAlphaRate',Float) = 1\",\r\n        \"_mixColorRate('mixColorRate',Float) = 1\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"blendmode\": \"add\",\r\n                \"zwrite\": \"off\",\r\n                \"ztest\":\"on\",\r\n                \"vs\": \"par_mask_tint\",\r\n                \"fs\": \"par_mask_tint\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","par_mask_tint.fs.glsl":"uniform sampler2D _Main_Tex; \r\nuniform sampler2D _Mask; \r\n\r\nvarying mediump vec2 _maintex_uv;\r\nvarying mediump vec2 _mask_uv;\r\n\r\nvarying mediump vec4 v_color;\r\n\r\nvoid main()    \r\n{\r\n    highp vec4 basecolor=texture2D(_Main_Tex,_maintex_uv);\r\n    highp vec4 maskcolor=texture2D(_Mask,_mask_uv);\r\n\r\n    mediump vec3 tempcolor=v_color.rgb*basecolor.rgb*maskcolor.rgb;\r\n    mediump float tempAlpha=v_color.a*basecolor.a*maskcolor.a;\r\n    mediump vec4 emission=vec4(tempcolor,tempAlpha);\r\n    \r\n    gl_FragData[0] = emission;\r\n}\r\n","par_mask_tint.vs.glsl":"attribute highp vec3 _glesVertex;\r\nattribute highp vec4 _glesColor;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\nuniform highp mat4 glstate_matrix_mvp;\r\n\r\nuniform mediump vec4 _Main_Tex_ST;\r\nuniform mediump vec4 _Mask_ST;\r\nvarying mediump vec2 _maintex_uv;\r\nvarying mediump vec2 _mask_uv;\r\n\r\nuniform mediump vec4 _Main_Color;\r\nuniform mediump float _mixColorRate;\r\nuniform mediump float _mixAlphaRate;\r\n\r\nvarying mediump vec4 v_color;\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\tposition =glstate_matrix_mvp * position;\r\n\t \r\n    _maintex_uv = _glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\r\n    _mask_uv = _glesMultiTexCoord0.xy * _Mask_ST.xy + _Mask_ST.zw;\r\n\tv_color=_glesColor*_Main_Color;\r\n\tv_color.rgb=v_color.rgb*_mixColorRate;\r\n\tv_color.a=v_color.a*_mixAlphaRate;\r\n\r\n\tgl_Position = position;\r\n}","quad.vs.glsl":"attribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nvarying highp vec2 xlv_TEXCOORD0;\n\nvoid main()\n{\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n    #ifdef QUAD\n    gl_Position = vec4(_glesVertex.xy*2.0,_glesVertex.z,1.0);\n    #else\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n    #endif\n}","trail.fs.glsl":"precision lowp float;\r\nuniform lowp sampler2D _MainTex;\r\n\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\nvarying highp vec4 v_color;\r\n\r\nvoid main()\r\n{\r\n    //gl_FragData[0] = v_color;\r\n\r\n    lowp vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\r\n\r\n    // if(basecolor.a < 0.01)\r\n    //     discard;\r\n\r\n    //lowp vec4 fristColor=basecolor*_MainColor * vec4(v_color.rgb, 1);\r\n    //lowp vec4 emission = fristColor;\r\n    lowp vec4 emission =  v_color * basecolor;\r\n    // lowp vec4 emission =  basecolor * vec4(1.0,1.0,1.0,v_color.a);\r\n\r\n    gl_FragData[0] = emission;\r\n}","trail.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n    \"queue\": 0,\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"all\",\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"trail\",\r\n                \"fs\": \"trail\"\r\n            }\r\n        ],\r\n\t\t\"base_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"all\",\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"trail\",\r\n                \"fs\": \"trail\"\r\n            }\r\n        ]\r\n    }\r\n}","trail.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n\r\n\r\nattribute vec4 _glesColor;\r\nvarying highp vec4 v_color;\r\n\r\nvoid main()\r\n{\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n    position = (glstate_matrix_mvp * position);\r\n\tv_color = _glesColor;\r\n    gl_Position =position;\r\n}","transparent.fs.glsl":"uniform lowp sampler2D _MainTex;                                                                                                \r\nvarying highp vec2 xlv_TEXCOORD0;\r\n\r\nlowp float f_Alpha;\r\nlowp float f_Superimposition;\r\n#ifdef INSTANCE\r\nvarying lowp float v_Alpha;\r\nvarying lowp float v_Superimposition;\r\n#else\r\nuniform lowp float _Alpha;\r\nuniform lowp float _Superimposition;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color; \r\nvarying lowp float factor;\r\n#endif\r\n\r\nvoid main() \r\n{\r\n    #ifdef INSTANCE\r\n        f_Alpha = v_Alpha;\r\n        f_Superimposition = v_Superimposition;\r\n    #else\r\n        f_Alpha = _Alpha;\r\n        f_Superimposition = _Superimposition;\r\n    #endif\r\n\r\n    lowp vec4 emission = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    emission.a=emission.a * f_Alpha;\r\n    emission.xyz *= f_Superimposition;\r\n    //----------------------------------------------------------\r\n    #ifdef FOG\r\n    emission.xyz= mix(glstate_fog_color.xyz, emission.xyz, factor);\r\n    #endif\r\n    gl_FragData[0] = emission;\r\n\r\n}","transparent.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n\t\"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\",\r\n        \"_Superimposition('Superimposition', Range(0.0, 7.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"transparent\",\r\n                \"fs\": \"transparent\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"transparent\",\r\n                \"fs\": \"transparent\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"transparent\",\r\n                \"fs\": \"transparent\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"transparent\",\r\n                \"fs\": \"transparent\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": [],\r\n        \"instance\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"transparent\",\r\n                \"fs\": \"transparent\"\r\n            }\r\n        ],\r\n        \"instance_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"transparent\",\r\n                \"fs\": \"transparent\"\r\n            }\r\n        ]\r\n    }\r\n}","transparent.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n\r\n#ifdef INSTANCE\r\nattribute lowp float _Alpha;\r\nattribute lowp float _Superimposition;\r\nvarying lowp float v_Alpha;\r\nvarying lowp float v_Superimposition;\r\nattribute highp vec4 instance_offset_matrix_0;\r\nattribute highp vec4 instance_offset_matrix_1;\r\nattribute highp vec4 instance_offset_matrix_2;\r\nattribute highp vec4 instance_offset_matrix_3;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    mat4 mat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn mat* srcVertex;\r\n}\r\n#endif\r\nvoid main()\r\n{\r\n\t#ifdef INSTANCE\r\n\t\tv_Alpha = _Alpha;\r\n\t\tv_Superimposition = _Superimposition;\r\n    #endif\r\n\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n\r\n\t#ifdef INSTANCE\r\n        highp mat4 instance_offset_matrix = mat4(instance_offset_matrix_0,instance_offset_matrix_1,instance_offset_matrix_2,instance_offset_matrix_3);\r\n        position = instance_offset_matrix * position;\r\n    #endif\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n    gl_Position = position;\r\n}","wiggle_alpha_blend.fs.glsl":"uniform lowp sampler2D _MainTex;                                                                                                \r\nvarying highp vec2 xlv_TEXCOORD0;\r\n//-------------------------------\r\nuniform lowp float _ScrollX;\r\nuniform lowp float _ScrollY;\r\nuniform lowp float _WiggleScrollX;\r\nuniform lowp float _WiggleScrollY;\r\nuniform lowp float _WiggleStrength;\r\nuniform lowp sampler2D _MaskTex;\r\nuniform lowp sampler2D _WiggleTex;\r\n//-------------------------------\r\nuniform mediump float glstate_timer;\r\n// uniform lowp float _Alpha;\r\n// uniform lowp float _Superimposition;\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color; \r\nvarying lowp float factor;\r\n#endif\r\nvoid main() \r\n{\r\n    mediump vec2 _Time = vec2(glstate_timer * 0.05 , glstate_timer);\r\n    //Wiggle calculation\r\n    mediump vec2 texCoord_0;\r\n    mediump vec2 tmpvar_6 = fract((vec2(_WiggleScrollX,_WiggleScrollY) * _Time.xy));\r\n    mediump vec2 uv_4 = (xlv_TEXCOORD0 + tmpvar_6);\r\n    mediump vec4 tmpvar_7 = texture2D(_WiggleTex, uv_4);\r\n    texCoord_0.x = (xlv_TEXCOORD0.x - (tmpvar_7.x * _WiggleStrength));\r\n    texCoord_0.y = (xlv_TEXCOORD0.y + (tmpvar_7.z * _WiggleStrength));\r\n    mediump vec2 tmpvar_9 = fract((vec2(_ScrollX,_ScrollY) * _Time.xy));\r\n    texCoord_0 = (texCoord_0 + tmpvar_9);\r\n\r\n    mediump vec4 emission = texture2D(_MainTex, texCoord_0);\r\n    // emission.a = emission.a*_Alpha;\r\n    // emission.xyz *= _Superimposition;\r\n    //----------------------------------------------------------\r\n\r\n    //mask \r\n    emission.w = texture2D(_MaskTex, texCoord_0).x;\r\n\r\n    //---------------------------------------------------------\r\n    #ifdef FOG\r\n    emission.xyz= mix(glstate_fog_color.xyz, emission.xyz, factor);\r\n    #endif\r\n    gl_FragData[0] = emission;\r\n\r\n}","wiggle_alpha_blend.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n\t\"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_MaskTex('掩码纹理(Alpha)',Texture)='white'{}\",\r\n        \"_WiggleTex('扭动纹理(Alpha)',Texture)='white'{}\",\r\n        \"_WiggleStrength('扭动强度', Range(0.0, 10.0)) = 1.0\",\r\n        \"_ScrollX('主纹理 uv X', float) = 0.0\",\r\n        \"_ScrollY('主纹理 uv Y', float) = 0.0\",\r\n        \"_WiggleScrollX('扰动纹理 uv X', float) = 1.0\",\r\n        \"_WiggleScrollY('扰动纹理 uv Y', float) = 0.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"zwrite\" : \"off\",\r\n                \"vs\": \"wiggle_alpha_blend\",\r\n                \"fs\": \"wiggle_alpha_blend\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"zwrite\" : \"off\",\r\n                \"vs\": \"wiggle_alpha_blend\",\r\n                \"fs\": \"wiggle_alpha_blend\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"zwrite\" : \"off\",\r\n                \"vs\": \"wiggle_alpha_blend\",\r\n                \"fs\": \"wiggle_alpha_blend\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"zwrite\" : \"off\",\r\n                \"vs\": \"wiggle_alpha_blend\",\r\n                \"fs\": \"wiggle_alpha_blend\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","wiggle_alpha_blend.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    mat4 mat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn mat* srcVertex;\r\n}\r\n#endif\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n    gl_Position = position;\r\n}"}