{"actionlinecaustics.fs.glsl":"\r\n\r\nprecision highp float;\r\n\r\n#define AMBIENT_LIGHT 0.\r\n#define DEPTH_START -1.0\r\n#define DEPTH_END -5.0\r\n\r\n#define NO_LIGHTING_ABOVE_WATER\r\n\r\n#define RIM_POWER 0.5\r\n#define RIM_LIGHTING_OPERATOR -= 0.25 *\r\n\r\n#ifdef LOW_END\r\n\t#define VERTEX_RIM_LIGHTING\r\n\t#define ACTION_LINE\r\n#else\r\n\t#define PIXEL_RIM_LIGHTING\r\n\t#define PER_PIXEL_CAUSTICS\r\n\t#define BUMP_MAPPED_CAUSTICS\r\n\t#define ACTION_LINE\r\n#endif\r\n\r\n#ifdef PER_PIXEL_CAUSTICS\r\n\r\n\t#ifndef NEEDS_WORLD_NORMAL\r\n\t\t#define NEEDS_WORLD_NORMAL\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_PER_PIXEL_WORLD_POS\r\n\t\t#define NEEDS_PER_PIXEL_WORLD_POS\r\n\t#endif\r\n\r\n\t#ifndef UP_FACE_FACTOR\r\n\t\t#define UP_FACE_FACTOR\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NO_LIGHTING_ABOVE_WATER\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef AMBIENT_LIGHT\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ACTION_LINE\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FAST_ACTION_LINE\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef VERTEX_RIM_LIGHTING\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef PIXEL_RIM_LIGHTING\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_NORMAL\r\n\t\t#define NEEDS_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP_ADDITIVE\r\n\t#ifndef SPHERE_MAP\r\n\t\t#define SPHERE_MAP\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP_BLEND\r\n\t#ifndef SPHERE_MAP\r\n\t\t#define SPHERE_MAP\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP\r\n\t#ifndef NEEDS_NORMAL\r\n\t\t#define NEEDS_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ABOVE_WATER_BRIGHTEN\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef UP_FACE_FACTOR\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NEEDS_NORMAL\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n\r\n\r\nuniform lowp sampler2D _MainTex;\r\n\r\n#ifdef NEEDS_LIGHTING\r\n    // uniform lowp float _LightingIntensity;\r\n#endif\r\n#ifdef PER_PIXEL_CAUSTICS\r\n    uniform lowp float _CausticsIntensity;\r\n    uniform lowp sampler2D _CausticsTex;\r\n    uniform lowp float _UnitTime;\r\n    uniform float glstate_timer;\r\n#endif\r\n\r\n// NOTE: v2f\r\nvarying lowp vec2 xlv_TEXCOORD0;\r\nvarying lowp vec2 _CausticsTex_UV;\r\n\r\n#ifdef NEEDS_PER_PIXEL_WORLD_POS\r\n    varying vec3 pos;\r\n#endif\r\n#ifdef NEEDS_LIGHTING\r\n    // fixed2 lighting : COLOR0;\r\n    varying lowp float v_atten;\r\n\t#ifdef UP_FACE_FACTOR\r\n\tvarying lowp float v_facing;\r\n\t#endif\r\n#endif\r\n#ifdef NEEDS_NORMAL\r\n    // float3 normal : COLOR1;\r\n    varying vec3 v_normal;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color;\r\nvarying lowp float factor;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    lowp vec4 emission = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    // if(emission.a < _AlphaCut)\r\n    //     discard;\r\n\r\n    #ifdef LIGHTMAP\r\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    emission.xyz *= decode_hdr(lightmap);\r\n    #endif\r\n\r\n\r\n\r\n\r\n    // vec4 final = texture2D(_MainTex, xlv_TEXCOORD0);\r\n\r\n#ifdef NEEDS_LIGHTING\r\n    lowp float atten = v_atten;\r\n\t#ifdef PIXEL_RIM_LIGHTING\r\n\t\tmediump float rimFactor = dot(v_normal, v_normal);\r\n\t\t#ifdef RIM_POWER\r\n\t\t\trimFactor = pow(rimFactor, RIM_POWER);\r\n\t\t#endif\r\n\t\tatten RIM_LIGHTING_OPERATOR rimFactor;\r\n    #endif\r\n\r\n    // atten = mix(1., atten, _LightingIntensity);\r\n    atten = 1.;\r\n\r\n\t#ifdef PER_PIXEL_CAUSTICS\r\n        lowp float causticsStrength = _CausticsIntensity * v_facing;\r\n        vec2 projectedWorldPos = .1 *vec2(pos.x,pos.z);\r\n\r\n        projectedWorldPos = 1. + mod(projectedWorldPos,1.);\r\n        projectedWorldPos += mod(10.* glstate_timer * 0.01,2.);\r\n        #ifdef BUMP_MAPPED_CAUSTICS\r\n            projectedWorldPos += 0.05 * length(emission);\r\n        #endif\r\n        // The original version is using alpha channel\r\n        lowp float causticcol = texture2D(_CausticsTex,projectedWorldPos).r;\r\n\r\n        atten += causticsStrength * causticcol;\r\n\r\n    #endif\r\n    emission *= atten;\r\n#endif\r\n\r\n    #ifdef FOG\r\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    #endif\r\n\r\n    gl_FragData[0] = emission;\r\n}","actionlinecaustics.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_CausticsTex('Light',Texture) = 'white' {}\",\r\n        \"_LightingIntensity('LightRate',Range(0.0,1.0)) = 1.0\",\r\n        \"_CausticsIntensity('LightRate',Range(0.0,1.0)) = 1.0\",\r\n        \"_UnitTime('LightRate',Range(0.0,1.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"actionlinecaustics\",\r\n                \"fs\": \"actionlinecaustics\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"actionlinecaustics\",\r\n                \"fs\": \"actionlinecaustics\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"actionlinecaustics\",\r\n                \"fs\": \"actionlinecaustics\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"actionlinecaustics\",\r\n                \"fs\": \"actionlinecaustics\"\r\n            }\r\n        ]\r\n    }\r\n}","actionlinecaustics.vs.glsl":"precision highp float;\r\n\r\n#define AMBIENT_LIGHT 0.\r\n#define DEPTH_START -1.0\r\n#define DEPTH_END -5.0\r\n\r\n#define NO_LIGHTING_ABOVE_WATER\r\n\r\n#define RIM_POWER 0.5\r\n#define RIM_LIGHTING_OPERATOR -= 0.25 *\r\n\r\n#ifdef LOW_END\r\n\t#define VERTEX_RIM_LIGHTING\r\n\t#define ACTION_LINE\r\n#else\r\n\t#define PIXEL_RIM_LIGHTING\r\n\t#define PER_PIXEL_CAUSTICS\r\n\t#define BUMP_MAPPED_CAUSTICS\r\n\t#define ACTION_LINE\r\n#endif\r\n\r\n#ifdef PER_PIXEL_CAUSTICS\r\n\r\n\t#ifndef NEEDS_WORLD_NORMAL\r\n\t\t#define NEEDS_WORLD_NORMAL\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_PER_PIXEL_WORLD_POS\r\n\t\t#define NEEDS_PER_PIXEL_WORLD_POS\r\n\t#endif\r\n\r\n\t#ifndef UP_FACE_FACTOR\r\n\t\t#define UP_FACE_FACTOR\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NO_LIGHTING_ABOVE_WATER\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef AMBIENT_LIGHT\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ACTION_LINE\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FAST_ACTION_LINE\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef VERTEX_RIM_LIGHTING\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef PIXEL_RIM_LIGHTING\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_NORMAL\r\n\t\t#define NEEDS_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP_ADDITIVE\r\n\t#ifndef SPHERE_MAP\r\n\t\t#define SPHERE_MAP\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP_BLEND\r\n\t#ifndef SPHERE_MAP\r\n\t\t#define SPHERE_MAP\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP\r\n\t#ifndef NEEDS_NORMAL\r\n\t\t#define NEEDS_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ABOVE_WATER_BRIGHTEN\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef UP_FACE_FACTOR\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NEEDS_NORMAL\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n#endif\r\n\r\nattribute vec4 _glesVertex;\r\nattribute lowp vec4 _glesMultiTexCoord0;\r\nattribute vec3 _glesNormal;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_world2object;\r\nuniform mediump vec4 _MainTex_ST;\r\nuniform mediump vec4 _CausticsTex_ST;\r\n\r\n// NOTE: v2f\r\nvarying lowp vec2 xlv_TEXCOORD0;\r\nvarying lowp vec2 _CausticsTex_UV;\r\n\r\n#ifdef NEEDS_PER_PIXEL_WORLD_POS\r\n    varying vec3 pos;\r\n#endif\r\n#ifdef NEEDS_LIGHTING\r\n    // fixed2 lighting : COLOR0;\r\n    varying lowp float v_atten;\r\n\t#ifdef UP_FACE_FACTOR\r\n\tvarying lowp float v_facing;\r\n\t#endif\r\n#endif\r\n#ifdef NEEDS_NORMAL\r\n    // float3 normal : COLOR1;\r\n    varying vec3 v_normal;\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\n// #define glstate_fog_end\t\t150.\r\n// #define glstate_fog_start\t1.\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    mat4 mat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn mat* srcVertex;\r\n}\r\n#endif\r\n\r\nfloat inverseLerp(float x, float y, float z) {\r\n\treturn (z-x) / (y - x);\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec4 position=vec4(_glesVertex.xyz,1.0);\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    _CausticsTex_UV = _glesMultiTexCoord0.xy * _CausticsTex_ST.xy + _CausticsTex_ST.zw;\r\n\r\n\r\n\t// World position\r\n\tvec4 wp = glstate_matrix_model*position;\r\n\twp.xyz /= wp.w;\r\n\r\n#ifdef CALCULATE_NORMAL\r\n\tvec3 normal = normalize((glstate_matrix_model * vec4(_glesNormal, 0.0)).xyz);\r\n#endif\r\n\r\n#ifdef NEEDS_PER_PIXEL_WORLD_POS\r\n\tpos = wp.xyz;\r\n#endif\r\n\t// pos = _glesVertex.xyz;\r\n\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n#ifdef NEEDS_DEPTH_FACTOR\r\n\tmediump float waterDepth = inverseLerp(DEPTH_START, DEPTH_END, wp.y);\r\n#endif\r\n\r\n#ifdef NEEDS_LIGHTING\r\n\tmediump float atten = 0.;\r\n\t#ifdef ACTION_LINE\r\n\t\t// Middle-ground / above water factor\r\n\t\tmediump float actionLine = mix( 1., 0.2, (inverseLerp( 0., 1.5, wp.z) - inverseLerp(5.,50.,wp.z)) );\r\n\t#endif\r\n\r\n\t#ifdef AMBIENT_LIGHT\r\n\t\tatten += AMBIENT_LIGHT;\r\n\t#endif\r\n\r\n\t#ifdef VERTEX_RIM_LIGHTING\r\n\t\tmediump float rimFactor = 1. - dot(normal, vec3(0,0,-1) );\r\n\t\t#ifdef RIM_POWER\r\n\t\trimFactor = pow(rimFactor, RIM_POWER);\r\n\t\t#endif\r\n\t\tatten RIM_LIGHTING_OPERATOR rimFactor;\r\n\t#endif\r\n\r\n\t#ifdef NO_LIGHTING_ABOVE_WATER\r\n\t\tatten = mix( 1., atten, waterDepth);\r\n\t#endif\r\n\tv_atten = atten;\r\n\r\n\t// v_facing = clamp(dot(normalize(normal), vec3(0, 1., 0)), 0., 1.);\r\n\t#ifdef UP_FACE_FACTOR\r\n\t\tv_facing = clamp(dot(normal, vec3(0, sign(DEPTH_START - wp.y), 0)), 0., 1.);\r\n\t#endif\r\n\r\n#endif\r\n\r\n#ifdef NEEDS_NORMAL\r\n\t\tv_normal = normal;\r\n#endif\r\n\r\n    // lowp vec2 _speed= vec2(_SpeedU,_SpeedV);\r\n    // _StreamLightUV = (_glesMultiTexCoord0.xy * _LightTex_ST.xy + _LightTex_ST.zw)  + _speed * glstate_timer;\r\n    gl_Position = position;\r\n}","additive_alpha.fs.glsl":"uniform lowp sampler2D _MainTex;  \r\nuniform lowp vec4 _MainColor;\r\nuniform lowp float _alpha;\r\nvarying mediump vec2 _base_uv;\r\n\r\nvoid main() \r\n{\r\n    lowp vec4 tmpvar_3 = texture2D(_MainTex, _base_uv)*_MainColor;\r\n    lowp float alpha=_alpha*tmpvar_3.a;\r\n    gl_FragData[0] =vec4(tmpvar_3.xyz,alpha);\r\n}","additive_alpha.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_MainColor('MainColor',Color) = (1,1,1,1)\",\r\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\r\n\t\t\"_alpha('alpha',float) = 1.0\"\r\n    ],\r\n    \"queue\": 0,\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"showface\": \"all\",\r\n\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"additive_alpha\",\r\n                \"fs\": \"additive_alpha\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"showface\": \"all\",\r\n\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"fog_additive_alpha\",\r\n                \"fs\": \"fog_additive_alpha\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"showface\": \"all\",\r\n\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"additive_alpha_bone_eff\",\r\n                \"fs\": \"additive_alpha\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"showface\": \"all\",\r\n\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"fog_additive_alpha_bone_eff\",\r\n                \"fs\": \"fog_additive_alpha\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","additive_alpha.vs.glsl":"attribute highp vec3 _glesVertex;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying mediump vec2 _base_uv;\r\n\r\n\r\nvoid main()\r\n{\r\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n\tgl_Position = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));\r\n}\r\n\r\n","additive_alpha_bone_eff.vs.glsl":"attribute highp vec3 _glesVertex;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform highp vec4 glstate_vec4_bones[80];\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying mediump vec2 _base_uv;\r\n\r\n\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy2 = 2.0 * quat.x * quat.y;\r\n\tfloat xz2 = 2.0 * quat.x * quat.z;\r\n\tfloat xw2 = 2.0 * quat.x * quat.w;\r\n\tfloat yz2 = 2.0 * quat.y * quat.z;\r\n\tfloat yw2 = 2.0 * quat.y * quat.w;\r\n\tfloat zw2 = 2.0 * quat.z * quat.w;\r\n\tfloat xx = quat.x * quat.x;\r\n\tfloat yy = quat.y * quat.y;\r\n\tfloat zz = quat.z * quat.z;\r\n\tfloat ww = quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(xx - yy - zz + ww)*s, (xy2 + zw2)*s, (xz2 - yw2)*s, 0,\r\n\t(xy2 - zw2)*s, (-xx + yy - zz + ww)*s, (yz2 + xw2)*s, 0,\r\n\t(xz2 + yw2)*s, (yz2 - xw2)*s, (-xx - yy + zz + ww)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz, 1.0);\r\n\r\n    int i = int(_glesBlendIndex4.x);\r\n    int i2 =int(_glesBlendIndex4.y);\r\n\tint i3 =int(_glesBlendIndex4.z);\r\n\tint i4 =int(_glesBlendIndex4.w);\r\n\r\n    mat4 mat = buildMat4(i)*_glesBlendWeight4.x\r\n\t\t\t + buildMat4(i2)*_glesBlendWeight4.y\r\n\t\t\t + buildMat4(i3)*_glesBlendWeight4.z\r\n\t\t\t + buildMat4(i4)*_glesBlendWeight4.w;\r\n\r\n    gl_Position = (glstate_matrix_mvp * mat)* tmpvar_1;\r\n}","background.fs.glsl":"precision highp float;\r\n\r\n\r\n\r\nuniform sampler2D _MainTex;\r\n\r\nvarying vec2 uv;\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color;\r\nvarying lowp float factor;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n    lowp vec4 emission = texture2D(_MainTex, uv);\r\n\r\n    // #ifdef LIGHTMAP\r\n    // lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    // emission.xyz *= decode_hdr(lightmap);\r\n    // #endif\r\n\r\n\r\n    #ifdef FOG\r\n    emission *= glstate_fog_color;\r\n    #endif\r\n\r\n    gl_FragData[0] = emission;\r\n\r\n}","background.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"background\",\r\n                \"fs\": \"background\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"background\",\r\n                \"fs\": \"background\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"background\",\r\n                \"fs\": \"background\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"background\",\r\n                \"fs\": \"background\"\r\n            }\r\n        ]\r\n    }\r\n}","background.vs.glsl":"precision highp float;\r\n\r\n\r\n\r\nattribute vec4 _glesVertex;\r\nattribute vec4 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\n\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying vec2 uv;\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n\r\n\r\n\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    // Force the screen space z to the far clip plane so even though this renders last (and the geometry is front of some stuff), it still renders behind everything\r\n    position.z = position.w - 0.001;\r\n\r\n    // #ifdef FOG\r\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    // factor = clamp(factor, 0.0, 1.0);\r\n    // #endif\r\n\r\n    uv = _glesMultiTexCoord0.xy*_MainTex_ST.xy+_MainTex_ST.zw;\r\n\r\n    gl_Position = position;\r\n}","CloakingDevice.fs.glsl":"precision highp float;\r\n\r\n#define SHADER_NAME CloakingDevice\r\n\r\nvarying vec4 color;\r\n\r\n\r\nvoid main()\r\n{\r\n\r\n    gl_FragData[0] = color;\r\n\r\n}","CloakingDevice.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n    \"properties\": [\r\n        \"_Rimsize('AlphaCut',Range(0.0,1.0)) = 1.0\",\r\n        \"_RimColour ('MainColor', Color) = (1,1,1,0.4)\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"ztest\": \"lequal\",\r\n                \"zwrite\": \"on\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"CloakingDevice\",\r\n                \"fs\": \"CloakingDevice\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"ztest\": \"lequal\",\r\n                \"zwrite\": \"on\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"CloakingDevice\",\r\n                \"fs\": \"CloakingDevice\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"ztest\": \"lequal\",\r\n                \"zwrite\": \"on\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"CloakingDevice\",\r\n                \"fs\": \"CloakingDevice\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"ztest\": \"lequal\",\r\n                \"zwrite\": \"on\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"CloakingDevice\",\r\n                \"fs\": \"CloakingDevice\"\r\n            }\r\n        ]\r\n    }\r\n}","CloakingDevice.vs.glsl":"precision highp float;\r\n\r\n\r\n\r\nattribute mediump vec3 _glesVertex;\r\nattribute highp vec3 _glesNormal;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform vec4 glstate_eyepos;\r\n\r\n\r\n// varying vec2 uv;\r\nvarying vec4 color;\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform highp float glstate_fog_start;\r\n// uniform highp float glstate_fog_end;\r\n// varying highp float factor;\r\n// #endif\r\n\r\nuniform vec4 _RimColour;\r\nuniform float _Rimsize;\r\n\r\n\r\n#ifdef SKIN\r\nhighp mat4 blendMat;\r\nattribute highp vec4 _glesBlendIndex4;\r\nattribute highp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,highp vec4 blendIndex,highp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat* srcVertex;\r\n}\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    highp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    highp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n\r\n\t// World position\r\n    vec3 normalizedNormal = _glesNormal;\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    normalizedNormal = normalize(mat3(blendMat) * _glesNormal);\r\n    #endif\r\n\tvec4 wp = glstate_matrix_model * position;\r\n\t// wp.xyz /= wp.w;\r\n    position = glstate_matrix_mvp * position;\r\n    vec3 viewDir = normalize(glstate_eyepos.xyz - wp.xyz);\r\n    normalizedNormal = normalize(mat3(glstate_matrix_model) * normalizedNormal);\r\n\r\n\r\n    // Apply the rim effect\r\n    float NoV = 1. - dot(normalizedNormal, viewDir);\r\n    // NoV = dot(NoV, NoV);\r\n\r\n    color = _RimColour;\r\n    color.a *= smoothstep(1.0 - _Rimsize, 1.0, NoV);\r\n    // #ifdef FOG\r\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    // factor = clamp(factor, 0.0, 1.0);\r\n    // #endif\r\n\r\n    gl_Position = position;\r\n}","d3UI.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n\t\"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"zwrite\":\"on\",\r\n                \"ztest\":\"on\",\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"all\",\r\n                \"vs\": \"lineui\",\r\n                \"fs\": \"lineui\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","diffuse.fs.glsl":"precision lowp float;\r\nuniform lowp sampler2D _MainTex;\r\nuniform lowp vec4 _MainColor;\r\nuniform lowp float _AlphaCut;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n\r\n//light\r\nlowp vec4 xlv_COLOR = vec4(0.0,0.0,0.0,1.0); \r\nbool hasLight = false;\r\nlowp vec3 fixedAmbient = vec3(0.6,0.6,0.6);\r\nuniform lowp float glstate_lightcount;\r\nuniform lowp vec4 glstate_vec4_lightposs[8];\r\nuniform lowp vec4 glstate_vec4_lightdirs[8];\r\nuniform lowp float glstate_float_spotangelcoss[8];\r\nuniform lowp vec4 glstate_vec4_lightcolors[8];\r\nuniform lowp float glstate_float_lightrange[8];\r\nuniform lowp float glstate_float_lightintensity[8];\r\n\r\nvarying lowp vec3 v_N;\r\nvarying lowp vec3 v_Mpos;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color; \r\nvarying lowp float factor;\r\n#endif\r\n\r\n//calcDiffuse 计算漫反射强度函数\r\n//统一三种光源的传参方式，在函数内混合，方便就不高效\r\n//只需要方向光时另写\r\n//N 世界空间法线\r\n//worldpos 世界空间pos\r\n//lightPos 光源位置,w=0 表示方向光\r\n//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot\r\n//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来\r\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot,lowp float range )\r\n{\r\n    lowp vec3 v3 = lightPos.xyz - worldpos;\r\n    lowp float len = length(v3);\r\n    len = len > range ? range : len;\r\n    //求入射角，点光源&聚光灯\r\n    lowp vec3 L = normalize(v3); \r\n    //求张角 聚光灯 也是方向光入射角\r\n    lowp vec3 L2 = -lightDir.xyz;\r\n    lowp float dotSpot = dot(L,L2);\r\n    //漫反射强度\r\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0) * pow(1.0 - len/range,2.0); \r\n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \r\n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\r\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\r\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\r\n    return diffuse;\r\n}\r\n\r\nvoid calcCOLOR(){\r\n    int c =int(glstate_lightcount);\r\n\tif(c>0){\r\n        hasLight = true;\r\n        lowp float diff=0.0;\r\n\t\t//calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);\r\n\t\tfor(int i=0;i<8;i++)\r\n\t\t{\r\n\t\t\tif(i>=c)break;\r\n\t\t\t//diff += calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\r\n\t\t\tdiff = calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\r\n            xlv_COLOR += glstate_float_lightintensity[i] * glstate_vec4_lightcolors[i] * diff;\r\n\t\t}\r\n\t\txlv_COLOR.w = 1.0;  \r\n    }\r\n}\r\n\r\nvoid main() \r\n{\r\n    lowp vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    if(basecolor.a < _AlphaCut)\r\n        discard;\r\n    lowp vec4 fristColor=basecolor*_MainColor;\r\n    lowp vec4 emission = fristColor;\r\n\r\n    //----------------------------------------------------------\r\n    //light\r\n    calcCOLOR();\r\n    \r\n    #ifdef LIGHTMAP\r\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    emission.xyz *= decode_hdr(lightmap);\r\n    if(hasLight){ // have light\r\n        fristColor = fristColor * xlv_COLOR ;\r\n        emission = emission + mix(vec4(1.0, 1.0, 1.0, 1.0), fristColor, fristColor.wwww);\r\n    }\r\n    #else\r\n\tif(hasLight){ // have light\r\n        emission = (fristColor * xlv_COLOR) + (fristColor * vec4(fixedAmbient,1.0));\r\n    }\r\n    #endif\r\n\r\n    #ifdef FOG\r\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    #endif\r\n    \r\n    gl_FragData[0] = emission;\r\n}","diffuse.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\r\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\r\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\r\n    ],\r\n    \"passes\": {\r\n\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"lightmap\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"lightmap_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ]\r\n    }\r\n}","diffuse.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n//light\r\nlowp mat4 blendMat ;\r\nattribute lowp vec3 _glesNormal;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform lowp float glstate_lightcount;\r\n\r\nvarying highp vec3 v_N;\r\nvarying highp vec3 v_Mpos;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\n// #define glstate_fog_end\t\t150.\r\n// #define glstate_fog_start\t1.\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n\r\n#endif\r\n\r\nvoid calcNormal(highp vec4 pos){\r\n\tint c =int(glstate_lightcount);\r\n\tif(c>0){\r\n\t\t//求世界空间法线\r\n\t\t#ifdef SKIN\r\n\t\tv_N = normalize(mat3(blendMat) * _glesNormal);\r\n\t\t#else\r\n\t\tv_N = _glesNormal;\r\n\t\t#endif\r\n\t\tlowp mat3 normalmat = mat3(glstate_matrix_model);\r\n\t\tv_N =normalize(normalmat*v_N);\r\n\t\tv_Mpos =(glstate_matrix_model * pos).xyz;\r\n\t}\r\n}\r\n\r\nvoid main()\r\n{\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n\t//light\r\n    calcNormal(position);\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    #ifdef FOG\r\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    #endif\r\n\r\n\r\n    gl_Position =position;\r\n}","diffuse_bothside.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\r\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\r\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\r\n    ],\r\n    \"passes\": {\r\n\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"lightmap\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"lightmap_fog\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ]\r\n    }\r\n}","f14trans.fs.glsl":"uniform mediump sampler2D _Main_Tex;\r\n\r\nvarying lowp vec4 xlv_COLOR;\r\nvarying mediump vec2 xlv_TEXCOORD0;          \r\nvoid main() \r\n{\r\n    lowp vec4 basecolor = texture2D(_Main_Tex, xlv_TEXCOORD0);\r\n    gl_FragData[0] =basecolor*xlv_COLOR;\r\n    //gl_FragData[0] =vec4(1,0,0,1);\r\n}","f14trans.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;   \r\nattribute lowp vec4 _glesColor;\r\n\r\nuniform lowp vec4 _Main_Color;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _Main_Tex_ST;\r\n\r\n\r\nvarying lowp vec4 xlv_COLOR;\r\nvarying mediump vec2 xlv_TEXCOORD0;                \r\nvoid main()                                     \r\n{                                               \r\n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz,1.0);\r\n    xlv_COLOR = _Main_Color*_glesColor;\r\n\txlv_TEXCOORD0 =_glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\r\n                \r\n    gl_Position = (glstate_matrix_mvp *tmpvar_1);  \r\n}","fog_additive_alpha.fs.glsl":"uniform mediump sampler2D _MainTex;  \r\nuniform lowp vec4 _MainColor;\r\nuniform lowp float _alpha;\r\nvarying mediump vec2 _base_uv;\r\n\r\nuniform lowp vec4 glstate_fog_color; \r\nvarying lowp float factor; \r\nvoid main() \r\n{\r\n    lowp vec4 tmpvar_3 = texture2D(_MainTex, _base_uv)*_MainColor;\r\n    lowp float alpha=_alpha*tmpvar_3.a;\r\n    lowp vec3 afterFog = mix(vec3(0,0,0), tmpvar_3.rgb, factor);\r\n    gl_FragData[0] = vec4(afterFog,alpha);\r\n}","fog_additive_alpha.vs.glsl":"attribute highp vec3 _glesVertex;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\n\r\nvarying lowp float factor;\r\nvarying mediump vec2 _base_uv;\r\n\r\n\r\nvoid main()\r\n{\r\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n\thighp vec4 pos = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));\r\n    factor = (glstate_fog_end - abs(pos.z))/(glstate_fog_end - glstate_fog_start); \r\n    factor = clamp(factor, 0.0, 1.0);  \r\n    gl_Position = pos;\r\n}","fog_additive_alpha_bone_eff.vs.glsl":"attribute highp vec3 _glesVertex;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nvarying mediump vec2 _base_uv;\r\n\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[80];\r\n\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy2 = 2.0 * quat.x * quat.y;\r\n\tfloat xz2 = 2.0 * quat.x * quat.z;\r\n\tfloat xw2 = 2.0 * quat.x * quat.w;\r\n\tfloat yz2 = 2.0 * quat.y * quat.z;\r\n\tfloat yw2 = 2.0 * quat.y * quat.w;\r\n\tfloat zw2 = 2.0 * quat.z * quat.w;\r\n\tfloat xx = quat.x * quat.x;\r\n\tfloat yy = quat.y * quat.y;\r\n\tfloat zz = quat.z * quat.z;\r\n\tfloat ww = quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(xx - yy - zz + ww)*s, (xy2 + zw2)*s, (xz2 - yw2)*s, 0,\r\n\t(xy2 - zw2)*s, (-xx + yy - zz + ww)*s, (yz2 + xw2)*s, 0,\r\n\t(xz2 + yw2)*s, (yz2 - xw2)*s, (-xx - yy + zz + ww)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz, 1.0);\r\n\r\n    int i = int(_glesBlendIndex4.x);\r\n    int i2 =int(_glesBlendIndex4.y);\r\n\tint i3 =int(_glesBlendIndex4.z);\r\n\tint i4 =int(_glesBlendIndex4.w);\r\n\r\n    mat4 mat = buildMat4(i)*_glesBlendWeight4.x\r\n\t\t\t + buildMat4(i2)*_glesBlendWeight4.y\r\n\t\t\t + buildMat4(i3)*_glesBlendWeight4.z\r\n\t\t\t + buildMat4(i4)*_glesBlendWeight4.w;\r\n\r\n\thighp vec4 pos = (glstate_matrix_mvp * mat)* tmpvar_1;\r\n    factor = (glstate_fog_end - abs(pos.z))/(glstate_fog_end - glstate_fog_start);\r\n    factor = clamp(factor, 0.0, 1.0);\r\n    gl_Position = pos;\r\n}","godray.fs.glsl":"\r\n\r\nprecision highp float;\r\n\r\n\r\nuniform float glstate_timer;\r\n\r\n\r\nuniform sampler2D _MainTex;\r\n\r\n\r\n\r\nvarying mediump vec2 color;\r\nvarying vec2 uv;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp vec4 glstate_fog_color;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\nvoid main()\r\n{\r\n    // lowp vec4 emission = texture2D(_MainTex, uv);\r\n    // if(emission.a < _AlphaCut)\r\n    //     discard;\r\n\r\n    #ifdef LIGHTMAP\r\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    emission.xyz *= decode_hdr(lightmap);\r\n    #endif\r\n\r\n    // #ifdef FOG\r\n    // emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    // #endif\r\n\r\n\r\n\r\n    mediump vec4 texcol = texture2D(_MainTex, uv);\r\n    texcol.a = 0.2 * abs(sin( 25. * (color.r + glstate_timer * 0.01) * 3.14159265359));\r\n\r\n    gl_FragData[0] = texcol;\r\n\r\n}","godray.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"zwrite\": \"off\",\r\n                \"ztest\": \"off\",\r\n                \"vs\": \"godray\",\r\n                \"fs\": \"godray\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"zwrite\": \"off\",\r\n                \"ztest\": \"off\",\r\n                \"vs\": \"godray\",\r\n                \"fs\": \"godray\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"vs\": \"godray\",\r\n                \"fs\": \"godray\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"vs\": \"godray\",\r\n                \"fs\": \"godray\"\r\n            }\r\n        ]\r\n    }\r\n}","godray.vs.glsl":"precision highp float;\r\n\r\n\r\n#define DEPTH_START -1.0\r\n#define DEPTH_END -5.0\r\n\r\n\r\n\r\nattribute vec4 _glesVertex;\r\nattribute vec4 _glesMultiTexCoord0;\r\nattribute mediump vec4 _glesColor;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_world2object;\r\n\r\n\r\nvarying mediump vec2 color;\r\nvarying vec2 uv;\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp float glstate_fog_start;\r\n// uniform lowp float glstate_fog_end;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n    uv = _glesMultiTexCoord0.xy;\r\n\r\n\r\n\tcolor = _glesColor.rg;\r\n\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    // #ifdef FOG\r\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    // factor = clamp(factor, 0.0, 1.0);\r\n    // #endif\r\n\r\n\r\n\r\n    // lowp vec2 _speed= vec2(_SpeedU,_SpeedV);\r\n    // _StreamLightUV = (_glesMultiTexCoord0.xy * _LightTex_ST.xy + _LightTex_ST.zw)  + _speed * glstate_timer;\r\n    gl_Position = position;\r\n}","lineui.fs.glsl":"uniform sampler2D _MainTex;\r\nvarying lowp vec4 xlv_COLOR;\r\nvarying highp vec2 xlv_TEXCOORD0;\r\nvoid main()\r\n{\r\n    lowp vec4 tmpvar_3;\r\n    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\r\n    gl_FragData[0] = tmpvar_3;\r\n}","lineui.shader.json":"{\r\n    \"layer\": \"overlay\",\r\n\t\"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\",\r\n        \"_Superimposition('Superimposition', Range(0.0, 7.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"zwrite\":\"on\",\r\n                \"ztest\":\"on\",\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"all\",\r\n                \"vs\": \"lineui\",\r\n                \"fs\": \"lineui\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","lineui.vs.glsl":"attribute vec4 _glesVertex;    \r\nattribute vec4 _glesColor;                   \r\nattribute vec4 _glesMultiTexCoord0;          \r\nuniform highp mat4 glstate_matrix_mvp;       \r\nvarying lowp vec4 xlv_COLOR;                 \r\nvarying highp vec2 xlv_TEXCOORD0;            \r\nvoid main()                                      \r\n{                                                \r\n\thighp vec4 tmpvar_1;                         \r\n\ttmpvar_1.w = 1.0;                            \r\n\ttmpvar_1.xyz = _glesVertex.xyz;              \r\n\txlv_COLOR = _glesColor;                      \r\n\txlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \r\n\tgl_Position = (glstate_matrix_mvp * tmpvar_1);   \r\n}","luminanceshiftrim.fs.glsl":"precision highp float;\r\n\r\nuniform float glstate_timer;\r\n\r\nuniform lowp sampler2D _MainTex;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\nvarying vec4 data;\r\n\r\n\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp vec4 glstate_fog_color;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\nmediump float GetLuminance (mediump vec3 rgb)\r\n{\r\n     return (0.2126 * rgb.x) + (0.7152 * rgb.y) + (0.0722 * rgb.z);\r\n}\r\n\r\nvoid main()\r\n{\r\n\r\n    // ALBEDO_TEXTURE\r\n    mediump vec4 tex = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    // if(albedo.a < _AlphaCut)\r\n    //     discard;\r\n\r\n// #if !LOW_END\r\n    // NOTE: High End\r\n    mediump float luminanceOverride = tex.a;\r\n    mediump float shift = .5 * (1. + sin(mod(3.14159 * (.5 * glstate_timer + luminanceOverride), 3.14159)));\r\n    shift /= 3. * GetLuminance(tex.rgb);\r\n    shift -= .1;\r\n\r\n    mediump float newLuminance = mix(1., shift, data.g);\r\n    tex *= newLuminance;\r\n    // NOTE: High End\r\n// #endif\r\n\r\n    #ifdef LIGHTMAP\r\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    albedo.xyz *= decode_hdr(lightmap);\r\n    #endif\r\n\r\n    gl_FragData[0] = data.r * tex;\r\n\r\n}","luminanceshiftrim.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_RimSize('Rim Size',Range(0.0,5.0)) = 0.0\",\r\n        \"_RimIntensity('Rim intensity',Range(0.0,50.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"luminanceshiftrim\",\r\n                \"fs\": \"luminanceshiftrim\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"luminanceshiftrim\",\r\n                \"fs\": \"luminanceshiftrim\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"luminanceshiftrim\",\r\n                \"fs\": \"luminanceshiftrim\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"luminanceshiftrim\",\r\n                \"fs\": \"luminanceshiftrim\"\r\n            }\r\n        ]\r\n    }\r\n}","luminanceshiftrim.vs.glsl":"precision highp float;\r\n\r\n\r\n\r\nattribute vec3 _glesVertex;\r\nattribute vec4 _glesMultiTexCoord0;\r\nattribute vec3 _glesColor;\r\nattribute highp vec3 _glesNormal;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform vec4 glstate_eyepos;\r\n\r\n\r\nuniform mediump vec4 _MainTex_ST;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n// varying vec2 uv;\r\nvarying vec4 data;\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n// #ifdef FOGs\r\n// uniform highp float glstate_fog_start;\r\n// uniform highp float glstate_fog_end;\r\n// varying highp float factor;\r\n// #endif\r\n\r\nuniform float _RimSize;\r\nuniform float _RimIntensity;\r\n\r\n\r\n#ifdef SKIN\r\nhighp mat4 blendMat;\r\nattribute highp vec4 _glesBlendIndex4;\r\nattribute highp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,highp vec4 blendIndex,highp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat* srcVertex;\r\n}\r\n#endif\r\n\r\n\r\nvoid main()\r\n{\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    highp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    highp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n\t// World position\r\n    vec3 normalizedNormal = _glesNormal;\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    normalizedNormal = normalize(mat3(blendMat) * _glesNormal);\r\n    #endif\r\n\tvec4 wp = glstate_matrix_model * position;\r\n\t// wp.xyz /= wp.w;\r\n    position = glstate_matrix_mvp * position;\r\n\r\n\r\n    // Apply the rim effect\r\n    vec3 viewDir = normalize(glstate_eyepos.xyz - wp.xyz);\r\n    normalizedNormal = normalize(mat3(glstate_matrix_model) * normalizedNormal);\r\n\tfloat dotProduct = .5 * (1. - dot(normalizedNormal, viewDir));\r\n\r\n\t// Rim Intensity\r\n\tdata.r = 1. + mix(0., _RimIntensity, dotProduct);\r\n\r\n\t// Shift intensity\r\n    data.g = _glesColor.r;\r\n\r\n    gl_Position = position;\r\n}","particles_add.shader.json":"{\r\n  \"layer\": \"transparent\",\r\n  \"queue\":  0,\r\n  \"properties\": [\r\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\r\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n          {\r\n            \"blendmode\": \"add\",\r\n            \"showface\": \"all\",\r\n            \"zwrite\": \"off\",\r\n            \"vs\": \"f14trans\",\r\n            \"fs\": \"f14trans\"\r\n          }\r\n        ],\r\n        \"shadowgen\": [],  \r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","particles_blend.shader.json":"{\r\n  \"layer\": \"transparent\",\r\n  \"queue\":  0,\r\n  \"properties\": [\r\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\r\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n          {\r\n            \"blendmode\": \"blend\",\r\n            \"showface\": \"all\",\r\n            \"zwrite\": \"off\",\r\n            \"vs\": \"f14trans\",\r\n            \"fs\": \"f14trans\"\r\n          }\r\n        ],\r\n        \"shadowgen\": [],  \r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","particle_mask_add_tint.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n\t\"properties\": [\r\n        \"_Main_Tex('MainTex',Texture)='white'{}\",\r\n        \"_Mask('Mask',Texture)='white'{}\",\r\n        \"_Main_Tex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\r\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\r\n        \"_Main_Color('Main_Color', Color) = (1,1,1,1)\",\r\n        \"_mixAlphaRate('mixAlphaRate',Float) = 1\",\r\n        \"_mixColorRate('mixColorRate',Float) = 1\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"all\",\r\n                \"blendmode\": \"add\",\r\n                \"zwrite\": \"off\",\r\n                \"ztest\":\"on\",\r\n                \"vs\": \"par_mask_tint\",\r\n                \"fs\": \"par_mask_tint\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","par_mask_tint.fs.glsl":"uniform sampler2D _Main_Tex; \r\nuniform sampler2D _Mask; \r\n\r\nvarying mediump vec2 _maintex_uv;\r\nvarying mediump vec2 _mask_uv;\r\n\r\nvarying mediump vec4 v_color;\r\n\r\nvoid main()    \r\n{\r\n    highp vec4 basecolor=texture2D(_Main_Tex,_maintex_uv);\r\n    highp vec4 maskcolor=texture2D(_Mask,_mask_uv);\r\n\r\n    mediump vec3 tempcolor=v_color.rgb*basecolor.rgb*maskcolor.rgb;\r\n    mediump float tempAlpha=v_color.a*basecolor.a*maskcolor.a;\r\n    mediump vec4 emission=vec4(tempcolor,tempAlpha);\r\n    \r\n    gl_FragData[0] = emission;\r\n}\r\n","par_mask_tint.vs.glsl":"attribute highp vec3 _glesVertex;\r\nattribute highp vec4 _glesColor;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\nuniform highp mat4 glstate_matrix_mvp;\r\n\r\nuniform mediump vec4 _Main_Tex_ST;\r\nuniform mediump vec4 _Mask_ST;\r\nvarying mediump vec2 _maintex_uv;\r\nvarying mediump vec2 _mask_uv;\r\n\r\nuniform mediump vec4 _Main_Color;\r\nuniform mediump float _mixColorRate;\r\nuniform mediump float _mixAlphaRate;\r\n\r\nvarying mediump vec4 v_color;\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\tposition =glstate_matrix_mvp * position;\r\n\t \r\n    _maintex_uv = _glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\r\n    _mask_uv = _glesMultiTexCoord0.xy * _Mask_ST.xy + _Mask_ST.zw;\r\n\tv_color=_glesColor*_Main_Color;\r\n\tv_color.rgb=v_color.rgb*_mixColorRate;\r\n\tv_color.a=v_color.a*_mixAlphaRate;\r\n\r\n\tgl_Position = position;\r\n}","PreZCloakingDevice.fs.glsl":"precision highp float;\r\n\r\n#define SHADER_NAME PreZCloakingDevice\r\n\r\nvarying vec4 color;\r\n\r\nvoid main()\r\n{\r\n\r\n    gl_FragData[0] = vec4(0, 0, 0, 0);\r\n\r\n}","PreZCloakingDevice.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n    \"properties\": [\r\n        \"_Rimsize('AlphaCut',Range(0.0,1.0)) = 1.0\",\r\n        \"_RimColour ('MainColor', Color) = (1,1,1,0.4)\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"ztest\": \"lequal\",\r\n                \"zwrite\": \"on\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"CloakingDevice\",\r\n                \"fs\": \"PreZCloakingDevice\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"ztest\": \"lequal\",\r\n                \"zwrite\": \"on\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"CloakingDevice\",\r\n                \"fs\": \"PreZCloakingDevice\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"ztest\": \"lequal\",\r\n                \"zwrite\": \"on\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"CloakingDevice\",\r\n                \"fs\": \"PreZCloakingDevice\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"blendmode\": \"add\",\r\n                \"ztest\": \"lequal\",\r\n                \"zwrite\": \"on\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"CloakingDevice\",\r\n                \"fs\": \"PreZCloakingDevice\"\r\n            }\r\n        ]\r\n    }\r\n}","RimLit.fs.glsl":"precision highp float;\r\n\r\n#define _LightingIntensity      1.\r\n\r\n#define DEPTH_START\t\t0.0\r\n#define DEPTH_END\t\t-5.0\r\n#define AMBIENT_LIGHT\t1.\r\n\r\n#define RIM_POWER\t\t0.5\r\n#define RIM_LIGHTING_OPERATOR += 0.25 *\r\n\r\n#ifdef LOW_END\r\n\t#define VERTEX_RIM_LIGHTING\r\n#else\r\n\t#define PIXEL_RIM_LIGHTING\r\n#endif\r\n\r\n\r\n#ifdef PER_PIXEL_CAUSTICS\r\n\r\n\t#ifndef NEEDS_WORLD_NORMAL\r\n\t\t#define NEEDS_WORLD_NORMAL\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_PER_PIXEL_WORLD_POS\r\n\t\t#define NEEDS_PER_PIXEL_WORLD_POS\r\n\t#endif\r\n\r\n\t#ifndef UP_FACE_FACTOR\r\n\t\t#define UP_FACE_FACTOR\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NO_LIGHTING_ABOVE_WATER\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef AMBIENT_LIGHT\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ACTION_LINE\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FAST_ACTION_LINE\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef VERTEX_RIM_LIGHTING\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef PIXEL_RIM_LIGHTING\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_NORMAL\r\n\t\t#define NEEDS_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP_ADDITIVE\r\n\t#ifndef SPHERE_MAP\r\n\t\t#define SPHERE_MAP\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP_BLEND\r\n\t#ifndef SPHERE_MAP\r\n\t\t#define SPHERE_MAP\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP\r\n\t#ifndef NEEDS_NORMAL\r\n\t\t#define NEEDS_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ABOVE_WATER_BRIGHTEN\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef UP_FACE_FACTOR\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NEEDS_NORMAL\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef PER_PIXEL_CAUSTICS\r\n    uniform lowp float _CausticsIntensity;\r\n    uniform lowp sampler2D _CausticsTex;\r\n    uniform lowp float _UnitTime;\r\n    uniform float glstate_timer;\r\n#endif\r\n\r\n\r\nuniform lowp sampler2D _MainTex;\r\n// uniform lowp float _LightingIntensity;\r\n\r\n// v2f\r\nvarying lowp vec2 xlv_TEXCOORD0;\r\n#ifdef NEEDS_NORMAL\r\n\tvarying vec3 v_normal;\r\n#endif\r\n#ifdef NEEDS_LIGHTING\r\n    // fixed2 lighting : COLOR0;\r\n    varying lowp float v_atten;\r\n\t#ifdef UP_FACE_FACTOR\r\n    varying lowp float v_facing;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp vec4 glstate_fog_color;\r\nvarying lowp float factor;\r\n#endif\r\n\r\nvoid main()\r\n{\r\n\r\n    // ALBEDO_TEXTURE\r\n    lowp vec4 albedo = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    // if(albedo.a < _AlphaCut)\r\n    //     discard;\r\n\r\n\r\n\r\n    #ifdef LIGHTMAP\r\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    albedo.xyz *= decode_hdr(lightmap);\r\n    #endif\r\n\r\n\r\n#ifdef NEEDS_LIGHTING\r\n    lowp float atten = v_atten;\r\n\r\n\t#ifdef PIXEL_RIM_LIGHTING\r\n        float rimFactor = dot(v_normal, v_normal);\r\n        #ifdef RIM_POWER\r\n            rimFactor = pow(rimFactor, RIM_POWER);\r\n        #endif\r\n\t\tatten RIM_LIGHTING_OPERATOR rimFactor;\r\n\t#endif\r\n\r\n    atten = mix(1., atten, _LightingIntensity);\r\n\r\n    albedo *= atten;\r\n#endif\r\n\r\n#ifndef ALPHA_ON\r\n    albedo.a = 1.;\r\n#endif\r\n\r\n    gl_FragData[0] = albedo;\r\n}","RimLit.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLit\",\r\n                \"fs\": \"RimLit\"\r\n            }\r\n        ]\r\n    }\r\n}","RimLit.vs.glsl":"precision highp float;\r\n\r\n\r\n#define DEPTH_START\t\t0.0\r\n#define DEPTH_END\t\t-5.0\r\n#define AMBIENT_LIGHT\t1.\r\n\r\n#define RIM_POWER\t\t0.5\r\n#define RIM_LIGHTING_OPERATOR += 0.25 *\r\n\r\n#ifdef LOW_END\r\n\t#define VERTEX_RIM_LIGHTING\r\n#else\r\n\t#define PIXEL_RIM_LIGHTING\r\n#endif\r\n\r\n\r\n#ifdef PER_PIXEL_CAUSTICS\r\n\r\n\t#ifndef NEEDS_WORLD_NORMAL\r\n\t\t#define NEEDS_WORLD_NORMAL\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_PER_PIXEL_WORLD_POS\r\n\t\t#define NEEDS_PER_PIXEL_WORLD_POS\r\n\t#endif\r\n\r\n\t#ifndef UP_FACE_FACTOR\r\n\t\t#define UP_FACE_FACTOR\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NO_LIGHTING_ABOVE_WATER\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef AMBIENT_LIGHT\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ACTION_LINE\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef FAST_ACTION_LINE\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef VERTEX_RIM_LIGHTING\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n#endif\r\n\r\n#ifdef PIXEL_RIM_LIGHTING\r\n\t#ifndef NEEDS_LIGHTING\r\n\t\t#define NEEDS_LIGHTING\r\n\t#endif\r\n\r\n\t#ifndef NEEDS_NORMAL\r\n\t\t#define NEEDS_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP_ADDITIVE\r\n\t#ifndef SPHERE_MAP\r\n\t\t#define SPHERE_MAP\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP_BLEND\r\n\t#ifndef SPHERE_MAP\r\n\t\t#define SPHERE_MAP\r\n\t#endif\r\n#endif\r\n\r\n#ifdef SPHERE_MAP\r\n\t#ifndef NEEDS_NORMAL\r\n\t\t#define NEEDS_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ABOVE_WATER_BRIGHTEN\r\n\t#ifndef NEEDS_DEPTH_FACTOR\r\n\t\t#define NEEDS_DEPTH_FACTOR\r\n\t#endif\r\n#endif\r\n\r\n#ifdef UP_FACE_FACTOR\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n#ifdef NEEDS_NORMAL\r\n\t#ifndef CALCULATE_NORMAL\r\n\t\t#define CALCULATE_NORMAL\r\n\t#endif\r\n#endif\r\n\r\n// appdata\r\nattribute vec4 _glesVertex;\r\nattribute lowp vec4 _glesMultiTexCoord0;\r\nattribute lowp vec3 _glesNormal;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_world2object;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\n\r\n// v2f\r\nvarying lowp vec2 xlv_TEXCOORD0;\r\n#ifdef NEEDS_NORMAL\r\n\tvarying vec3 v_normal;\r\n#endif\r\n#ifdef NEEDS_LIGHTING\r\n    // fixed2 lighting : COLOR0;\r\n    varying lowp float v_atten;\r\n\t#ifdef UP_FACE_FACTOR\r\n    varying lowp float v_facing;\r\n\t#endif\r\n#endif\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n#ifdef FOG\r\nuniform lowp float glstate_fog_start;\r\nuniform lowp float glstate_fog_end;\r\nvarying lowp float factor;\r\n#endif\r\n\r\n#ifdef SKIN\r\nhighp mat4 blendMat;\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n#endif\r\n\r\nfloat inverseLerp(float x, float y, float z) {\r\n\t// return (z-x) / (y - x);\r\n    return smoothstep(x,y,z);   // TODO:\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n    vec3 normal = _glesNormal;\r\n\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    normal = normalize(mat3(blendMat) * _glesNormal);\r\n    #endif\r\n\t// World position\r\n\t// mediump vec4 wp = glstate_matrix_model * position;\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n#ifdef CALCULATE_NORMAL\r\n    normal = normalize(mat3(glstate_matrix_model) * normal);\r\n#endif\r\n\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n#ifdef NEEDS_LIGHTING\r\n\tmediump float atten = 0.;\r\n\t#ifdef AMBIENT_LIGHT\r\n\t\tatten += AMBIENT_LIGHT;\r\n\t#endif\r\n\t#ifdef VERTEX_RIM_LIGHTING\r\n\t\tmediump float rimFactor = 1.-dot(normal, vec3(0,0,-1) );\r\n\r\n\t\t#ifdef RIM_POWER\r\n\t\trimFactor = pow(rimFactor, RIM_POWER);\r\n\t\t#endif\r\n\r\n\t\tatten RIM_LIGHTING_OPERATOR rimFactor;\r\n\t#endif\t// lighting.x\r\n\tv_atten = atten;\r\n#endif\r\n\r\n#ifdef NEEDS_NORMAL\r\n\t\tv_normal = normal;\r\n#endif\r\n\r\n    gl_Position = position;\r\n}","rimlitsurfacecaustics.fs.glsl":"precision highp float;\r\n\r\n\r\n#define RIM_POWER               0.5\r\n#define RIM_LIGHTING_OPERATOR += 0.25 *\r\n\r\n\r\nuniform float glstate_timer;\r\n\r\n\r\nuniform lowp sampler2D _MainTex;\r\nuniform lowp sampler2D _CausticsTex;\r\nuniform lowp float _LightingIntensity;\r\nuniform lowp float _CausticsIntensity;\r\n// // TINT_ON\r\n// uniform lowp vec4 _Tint;\r\n// uniform lowp float _TintIntensity;\r\n\r\nvarying lowp vec2 xlv_TEXCOORD0;\r\nvarying vec3 pos;\r\nvarying lowp float v_atten;\r\nvarying lowp float v_facing;\r\nvarying vec3 v_normal;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp vec4 glstate_fog_color;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\nvoid main()\r\n{\r\n\r\n    // ALBEDO_TEXTURE\r\n    lowp vec4 albedo = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    // if(albedo.a < _AlphaCut)\r\n    //     discard;\r\n\r\n    // TINT_ON\r\n    // albedo.rgb += _Tint.rgb * _TintIntensity;\r\n\r\n\r\n    #ifdef LIGHTMAP\r\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    albedo.xyz *= decode_hdr(lightmap);\r\n    #endif\r\n\r\n\r\n    // NEEDS_LIGHTING\r\n    lowp float atten = v_atten;\r\n\r\n    // PIXEL_RIM_LIGHTING\r\n    mediump float rimFactor = dot(v_normal, v_normal);\r\n#ifdef RIM_POWER\r\n    rimFactor = pow(rimFactor, RIM_POWER);\r\n#endif\r\n    // RIM_LIGHTING_OPERATOR\r\n    atten += 0.25 * rimFactor;\r\n\r\n    atten = mix(1., atten, _LightingIntensity);\r\n    // float causticcol = texture2D(_CausticsTex,projectedWorldPos).a;\r\n    // The original version is using alpha channel\r\n\r\n    // PER_PIXEL_CAUSTICS\r\n    lowp float causticsStrength = _CausticsIntensity * v_facing;\r\n    vec2 projectedWorldPos = .1 *vec2(pos.x,pos.z);\r\n    projectedWorldPos = 1. + mod(projectedWorldPos,1.);\r\n    projectedWorldPos+= mod(10.*glstate_timer * 0.01,2.);\r\n\r\n\r\n    lowp float causticcol = texture2D(_CausticsTex,projectedWorldPos).r;\r\n\r\n    // 'Add' caustics\r\n    atten += causticsStrength * causticcol;\r\n\r\n\r\n    albedo *= atten;\r\n    albedo.a = 1.;\r\n\r\n    // #ifdef FOG\r\n    // albedo.xyz = mix(glstate_fog_color.rgb, albedo.rgb, factor);\r\n    // #endif\r\n\r\n    gl_FragData[0] = albedo;\r\n}","rimlitsurfacecaustics.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_CausticsTex('Caustics',Texture) = 'white' {}\",\r\n        \"_CausticsIntensity('Caustics Strength',Range(0.0,2.0)) = 1.0\",\r\n        \"_LightingIntensity('Lighting Intensity',Range(0.0,1.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"rimlitsurfacecaustics\",\r\n                \"fs\": \"rimlitsurfacecaustics\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"rimlitsurfacecaustics\",\r\n                \"fs\": \"rimlitsurfacecaustics\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"rimlitsurfacecaustics\",\r\n                \"fs\": \"rimlitsurfacecaustics\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"rimlitsurfacecaustics\",\r\n                \"fs\": \"rimlitsurfacecaustics\"\r\n            }\r\n        ]\r\n    }\r\n}","rimlitsurfacecaustics.vs.glsl":"precision highp float;\r\n\r\n\r\n#define DEPTH_START\t\t-10.\r\n#define DEPTH_END\t\t10.\r\n#define AMBIENT_LIGHT\t0.75\r\n\r\n\r\nattribute vec4 _glesVertex;\r\nattribute lowp vec4 _glesMultiTexCoord0;\r\nattribute vec3 _glesNormal;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_world2object;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying lowp vec2 xlv_TEXCOORD0;\r\n\r\nvarying vec3 pos;\r\nvarying lowp float v_atten;\r\nvarying lowp float v_facing;\r\nvarying vec3 v_normal;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n// #ifdef FOG\r\n// // #define glstate_fog_end\t\t150.\r\n// // #define glstate_fog_start\t1.\r\n// uniform lowp float glstate_fog_start;\r\n// uniform lowp float glstate_fog_end;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\n#ifdef SKIN\r\nhighp mat4 blendMat;\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n#endif\r\n\r\nfloat inverseLerp(float x, float y, float z) {\r\n\t// return (z-x) / (y - x);\r\n    return smoothstep(x,y,z);   // TODO:\r\n}\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n\r\n    vec3 normal = _glesNormal;\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    normal = normalize(mat3(blendMat) * _glesNormal);\r\n    #endif\r\n\t// World position\r\n\tvec4 wp = glstate_matrix_model * position;\r\n\t// wp.xyz /= wp.w;\r\n    position = (glstate_matrix_mvp * position);\r\n\t// CALCULATE_NORMAL\r\n    normal = normalize(mat3(glstate_matrix_model) * normal);\r\n\tv_normal = normal;\r\n\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n\t// NEEDS_PER_PIXEL_WORLD_POS\r\n\tpos = wp.xyz;\r\n\tv_facing = clamp(dot(normal, vec3(0, sign(DEPTH_START - wp.y), 0)), 0., 1.);\r\n\r\n\t// NEEDS_DEPTH_FACTOR\r\n\t// float waterDepth = inverseLerp(DEPTH_START, DEPTH_END, wp.y);\r\n\r\n\t// NEEDS_LIGHTING\r\n\tfloat atten = 0.;\r\n\r\n#ifdef AMBIENT_LIGHT\r\n\tatten += AMBIENT_LIGHT;\r\n#endif\r\n\r\n\t// NO_LIGHTING_ABOVE_WATER\r\n\t// atten = mix( 1., atten, waterDepth);\r\n\r\n\tv_atten = atten;\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n\r\n    // #ifdef FOG\r\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    // factor = clamp(factor, 0.0, 1.0);\r\n    // #endif\r\n\r\n\r\n\t// v_facing = clamp(dot(normalize(normal), vec3(0, 1., 0)), 0., 1.);\r\n\r\n    gl_Position = position;\r\n}","RimLitUnderwaterCaustics.fs.glsl":"precision highp float;\r\n\r\n\r\n#define RIM_POWER               0.5\r\n#define RIM_LIGHTING_OPERATOR += 0.25 *\r\n\r\n\r\nuniform float glstate_timer;\r\n\r\n\r\nuniform lowp sampler2D _MainTex;\r\nuniform lowp sampler2D _CausticsTex;\r\nuniform lowp float _LightingIntensity;\r\nuniform lowp float _CausticsIntensity;\r\n// TINT_ON\r\nuniform lowp vec4 _Tint;\r\nuniform lowp float _TintIntensity;\r\n\r\nvarying lowp vec2 xlv_TEXCOORD0;\r\nvarying vec3 pos;\r\nvarying lowp float v_atten;\r\nvarying lowp float v_facing;\r\nvarying vec3 v_normal;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp vec4 glstate_fog_color;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\nvoid main()\r\n{\r\n\r\n    // ALBEDO_TEXTURE\r\n    lowp vec4 albedo = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    // if(albedo.a < _AlphaCut)\r\n    //     discard;\r\n\r\n    // TINT_ON\r\n    albedo.rgb += _Tint.rgb * _TintIntensity;\r\n\r\n\r\n    #ifdef LIGHTMAP\r\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    albedo.xyz *= decode_hdr(lightmap);\r\n    #endif\r\n\r\n\r\n    // NEEDS_LIGHTING\r\n    lowp float atten = v_atten;\r\n\r\n    // PIXEL_RIM_LIGHTING\r\n    mediump float rimFactor = dot(v_normal, v_normal);\r\n#ifdef RIM_POWER\r\n    rimFactor = pow(rimFactor, RIM_POWER);\r\n#endif\r\n    // RIM_LIGHTING_OPERATOR\r\n    atten += 0.25 * rimFactor;\r\n\r\n    atten = mix(1., atten, _LightingIntensity);\r\n    // float causticcol = texture2D(_CausticsTex,projectedWorldPos).a;\r\n    // The original version is using alpha channel\r\n\r\n    // PER_PIXEL_CAUSTICS\r\n    lowp float causticsStrength = _CausticsIntensity * v_facing;\r\n    vec2 projectedWorldPos = .1 *vec2(pos.x,pos.z);\r\n    projectedWorldPos = 1. + mod(projectedWorldPos,1.);\r\n    projectedWorldPos+= mod(10.*glstate_timer * 0.01,2.);\r\n\r\n\r\n    lowp float causticcol = texture2D(_CausticsTex,projectedWorldPos).r;\r\n\r\n    // 'Add' caustics\r\n    atten += causticsStrength * causticcol;\r\n\r\n\r\n    albedo *= atten;\r\n    albedo.a = 1.;\r\n\r\n    // #ifdef FOG\r\n    // albedo.xyz = mix(glstate_fog_color.rgb, albedo.rgb, factor);\r\n    // #endif\r\n\r\n    gl_FragData[0] = albedo;\r\n}","RimLitUnderwaterCaustics.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_CausticsTex('Caustics',Texture) = 'white' {}\",\r\n        \"_CausticsIntensity('Caustics Strength',Range(0.0,2.0)) = 1.0\",\r\n        \"_LightingIntensity('Lighting Intensity',Range(0.0,1.0)) = 1.0\",\r\n        \"_Tint ('Tint Colour', Color) = (1,1,1,1)\",\r\n        \"_TintIntensity('Tint intensity',Range(0.0,1.0)) = 0.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLitUnderwaterCaustics\",\r\n                \"fs\": \"RimLitUnderwaterCaustics\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLitUnderwaterCaustics\",\r\n                \"fs\": \"RimLitUnderwaterCaustics\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLitUnderwaterCaustics\",\r\n                \"fs\": \"RimLitUnderwaterCaustics\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"RimLitUnderwaterCaustics\",\r\n                \"fs\": \"RimLitUnderwaterCaustics\"\r\n            }\r\n        ]\r\n    }\r\n}","RimLitUnderwaterCaustics.vs.glsl":"precision highp float;\r\n\r\n\r\n#define DEPTH_START\t\t0.0\r\n#define DEPTH_END\t\t-5.0\r\n#define AMBIENT_LIGHT\t0.75\r\n\r\n\r\nattribute vec4 _glesVertex;\r\nattribute lowp vec4 _glesMultiTexCoord0;\r\nattribute vec3 _glesNormal;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_world2object;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying lowp vec2 xlv_TEXCOORD0;\r\n\r\nvarying vec3 pos;\r\nvarying lowp float v_atten;\r\nvarying lowp float v_facing;\r\nvarying vec3 v_normal;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n// #ifdef FOG\r\n// // #define glstate_fog_end\t\t150.\r\n// // #define glstate_fog_start\t1.\r\n// uniform lowp float glstate_fog_start;\r\n// uniform lowp float glstate_fog_end;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\n#ifdef SKIN\r\nhighp mat4 blendMat;\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n#endif\r\n\r\nfloat inverseLerp(float x, float y, float z) {\r\n\t// return (z-x) / (y - x);\r\n    return smoothstep(x,y,z);   // TODO:\r\n}\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n\r\n    vec3 normal = _glesNormal;\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    normal = normalize(mat3(blendMat) * _glesNormal);\r\n    #endif\r\n\t// World position\r\n\tvec4 wp = glstate_matrix_model * position;\r\n\t// wp.xyz /= wp.w;\r\n    position = (glstate_matrix_mvp * position);\r\n\t// CALCULATE_NORMAL\r\n    normal = normalize(mat3(glstate_matrix_model) * normal);\r\n\tv_normal = normal;\r\n\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n\t// NEEDS_PER_PIXEL_WORLD_POS\r\n\tpos = wp.xyz;\r\n\tv_facing = clamp(dot(normal, vec3(0, sign(DEPTH_START - wp.y), 0)), 0., 1.);\r\n\r\n\t// NEEDS_DEPTH_FACTOR\r\n\tfloat waterDepth = inverseLerp(DEPTH_START, DEPTH_END, wp.y);\r\n\r\n\t// NEEDS_LIGHTING\r\n\tfloat atten = 0.;\r\n\r\n#ifdef AMBIENT_LIGHT\r\n\tatten += AMBIENT_LIGHT;\r\n#endif\r\n\r\n\t// NO_LIGHTING_ABOVE_WATER\r\n\tatten = mix( 1., atten, waterDepth);\r\n\tv_atten = atten;\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n\r\n    // #ifdef FOG\r\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    // factor = clamp(factor, 0.0, 1.0);\r\n    // #endif\r\n\r\n\r\n\t// v_facing = clamp(dot(normalize(normal), vec3(0, 1., 0)), 0., 1.);\r\n\r\n    gl_Position = position;\r\n}","skyplanebackground.fs.glsl":"\r\n\r\nprecision highp float;\r\n\r\n\r\n\r\nuniform sampler2D _MainTex;\r\n\r\nvarying vec2 uv;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp vec4 glstate_fog_color;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\nvoid main()\r\n{\r\n    lowp vec4 emission = texture2D(_MainTex, uv);\r\n\r\n    // #ifdef LIGHTMAP\r\n    // lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    // emission.xyz *= decode_hdr(lightmap);\r\n    // #endif\r\n\r\n    // #ifdef FOG\r\n    // emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    // #endif\r\n\r\n    gl_FragData[0] = emission;\r\n\r\n}","skyplanebackground.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"skyplanebackground\",\r\n                \"fs\": \"skyplanebackground\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"skyplanebackground\",\r\n                \"fs\": \"skyplanebackground\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"skyplanebackground\",\r\n                \"fs\": \"skyplanebackground\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"skyplanebackground\",\r\n                \"fs\": \"skyplanebackground\"\r\n            }\r\n        ]\r\n    }\r\n}","skyplanebackground.vs.glsl":"precision highp float;\r\n\r\n\r\n\r\nattribute vec4 _glesVertex;\r\nattribute vec4 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\n\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying vec2 uv;\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp float glstate_fog_start;\r\n// uniform lowp float glstate_fog_end;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\n\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n\r\n\r\n    // #ifdef FOG\r\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    // factor = clamp(factor, 0.0, 1.0);\r\n    // #endif\r\n\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    // Force the screen space z to the far clip plane so even though this renders last (and the geometry is front of some stuff), it still renders behind everything\r\n    position.z = position.w - 0.01;\r\n\r\n    uv = _glesMultiTexCoord0.xy*_MainTex_ST.xy+_MainTex_ST.zw;\r\n\r\n    gl_Position = position;\r\n}","skyplanebackgroundblend.fs.glsl":"precision highp float;\r\n\r\n\r\n\r\nuniform sampler2D _MainTex;\r\nuniform sampler2D _NextTex;\r\nuniform float _BlendValue;\r\n\r\nvarying vec2 uv;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp vec4 glstate_fog_color;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\nvoid main()\r\n{\r\n    vec4 emission = mix(texture2D(_MainTex, uv), texture2D(_NextTex, uv), _BlendValue);\r\n\r\n    // #ifdef LIGHTMAP\r\n    // lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    // emission.xyz *= decode_hdr(lightmap);\r\n    // #endif\r\n\r\n    // #ifdef FOG\r\n    // emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n    // #endif\r\n\r\n    gl_FragData[0] = emission;\r\n\r\n}","skyplanebackgroundblend.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_NextTex('Destiny Texture',Texture)='white'{}\",\r\n        \"_BlendValue('Blend Value',Range(0.0,1.0)) = 0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"skyplanebackgroundblend\",\r\n                \"fs\": \"skyplanebackgroundblend\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"skyplanebackgroundblend\",\r\n                \"fs\": \"skyplanebackgroundblend\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"skyplanebackgroundblend\",\r\n                \"fs\": \"skyplanebackgroundblend\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"skyplanebackgroundblend\",\r\n                \"fs\": \"skyplanebackgroundblend\"\r\n            }\r\n        ]\r\n    }\r\n}","skyplanebackgroundblend.vs.glsl":"precision highp float;\r\n\r\n\r\n\r\nattribute vec4 _glesVertex;\r\nattribute vec4 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\n\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying vec2 uv;\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp float glstate_fog_start;\r\n// uniform lowp float glstate_fog_end;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\n\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n\r\n\r\n    // #ifdef FOG\r\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    // factor = clamp(factor, 0.0, 1.0);\r\n    // #endif\r\n\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    // Force the screen space z to the far clip plane so even though this renders last (and the geometry is front of some stuff), it still renders behind everything\r\n    position.z = position.w - 0.01;\r\n\r\n    uv = _glesMultiTexCoord0.xy*_MainTex_ST.xy+_MainTex_ST.zw;\r\n\r\n    gl_Position = position;\r\n}","SphereMapAdditive.fs.glsl":"precision highp float;\r\n\r\n\r\n#define RIM_POWER               0.5\r\n#define RIM_LIGHTING_OPERATOR += 0.25 *\r\n\r\n\r\nuniform lowp sampler2D _MainTex;\r\nuniform lowp sampler2D _SphereMap;\r\nuniform lowp float _SphereMapIntensity;\r\n\r\nvarying lowp vec2 xlv_TEXCOORD0;\r\nvarying vec3 v_normal;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nuniform lowp sampler2D _LightmapTex;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\nlowp vec3 decode_hdr(lowp vec4 data)\r\n{\r\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n    return data.rgb * power * 2.0 ;\r\n}\r\n#endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp vec4 glstate_fog_color;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\nvoid main()\r\n{\r\n\r\n    // ALBEDO_TEXTURE\r\n    // lowp vec4 albedo = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    lowp vec4 albedo = vec4(0);\r\n    // if(albedo.a < _AlphaCut)\r\n    //     discard;\r\n\r\n    // SPHERE_MAP\r\n    lowp vec2 sphereMapCoordinate = 0.5 + 0.5 * v_normal.xy;\r\n    // SPHERE_MAP_ADDITIVE\r\n    albedo += texture2D(_SphereMap, sphereMapCoordinate) * _SphereMapIntensity;\r\n\r\n    #ifdef LIGHTMAP\r\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    albedo.xyz *= decode_hdr(lightmap);\r\n    #endif\r\n\r\n\r\n\r\n\r\n    // #ifdef FOG\r\n    // albedo.xyz = mix(glstate_fog_color.rgb, albedo.rgb, factor);\r\n    // #endif\r\n\r\n    gl_FragData[0] = albedo;\r\n}","SphereMapAdditive.shader.json":"{\r\n    \"layer\": \"geometry\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_SphereMap('SphereMap',Texture) = 'white' {}\",\r\n        \"_SphereMapIntensity('Lighting Intensity',Range(0.0,1.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"SphereMapAdditive\",\r\n                \"fs\": \"SphereMapAdditive\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"SphereMapAdditive\",\r\n                \"fs\": \"SphereMapAdditive\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"SphereMapAdditive\",\r\n                \"fs\": \"SphereMapAdditive\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"SphereMapAdditive\",\r\n                \"fs\": \"SphereMapAdditive\"\r\n            }\r\n        ]\r\n    }\r\n}","SphereMapAdditive.vs.glsl":"precision highp float;\r\n\r\n\r\n\r\nattribute vec4 _glesVertex;\r\nattribute lowp vec4 _glesMultiTexCoord0;\r\nattribute vec3 _glesNormal;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying lowp vec2 xlv_TEXCOORD0;\r\n\r\nvarying vec3 v_normal;\r\n\r\n\r\n#ifdef LIGHTMAP\r\nattribute mediump vec4 _glesMultiTexCoord1;\r\nuniform mediump vec4 glstate_lightmapOffset;\r\n// uniform mediump float glstate_lightmapUV;\r\nvarying mediump vec2 lightmap_TEXCOORD;\r\n#endif\r\n\r\n// #ifdef FOG\r\n// #define glstate_fog_end\t\t150.\r\n// #define glstate_fog_start\t1.\r\n// // uniform lowp float glstate_fog_start;\r\n// // uniform lowp float glstate_fog_end;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\n#ifdef SKIN\r\nhighp mat4 blendMat;\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    blendMat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn blendMat * srcVertex;\r\n}\r\n#endif\r\n\r\nfloat inverseLerp(float x, float y, float z) {\r\n\t// return (z-x) / (y - x);\r\n    return smoothstep(x,y,z);   // TODO:\r\n}\r\n\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n\r\n    vec3 normal = _glesNormal;\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    normal = normalize(mat3(blendMat) * _glesNormal);\r\n    #endif\r\n\t// // World position\r\n\t// vec4 wp = glstate_matrix_model * position;\r\n\t// // wp.xyz /= wp.w;\r\n    position = (glstate_matrix_mvp * position);\r\n\t// CALCULATE_NORMAL\r\n    normal = normalize(mat3(glstate_matrix_model) * normal);\r\n\tv_normal = normal;\r\n\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n\r\n\r\n\r\n\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef LIGHTMAP\r\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    lightmap_TEXCOORD = vec2(u,v);\r\n    #endif\r\n\r\n\r\n    // #ifdef FOG\r\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    // factor = clamp(factor, 0.0, 1.0);\r\n    // #endif\r\n\r\n\r\n\t// v_facing = clamp(dot(normalize(normal), vec3(0, 1., 0)), 0., 1.);\r\n\r\n    gl_Position = position;\r\n}","trail.fs.glsl":"precision lowp float;\r\nuniform lowp sampler2D _MainTex;\r\n\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\nvarying highp vec4 v_color;\r\n\r\nvoid main()\r\n{\r\n    //gl_FragData[0] = v_color;\r\n\r\n    lowp vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\r\n\r\n    // if(basecolor.a < 0.01)\r\n    //     discard;\r\n\r\n    //lowp vec4 fristColor=basecolor*_MainColor * vec4(v_color.rgb, 1);\r\n    //lowp vec4 emission = fristColor;\r\n    lowp vec4 emission =  v_color * basecolor;\r\n    // lowp vec4 emission =  basecolor * vec4(1.0,1.0,1.0,v_color.a);\r\n\r\n    gl_FragData[0] = emission;\r\n}","trail.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n    \"queue\": 0,\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"all\",\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"trail\",\r\n                \"fs\": \"trail\"\r\n            }\r\n        ],\r\n\t\t\"base_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"all\",\r\n                \"zwrite\": \"off\",\r\n                \"vs\": \"trail\",\r\n                \"fs\": \"trail\"\r\n            }\r\n        ]\r\n    }\r\n}","trail.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n\r\n\r\nattribute vec4 _glesColor;\r\nvarying highp vec4 v_color;\r\n\r\nvoid main()\r\n{\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n    position = (glstate_matrix_mvp * position);\r\n\tv_color = _glesColor;\r\n    gl_Position =position;\r\n}","transparent.fs.glsl":"uniform lowp sampler2D _MainTex;\r\nvarying highp vec2 xlv_TEXCOORD0;\r\nuniform lowp float _Alpha;\r\nuniform lowp float _Superimposition;\r\n\r\n// #ifdef FOG\r\n// uniform lowp vec4 glstate_fog_color;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\nvoid main()\r\n{\r\n    lowp vec4 emission = texture2D(_MainTex, xlv_TEXCOORD0);\r\n    emission.a=emission.a*_Alpha;\r\n    emission.xyz *= _Superimposition;\r\n    //----------------------------------------------------------\r\n    // #ifdef FOG\r\n    // emission.xyz= mix(glstate_fog_color.xyz, emission.xyz, factor);\r\n    // #endif\r\n    gl_FragData[0] = emission;\r\n\r\n}","transparent.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n\t\"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\",\r\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\",\r\n        \"_Superimposition('Superimposition', Range(0.0, 7.0)) = 1.0\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"transparent\",\r\n                \"fs\": \"transparent\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"transparent\",\r\n                \"fs\": \"transparent\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"transparent\",\r\n                \"fs\": \"transparent\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"transparent\",\r\n                \"fs\": \"transparent\"\r\n            }\r\n        ],\r\n        \"shadowgen\": [],\r\n        \"bone\": [],\r\n        \"shadowuse\": []\r\n    }\r\n}","transparent.vs.glsl":"attribute highp vec4 _glesVertex;\r\nattribute mediump vec4 _glesMultiTexCoord0;\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying mediump vec2 xlv_TEXCOORD0;\r\n\r\n// #ifdef FOG\r\n// #define glstate_fog_end\t\t150.\r\n// #define glstate_fog_start\t1.\r\n// // uniform lowp float glstate_fog_start;\r\n// // uniform lowp float glstate_fog_end;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\n#ifdef SKIN\r\nattribute lowp vec4 _glesBlendIndex4;\r\nattribute lowp vec4 _glesBlendWeight4;\r\nuniform highp vec4 glstate_vec4_bones[110];\r\nmat4 buildMat4(int index)\r\n{\r\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\r\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\r\n\tfloat xy = 2.0 * quat.x * quat.y;\r\n\tfloat xz = 2.0 * quat.x * quat.z;\r\n\tfloat xw = 2.0 * quat.x * quat.w;\r\n\tfloat yz = 2.0 * quat.y * quat.z;\r\n\tfloat yw = 2.0 * quat.y * quat.w;\r\n\tfloat zw = 2.0 * quat.z * quat.w;\r\n\tfloat xx = 2.0*quat.x * quat.x;\r\n\tfloat yy = 2.0*quat.y * quat.y;\r\n\tfloat zz = 2.0*quat.z * quat.z;\r\n\tfloat ww = 2.0*quat.w * quat.w;\r\n\tfloat s = translation.w;\r\n\tmat4 matrix = mat4(\r\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\r\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\r\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\r\n\ttranslation.x, translation.y, translation.z, 1);\r\n\treturn matrix;\r\n}\r\n\r\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\r\n{\r\n\tint i = int(blendIndex.x);\r\n    int i2 =int(blendIndex.y);\r\n\tint i3 =int(blendIndex.z);\r\n\tint i4 =int(blendIndex.w);\r\n\r\n    mat4 mat = buildMat4(i)*blendWeight.x\r\n\t\t\t + buildMat4(i2)*blendWeight.y\r\n\t\t\t + buildMat4(i3)*blendWeight.z\r\n\t\t\t + buildMat4(i4)*blendWeight.w;\r\n\treturn mat* srcVertex;\r\n}\r\n#endif\r\nvoid main()\r\n{\r\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\r\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n\r\n    //----------------------------------------------------------\r\n    #ifdef SKIN\r\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\r\n    #endif\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n    // #ifdef FOG\r\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    // factor = clamp(factor, 0.0, 1.0);\r\n    // #endif\r\n\r\n    gl_Position = position;\r\n}","water.fs.glsl":"\r\n\r\nprecision highp float;\r\n\r\n\r\n\r\nuniform sampler2D _MainTex;\r\n\r\n\r\nvarying vec4 color;\r\nvarying vec2 uv;\r\n\r\n// #ifdef LIGHTMAP\r\n// uniform lowp sampler2D _LightmapTex;\r\n// varying mediump vec2 lightmap_TEXCOORD;\r\n// lowp vec3 decode_hdr(lowp vec4 data)\r\n// {\r\n//     lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\r\n//     return data.rgb * power * 2.0 ;\r\n// }\r\n// #endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp vec4 glstate_fog_color;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\nvoid main()\r\n{\r\n    vec4 emission = texture2D(_MainTex, uv);\r\n    // lowp vec4 emission = lerp(tex2D(_MainTex, uv), tex2D(_NextTex, uv), _BlendValue);\r\n    // if(emission.a < _AlphaCut)\r\n    //     discard;\r\n\r\n    // #ifdef LIGHTMAP\r\n    // lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\r\n    // emission.xyz *= decode_hdr(lightmap);\r\n    // #endif\r\n\r\n\r\n\r\n\r\n\r\n    // vec4 texcol = texture2D(_MainTex, uv);\r\n    // texcol.a = 0.2 * abs(sin( 25. * (color.r + glstate_timer * 0.02) * 3.14159265359));\r\n\r\n\t// #ifdef FOG\r\n    // emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\r\n\t// #endif\r\n\r\n    emission.a *= color.x;\r\n    gl_FragData[0] = emission;\r\n\r\n}","water.shader.json":"{\r\n    \"layer\": \"transparent\",\r\n    \"properties\": [\r\n        \"_MainTex('MainTex',Texture)='white'{}\"\r\n    ],\r\n    \"passes\": {\r\n        \"base\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"zwrite\": \"off\",\r\n                \"ztest\": \"lequal\",\r\n                \"showface\": \"all\",\r\n                \"vs\": \"water\",\r\n                \"fs\": \"water\"\r\n            }\r\n        ],\r\n        \"base_fog\": [\r\n            {\r\n                \"blendmode\": \"blend\",\r\n                \"zwrite\": \"off\",\r\n                \"ztest\": \"lequal\",\r\n                \"showface\": \"all\",\r\n                \"vs\": \"water\",\r\n                \"fs\": \"water\"\r\n            }\r\n        ],\r\n        \"skin\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"water\",\r\n                \"fs\": \"water\"\r\n            }\r\n        ],\r\n        \"skin_fog\": [\r\n            {\r\n                \"showface\": \"ccw\",\r\n                \"vs\": \"water\",\r\n                \"fs\": \"water\"\r\n            }\r\n        ]\r\n    }\r\n}","water.vs.glsl":"precision highp float;\r\n\r\n#define timer glstate_timer * 0.01\r\n\r\nattribute highp vec4 _glesVertex;\r\nattribute mediump vec2 _glesMultiTexCoord0;\r\nattribute lowp vec2 _glesMultiTexCoord1;\r\nattribute mediump vec4 _glesColor;\r\n\r\nuniform highp mat4 glstate_matrix_mvp;\r\nuniform highp mat4 glstate_matrix_model;\r\nuniform highp mat4 glstate_matrix_world2object;\r\n\r\nuniform vec4 glstate_eyepos;\r\nuniform float glstate_timer;\r\n\r\nuniform mediump vec4 _MainTex_ST;\r\n\r\nvarying vec4 color;\r\nvarying vec2 uv;\r\n\r\n// #ifdef LIGHTMAP\r\n// attribute mediump vec4 _glesMultiTexCoord1;\r\n// uniform mediump vec4 glstate_lightmapOffset;\r\n// // uniform mediump float glstate_lightmapUV;\r\n// varying mediump vec2 lightmap_TEXCOORD;\r\n// #endif\r\n\r\n// #ifdef FOG\r\n// uniform lowp float glstate_fog_start;\r\n// uniform lowp float glstate_fog_end;\r\n// varying lowp float factor;\r\n// #endif\r\n\r\n\r\nfloat inverseLerp(float x,float y,float z){\r\n\t// return clamp((z-x)/(y-x), 0., 1.);\r\n    // return clamp(z-x, 0, y)/(y-x);\r\n    return smoothstep(x,y,z);   // TODO:\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n    vec4 position=vec4(_glesVertex.xyz,1.0);\r\n\r\n\r\n    // //----------------------------------------------------------\r\n    // #ifdef LIGHTMAP\r\n    // mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\r\n    // lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\r\n    // lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\r\n    // lightmap_TEXCOORD = vec2(u,v);\r\n    // #endif\r\n\r\n\r\n\r\n    // #ifdef FOG\r\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\r\n    // factor = clamp(factor, 0.0, 1.0);\r\n    // #endif\r\n\r\n\r\n    mediump float belowWaterFactor = inverseLerp(1., -3. , glstate_eyepos.y);\r\n\r\n    position.z *= 0.5;\r\n\r\n    color.x = inverseLerp(-1., 0., position.z) - inverseLerp(30., 40., position.z);\r\n    color.y = 0.;\r\n\r\n    position.y *= sin( 150. * (_glesColor.r + timer * 3.14159265359)) * 0.3 * color.x * belowWaterFactor;\r\n    position.y -= belowWaterFactor * 2. * inverseLerp(20., 40., position.z);\r\n\r\n\r\n\r\n    position = (glstate_matrix_mvp * position);\r\n\r\n\r\n    uv = _glesMultiTexCoord0.xy*_MainTex_ST.xy+_MainTex_ST.zw;\r\n    uv += timer * 15.;\r\n\r\n    gl_Position = position;\r\n}"}