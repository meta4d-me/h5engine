{"actionlinecaustics.fs.glsl":"\n\nprecision highp float;\n\n#define AMBIENT_LIGHT 0.\n#define DEPTH_START -1.0\n#define DEPTH_END -5.0\n\n#define NO_LIGHTING_ABOVE_WATER\n\n#define RIM_POWER 0.5\n#define RIM_LIGHTING_OPERATOR -= 0.25 *\n\n#ifdef LOW_END\n\t#define VERTEX_RIM_LIGHTING\n\t#define ACTION_LINE\n#else\n\t#define PIXEL_RIM_LIGHTING\n\t#define PER_PIXEL_CAUSTICS\n\t#define BUMP_MAPPED_CAUSTICS\n\t#define ACTION_LINE\n#endif\n\n#ifdef PER_PIXEL_CAUSTICS\n\n\t#ifndef NEEDS_WORLD_NORMAL\n\t\t#define NEEDS_WORLD_NORMAL\n\t#endif\n\n\t#ifndef NEEDS_PER_PIXEL_WORLD_POS\n\t\t#define NEEDS_PER_PIXEL_WORLD_POS\n\t#endif\n\n\t#ifndef UP_FACE_FACTOR\n\t\t#define UP_FACE_FACTOR\n\t#endif\n\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef NO_LIGHTING_ABOVE_WATER\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef AMBIENT_LIGHT\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef ACTION_LINE\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef FAST_ACTION_LINE\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef VERTEX_RIM_LIGHTING\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef PIXEL_RIM_LIGHTING\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n\n\t#ifndef NEEDS_NORMAL\n\t\t#define NEEDS_NORMAL\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP_ADDITIVE\n\t#ifndef SPHERE_MAP\n\t\t#define SPHERE_MAP\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP_BLEND\n\t#ifndef SPHERE_MAP\n\t\t#define SPHERE_MAP\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP\n\t#ifndef NEEDS_NORMAL\n\t\t#define NEEDS_NORMAL\n\t#endif\n#endif\n\n#ifdef ABOVE_WATER_BRIGHTEN\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef UP_FACE_FACTOR\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n#endif\n\n#ifdef NEEDS_NORMAL\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n#endif\n\n\n\nuniform lowp sampler2D _MainTex;\n\n#ifdef NEEDS_LIGHTING\n    // uniform lowp float _LightingIntensity;\n#endif\n#ifdef PER_PIXEL_CAUSTICS\n    uniform lowp float _CausticsIntensity;\n    uniform lowp sampler2D _CausticsTex;\n    uniform lowp float _UnitTime;\n    uniform float glstate_timer;\n#endif\n\n// NOTE: v2f\nvarying lowp vec2 xlv_TEXCOORD0;\nvarying lowp vec2 _CausticsTex_UV;\n\n#ifdef NEEDS_PER_PIXEL_WORLD_POS\n    varying vec3 pos;\n#endif\n#ifdef NEEDS_LIGHTING\n    // fixed2 lighting : COLOR0;\n    varying lowp float v_atten;\n\t#ifdef UP_FACE_FACTOR\n\tvarying lowp float v_facing;\n\t#endif\n#endif\n#ifdef NEEDS_NORMAL\n    // float3 normal : COLOR1;\n    varying vec3 v_normal;\n#endif\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color;\nvarying lowp float factor;\n#endif\n\nvoid main()\n{\n    lowp vec4 emission = texture2D(_MainTex, xlv_TEXCOORD0);\n    // if(emission.a < _AlphaCut)\n    //     discard;\n\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    emission.xyz *= decode_hdr(lightmap);\n    #endif\n\n\n\n\n    // vec4 final = texture2D(_MainTex, xlv_TEXCOORD0);\n\n#ifdef NEEDS_LIGHTING\n    lowp float atten = v_atten;\n\t#ifdef PIXEL_RIM_LIGHTING\n\t\tmediump float rimFactor = dot(v_normal, v_normal);\n\t\t#ifdef RIM_POWER\n\t\t\trimFactor = pow(rimFactor, RIM_POWER);\n\t\t#endif\n\t\tatten RIM_LIGHTING_OPERATOR rimFactor;\n    #endif\n\n    // atten = mix(1., atten, _LightingIntensity);\n    atten = 1.;\n\n\t#ifdef PER_PIXEL_CAUSTICS\n        lowp float causticsStrength = _CausticsIntensity * v_facing;\n        vec2 projectedWorldPos = .1 *vec2(pos.x,pos.z);\n\n        projectedWorldPos = 1. + mod(projectedWorldPos,1.);\n        projectedWorldPos += mod(10.* glstate_timer * 0.01,2.);\n        #ifdef BUMP_MAPPED_CAUSTICS\n            projectedWorldPos += 0.05 * length(emission);\n        #endif\n        // The original version is using alpha channel\n        lowp float causticcol = texture2D(_CausticsTex,projectedWorldPos).r;\n\n        atten += causticsStrength * causticcol;\n\n    #endif\n    emission *= atten;\n#endif\n\n    #ifdef FOG\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    #endif\n\n    gl_FragData[0] = emission;\n}","actionlinecaustics.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_CausticsTex('Light',Texture) = 'white' {}\",\n        \"_LightingIntensity('LightRate',Range(0.0,1.0)) = 1.0\",\n        \"_CausticsIntensity('LightRate',Range(0.0,1.0)) = 1.0\",\n        \"_UnitTime('LightRate',Range(0.0,1.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"actionlinecaustics\",\n                \"fs\": \"actionlinecaustics\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"actionlinecaustics\",\n                \"fs\": \"actionlinecaustics\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"actionlinecaustics\",\n                \"fs\": \"actionlinecaustics\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"actionlinecaustics\",\n                \"fs\": \"actionlinecaustics\"\n            }\n        ]\n    }\n}","actionlinecaustics.vs.glsl":"precision highp float;\n\n#define AMBIENT_LIGHT 0.\n#define DEPTH_START -1.0\n#define DEPTH_END -5.0\n\n#define NO_LIGHTING_ABOVE_WATER\n\n#define RIM_POWER 0.5\n#define RIM_LIGHTING_OPERATOR -= 0.25 *\n\n#ifdef LOW_END\n\t#define VERTEX_RIM_LIGHTING\n\t#define ACTION_LINE\n#else\n\t#define PIXEL_RIM_LIGHTING\n\t#define PER_PIXEL_CAUSTICS\n\t#define BUMP_MAPPED_CAUSTICS\n\t#define ACTION_LINE\n#endif\n\n#ifdef PER_PIXEL_CAUSTICS\n\n\t#ifndef NEEDS_WORLD_NORMAL\n\t\t#define NEEDS_WORLD_NORMAL\n\t#endif\n\n\t#ifndef NEEDS_PER_PIXEL_WORLD_POS\n\t\t#define NEEDS_PER_PIXEL_WORLD_POS\n\t#endif\n\n\t#ifndef UP_FACE_FACTOR\n\t\t#define UP_FACE_FACTOR\n\t#endif\n\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef NO_LIGHTING_ABOVE_WATER\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef AMBIENT_LIGHT\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef ACTION_LINE\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef FAST_ACTION_LINE\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef VERTEX_RIM_LIGHTING\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef PIXEL_RIM_LIGHTING\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n\n\t#ifndef NEEDS_NORMAL\n\t\t#define NEEDS_NORMAL\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP_ADDITIVE\n\t#ifndef SPHERE_MAP\n\t\t#define SPHERE_MAP\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP_BLEND\n\t#ifndef SPHERE_MAP\n\t\t#define SPHERE_MAP\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP\n\t#ifndef NEEDS_NORMAL\n\t\t#define NEEDS_NORMAL\n\t#endif\n#endif\n\n#ifdef ABOVE_WATER_BRIGHTEN\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef UP_FACE_FACTOR\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n#endif\n\n#ifdef NEEDS_NORMAL\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n#endif\n\nattribute vec4 _glesVertex;\nattribute lowp vec4 _glesMultiTexCoord0;\nattribute vec3 _glesNormal;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_world2object;\nuniform mediump vec4 _MainTex_ST;\nuniform mediump vec4 _CausticsTex_ST;\n\n// NOTE: v2f\nvarying lowp vec2 xlv_TEXCOORD0;\nvarying lowp vec2 _CausticsTex_UV;\n\n#ifdef NEEDS_PER_PIXEL_WORLD_POS\n    varying vec3 pos;\n#endif\n#ifdef NEEDS_LIGHTING\n    // fixed2 lighting : COLOR0;\n    varying lowp float v_atten;\n\t#ifdef UP_FACE_FACTOR\n\tvarying lowp float v_facing;\n\t#endif\n#endif\n#ifdef NEEDS_NORMAL\n    // float3 normal : COLOR1;\n    varying vec3 v_normal;\n#endif\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n#ifdef FOG\n// #define glstate_fog_end\t\t150.\n// #define glstate_fog_start\t1.\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n#ifdef SKIN\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    mat4 mat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn mat* srcVertex;\n}\n#endif\n\nfloat inverseLerp(float x, float y, float z) {\n\treturn (z-x) / (y - x);\n}\n\nvoid main()\n{\n    vec4 position=vec4(_glesVertex.xyz,1.0);\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n    _CausticsTex_UV = _glesMultiTexCoord0.xy * _CausticsTex_ST.xy + _CausticsTex_ST.zw;\n\n\n\t// World position\n\tvec4 wp = glstate_matrix_model*position;\n\twp.xyz /= wp.w;\n\n#ifdef CALCULATE_NORMAL\n\tvec3 normal = normalize((glstate_matrix_model * vec4(_glesNormal, 0.0)).xyz);\n#endif\n\n#ifdef NEEDS_PER_PIXEL_WORLD_POS\n\tpos = wp.xyz;\n#endif\n\t// pos = _glesVertex.xyz;\n\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n#ifdef NEEDS_DEPTH_FACTOR\n\tmediump float waterDepth = inverseLerp(DEPTH_START, DEPTH_END, wp.y);\n#endif\n\n#ifdef NEEDS_LIGHTING\n\tmediump float atten = 0.;\n\t#ifdef ACTION_LINE\n\t\t// Middle-ground / above water factor\n\t\tmediump float actionLine = mix( 1., 0.2, (inverseLerp( 0., 1.5, wp.z) - inverseLerp(5.,50.,wp.z)) );\n\t#endif\n\n\t#ifdef AMBIENT_LIGHT\n\t\tatten += AMBIENT_LIGHT;\n\t#endif\n\n\t#ifdef VERTEX_RIM_LIGHTING\n\t\tmediump float rimFactor = 1. - dot(normal, vec3(0,0,-1) );\n\t\t#ifdef RIM_POWER\n\t\trimFactor = pow(rimFactor, RIM_POWER);\n\t\t#endif\n\t\tatten RIM_LIGHTING_OPERATOR rimFactor;\n\t#endif\n\n\t#ifdef NO_LIGHTING_ABOVE_WATER\n\t\tatten = mix( 1., atten, waterDepth);\n\t#endif\n\tv_atten = atten;\n\n\t// v_facing = clamp(dot(normalize(normal), vec3(0, 1., 0)), 0., 1.);\n\t#ifdef UP_FACE_FACTOR\n\t\tv_facing = clamp(dot(normal, vec3(0, sign(DEPTH_START - wp.y), 0)), 0., 1.);\n\t#endif\n\n#endif\n\n#ifdef NEEDS_NORMAL\n\t\tv_normal = normal;\n#endif\n\n    // lowp vec2 _speed= vec2(_SpeedU,_SpeedV);\n    // _StreamLightUV = (_glesMultiTexCoord0.xy * _LightTex_ST.xy + _LightTex_ST.zw)  + _speed * glstate_timer;\n    gl_Position = position;\n}","additive_alpha.fs.glsl":"uniform lowp sampler2D _MainTex;  \nuniform lowp vec4 _MainColor;\nuniform lowp float _alpha;\nvarying mediump vec2 _base_uv;\n\nvoid main() \n{\n    lowp vec4 tmpvar_3 = texture2D(_MainTex, _base_uv)*_MainColor;\n    lowp float alpha=_alpha*tmpvar_3.a;\n    gl_FragData[0] =vec4(tmpvar_3.xyz,alpha);\n}","additive_alpha.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_MainColor('MainColor',Color) = (1,1,1,1)\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n\t\t\"_alpha('alpha',float) = 1.0\"\n    ],\n    \"queue\": 0,\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"add\",\n                \"showface\": \"all\",\n\n                \"zwrite\": \"off\",\n                \"vs\": \"additive_alpha\",\n                \"fs\": \"additive_alpha\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"add\",\n                \"showface\": \"all\",\n\n                \"zwrite\": \"off\",\n                \"vs\": \"fog_additive_alpha\",\n                \"fs\": \"fog_additive_alpha\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"blendmode\": \"add\",\n                \"showface\": \"all\",\n\n                \"zwrite\": \"off\",\n                \"vs\": \"additive_alpha_bone_eff\",\n                \"fs\": \"additive_alpha\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"blendmode\": \"add\",\n                \"showface\": \"all\",\n\n                \"zwrite\": \"off\",\n                \"vs\": \"fog_additive_alpha_bone_eff\",\n                \"fs\": \"fog_additive_alpha\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","additive_alpha.vs.glsl":"attribute highp vec3 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\n\nvarying mediump vec2 _base_uv;\n\n\nvoid main()\n{\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n\tgl_Position = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));\n}\n\n","additive_alpha_bone_eff.vs.glsl":"attribute highp vec3 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 glstate_vec4_bones[80];\nuniform mediump vec4 _MainTex_ST;\n\nvarying mediump vec2 _base_uv;\n\n\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy2 = 2.0 * quat.x * quat.y;\n\tfloat xz2 = 2.0 * quat.x * quat.z;\n\tfloat xw2 = 2.0 * quat.x * quat.w;\n\tfloat yz2 = 2.0 * quat.y * quat.z;\n\tfloat yw2 = 2.0 * quat.y * quat.w;\n\tfloat zw2 = 2.0 * quat.z * quat.w;\n\tfloat xx = quat.x * quat.x;\n\tfloat yy = quat.y * quat.y;\n\tfloat zz = quat.z * quat.z;\n\tfloat ww = quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(xx - yy - zz + ww)*s, (xy2 + zw2)*s, (xz2 - yw2)*s, 0,\n\t(xy2 - zw2)*s, (-xx + yy - zz + ww)*s, (yz2 + xw2)*s, 0,\n\t(xz2 + yw2)*s, (yz2 - xw2)*s, (-xx - yy + zz + ww)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\n\nvoid main()\n{\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz, 1.0);\n\n    int i = int(_glesBlendIndex4.x);\n    int i2 =int(_glesBlendIndex4.y);\n\tint i3 =int(_glesBlendIndex4.z);\n\tint i4 =int(_glesBlendIndex4.w);\n\n    mat4 mat = buildMat4(i)*_glesBlendWeight4.x\n\t\t\t + buildMat4(i2)*_glesBlendWeight4.y\n\t\t\t + buildMat4(i3)*_glesBlendWeight4.z\n\t\t\t + buildMat4(i4)*_glesBlendWeight4.w;\n\n    gl_Position = (glstate_matrix_mvp * mat)* tmpvar_1;\n}","background.fs.glsl":"precision highp float;\n\n\n\nuniform sampler2D _MainTex;\n\nvarying vec2 uv;\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color;\nvarying lowp float factor;\n#endif\n\nvoid main()\n{\n    lowp vec4 emission = texture2D(_MainTex, uv);\n\n    // #ifdef LIGHTMAP\n    // lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    // emission.xyz *= decode_hdr(lightmap);\n    // #endif\n\n\n    #ifdef FOG\n    emission *= glstate_fog_color;\n    #endif\n\n    gl_FragData[0] = emission;\n\n}","background.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"background\",\n                \"fs\": \"background\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"background\",\n                \"fs\": \"background\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"background\",\n                \"fs\": \"background\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"background\",\n                \"fs\": \"background\"\n            }\n        ]\n    }\n}","background.vs.glsl":"precision highp float;\n\n\n\nattribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp;\n\nuniform mediump vec4 _MainTex_ST;\n\nvarying vec2 uv;\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n\n\n\n    position = (glstate_matrix_mvp * position);\n\n    // Force the screen space z to the far clip plane so even though this renders last (and the geometry is front of some stuff), it still renders behind everything\n    position.z = position.w - 0.001;\n\n    // #ifdef FOG\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    // factor = clamp(factor, 0.0, 1.0);\n    // #endif\n\n    uv = _glesMultiTexCoord0.xy*_MainTex_ST.xy+_MainTex_ST.zw;\n\n    gl_Position = position;\n}","CloakingDevice.fs.glsl":"precision highp float;\n\n#define SHADER_NAME CloakingDevice\n\nvarying vec4 color;\n\n\nvoid main()\n{\n\n    gl_FragData[0] = color;\n\n}","CloakingDevice.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"_Rimsize('AlphaCut',Range(0.0,1.0)) = 1.0\",\n        \"_RimColour ('MainColor', Color) = (1,1,1,0.4)\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"ztest\": \"lequal\",\n                \"zwrite\": \"on\",\n                \"showface\": \"ccw\",\n                \"vs\": \"CloakingDevice\",\n                \"fs\": \"CloakingDevice\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"ztest\": \"lequal\",\n                \"zwrite\": \"on\",\n                \"showface\": \"ccw\",\n                \"vs\": \"CloakingDevice\",\n                \"fs\": \"CloakingDevice\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"blendmode\": \"blend\",\n                \"ztest\": \"lequal\",\n                \"zwrite\": \"on\",\n                \"showface\": \"ccw\",\n                \"vs\": \"CloakingDevice\",\n                \"fs\": \"CloakingDevice\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"ztest\": \"lequal\",\n                \"zwrite\": \"on\",\n                \"showface\": \"ccw\",\n                \"vs\": \"CloakingDevice\",\n                \"fs\": \"CloakingDevice\"\n            }\n        ]\n    }\n}","CloakingDevice.vs.glsl":"precision highp float;\n\n\n\nattribute mediump vec3 _glesVertex;\nattribute highp vec3 _glesNormal;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_mvp;\nuniform vec4 glstate_eyepos;\n\n\n// varying vec2 uv;\nvarying vec4 color;\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n// #ifdef FOG\n// uniform highp float glstate_fog_start;\n// uniform highp float glstate_fog_end;\n// varying highp float factor;\n// #endif\n\nuniform vec4 _RimColour;\nuniform float _Rimsize;\n\n\n#ifdef SKIN\nhighp mat4 blendMat;\nattribute highp vec4 _glesBlendIndex4;\nattribute highp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,highp vec4 blendIndex,highp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat* srcVertex;\n}\n#endif\n\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    highp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    highp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n\n\t// World position\n    vec3 normalizedNormal = _glesNormal;\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    normalizedNormal = normalize(mat3(blendMat) * _glesNormal);\n    #endif\n\tvec4 wp = glstate_matrix_model * position;\n\t// wp.xyz /= wp.w;\n    position = glstate_matrix_mvp * position;\n    vec3 viewDir = normalize(glstate_eyepos.xyz - wp.xyz);\n    normalizedNormal = normalize(mat3(glstate_matrix_model) * normalizedNormal);\n\n\n    // Apply the rim effect\n    float NoV = 1. - dot(normalizedNormal, viewDir);\n    // NoV = dot(NoV, NoV);\n\n    color = _RimColour;\n    color.a *= smoothstep(1.0 - _Rimsize, 1.0, NoV);\n    // #ifdef FOG\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    // factor = clamp(factor, 0.0, 1.0);\n    // #endif\n\n    gl_Position = position;\n}","d3UI.shader.json":"{\n    \"layer\": \"geometry\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"zwrite\":\"on\",\n                \"ztest\":\"on\",\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"vs\": \"lineui\",\n                \"fs\": \"lineui\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","diffuse.fs.glsl":"precision lowp float;\nuniform lowp sampler2D _MainTex;\nuniform lowp vec4 _MainColor;\nuniform lowp float _AlphaCut;\nvarying mediump vec2 xlv_TEXCOORD0;\n\n//light\nlowp vec4 xlv_COLOR = vec4(0.0,0.0,0.0,1.0); \nbool hasLight = false;\nlowp vec3 fixedAmbient = vec3(0.6,0.6,0.6);\nuniform lowp float glstate_lightcount;\nuniform lowp vec4 glstate_vec4_lightposs[8];\nuniform lowp vec4 glstate_vec4_lightdirs[8];\nuniform lowp float glstate_float_spotangelcoss[8];\nuniform lowp vec4 glstate_vec4_lightcolors[8];\nuniform lowp float glstate_float_lightrange[8];\nuniform lowp float glstate_float_lightintensity[8];\n\nvarying lowp vec3 v_N;\nvarying lowp vec3 v_Mpos;\n\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor;\n#endif\n\n//calcDiffuse 计算漫反射强度函数\n//统一三种光源的传参方式，在函数内混合，方便就不高效\n//只需要方向光时另写\n//N 世界空间法线\n//worldpos 世界空间pos\n//lightPos 光源位置,w=0 表示方向光\n//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot\n//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来\nlowp float calcDiffuse(lowp vec3 N,lowp vec3 worldpos,lowp vec4 lightPos,lowp vec4 lightDir,lowp float cosspot,lowp float range )\n{\n    lowp vec3 v3 = lightPos.xyz - worldpos;\n    lowp float len = length(v3);\n    len = len > range ? range : len;\n    //求入射角，点光源&聚光灯\n    lowp vec3 L = normalize(v3); \n    //求张角 聚光灯 也是方向光入射角\n    lowp vec3 L2 = -lightDir.xyz;\n    lowp float dotSpot = dot(L,L2);\n    //漫反射强度\n    lowp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0) * pow(1.0 - len/range,2.0); \n    lowp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0); \n    //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源\n    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);\n    diffuse= mix(diffuseD,diffuse,lightPos.w);\n    return diffuse;\n}\n\nvoid calcCOLOR(){\n    int c =int(glstate_lightcount);\n\tif(c>0){\n        hasLight = true;\n        lowp float diff=0.0;\n\t\t//calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);\n\t\tfor(int i=0;i<8;i++)\n\t\t{\n\t\t\tif(i>=c)break;\n\t\t\t//diff += calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\n\t\t\tdiff = calcDiffuse(v_N,v_Mpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i],glstate_float_lightrange[i]);\n            xlv_COLOR += glstate_float_lightintensity[i] * glstate_vec4_lightcolors[i] * diff;\n\t\t}\n\t\txlv_COLOR.w = 1.0;  \n    }\n}\n\nvoid main() \n{\n    lowp vec4 basecolor = texture2D(_MainTex, xlv_TEXCOORD0);\n    if(basecolor.a < _AlphaCut)\n        discard;\n    lowp vec4 fristColor=basecolor*_MainColor;\n    lowp vec4 emission = fristColor;\n\n    //----------------------------------------------------------\n    //light\n    calcCOLOR();\n    \n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    emission.xyz *= decode_hdr(lightmap);\n    if(hasLight){ // have light\n        fristColor = fristColor * xlv_COLOR ;\n        emission = emission + mix(vec4(1.0, 1.0, 1.0, 1.0), fristColor, fristColor.wwww);\n    }\n    #else\n\tif(hasLight){ // have light\n        emission = (fristColor * xlv_COLOR) + (fristColor * vec4(fixedAmbient,1.0));\n    }\n    #endif\n\n    #ifdef FOG\n    emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    #endif\n    \n    gl_FragData[0] = emission;\n}","diffuse.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLit\",\n                \"fs\": \"RimLit\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLit\",\n                \"fs\": \"RimLit\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLit\",\n                \"fs\": \"RimLit\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLit\",\n                \"fs\": \"RimLit\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLit\",\n                \"fs\": \"RimLit\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLit\",\n                \"fs\": \"RimLit\"\n            }\n        ]\n    }\n}","diffuse.vs.glsl":"attribute highp vec4 _glesVertex;\nattribute mediump vec4 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\nvarying mediump vec2 xlv_TEXCOORD0;\n//light\nlowp mat4 blendMat ;\nattribute lowp vec3 _glesNormal;\nuniform highp mat4 glstate_matrix_model;\nuniform lowp float glstate_lightcount;\n\nvarying highp vec3 v_N;\nvarying highp vec3 v_Mpos;\n\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n#ifdef FOG\n// #define glstate_fog_end\t\t150.\n// #define glstate_fog_start\t1.\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n#ifdef SKIN\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat * srcVertex;\n}\n\n#endif\n\nvoid calcNormal(highp vec4 pos){\n\tint c =int(glstate_lightcount);\n\tif(c>0){\n\t\t//求世界空间法线\n\t\t#ifdef SKIN\n\t\tv_N = normalize(mat3(blendMat) * _glesNormal);\n\t\t#else\n\t\tv_N = _glesNormal;\n\t\t#endif\n\t\tlowp mat3 normalmat = mat3(glstate_matrix_model);\n\t\tv_N =normalize(normalmat*v_N);\n\t\tv_Mpos =(glstate_matrix_model * pos).xyz;\n\t}\n}\n\nvoid main()\n{\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n\t//light\n    calcNormal(position);\n    position = (glstate_matrix_mvp * position);\n\n    #ifdef FOG\n    factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    #endif\n\n\n    gl_Position =position;\n}","diffuse_bothside.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\",\n        \"_MainColor ('MainColor', Color) = (1,1,1,1)\"\n    ],\n    \"passes\": {\n\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ],\n        \"lightmap_fog\": [\n            {\n                \"showface\": \"all\",\n                \"vs\": \"diffuse\",\n                \"fs\": \"diffuse\"\n            }\n        ]\n    }\n}","f14trans.fs.glsl":"uniform mediump sampler2D _Main_Tex;\n\nvarying lowp vec4 xlv_COLOR;\nvarying mediump vec2 xlv_TEXCOORD0;          \nvoid main() \n{\n    lowp vec4 basecolor = texture2D(_Main_Tex, xlv_TEXCOORD0);\n    gl_FragData[0] =basecolor*xlv_COLOR;\n    //gl_FragData[0] =vec4(1,0,0,1);\n}","f14trans.vs.glsl":"attribute highp vec4 _glesVertex;\nattribute mediump vec4 _glesMultiTexCoord0;   \nattribute lowp vec4 _glesColor;\n\nuniform lowp vec4 _Main_Color;\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _Main_Tex_ST;\n\n\nvarying lowp vec4 xlv_COLOR;\nvarying mediump vec2 xlv_TEXCOORD0;                \nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz,1.0);\n    xlv_COLOR = _Main_Color*_glesColor;\n\txlv_TEXCOORD0 =_glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\n                \n    gl_Position = (glstate_matrix_mvp *tmpvar_1);  \n}","fog_additive_alpha.fs.glsl":"uniform mediump sampler2D _MainTex;  \nuniform lowp vec4 _MainColor;\nuniform lowp float _alpha;\nvarying mediump vec2 _base_uv;\n\nuniform lowp vec4 glstate_fog_color; \nvarying lowp float factor; \nvoid main() \n{\n    lowp vec4 tmpvar_3 = texture2D(_MainTex, _base_uv)*_MainColor;\n    lowp float alpha=_alpha*tmpvar_3.a;\n    lowp vec3 afterFog = mix(vec3(0,0,0), tmpvar_3.rgb, factor);\n    gl_FragData[0] = vec4(afterFog,alpha);\n}","fog_additive_alpha.vs.glsl":"attribute highp vec3 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\n\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\n\nvarying lowp float factor;\nvarying mediump vec2 _base_uv;\n\n\nvoid main()\n{\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n\thighp vec4 pos = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));\n    factor = (glstate_fog_end - abs(pos.z))/(glstate_fog_end - glstate_fog_start); \n    factor = clamp(factor, 0.0, 1.0);  \n    gl_Position = pos;\n}","fog_additive_alpha_bone_eff.vs.glsl":"attribute highp vec3 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\nvarying mediump vec2 _base_uv;\n\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[80];\n\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy2 = 2.0 * quat.x * quat.y;\n\tfloat xz2 = 2.0 * quat.x * quat.z;\n\tfloat xw2 = 2.0 * quat.x * quat.w;\n\tfloat yz2 = 2.0 * quat.y * quat.z;\n\tfloat yw2 = 2.0 * quat.y * quat.w;\n\tfloat zw2 = 2.0 * quat.z * quat.w;\n\tfloat xx = quat.x * quat.x;\n\tfloat yy = quat.y * quat.y;\n\tfloat zz = quat.z * quat.z;\n\tfloat ww = quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(xx - yy - zz + ww)*s, (xy2 + zw2)*s, (xz2 - yw2)*s, 0,\n\t(xy2 - zw2)*s, (-xx + yy - zz + ww)*s, (yz2 + xw2)*s, 0,\n\t(xz2 + yw2)*s, (yz2 - xw2)*s, (-xx - yy + zz + ww)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\n\nvoid main()\n{\n\t_base_uv = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    highp vec4 tmpvar_1=vec4(_glesVertex.xyz, 1.0);\n\n    int i = int(_glesBlendIndex4.x);\n    int i2 =int(_glesBlendIndex4.y);\n\tint i3 =int(_glesBlendIndex4.z);\n\tint i4 =int(_glesBlendIndex4.w);\n\n    mat4 mat = buildMat4(i)*_glesBlendWeight4.x\n\t\t\t + buildMat4(i2)*_glesBlendWeight4.y\n\t\t\t + buildMat4(i3)*_glesBlendWeight4.z\n\t\t\t + buildMat4(i4)*_glesBlendWeight4.w;\n\n\thighp vec4 pos = (glstate_matrix_mvp * mat)* tmpvar_1;\n    factor = (glstate_fog_end - abs(pos.z))/(glstate_fog_end - glstate_fog_start);\n    factor = clamp(factor, 0.0, 1.0);\n    gl_Position = pos;\n}","godray.fs.glsl":"\n\nprecision highp float;\n\n\nuniform float glstate_timer;\n\n\nuniform sampler2D _MainTex;\n\n\n\nvarying mediump vec2 color;\nvarying vec2 uv;\n\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n// #ifdef FOG\n// uniform lowp vec4 glstate_fog_color;\n// varying lowp float factor;\n// #endif\n\nvoid main()\n{\n    // lowp vec4 emission = texture2D(_MainTex, uv);\n    // if(emission.a < _AlphaCut)\n    //     discard;\n\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    emission.xyz *= decode_hdr(lightmap);\n    #endif\n\n    // #ifdef FOG\n    // emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    // #endif\n\n\n\n    mediump vec4 texcol = texture2D(_MainTex, uv);\n    texcol.a = 0.2 * abs(sin( 25. * (color.r + glstate_timer * 0.01) * 3.14159265359));\n\n    gl_FragData[0] = texcol;\n\n}","godray.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\": \"off\",\n                \"vs\": \"godray\",\n                \"fs\": \"godray\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\": \"off\",\n                \"vs\": \"godray\",\n                \"fs\": \"godray\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"vs\": \"godray\",\n                \"fs\": \"godray\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"vs\": \"godray\",\n                \"fs\": \"godray\"\n            }\n        ]\n    }\n}","godray.vs.glsl":"precision highp float;\n\n\n#define DEPTH_START -1.0\n#define DEPTH_END -5.0\n\n\n\nattribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nattribute mediump vec4 _glesColor;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_world2object;\n\n\nvarying mediump vec2 color;\nvarying vec2 uv;\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n// #ifdef FOG\n// uniform lowp float glstate_fog_start;\n// uniform lowp float glstate_fog_end;\n// varying lowp float factor;\n// #endif\n\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n    uv = _glesMultiTexCoord0.xy;\n\n\n\tcolor = _glesColor.rg;\n\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n\n    position = (glstate_matrix_mvp * position);\n\n    // #ifdef FOG\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    // factor = clamp(factor, 0.0, 1.0);\n    // #endif\n\n\n\n    // lowp vec2 _speed= vec2(_SpeedU,_SpeedV);\n    // _StreamLightUV = (_glesMultiTexCoord0.xy * _LightTex_ST.xy + _LightTex_ST.zw)  + _speed * glstate_timer;\n    gl_Position = position;\n}","lineui.fs.glsl":"uniform sampler2D _MainTex;\nvarying lowp vec4 xlv_COLOR;\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main()\n{\n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n    gl_FragData[0] = tmpvar_3;\n}","lineui.shader.json":"{\n    \"layer\": \"overlay\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\",\n        \"_Superimposition('Superimposition', Range(0.0, 7.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"zwrite\":\"on\",\n                \"ztest\":\"on\",\n                \"blendmode\": \"blend\",\n                \"showface\": \"all\",\n                \"vs\": \"lineui\",\n                \"fs\": \"lineui\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","lineui.vs.glsl":"attribute vec4 _glesVertex;    \nattribute vec4 _glesColor;                   \nattribute vec4 _glesMultiTexCoord0;          \nuniform highp mat4 glstate_matrix_mvp;       \nvarying lowp vec4 xlv_COLOR;                 \nvarying highp vec2 xlv_TEXCOORD0;            \nvoid main()                                      \n{                                                \n\thighp vec4 tmpvar_1;                         \n\ttmpvar_1.w = 1.0;                            \n\ttmpvar_1.xyz = _glesVertex.xyz;              \n\txlv_COLOR = _glesColor;                      \n\txlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \n\tgl_Position = (glstate_matrix_mvp * tmpvar_1);   \n}","luminanceshiftrim.fs.glsl":"precision highp float;\n\nuniform float glstate_timer;\n\nuniform lowp sampler2D _MainTex;\nvarying mediump vec2 xlv_TEXCOORD0;\nvarying vec4 data;\n\n\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n// #ifdef FOG\n// uniform lowp vec4 glstate_fog_color;\n// varying lowp float factor;\n// #endif\n\nmediump float GetLuminance (mediump vec3 rgb)\n{\n     return (0.2126 * rgb.x) + (0.7152 * rgb.y) + (0.0722 * rgb.z);\n}\n\nvoid main()\n{\n\n    // ALBEDO_TEXTURE\n    mediump vec4 tex = texture2D(_MainTex, xlv_TEXCOORD0);\n    // if(albedo.a < _AlphaCut)\n    //     discard;\n\n// #if !LOW_END\n    // NOTE: High End\n    mediump float luminanceOverride = tex.a;\n    mediump float shift = .5 * (1. + sin(mod(3.14159 * (.5 * glstate_timer + luminanceOverride), 3.14159)));\n    shift /= 3. * GetLuminance(tex.rgb);\n    shift -= .1;\n\n    mediump float newLuminance = mix(1., shift, data.g);\n    tex *= newLuminance;\n    // NOTE: High End\n// #endif\n\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    albedo.xyz *= decode_hdr(lightmap);\n    #endif\n\n    gl_FragData[0] = data.r * tex;\n\n}","luminanceshiftrim.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_RimSize('Rim Size',Range(0.0,5.0)) = 0.0\",\n        \"_RimIntensity('Rim intensity',Range(0.0,50.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"luminanceshiftrim\",\n                \"fs\": \"luminanceshiftrim\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"luminanceshiftrim\",\n                \"fs\": \"luminanceshiftrim\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"luminanceshiftrim\",\n                \"fs\": \"luminanceshiftrim\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"luminanceshiftrim\",\n                \"fs\": \"luminanceshiftrim\"\n            }\n        ]\n    }\n}","luminanceshiftrim.vs.glsl":"precision highp float;\n\n\n\nattribute vec3 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nattribute vec3 _glesColor;\nattribute highp vec3 _glesNormal;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_mvp;\nuniform vec4 glstate_eyepos;\n\n\nuniform mediump vec4 _MainTex_ST;\nvarying mediump vec2 xlv_TEXCOORD0;\n// varying vec2 uv;\nvarying vec4 data;\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n// #ifdef FOGs\n// uniform highp float glstate_fog_start;\n// uniform highp float glstate_fog_end;\n// varying highp float factor;\n// #endif\n\nuniform float _RimSize;\nuniform float _RimIntensity;\n\n\n#ifdef SKIN\nhighp mat4 blendMat;\nattribute highp vec4 _glesBlendIndex4;\nattribute highp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,highp vec4 blendIndex,highp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat* srcVertex;\n}\n#endif\n\n\nvoid main()\n{\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    highp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    highp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n\t// World position\n    vec3 normalizedNormal = _glesNormal;\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    normalizedNormal = normalize(mat3(blendMat) * _glesNormal);\n    #endif\n\tvec4 wp = glstate_matrix_model * position;\n\t// wp.xyz /= wp.w;\n    position = glstate_matrix_mvp * position;\n\n\n    // Apply the rim effect\n    vec3 viewDir = normalize(glstate_eyepos.xyz - wp.xyz);\n    normalizedNormal = normalize(mat3(glstate_matrix_model) * normalizedNormal);\n\tfloat dotProduct = .5 * (1. - dot(normalizedNormal, viewDir));\n\n\t// Rim Intensity\n\tdata.r = 1. + mix(0., _RimIntensity, dotProduct);\n\n\t// Shift intensity\n    data.g = _glesColor.r;\n\n    gl_Position = position;\n}","particles_add.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"add\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particles_blend.shader.json":"{\n  \"layer\": \"transparent\",\n  \"queue\":  0,\n  \"properties\": [\n\t\t\"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Main_Color ('Tint Color', Color) = (1.0,1.0,1.0,1.0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n          {\n            \"blendmode\": \"blend\",\n            \"showface\": \"all\",\n            \"zwrite\": \"off\",\n            \"vs\": \"f14trans\",\n            \"fs\": \"f14trans\"\n          }\n        ],\n        \"shadowgen\": [],  \n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","particle_mask_add_tint.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_Main_Tex('MainTex',Texture)='white'{}\",\n        \"_Mask('Mask',Texture)='white'{}\",\n        \"_Main_Tex_ST('MainTex_ST',Vector)=(1,1,0,0)\",\n        \"_Mask_ST('Mask_ST',Vector)=(1,1,0,0)\",\n        \"_Main_Color('Main_Color', Color) = (1,1,1,1)\",\n        \"_mixAlphaRate('mixAlphaRate',Float) = 1\",\n        \"_mixColorRate('mixColorRate',Float) = 1\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"all\",\n                \"blendmode\": \"add\",\n                \"zwrite\": \"off\",\n                \"ztest\":\"on\",\n                \"vs\": \"par_mask_tint\",\n                \"fs\": \"par_mask_tint\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","par_mask_tint.fs.glsl":"uniform sampler2D _Main_Tex; \nuniform sampler2D _Mask; \n\nvarying mediump vec2 _maintex_uv;\nvarying mediump vec2 _mask_uv;\n\nvarying mediump vec4 v_color;\n\nvoid main()    \n{\n    highp vec4 basecolor=texture2D(_Main_Tex,_maintex_uv);\n    highp vec4 maskcolor=texture2D(_Mask,_mask_uv);\n\n    mediump vec3 tempcolor=v_color.rgb*basecolor.rgb*maskcolor.rgb;\n    mediump float tempAlpha=v_color.a*basecolor.a*maskcolor.a;\n    mediump vec4 emission=vec4(tempcolor,tempAlpha);\n    \n    gl_FragData[0] = emission;\n}\n","par_mask_tint.vs.glsl":"attribute highp vec3 _glesVertex;\nattribute highp vec4 _glesColor;\nattribute mediump vec2 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\n\nuniform mediump vec4 _Main_Tex_ST;\nuniform mediump vec4 _Mask_ST;\nvarying mediump vec2 _maintex_uv;\nvarying mediump vec2 _mask_uv;\n\nuniform mediump vec4 _Main_Color;\nuniform mediump float _mixColorRate;\nuniform mediump float _mixAlphaRate;\n\nvarying mediump vec4 v_color;\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\tposition =glstate_matrix_mvp * position;\n\t \n    _maintex_uv = _glesMultiTexCoord0.xy * _Main_Tex_ST.xy + _Main_Tex_ST.zw;\n    _mask_uv = _glesMultiTexCoord0.xy * _Mask_ST.xy + _Mask_ST.zw;\n\tv_color=_glesColor*_Main_Color;\n\tv_color.rgb=v_color.rgb*_mixColorRate;\n\tv_color.a=v_color.a*_mixAlphaRate;\n\n\tgl_Position = position;\n}","PreZCloakingDevice.fs.glsl":"precision highp float;\n\n#define SHADER_NAME PreZCloakingDevice\n\nvarying vec4 color;\n\nvoid main()\n{\n\n    gl_FragData[0] = vec4(0, 0, 0, 0);\n\n}","PreZCloakingDevice.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"_Rimsize('AlphaCut',Range(0.0,1.0)) = 1.0\",\n        \"_RimColour ('MainColor', Color) = (1,1,1,0.4)\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"add\",\n                \"ztest\": \"lequal\",\n                \"zwrite\": \"on\",\n                \"showface\": \"ccw\",\n                \"vs\": \"CloakingDevice\",\n                \"fs\": \"PreZCloakingDevice\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"add\",\n                \"ztest\": \"lequal\",\n                \"zwrite\": \"on\",\n                \"showface\": \"ccw\",\n                \"vs\": \"CloakingDevice\",\n                \"fs\": \"PreZCloakingDevice\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"blendmode\": \"add\",\n                \"ztest\": \"lequal\",\n                \"zwrite\": \"on\",\n                \"showface\": \"ccw\",\n                \"vs\": \"CloakingDevice\",\n                \"fs\": \"PreZCloakingDevice\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"blendmode\": \"add\",\n                \"ztest\": \"lequal\",\n                \"zwrite\": \"on\",\n                \"showface\": \"ccw\",\n                \"vs\": \"CloakingDevice\",\n                \"fs\": \"PreZCloakingDevice\"\n            }\n        ]\n    }\n}","RimLit.fs.glsl":"precision highp float;\n\n#define _LightingIntensity      1.\n\n#define DEPTH_START\t\t0.0\n#define DEPTH_END\t\t-5.0\n#define AMBIENT_LIGHT\t1.\n\n#define RIM_POWER\t\t0.5\n#define RIM_LIGHTING_OPERATOR += 0.25 *\n\n#ifdef LOW_END\n\t#define VERTEX_RIM_LIGHTING\n#else\n\t#define PIXEL_RIM_LIGHTING\n#endif\n\n\n#ifdef PER_PIXEL_CAUSTICS\n\n\t#ifndef NEEDS_WORLD_NORMAL\n\t\t#define NEEDS_WORLD_NORMAL\n\t#endif\n\n\t#ifndef NEEDS_PER_PIXEL_WORLD_POS\n\t\t#define NEEDS_PER_PIXEL_WORLD_POS\n\t#endif\n\n\t#ifndef UP_FACE_FACTOR\n\t\t#define UP_FACE_FACTOR\n\t#endif\n\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef NO_LIGHTING_ABOVE_WATER\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef AMBIENT_LIGHT\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef ACTION_LINE\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef FAST_ACTION_LINE\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef VERTEX_RIM_LIGHTING\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef PIXEL_RIM_LIGHTING\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n\n\t#ifndef NEEDS_NORMAL\n\t\t#define NEEDS_NORMAL\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP_ADDITIVE\n\t#ifndef SPHERE_MAP\n\t\t#define SPHERE_MAP\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP_BLEND\n\t#ifndef SPHERE_MAP\n\t\t#define SPHERE_MAP\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP\n\t#ifndef NEEDS_NORMAL\n\t\t#define NEEDS_NORMAL\n\t#endif\n#endif\n\n#ifdef ABOVE_WATER_BRIGHTEN\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef UP_FACE_FACTOR\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n#endif\n\n#ifdef NEEDS_NORMAL\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n#endif\n\n#ifdef PER_PIXEL_CAUSTICS\n    uniform lowp float _CausticsIntensity;\n    uniform lowp sampler2D _CausticsTex;\n    uniform lowp float _UnitTime;\n    uniform float glstate_timer;\n#endif\n\n\nuniform lowp sampler2D _MainTex;\n// uniform lowp float _LightingIntensity;\n\n// v2f\nvarying lowp vec2 xlv_TEXCOORD0;\n#ifdef NEEDS_NORMAL\n\tvarying vec3 v_normal;\n#endif\n#ifdef NEEDS_LIGHTING\n    // fixed2 lighting : COLOR0;\n    varying lowp float v_atten;\n\t#ifdef UP_FACE_FACTOR\n    varying lowp float v_facing;\n\t#endif\n#endif\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n#ifdef FOG\nuniform lowp vec4 glstate_fog_color;\nvarying lowp float factor;\n#endif\n\nvoid main()\n{\n\n    // ALBEDO_TEXTURE\n    lowp vec4 albedo = texture2D(_MainTex, xlv_TEXCOORD0);\n    // if(albedo.a < _AlphaCut)\n    //     discard;\n\n\n\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    albedo.xyz *= decode_hdr(lightmap);\n    #endif\n\n\n#ifdef NEEDS_LIGHTING\n    lowp float atten = v_atten;\n\n\t#ifdef PIXEL_RIM_LIGHTING\n        float rimFactor = dot(v_normal, v_normal);\n        #ifdef RIM_POWER\n            rimFactor = pow(rimFactor, RIM_POWER);\n        #endif\n\t\tatten RIM_LIGHTING_OPERATOR rimFactor;\n\t#endif\n\n    atten = mix(1., atten, _LightingIntensity);\n\n    albedo *= atten;\n#endif\n\n#ifndef ALPHA_ON\n    albedo.a = 1.;\n#endif\n\n    gl_FragData[0] = albedo;\n}","RimLit.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_MainTex_ST('MainTex_ST',Vector) = (1,1,0,0)\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLit\",\n                \"fs\": \"RimLit\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLit\",\n                \"fs\": \"RimLit\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLit\",\n                \"fs\": \"RimLit\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLit\",\n                \"fs\": \"RimLit\"\n            }\n        ]\n    }\n}","RimLit.vs.glsl":"precision highp float;\n\n\n#define DEPTH_START\t\t0.0\n#define DEPTH_END\t\t-5.0\n#define AMBIENT_LIGHT\t1.\n\n#define RIM_POWER\t\t0.5\n#define RIM_LIGHTING_OPERATOR += 0.25 *\n\n#ifdef LOW_END\n\t#define VERTEX_RIM_LIGHTING\n#else\n\t#define PIXEL_RIM_LIGHTING\n#endif\n\n\n#ifdef PER_PIXEL_CAUSTICS\n\n\t#ifndef NEEDS_WORLD_NORMAL\n\t\t#define NEEDS_WORLD_NORMAL\n\t#endif\n\n\t#ifndef NEEDS_PER_PIXEL_WORLD_POS\n\t\t#define NEEDS_PER_PIXEL_WORLD_POS\n\t#endif\n\n\t#ifndef UP_FACE_FACTOR\n\t\t#define UP_FACE_FACTOR\n\t#endif\n\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef NO_LIGHTING_ABOVE_WATER\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef AMBIENT_LIGHT\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef ACTION_LINE\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef FAST_ACTION_LINE\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef VERTEX_RIM_LIGHTING\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n#endif\n\n#ifdef PIXEL_RIM_LIGHTING\n\t#ifndef NEEDS_LIGHTING\n\t\t#define NEEDS_LIGHTING\n\t#endif\n\n\t#ifndef NEEDS_NORMAL\n\t\t#define NEEDS_NORMAL\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP_ADDITIVE\n\t#ifndef SPHERE_MAP\n\t\t#define SPHERE_MAP\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP_BLEND\n\t#ifndef SPHERE_MAP\n\t\t#define SPHERE_MAP\n\t#endif\n#endif\n\n#ifdef SPHERE_MAP\n\t#ifndef NEEDS_NORMAL\n\t\t#define NEEDS_NORMAL\n\t#endif\n#endif\n\n#ifdef ABOVE_WATER_BRIGHTEN\n\t#ifndef NEEDS_DEPTH_FACTOR\n\t\t#define NEEDS_DEPTH_FACTOR\n\t#endif\n#endif\n\n#ifdef UP_FACE_FACTOR\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n#endif\n\n#ifdef NEEDS_NORMAL\n\t#ifndef CALCULATE_NORMAL\n\t\t#define CALCULATE_NORMAL\n\t#endif\n#endif\n\n// appdata\nattribute vec4 _glesVertex;\nattribute lowp vec4 _glesMultiTexCoord0;\nattribute lowp vec3 _glesNormal;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_world2object;\nuniform mediump vec4 _MainTex_ST;\n\n\n// v2f\nvarying lowp vec2 xlv_TEXCOORD0;\n#ifdef NEEDS_NORMAL\n\tvarying vec3 v_normal;\n#endif\n#ifdef NEEDS_LIGHTING\n    // fixed2 lighting : COLOR0;\n    varying lowp float v_atten;\n\t#ifdef UP_FACE_FACTOR\n    varying lowp float v_facing;\n\t#endif\n#endif\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n#ifdef FOG\nuniform lowp float glstate_fog_start;\nuniform lowp float glstate_fog_end;\nvarying lowp float factor;\n#endif\n\n#ifdef SKIN\nhighp mat4 blendMat;\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat * srcVertex;\n}\n#endif\n\nfloat inverseLerp(float x, float y, float z) {\n\t// return (z-x) / (y - x);\n    return smoothstep(x,y,z);   // TODO:\n}\n\nvoid main()\n{\n    vec4 position=vec4(_glesVertex.xyz,1.0);\n\n    vec3 normal = _glesNormal;\n\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    normal = normalize(mat3(blendMat) * _glesNormal);\n    #endif\n\t// World position\n\t// mediump vec4 wp = glstate_matrix_model * position;\n    position = (glstate_matrix_mvp * position);\n\n#ifdef CALCULATE_NORMAL\n    normal = normalize(mat3(glstate_matrix_model) * normal);\n#endif\n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n#ifdef NEEDS_LIGHTING\n\tmediump float atten = 0.;\n\t#ifdef AMBIENT_LIGHT\n\t\tatten += AMBIENT_LIGHT;\n\t#endif\n\t#ifdef VERTEX_RIM_LIGHTING\n\t\tmediump float rimFactor = 1.-dot(normal, vec3(0,0,-1) );\n\n\t\t#ifdef RIM_POWER\n\t\trimFactor = pow(rimFactor, RIM_POWER);\n\t\t#endif\n\n\t\tatten RIM_LIGHTING_OPERATOR rimFactor;\n\t#endif\t// lighting.x\n\tv_atten = atten;\n#endif\n\n#ifdef NEEDS_NORMAL\n\t\tv_normal = normal;\n#endif\n\n    gl_Position = position;\n}","rimlitsurfacecaustics.fs.glsl":"precision highp float;\n\n\n#define RIM_POWER               0.5\n#define RIM_LIGHTING_OPERATOR += 0.25 *\n\n\nuniform float glstate_timer;\n\n\nuniform lowp sampler2D _MainTex;\nuniform lowp sampler2D _CausticsTex;\nuniform lowp float _LightingIntensity;\nuniform lowp float _CausticsIntensity;\n// // TINT_ON\n// uniform lowp vec4 _Tint;\n// uniform lowp float _TintIntensity;\n\nvarying lowp vec2 xlv_TEXCOORD0;\nvarying vec3 pos;\nvarying lowp float v_atten;\nvarying lowp float v_facing;\nvarying vec3 v_normal;\n\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n// #ifdef FOG\n// uniform lowp vec4 glstate_fog_color;\n// varying lowp float factor;\n// #endif\n\nvoid main()\n{\n\n    // ALBEDO_TEXTURE\n    lowp vec4 albedo = texture2D(_MainTex, xlv_TEXCOORD0);\n    // if(albedo.a < _AlphaCut)\n    //     discard;\n\n    // TINT_ON\n    // albedo.rgb += _Tint.rgb * _TintIntensity;\n\n\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    albedo.xyz *= decode_hdr(lightmap);\n    #endif\n\n\n    // NEEDS_LIGHTING\n    lowp float atten = v_atten;\n\n    // PIXEL_RIM_LIGHTING\n    mediump float rimFactor = dot(v_normal, v_normal);\n#ifdef RIM_POWER\n    rimFactor = pow(rimFactor, RIM_POWER);\n#endif\n    // RIM_LIGHTING_OPERATOR\n    atten += 0.25 * rimFactor;\n\n    atten = mix(1., atten, _LightingIntensity);\n    // float causticcol = texture2D(_CausticsTex,projectedWorldPos).a;\n    // The original version is using alpha channel\n\n    // PER_PIXEL_CAUSTICS\n    lowp float causticsStrength = _CausticsIntensity * v_facing;\n    vec2 projectedWorldPos = .1 *vec2(pos.x,pos.z);\n    projectedWorldPos = 1. + mod(projectedWorldPos,1.);\n    projectedWorldPos+= mod(10.*glstate_timer * 0.01,2.);\n\n\n    lowp float causticcol = texture2D(_CausticsTex,projectedWorldPos).r;\n\n    // 'Add' caustics\n    atten += causticsStrength * causticcol;\n\n\n    albedo *= atten;\n    albedo.a = 1.;\n\n    // #ifdef FOG\n    // albedo.xyz = mix(glstate_fog_color.rgb, albedo.rgb, factor);\n    // #endif\n\n    gl_FragData[0] = albedo;\n}","rimlitsurfacecaustics.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_CausticsTex('Caustics',Texture) = 'white' {}\",\n        \"_CausticsIntensity('Caustics Strength',Range(0.0,2.0)) = 1.0\",\n        \"_LightingIntensity('Lighting Intensity',Range(0.0,1.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"rimlitsurfacecaustics\",\n                \"fs\": \"rimlitsurfacecaustics\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"rimlitsurfacecaustics\",\n                \"fs\": \"rimlitsurfacecaustics\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"rimlitsurfacecaustics\",\n                \"fs\": \"rimlitsurfacecaustics\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"rimlitsurfacecaustics\",\n                \"fs\": \"rimlitsurfacecaustics\"\n            }\n        ]\n    }\n}","rimlitsurfacecaustics.vs.glsl":"precision highp float;\n\n\n#define DEPTH_START\t\t-10.\n#define DEPTH_END\t\t10.\n#define AMBIENT_LIGHT\t0.75\n\n\nattribute vec4 _glesVertex;\nattribute lowp vec4 _glesMultiTexCoord0;\nattribute vec3 _glesNormal;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_world2object;\nuniform mediump vec4 _MainTex_ST;\n\nvarying lowp vec2 xlv_TEXCOORD0;\n\nvarying vec3 pos;\nvarying lowp float v_atten;\nvarying lowp float v_facing;\nvarying vec3 v_normal;\n\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n// #ifdef FOG\n// // #define glstate_fog_end\t\t150.\n// // #define glstate_fog_start\t1.\n// uniform lowp float glstate_fog_start;\n// uniform lowp float glstate_fog_end;\n// varying lowp float factor;\n// #endif\n\n#ifdef SKIN\nhighp mat4 blendMat;\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat * srcVertex;\n}\n#endif\n\nfloat inverseLerp(float x, float y, float z) {\n\t// return (z-x) / (y - x);\n    return smoothstep(x,y,z);   // TODO:\n}\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n\n    vec3 normal = _glesNormal;\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    normal = normalize(mat3(blendMat) * _glesNormal);\n    #endif\n\t// World position\n\tvec4 wp = glstate_matrix_model * position;\n\t// wp.xyz /= wp.w;\n    position = (glstate_matrix_mvp * position);\n\t// CALCULATE_NORMAL\n    normal = normalize(mat3(glstate_matrix_model) * normal);\n\tv_normal = normal;\n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n\t// NEEDS_PER_PIXEL_WORLD_POS\n\tpos = wp.xyz;\n\tv_facing = clamp(dot(normal, vec3(0, sign(DEPTH_START - wp.y), 0)), 0., 1.);\n\n\t// NEEDS_DEPTH_FACTOR\n\t// float waterDepth = inverseLerp(DEPTH_START, DEPTH_END, wp.y);\n\n\t// NEEDS_LIGHTING\n\tfloat atten = 0.;\n\n#ifdef AMBIENT_LIGHT\n\tatten += AMBIENT_LIGHT;\n#endif\n\n\t// NO_LIGHTING_ABOVE_WATER\n\t// atten = mix( 1., atten, waterDepth);\n\n\tv_atten = atten;\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n\n    // #ifdef FOG\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    // factor = clamp(factor, 0.0, 1.0);\n    // #endif\n\n\n\t// v_facing = clamp(dot(normalize(normal), vec3(0, 1., 0)), 0., 1.);\n\n    gl_Position = position;\n}","RimLitUnderwaterCaustics.fs.glsl":"precision highp float;\n\n\n#define RIM_POWER               0.5\n#define RIM_LIGHTING_OPERATOR += 0.25 *\n\n\nuniform float glstate_timer;\n\n\nuniform lowp sampler2D _MainTex;\nuniform lowp sampler2D _CausticsTex;\nuniform lowp float _LightingIntensity;\nuniform lowp float _CausticsIntensity;\n// TINT_ON\nuniform lowp vec4 _Tint;\nuniform lowp float _TintIntensity;\n\nvarying lowp vec2 xlv_TEXCOORD0;\nvarying vec3 pos;\nvarying lowp float v_atten;\nvarying lowp float v_facing;\nvarying vec3 v_normal;\n\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n// #ifdef FOG\n// uniform lowp vec4 glstate_fog_color;\n// varying lowp float factor;\n// #endif\n\nvoid main()\n{\n\n    // ALBEDO_TEXTURE\n    lowp vec4 albedo = texture2D(_MainTex, xlv_TEXCOORD0);\n    // if(albedo.a < _AlphaCut)\n    //     discard;\n\n    // TINT_ON\n    albedo.rgb += _Tint.rgb * _TintIntensity;\n\n\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    albedo.xyz *= decode_hdr(lightmap);\n    #endif\n\n\n    // NEEDS_LIGHTING\n    lowp float atten = v_atten;\n\n    // PIXEL_RIM_LIGHTING\n    mediump float rimFactor = dot(v_normal, v_normal);\n#ifdef RIM_POWER\n    rimFactor = pow(rimFactor, RIM_POWER);\n#endif\n    // RIM_LIGHTING_OPERATOR\n    atten += 0.25 * rimFactor;\n\n    atten = mix(1., atten, _LightingIntensity);\n    // float causticcol = texture2D(_CausticsTex,projectedWorldPos).a;\n    // The original version is using alpha channel\n\n    // PER_PIXEL_CAUSTICS\n    lowp float causticsStrength = _CausticsIntensity * v_facing;\n    vec2 projectedWorldPos = .1 *vec2(pos.x,pos.z);\n    projectedWorldPos = 1. + mod(projectedWorldPos,1.);\n    projectedWorldPos+= mod(10.*glstate_timer * 0.01,2.);\n\n\n    lowp float causticcol = texture2D(_CausticsTex,projectedWorldPos).r;\n\n    // 'Add' caustics\n    atten += causticsStrength * causticcol;\n\n\n    albedo *= atten;\n    albedo.a = 1.;\n\n    // #ifdef FOG\n    // albedo.xyz = mix(glstate_fog_color.rgb, albedo.rgb, factor);\n    // #endif\n\n    gl_FragData[0] = albedo;\n}","RimLitUnderwaterCaustics.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_CausticsTex('Caustics',Texture) = 'white' {}\",\n        \"_CausticsIntensity('Caustics Strength',Range(0.0,2.0)) = 1.0\",\n        \"_LightingIntensity('Lighting Intensity',Range(0.0,1.0)) = 1.0\",\n        \"_Tint ('Tint Colour', Color) = (1,1,1,1)\",\n        \"_TintIntensity('Tint intensity',Range(0.0,1.0)) = 0.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLitUnderwaterCaustics\",\n                \"fs\": \"RimLitUnderwaterCaustics\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLitUnderwaterCaustics\",\n                \"fs\": \"RimLitUnderwaterCaustics\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLitUnderwaterCaustics\",\n                \"fs\": \"RimLitUnderwaterCaustics\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"RimLitUnderwaterCaustics\",\n                \"fs\": \"RimLitUnderwaterCaustics\"\n            }\n        ]\n    }\n}","RimLitUnderwaterCaustics.vs.glsl":"precision highp float;\n\n\n#define DEPTH_START\t\t0.0\n#define DEPTH_END\t\t-5.0\n#define AMBIENT_LIGHT\t0.75\n\n\nattribute vec4 _glesVertex;\nattribute lowp vec4 _glesMultiTexCoord0;\nattribute vec3 _glesNormal;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_world2object;\nuniform mediump vec4 _MainTex_ST;\n\nvarying lowp vec2 xlv_TEXCOORD0;\n\nvarying vec3 pos;\nvarying lowp float v_atten;\nvarying lowp float v_facing;\nvarying vec3 v_normal;\n\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n// #ifdef FOG\n// // #define glstate_fog_end\t\t150.\n// // #define glstate_fog_start\t1.\n// uniform lowp float glstate_fog_start;\n// uniform lowp float glstate_fog_end;\n// varying lowp float factor;\n// #endif\n\n#ifdef SKIN\nhighp mat4 blendMat;\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat * srcVertex;\n}\n#endif\n\nfloat inverseLerp(float x, float y, float z) {\n\t// return (z-x) / (y - x);\n    return smoothstep(x,y,z);   // TODO:\n}\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n\n    vec3 normal = _glesNormal;\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    normal = normalize(mat3(blendMat) * _glesNormal);\n    #endif\n\t// World position\n\tvec4 wp = glstate_matrix_model * position;\n\t// wp.xyz /= wp.w;\n    position = (glstate_matrix_mvp * position);\n\t// CALCULATE_NORMAL\n    normal = normalize(mat3(glstate_matrix_model) * normal);\n\tv_normal = normal;\n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n\t// NEEDS_PER_PIXEL_WORLD_POS\n\tpos = wp.xyz;\n\tv_facing = clamp(dot(normal, vec3(0, sign(DEPTH_START - wp.y), 0)), 0., 1.);\n\n\t// NEEDS_DEPTH_FACTOR\n\tfloat waterDepth = inverseLerp(DEPTH_START, DEPTH_END, wp.y);\n\n\t// NEEDS_LIGHTING\n\tfloat atten = 0.;\n\n#ifdef AMBIENT_LIGHT\n\tatten += AMBIENT_LIGHT;\n#endif\n\n\t// NO_LIGHTING_ABOVE_WATER\n\tatten = mix( 1., atten, waterDepth);\n\tv_atten = atten;\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n\n    // #ifdef FOG\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    // factor = clamp(factor, 0.0, 1.0);\n    // #endif\n\n\n\t// v_facing = clamp(dot(normalize(normal), vec3(0, 1., 0)), 0., 1.);\n\n    gl_Position = position;\n}","skyplanebackground.fs.glsl":"\n\nprecision highp float;\n\n\n\nuniform sampler2D _MainTex;\n\nvarying vec2 uv;\n\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n// #ifdef FOG\n// uniform lowp vec4 glstate_fog_color;\n// varying lowp float factor;\n// #endif\n\nvoid main()\n{\n    lowp vec4 emission = texture2D(_MainTex, uv);\n\n    // #ifdef LIGHTMAP\n    // lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    // emission.xyz *= decode_hdr(lightmap);\n    // #endif\n\n    // #ifdef FOG\n    // emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    // #endif\n\n    gl_FragData[0] = emission;\n\n}","skyplanebackground.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"skyplanebackground\",\n                \"fs\": \"skyplanebackground\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"skyplanebackground\",\n                \"fs\": \"skyplanebackground\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"skyplanebackground\",\n                \"fs\": \"skyplanebackground\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"skyplanebackground\",\n                \"fs\": \"skyplanebackground\"\n            }\n        ]\n    }\n}","skyplanebackground.vs.glsl":"precision highp float;\n\n\n\nattribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp;\n\nuniform mediump vec4 _MainTex_ST;\n\nvarying vec2 uv;\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n// #ifdef FOG\n// uniform lowp float glstate_fog_start;\n// uniform lowp float glstate_fog_end;\n// varying lowp float factor;\n// #endif\n\n\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n\n\n    // #ifdef FOG\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    // factor = clamp(factor, 0.0, 1.0);\n    // #endif\n\n    position = (glstate_matrix_mvp * position);\n\n    // Force the screen space z to the far clip plane so even though this renders last (and the geometry is front of some stuff), it still renders behind everything\n    position.z = position.w - 0.01;\n\n    uv = _glesMultiTexCoord0.xy*_MainTex_ST.xy+_MainTex_ST.zw;\n\n    gl_Position = position;\n}","skyplanebackgroundblend.fs.glsl":"precision highp float;\n\n\n\nuniform sampler2D _MainTex;\nuniform sampler2D _NextTex;\nuniform float _BlendValue;\n\nvarying vec2 uv;\n\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n// #ifdef FOG\n// uniform lowp vec4 glstate_fog_color;\n// varying lowp float factor;\n// #endif\n\nvoid main()\n{\n    vec4 emission = mix(texture2D(_MainTex, uv), texture2D(_NextTex, uv), _BlendValue);\n\n    // #ifdef LIGHTMAP\n    // lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    // emission.xyz *= decode_hdr(lightmap);\n    // #endif\n\n    // #ifdef FOG\n    // emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n    // #endif\n\n    gl_FragData[0] = emission;\n\n}","skyplanebackgroundblend.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_NextTex('Destiny Texture',Texture)='white'{}\",\n        \"_BlendValue('Blend Value',Range(0.0,1.0)) = 0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"skyplanebackgroundblend\",\n                \"fs\": \"skyplanebackgroundblend\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"skyplanebackgroundblend\",\n                \"fs\": \"skyplanebackgroundblend\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"skyplanebackgroundblend\",\n                \"fs\": \"skyplanebackgroundblend\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"skyplanebackgroundblend\",\n                \"fs\": \"skyplanebackgroundblend\"\n            }\n        ]\n    }\n}","skyplanebackgroundblend.vs.glsl":"precision highp float;\n\n\n\nattribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\n\nuniform highp mat4 glstate_matrix_mvp;\n\nuniform mediump vec4 _MainTex_ST;\n\nvarying vec2 uv;\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n// #ifdef FOG\n// uniform lowp float glstate_fog_start;\n// uniform lowp float glstate_fog_end;\n// varying lowp float factor;\n// #endif\n\n\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n\n\n    // #ifdef FOG\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    // factor = clamp(factor, 0.0, 1.0);\n    // #endif\n\n    position = (glstate_matrix_mvp * position);\n\n    // Force the screen space z to the far clip plane so even though this renders last (and the geometry is front of some stuff), it still renders behind everything\n    position.z = position.w - 0.01;\n\n    uv = _glesMultiTexCoord0.xy*_MainTex_ST.xy+_MainTex_ST.zw;\n\n    gl_Position = position;\n}","SphereMapAdditive.fs.glsl":"precision highp float;\n\n\n#define RIM_POWER               0.5\n#define RIM_LIGHTING_OPERATOR += 0.25 *\n\n\nuniform lowp sampler2D _MainTex;\nuniform lowp sampler2D _SphereMap;\nuniform lowp float _SphereMapIntensity;\n\nvarying lowp vec2 xlv_TEXCOORD0;\nvarying vec3 v_normal;\n\n\n#ifdef LIGHTMAP\nuniform lowp sampler2D _LightmapTex;\nvarying mediump vec2 lightmap_TEXCOORD;\nlowp vec3 decode_hdr(lowp vec4 data)\n{\n    lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * 2.0 ;\n}\n#endif\n\n// #ifdef FOG\n// uniform lowp vec4 glstate_fog_color;\n// varying lowp float factor;\n// #endif\n\nvoid main()\n{\n\n    // ALBEDO_TEXTURE\n    // lowp vec4 albedo = texture2D(_MainTex, xlv_TEXCOORD0);\n    lowp vec4 albedo = vec4(0);\n    // if(albedo.a < _AlphaCut)\n    //     discard;\n\n    // SPHERE_MAP\n    lowp vec2 sphereMapCoordinate = 0.5 + 0.5 * v_normal.xy;\n    // SPHERE_MAP_ADDITIVE\n    albedo += texture2D(_SphereMap, sphereMapCoordinate) * _SphereMapIntensity;\n\n    #ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    albedo.xyz *= decode_hdr(lightmap);\n    #endif\n\n\n\n\n    // #ifdef FOG\n    // albedo.xyz = mix(glstate_fog_color.rgb, albedo.rgb, factor);\n    // #endif\n\n    gl_FragData[0] = albedo;\n}","SphereMapAdditive.shader.json":"{\n    \"layer\": \"geometry\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_SphereMap('SphereMap',Texture) = 'white' {}\",\n        \"_SphereMapIntensity('Lighting Intensity',Range(0.0,1.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"SphereMapAdditive\",\n                \"fs\": \"SphereMapAdditive\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"SphereMapAdditive\",\n                \"fs\": \"SphereMapAdditive\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"SphereMapAdditive\",\n                \"fs\": \"SphereMapAdditive\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"SphereMapAdditive\",\n                \"fs\": \"SphereMapAdditive\"\n            }\n        ]\n    }\n}","SphereMapAdditive.vs.glsl":"precision highp float;\n\n\n\nattribute vec4 _glesVertex;\nattribute lowp vec4 _glesMultiTexCoord0;\nattribute vec3 _glesNormal;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_model;\nuniform mediump vec4 _MainTex_ST;\n\nvarying lowp vec2 xlv_TEXCOORD0;\n\nvarying vec3 v_normal;\n\n\n#ifdef LIGHTMAP\nattribute mediump vec4 _glesMultiTexCoord1;\nuniform mediump vec4 glstate_lightmapOffset;\n// uniform mediump float glstate_lightmapUV;\nvarying mediump vec2 lightmap_TEXCOORD;\n#endif\n\n// #ifdef FOG\n// #define glstate_fog_end\t\t150.\n// #define glstate_fog_start\t1.\n// // uniform lowp float glstate_fog_start;\n// // uniform lowp float glstate_fog_end;\n// varying lowp float factor;\n// #endif\n\n#ifdef SKIN\nhighp mat4 blendMat;\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    blendMat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn blendMat * srcVertex;\n}\n#endif\n\nfloat inverseLerp(float x, float y, float z) {\n\t// return (z-x) / (y - x);\n    return smoothstep(x,y,z);   // TODO:\n}\n\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n\n\n    vec3 normal = _glesNormal;\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    normal = normalize(mat3(blendMat) * _glesNormal);\n    #endif\n\t// // World position\n\t// vec4 wp = glstate_matrix_model * position;\n\t// // wp.xyz /= wp.w;\n    position = (glstate_matrix_mvp * position);\n\t// CALCULATE_NORMAL\n    normal = normalize(mat3(glstate_matrix_model) * normal);\n\tv_normal = normal;\n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n\n\n\n\n\n    //----------------------------------------------------------\n    #ifdef LIGHTMAP\n    mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    lightmap_TEXCOORD = vec2(u,v);\n    #endif\n\n\n    // #ifdef FOG\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    // factor = clamp(factor, 0.0, 1.0);\n    // #endif\n\n\n\t// v_facing = clamp(dot(normalize(normal), vec3(0, 1., 0)), 0., 1.);\n\n    gl_Position = position;\n}","transparent.fs.glsl":"uniform lowp sampler2D _MainTex;\nvarying highp vec2 xlv_TEXCOORD0;\nuniform lowp float _Alpha;\nuniform lowp float _Superimposition;\n\n// #ifdef FOG\n// uniform lowp vec4 glstate_fog_color;\n// varying lowp float factor;\n// #endif\n\nvoid main()\n{\n    lowp vec4 emission = texture2D(_MainTex, xlv_TEXCOORD0);\n    emission.a=emission.a*_Alpha;\n    emission.xyz *= _Superimposition;\n    //----------------------------------------------------------\n    // #ifdef FOG\n    // emission.xyz= mix(glstate_fog_color.xyz, emission.xyz, factor);\n    // #endif\n    gl_FragData[0] = emission;\n\n}","transparent.shader.json":"{\n    \"layer\": \"transparent\",\n\t\"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\",\n        \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\",\n        \"_Superimposition('Superimposition', Range(0.0, 7.0)) = 1.0\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"showface\": \"ccw\",\n                \"vs\": \"transparent\",\n                \"fs\": \"transparent\"\n            }\n        ],\n        \"shadowgen\": [],\n        \"bone\": [],\n        \"shadowuse\": []\n    }\n}","transparent.vs.glsl":"attribute highp vec4 _glesVertex;\nattribute mediump vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform mediump vec4 _MainTex_ST;\n\nvarying mediump vec2 xlv_TEXCOORD0;\n\n// #ifdef FOG\n// #define glstate_fog_end\t\t150.\n// #define glstate_fog_start\t1.\n// // uniform lowp float glstate_fog_start;\n// // uniform lowp float glstate_fog_end;\n// varying lowp float factor;\n// #endif\n\n#ifdef SKIN\nattribute lowp vec4 _glesBlendIndex4;\nattribute lowp vec4 _glesBlendWeight4;\nuniform highp vec4 glstate_vec4_bones[110];\nmat4 buildMat4(int index)\n{\n\tvec4 quat = glstate_vec4_bones[index * 2 + 0];\n\tvec4 translation = glstate_vec4_bones[index * 2 + 1];\n\tfloat xy = 2.0 * quat.x * quat.y;\n\tfloat xz = 2.0 * quat.x * quat.z;\n\tfloat xw = 2.0 * quat.x * quat.w;\n\tfloat yz = 2.0 * quat.y * quat.z;\n\tfloat yw = 2.0 * quat.y * quat.w;\n\tfloat zw = 2.0 * quat.z * quat.w;\n\tfloat xx = 2.0*quat.x * quat.x;\n\tfloat yy = 2.0*quat.y * quat.y;\n\tfloat zz = 2.0*quat.z * quat.z;\n\tfloat ww = 2.0*quat.w * quat.w;\n\tfloat s = translation.w;\n\tmat4 matrix = mat4(\n\t(1.0-yy-zz)*s, (xy+zw)*s, (xz-yw)*s, 0,\n\t(xy-zw)*s, (1.0-xx-zz)*s, (yz + xw)*s, 0,\n\t(xz + yw)*s, (yz - xw)*s, (1.0-xx-yy)*s, 0,\n\ttranslation.x, translation.y, translation.z, 1);\n\treturn matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,lowp vec4 blendIndex,lowp vec4 blendWeight)\n{\n\tint i = int(blendIndex.x);\n    int i2 =int(blendIndex.y);\n\tint i3 =int(blendIndex.z);\n\tint i4 =int(blendIndex.w);\n\n    mat4 mat = buildMat4(i)*blendWeight.x\n\t\t\t + buildMat4(i2)*blendWeight.y\n\t\t\t + buildMat4(i3)*blendWeight.z\n\t\t\t + buildMat4(i4)*blendWeight.w;\n\treturn mat* srcVertex;\n}\n#endif\nvoid main()\n{\n    highp vec4 position=vec4(_glesVertex.xyz,1.0);\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n\n    //----------------------------------------------------------\n    #ifdef SKIN\n    position =calcVertex(position,_glesBlendIndex4,_glesBlendWeight4);\n    #endif\n    position = (glstate_matrix_mvp * position);\n\n    // #ifdef FOG\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    // factor = clamp(factor, 0.0, 1.0);\n    // #endif\n\n    gl_Position = position;\n}","water.fs.glsl":"\n\nprecision highp float;\n\n\n\nuniform sampler2D _MainTex;\n\n\nvarying vec4 color;\nvarying vec2 uv;\n\n// #ifdef LIGHTMAP\n// uniform lowp sampler2D _LightmapTex;\n// varying mediump vec2 lightmap_TEXCOORD;\n// lowp vec3 decode_hdr(lowp vec4 data)\n// {\n//     lowp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n//     return data.rgb * power * 2.0 ;\n// }\n// #endif\n\n// #ifdef FOG\n// uniform lowp vec4 glstate_fog_color;\n// varying lowp float factor;\n// #endif\n\nvoid main()\n{\n    vec4 emission = texture2D(_MainTex, uv);\n    // lowp vec4 emission = lerp(tex2D(_MainTex, uv), tex2D(_NextTex, uv), _BlendValue);\n    // if(emission.a < _AlphaCut)\n    //     discard;\n\n    // #ifdef LIGHTMAP\n    // lowp vec4 lightmap = texture2D(_LightmapTex, lightmap_TEXCOORD);\n    // emission.xyz *= decode_hdr(lightmap);\n    // #endif\n\n\n\n\n\n    // vec4 texcol = texture2D(_MainTex, uv);\n    // texcol.a = 0.2 * abs(sin( 25. * (color.r + glstate_timer * 0.02) * 3.14159265359));\n\n\t// #ifdef FOG\n    // emission.xyz = mix(glstate_fog_color.rgb, emission.rgb, factor);\n\t// #endif\n\n    emission.a *= color.x;\n    gl_FragData[0] = emission;\n\n}","water.shader.json":"{\n    \"layer\": \"transparent\",\n    \"properties\": [\n        \"_MainTex('MainTex',Texture)='white'{}\"\n    ],\n    \"passes\": {\n        \"base\": [\n            {\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\": \"lequal\",\n                \"showface\": \"all\",\n                \"vs\": \"water\",\n                \"fs\": \"water\"\n            }\n        ],\n        \"base_fog\": [\n            {\n                \"blendmode\": \"blend\",\n                \"zwrite\": \"off\",\n                \"ztest\": \"lequal\",\n                \"showface\": \"all\",\n                \"vs\": \"water\",\n                \"fs\": \"water\"\n            }\n        ],\n        \"skin\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"water\",\n                \"fs\": \"water\"\n            }\n        ],\n        \"skin_fog\": [\n            {\n                \"showface\": \"ccw\",\n                \"vs\": \"water\",\n                \"fs\": \"water\"\n            }\n        ]\n    }\n}","water.vs.glsl":"precision highp float;\n\n#define timer glstate_timer * 0.01\n\nattribute highp vec4 _glesVertex;\nattribute mediump vec2 _glesMultiTexCoord0;\nattribute lowp vec2 _glesMultiTexCoord1;\nattribute mediump vec4 _glesColor;\n\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_model;\nuniform highp mat4 glstate_matrix_world2object;\n\nuniform vec4 glstate_eyepos;\nuniform float glstate_timer;\n\nuniform mediump vec4 _MainTex_ST;\n\nvarying vec4 color;\nvarying vec2 uv;\n\n// #ifdef LIGHTMAP\n// attribute mediump vec4 _glesMultiTexCoord1;\n// uniform mediump vec4 glstate_lightmapOffset;\n// // uniform mediump float glstate_lightmapUV;\n// varying mediump vec2 lightmap_TEXCOORD;\n// #endif\n\n// #ifdef FOG\n// uniform lowp float glstate_fog_start;\n// uniform lowp float glstate_fog_end;\n// varying lowp float factor;\n// #endif\n\n\nfloat inverseLerp(float x,float y,float z){\n\t// return clamp((z-x)/(y-x), 0., 1.);\n    // return clamp(z-x, 0, y)/(y-x);\n    return smoothstep(x,y,z);   // TODO:\n}\n\n\nvoid main()\n{\n    vec4 position=vec4(_glesVertex.xyz,1.0);\n\n\n    // //----------------------------------------------------------\n    // #ifdef LIGHTMAP\n    // mediump vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    // lowp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    // lowp float v = beforelightUV.y * glstate_lightmapOffset.y + glstate_lightmapOffset.w;\n    // lightmap_TEXCOORD = vec2(u,v);\n    // #endif\n\n\n\n    // #ifdef FOG\n    // factor = (glstate_fog_end - abs(position.z))/(glstate_fog_end - glstate_fog_start);\n    // factor = clamp(factor, 0.0, 1.0);\n    // #endif\n\n\n    mediump float belowWaterFactor = inverseLerp(1., -3. , glstate_eyepos.y);\n\n    position.z *= 0.5;\n\n    color.x = inverseLerp(-1., 0., position.z) - inverseLerp(30., 40., position.z);\n    color.y = 0.;\n\n    position.y *= sin( 150. * (_glesColor.r + timer * 3.14159265359)) * 0.3 * color.x * belowWaterFactor;\n    position.y -= belowWaterFactor * 2. * inverseLerp(20., 40., position.z);\n\n\n\n    position = (glstate_matrix_mvp * position);\n\n\n    uv = _glesMultiTexCoord0.xy*_MainTex_ST.xy+_MainTex_ST.zw;\n    uv += timer * 15.;\n\n    gl_Position = position;\n}"}