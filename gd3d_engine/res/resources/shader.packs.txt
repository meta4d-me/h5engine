{"post_depth.vs.glsl":"precision highp float;attribute vec4 _glesVertex;    //attribute vec3 _glesNormal;//uniform highp mat4 glstate_matrix_modelview;uniform highp mat4 glstate_matrix_mvp;      // varying highp vec3 xlv_Normal;                       void main()                                     {            // highp mat3 normalMat=mat3(    //     glstate_matrix_mvp[0],    //     glstate_matrix_mvp[1],    //     glstate_matrix_mvp[2]);    // xlv_Normal=normalMat * _glesNormal;    // xlv_Normal+=1.0;    // xlv_Normal*=0.5;    gl_Position = (glstate_matrix_mvp * _glesVertex);  }","post_depth.fs.glsl":"precision highp float;//varying highp vec3 xlv_Normal;   const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );const float ShiftRight8 = 1. / 256.;vec4 packDepthToRGBA( const in float v ) {    vec4 r = vec4( fract( v * PackFactors ), v );r.yzw -= r.xyz * ShiftRight8; // tidy overflow    return r * PackUpscale;}float unpackRGBAToDepth( const in vec4 v ) {    return dot( v, UnpackFactors );}vec2 packDepthToRG( const in float v ) {    vec2 r = vec2( fract( v * PackFactors.z ), v );r.y -= r.x * ShiftRight8;    return r * PackUpscale;}float unpackRGToDepth( const in vec2 v ) {    return dot( v.xy, UnpackFactors.zw );}vec3 packDepthToRGB( const in float v ) {    vec3 r = vec3( fract( v * PackFactors.yz ), v );r.yz -= r.xy * ShiftRight8; // tidy overflow    return r * PackUpscale;}float unpackRGBToDepth( const in vec3 v ) {    return dot( v.xyz, UnpackFactors.yzw );}void main() {    float z = gl_FragCoord.z;// fract(gl_FragCoord.z *256.*256.);    // highp vec2 normal =xlv_Normal.xy;    gl_FragColor=packDepthToRGBA(z);}","post_quad.vs.glsl":"attribute vec4 _glesVertex;attribute vec4 _glesMultiTexCoord0; varying highp vec2 xlv_TEXCOORD0;   void main()                     {     gl_Position = _glesVertex;    xlv_TEXCOORD0=_glesMultiTexCoord0.xy;}   ","post_quad_depth.fs.glsl":"precision mediump float;varying highp vec2 xlv_TEXCOORD0;       uniform sampler2D _DepthTex;   uniform sampler2D _MainTex;  const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );const float ShiftRight8 = 1. / 256.;vec4 packDepthToRGBA( const in float v ) {    vec4 r = vec4( fract( v * PackFactors ), v );r.yzw -= r.xyz * ShiftRight8; // tidy overflow    return r * PackUpscale;}float unpackRGBAToDepth( const in vec4 v ) {    return dot( v, UnpackFactors );}float planeDistance(const in vec3 positionA, const in vec3 normalA,                     const in vec3 positionB, const in vec3 normalB) {  vec3 positionDelta = positionB-positionA;  float planeDistanceDelta = max(abs(dot(positionDelta, normalA)), abs(dot(positionDelta, normalB)));  return planeDistanceDelta;}void main()         {    lowp vec4 c1=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0.001,0));    lowp vec4 c2=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(-0.001,0));    lowp vec4 c3=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0,0.001));    lowp vec4 c4=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0,-0.001));    highp float z1 = unpackRGBAToDepth(c1);    highp float z2 = unpackRGBAToDepth(c2);    highp float z3 = unpackRGBAToDepth(c3);    highp float z4 = unpackRGBAToDepth(c4);    highp float d = clamp(  (abs(z2-z1)+abs(z4-z3))*10.0,0.0,1.0);    lowp vec4 c=texture2D(_MainTex, xlv_TEXCOORD0);    lowp float g = c.r*0.3+c.g*0.6+c.b*0.1;    gl_FragColor =mix(vec4(g,g,g,1.),vec4(1.0,1.0,0.0,1.0),d);// vec4(g*d,g*d,g*d,1.0);}","color.vs.glsl":"attribute vec4 _glesVertex;   attribute vec4 _glesColor;                  attribute vec4 _glesMultiTexCoord0;        uniform highp mat4 glstate_matrix_mvp;      varying lowp vec4 xlv_COLOR;                varying highp vec2 xlv_TEXCOORD0;           void main()                                     {                                                   highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;                               tmpvar_1.xyz = _glesVertex.xyz;                 xlv_COLOR = _glesColor;                         xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;         gl_Position = (glstate_matrix_mvp * tmpvar_1);  }","color.fs.glsl":"uniform sampler2D _MainTex;                                                 varying lowp vec4 xlv_COLOR;                                                 varying highp vec2 xlv_TEXCOORD0;   void main() {    lowp vec4 tmpvar_3;    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));    gl_FragData[0] = tmpvar_3;}","color.shader.json":"{    \"layer\": \"transparent\",    \"passes\": {        \"base\": [            {                \"showface\": \"all\",                \"vs\": \"color\",                \"fs\": \"color\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}","normalmap.vs.glsl":"// in  attributes from our SpriteBatchattribute vec3 _glesVertex;attribute vec2 _glesMultiTexCoord0;attribute vec4 _glesColor;attribute vec3 _glesNormal;attribute vec3 _glesTangent;  uniform highp mat4 glstate_matrix_mvp;uniform highp mat4 glstate_matrix_model;uniform highp mat4 glstate_matrix_modelview;uniform highp vec4 glstate_eyepos;uniform highp vec4 glstate_vec4_lightposs[8];uniform highp vec4 glstate_vec4_lightdirs[8];uniform highp float glstate_float_spotangelcoss[8];uniform highp float glstate_lightcount;// out  varyings to our fragment shadervarying highp vec4 xlv_COLOR;varying highp vec3 xlv_Position;      varying highp vec2 xlv_TEXCOORD0;varying highp mat3 TBNmat;varying highp vec3 worldpos;highp mat3 calBTNMatrix(highp mat3 NormalMatToWorld,highp vec3 _normal,highp vec3 _tangent){    highp vec3 normal=normalize(NormalMatToWorld*_normal);    highp vec3 tangent=normalize(NormalMatToWorld*_tangent);    highp vec3 binormal=cross(normal,tangent);  return (mat3(tangent,binormal,normal));}void main(){//求世界空间法线    mat3 normalmat = mat3(glstate_matrix_model);//normalmat[3] =vec4(0,0,0,1);   TBNmat=calBTNMatrix(normalmat,_glesNormal,_glesTangent);    worldpos =(glstate_matrix_model * vec4(_glesVertex.xyz, 1.0)).xyz;//eyedir = glstate_eyepos - worldpos;xlv_COLOR = _glesColor;xlv_Position = _glesVertex.xyz;xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;gl_Position = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));}","normalmap.fs.glsl":"uniform sampler2D _MainTex;  uniform sampler2D _NormalTex;   //normal mapuniform highp mat4 glstate_matrix_model;uniform highp vec4 glstate_vec4_lightposs[8];uniform highp vec4 glstate_vec4_lightdirs[8];uniform highp float glstate_float_spotangelcoss[8];uniform highp float glstate_lightcount;varying lowp vec4 xlv_COLOR;     varying highp vec3 xlv_Position;                                             varying highp vec2 xlv_TEXCOORD0; varying highp mat3 TBNmat;varying highp vec3 worldpos; highp float calcDiffuse(highp vec3 N,highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot);// highp mat3 cotangentFrame(vec3 normal,highp vec3 position,vec2 uv);void main() {//切空间逆矩阵的计算 应该在vertex shader 里面完成，不需要dfdx 和 dfdy//mesh 算好切线tangent，然后 normal 和 tangent cross 出 bnormal//然后合成出切空间逆矩阵，放在这里算不划算highp mat3 TBN = TBNmat;//    highp mat3 normalmat = mat3(glstate_matrix_model);highp vec3 N = normalize(TBNmat[2]*normalmat);    highp float diff=0.0;    //calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);    for(int i=0;i<8;i++)    {                int c =int(glstate_lightcount);        if(i>=c)break;highp vec4 lpos=glstate_vec4_lightposs[i];//lpos.xyz = TBN*lpos.xyz;highp vec4 ldir =glstate_vec4_lightdirs[i];//ldir.xyz = TBN*ldir.xyz;//这是进入切空间的原因highp vec3 normal;// = TBN*N;normal =  texture2D(_NormalTex, xlv_TEXCOORD0).xyz *2.0 -1.0;        normal =normalize(normal);normal =TBN*(normal);        diff += calcDiffuse(normal,worldpos,lpos,ldir,glstate_float_spotangelcoss[i]);    }//diff=1.0;lowp vec4 color = vec4(diff,diff,diff,1.0);           lowp vec4 tmpvar_3;    tmpvar_3 = (color * texture2D(_MainTex, xlv_TEXCOORD0));    gl_FragData[0] = tmpvar_3;}highp float calcDiffuse(highp vec3 N,highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot){    //求入射角，点光源&聚光灯    highp vec3 L = normalize(lightPos.xyz - worldpos);     //求张角 聚光灯 也是方向光入射角    highp vec3 L2 = -lightDir.xyz;    highp float dotSpot = dot(L,L2);    //漫反射强度    highp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0);     highp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0);     //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);    diffuse= mix(diffuseD,diffuse,lightPos.w);    return diffuse;     }","normalmap.shader.json":"{\"layer\": \"transparent\",\"passes\": {\"base\": [{\"showface\": \"all\",\"vs\": \"normalmap\",\"fs\": \"normalmap\"}],\"shadowgen\": [],\"bone\": [],\"shadowuse\": []}}","light1.vs.glsl":"attribute vec3 _glesVertex;   attribute vec3 _glesNormal;   attribute vec4 _glesColor;                  attribute vec4 _glesMultiTexCoord0;        uniform highp mat4 glstate_matrix_mvp;      uniform highp mat4 glstate_matrix_model;uniform highp mat4 glstate_matrix_modelview;uniform highp vec4 glstate_vec4_lightposs[8];uniform highp vec4 glstate_vec4_lightdirs[8];uniform highp float glstate_float_spotangelcoss[8];uniform highp float glstate_lightcount;varying lowp vec4 xlv_COLOR;                varying highp vec2 xlv_TEXCOORD0;     //calcDiffuse 计算漫反射强度函数//统一三种光源的传参方式，在函数内混合，方便就不高效//只需要方向光时另写//N 世界空间法线//worldpos 世界空间pos//lightPos 光源位置,w=0 表示方向光//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来highp float calcDiffuse(highp vec3 N,highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot){    //求入射角，点光源&聚光灯    highp vec3 L = normalize(lightPos.xyz - worldpos);     //求张角 聚光灯 也是方向光入射角    highp vec3 L2 = -lightDir.xyz;    highp float dotSpot = dot(L,L2);    //漫反射强度    highp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0);     highp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0);     //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);    diffuse= mix(diffuseD,diffuse,lightPos.w);    return diffuse;     }void main()                                     {                                                   highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;                               tmpvar_1.xyz = _glesVertex.xyz;        //求世界空间法线    highp mat3 normalmat = mat3(glstate_matrix_model);    highp vec3 N =normalize(normalmat*_glesNormal);    highp vec3 worldpos =(glstate_matrix_model * vec4(_glesVertex.xyz, 1.0)).xyz;    highp float diff=0.0;    //calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);    for(int i=0;i<8;i++)    {        int c =int(glstate_lightcount);        if(i>=c)break;        diff += calcDiffuse(N,worldpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i]);    }    xlv_COLOR = vec4(diff,diff,diff,1.0);             xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;         gl_Position = (glstate_matrix_mvp * tmpvar_1);  }","light1.fs.glsl":"uniform sampler2D _MainTex;                                                 varying lowp vec4 xlv_COLOR;                                                 varying highp vec2 xlv_TEXCOORD0;   void main() {    lowp vec4 tmpvar_3= (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));    mediump vec4 tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), tmpvar_3, tmpvar_3.wwww);    gl_FragData[0] = tmpvar_4;}","light1.shader.json":"{    \"layer\": \"transparent\",    \"passes\": {        \"base\": [            {                \"showface\": \"ccw\",                \"vs\": \"light1\",                \"fs\": \"light1\"            }        ],        \"skin\": [            {                \"showface\": \"ccw\",                \"vs\": \"bone_eff\",                \"fs\": \"diffuse\"            }        ],        \"base_depth\": [            {                \"showface\": \"ccw\",                \"vs\": \"post_depth\",                \"fs\": \"post_depth\"            }        ],        \"shadowuse\": []    }}","light2.vs.glsl":"attribute vec3 _glesVertex;   attribute vec3 _glesNormal;   attribute vec4 _glesColor;                  attribute vec4 _glesMultiTexCoord0; uniform highp sampler2D _NormalTex;   //normal mapuniform highp mat4 glstate_matrix_mvp;      uniform highp mat4 glstate_matrix_model;uniform highp mat4 glstate_matrix_modelview;uniform highp vec4 glstate_eyepos;varying highp vec3 vWorldpos;varying highp vec3 vNormal;varying highp vec2 xlv_TEXCOORD0;varying highp vec3 vEyepos;void main(){    highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;                               tmpvar_1.xyz =_glesVertex;    vWorldpos=(glstate_matrix_model*tmpvar_1).xyz;    //vWorldpos =glstate_matrix_model[3].xyz;//计算输出定点位置    vEyepos=glstate_eyepos.xyz;          //求世界空间法线    highp mat4 vnormalMat = glstate_matrix_model;    vnormalMat[3] =vec4(0,0,0,1);    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;    highp vec3 NormalMap = texture2D(_NormalTex, xlv_TEXCOORD0).rgb;    highp vec3 N = normalize(NormalMap * 2.0 - vec3(1.0));    vNormal =normalize((vec4(_glesNormal,1)*vnormalMat).xyz);    //vNormal=N;    gl_Position = (glstate_matrix_mvp * tmpvar_1);}","light2.fs.glsl":"uniform sampler2D _MainTex;uniform highp vec4 glstate_vec4_lightposs[8];uniform highp vec4 glstate_vec4_lightdirs[8];uniform highp float glstate_float_spotangelcoss[8];varying highp vec3 vWorldpos;varying highp vec3 vNormal;varying highp vec2 xlv_TEXCOORD0;varying highp vec3 vEyepos;//calcDiffuse 计算漫反射强度函数//统一三种光源的传参方式，在函数内混合，方便就不高效//只需要方向光时另写//N 世界空间法线//worldpos 世界空间pos//lightPos 光源位置,w=0 表示方向光//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来highp float calcDiffuse(highp vec3 N,highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot){    //求入射角，点光源&聚光灯    highp vec3 L = normalize(lightPos.xyz - worldpos);     //求张角 聚光灯 也是方向光入射角    highp vec3 L2 = -lightDir.xyz;    highp float dotSpot = dot(L,L2);    //漫反射强度    highp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0);     highp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0);     //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);    diffuse= mix(diffuseD,diffuse,lightPos.w);    return diffuse;}highp float calSpec(highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir){   // highp vec3 ks=vec3(0.5,0.5,0.5);//物体对于反射光线的衰减系数    highp float shininess=1.0;//高光系数   // highp vec3 lightcolor=vec3(1.0,1.0,1.0);    highp vec3 N=normalize(vNormal);   // highp vec3 L = normalize(lightPos.xyz - worldpos);     highp vec3 L = normalize(-lightDir.xyz);     highp vec3 v=normalize(vEyepos-worldpos);    highp vec3 H=normalize(L+v);    //highp vec3 R=reflect(-L,N);    //R=normalize(R);    highp  float specularLight = pow(clamp(dot(N,H),0.0,1.0), shininess);    //highp vec3 spec=ks*lightcolor*specularLight;    highp float spec=specularLight;    return spec;}void main() {    highp float diff=0.0;    highp float specularColor=0.0;    for(int i=0;i<8;i++)    {        diff+=calcDiffuse(vNormal,vWorldpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i]);        specularColor+=calSpec(vWorldpos,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i]);    }    lowp vec4 xlv_COLOR=vec4(diff,diff,diff,1.0);    xlv_COLOR+=vec4(specularColor,specularColor,specularColor,1.0);    lowp vec4 col_1;        mediump vec4 prev_2;    lowp vec4 tmpvar_3;    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));    prev_2 = tmpvar_3;    mediump vec4 tmpvar_4;    tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);    col_1 = tmpvar_4;       gl_FragData[0] = col_1;    //gl_FragData[0]=vec4(specularColor,1.0);    //gl_FragData[0] = xlv_COLOR;}","light2.shader.json":"{    \"layer\": \"transparent\",    \"passes\": {        \"base\": [            {                \"showface\": \"ccw\",                \"vs\": \"light2\",                \"fs\": \"light2\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}","light3.vs.glsl":"// in  attributes from our SpriteBatchattribute vec3 _glesVertex;attribute vec2 _glesMultiTexCoord0;attribute vec4 _glesColor;attribute vec3 _glesNormal;attribute vec3 _glesTangent;  uniform highp mat4 glstate_matrix_mvp;uniform highp mat4 glstate_matrix_model;uniform highp mat4 glstate_matrix_modelview;uniform highp vec4 glstate_eyepos;uniform highp vec4 glstate_vec4_lightposs[8];uniform highp vec4 glstate_vec4_lightdirs[8];uniform highp float glstate_float_spotangelcoss[8];// out  varyings to our fragment shader//varying highp vec4 xlv_COLOR;//varying highp vec3 xlv_Position;      varying highp vec2 xlv_TEXCOORD0;//varying highp vec3 xlv_Normal;//varying highp mat4 normalmat;varying highp mat3 TBNmat;varying highp vec3 worldpos;varying highp vec3 eyedir;highp mat3 calBTNMatrix(highp mat4 NormalMatToWorld,highp vec3 _normal,highp vec3 _tangent){    highp vec3 normal=normalize(vec3(NormalMatToWorld*vec4(_normal,0.0)));    highp vec3 tangent=normalize(vec3(NormalMatToWorld*vec4(_tangent,0.0)));    highp vec3 binormal=cross(normal,tangent);  return (mat3(tangent,binormal,normal));}void main(){//求世界空间法线  highp mat4  normalmat = glstate_matrix_model;normalmat[3] =vec4(0,0,0,1);   TBNmat=calBTNMatrix(normalmat,_glesNormal,_glesTangent);    worldpos =(glstate_matrix_model * vec4(_glesVertex.xyz, 1.0)).xyz;eyedir = glstate_eyepos.xyz - worldpos;//xlv_COLOR = _glesColor;//xlv_Normal = _glesNormal;//xlv_Position = _glesVertex.xyz;xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;gl_Position = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));}","light3.fs.glsl":"uniform sampler2D _MainTex;  uniform sampler2D _NormalTex;   //normal mapuniform highp vec4 glstate_vec4_lightposs[8];uniform highp vec4 glstate_vec4_lightdirs[8];uniform highp float glstate_float_spotangelcoss[8];uniform highp float glstate_lightcount;//varying lowp vec4 xlv_COLOR;     //varying highp vec3 xlv_Position;                                             varying highp vec2 xlv_TEXCOORD0; //varying highp vec3 xlv_Normal; //varying highp mat4 normalmat;varying highp mat3 TBNmat;varying highp vec3 worldpos; varying highp vec3 eyedir;highp float calcDiffuse(highp vec3 N,highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot);highp float calcSpec(highp vec3 N,highp vec3 worldpos,highp vec3 eyedir,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot);void main() {    //不需要法线图时，normal 就是这个N    //highp vec3 N =normalize((vec4(xlv_Normal,1)*normalmat).xyz);    highp float diff=0.0;    highp float spec=0.0;    //calcDiffuse(N,worldpos,glstate_vec4_lightposs[0],glstate_vec4_lightdirs[0],0.8);    for(int i=0;i<8;i++)    {        int c =int(glstate_lightcount);        if(i>=c)break;    highp vec4 lpos=glstate_vec4_lightposs[i];//lpos.xyz = TBN*lpos.xyz;highp vec4 ldir =glstate_vec4_lightdirs[i];//ldir.xyz = TBN*ldir.xyz;//这是进入切空间的原因highp vec3 normal;// = TBN*N;normal =  texture2D(_NormalTex, xlv_TEXCOORD0).xyz *2.0 -1.0;        normal =normalize(normal);normal =TBNmat*(normal);        diff += calcDiffuse(normal,worldpos,lpos,ldir,glstate_float_spotangelcoss[i]);        spec += calcSpec(normal,worldpos,eyedir,lpos,ldir,glstate_float_spotangelcoss[i]);    }//diff=1.0;lowp vec4 color = vec4(diff,diff,diff,1.0);           lowp vec4 colorspec =vec4(spec,spec,spec,1.0);    lowp vec4 fcolor;    fcolor = (color * texture2D(_MainTex, xlv_TEXCOORD0) + colorspec);    gl_FragData[0] = fcolor;}highp float calcDiffuse(highp vec3 N,highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot){    //求入射角，点光源&聚光灯    highp vec3 L = normalize(lightPos.xyz - worldpos);     //求张角 聚光灯 也是方向光入射角    highp vec3 L2 = -lightDir.xyz;    highp float dotSpot = dot(L,L2);    //漫反射强度    highp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0);     highp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0);     //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);    diffuse= mix(diffuseD,diffuse,lightPos.w);    return diffuse;     }highp float calcSpec(highp vec3 N,highp vec3 worldpos,highp vec3 eyedir,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot){    highp float shininess=30.0;//高光系数    highp vec3 L = normalize(lightPos.xyz - worldpos);     highp vec3 L2 = -lightDir.xyz;    highp float dotSpot = dot(L,L2);    //三种光源 计算出三个 高光强度，然后根据条件选出一个    highp float spec =pow(clamp(dot(N,normalize(L+eyedir)),0.0,1.0), shininess);    highp float specD =pow(clamp(dot(N,normalize(L2+eyedir)),0.0,1.0), shininess);    spec= mix(spec,spec*smoothstep(cosspot,1.0,dotSpot),lightDir.w);    spec= mix(specD,spec,lightPos.w);    //highp  float specularLight = pow(clamp(dot(N,H),0.0,1.0), shininess);    return spec;}","light3.shader.json":"{    \"layer\": \"transparent\",    \"passes\": {        \"base\": [            {                \"showface\": \"cw\",                \"vs\": \"light3\",                \"fs\": \"light3\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}","transparent-diffuse.vs.glsl":"attribute vec4 _glesVertex;   attribute vec4 _glesNormal;   attribute vec4 _glesColor;                  attribute vec4 _glesMultiTexCoord0;        uniform highp mat4 glstate_matrix_mvp;   varying lowp vec4 xlv_COLOR;                varying highp vec2 xlv_TEXCOORD0;   uniform highp vec4 _MainTex_ST;       void main()                                     {                                                   highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;                               tmpvar_1.xyz = _glesVertex.xyz;                 xlv_COLOR = _glesColor;                         xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;       //xlv_COLOR.xyz =pos.xyz;    gl_Position = (glstate_matrix_mvp * tmpvar_1);  }","transparent-diffuse.fs.glsl":"uniform sampler2D _MainTex;                                                 varying lowp vec4 xlv_COLOR;                                                 varying highp vec2 xlv_TEXCOORD0;   void main() {    lowp vec4 col_1;        mediump vec4 prev_2;    lowp vec4 tmpvar_3;    tmpvar_3 = (texture2D(_MainTex, xlv_TEXCOORD0));    //prev_2 = tmpvar_3;    //mediump vec4 tmpvar_4;    //tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);    //col_1 = tmpvar_4;    //col_1.x = xlv_TEXCOORD0.x;    //col_1.y = xlv_TEXCOORD0.y;    gl_FragData[0] = tmpvar_3;}","transparent-diffuse.shader.json":"{  \"layer\": \"transparent\",  \"properties\": [    \"_MainTex('MainTex',Texture)='white'{}\",\"_MainTex_ST('MainTex_ST',Vector) = (1,1,1,1)\"  ],  \"passes\": {    \"base\": [      {        \"blendmode\":  \"blend\",        \"showface\": \"ccw\",        \"vs\": \"transparent-diffuse\",        \"fs\": \"transparent-diffuse\"      }    ],    \"shadowgen\": [],    \"bone\": [],    \"shadowuse\": []  }}","uvroll.vs.glsl":"attribute vec4 _glesVertex;   attribute vec4 _glesMultiTexCoord0;      uniform highp mat4 glstate_matrix_mvp;uniform highp float glstate_timer;uniform highp float _SpeedU;uniform highp float _SpeedV;uniform highp vec4 _MainTex_ST;varying highp vec2 xlv_TEXCOORD0;void main()                                     {                                                   highp vec4 tmpvar_1 = vec4(_glesVertex.xyz,1);    highp vec2 _speed = vec2(_SpeedU,_SpeedV);    xlv_TEXCOORD0 = (_glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw)  + _speed * glstate_timer;    gl_Position = (glstate_matrix_mvp * tmpvar_1);  }","uvroll.shader.json":"{    \"layer\": \"geometry\",    \"properties\": [],    \"passes\": {        \"base\": [            {                \"showface\": \"ccw\",                \"vs\": \"uvroll\",                \"fs\": \"uvroll\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}","uvroll.fs.glsl":"uniform sampler2D _MainTex;uniform lowp float _AlphaCut;varying highp vec2 xlv_TEXCOORD0;void main() {    lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);    if(tmpvar_3.a < _AlphaCut)        discard;    gl_FragData[0] = tmpvar_3;}","diffuse.vs.glsl":"attribute vec4 _glesVertex;attribute vec4 _glesMultiTexCoord0;uniform highp mat4 glstate_matrix_mvp;varying highp vec2 xlv_TEXCOORD0;void main(){    highp vec4 tmpvar_1;    tmpvar_1.w = 1.0;    tmpvar_1.xyz = _glesVertex.xyz;xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;    gl_Position = (glstate_matrix_mvp * tmpvar_1);}","diffuse.fs.glsl":"uniform sampler2D _MainTex;uniform lowp float _AlphaCut;varying highp vec2 xlv_TEXCOORD0;void main() {    lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);    if(tmpvar_3.a < _AlphaCut)        discard;    gl_FragData[0] = tmpvar_3;}","diffuse.shader.json":"{    \"layer\": \"geometry\",    \"properties\": [        \"_MainTex('MainTex',Texture)='white'{}\",        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\"    ],    \"passes\": {        \"base\": [            {                \"showface\": \"ccw\",                \"vs\": \"diffuse\",                \"fs\": \"diffuse\",                \"zwrite\":\"on\",                \"ztest\":\"lequal\"            }        ],        \"skin\": [            {                \"showface\": \"ccw\",                \"vs\": \"bone_eff\",                \"fs\": \"diffuse\"            }        ],        \"lightmap\": [            {                \"showface\": \"ccw\",                \"vs\": \"diffuselightmap\",                \"fs\": \"diffuselightmap\"            }        ],        \"quad\": [            {                \"showface\": \"ccw\",                \"vs\": \"post_quad\",                \"fs\": \"post_quad_depth\"            }        ],        \"base_depth\": [            {                \"showface\": \"ccw\",                \"vs\": \"post_depth\",                \"fs\": \"post_depth\"            }        ]    }}","diffuse_bothside.shader.json":"{    \"layer\": \"geometry\",    \"properties\": [        \"_MainTex('MainTex',Texture)='white'{}\",        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\"    ],    \"passes\": {        \"base\": [            {                \"showface\": \"all\",                \"vs\": \"diffuse\",                \"fs\": \"diffuse\",                \"zwrite\":\"on\",                \"ztest\":\"lequal\"            }        ],        \"skin\": [            {                \"showface\": \"all\",                \"vs\": \"bone_eff\",                \"fs\": \"diffuse\"            }        ],        \"lightmap\": [            {                \"showface\": \"all\",                \"vs\": \"diffuselightmap\",                \"fs\": \"diffuselightmap\"            }        ],        \"quad\": [            {                \"showface\": \"all\",                \"vs\": \"post_quad\",                \"fs\": \"post_quad_depth\"            }        ],        \"base_depth\": [            {                \"showface\": \"all\",                \"vs\": \"post_depth\",                \"fs\": \"post_depth\"            }        ]    }}","colorwithborder.shader.json":"{    \"layer\": \"transparent\",    \"passes\": {        \"base\": [            {                \"showface\": \"all\",                \"vs\": \"color\",                \"fs\": \"color\"            },            {                \"vs\": \"color\",                \"fs\": \"white\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}","white.fs.glsl":"void main() {    gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);}","line.vs.glsl":"attribute vec4 _glesVertex;   attribute vec4 _glesColor;                 uniform highp mat4 glstate_matrix_mvp;      varying lowp vec4 xlv_COLOR;                 void main()                                     {                                                   highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;                               tmpvar_1.xyz = _glesVertex.xyz;                 xlv_COLOR = _glesColor;                         gl_Position = (glstate_matrix_mvp * tmpvar_1);  }","line.fs.glsl":"varying lowp vec4 xlv_COLOR;        void main() {    gl_FragData[0] = xlv_COLOR;}","line.shader.json":"{    \"layer\": \"common\",    \"passes\": {        \"base\": [            {                \"showface\": \"all\",                \"vs\": \"line\",                \"fs\": \"line\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}","materialcolor.vs.glsl":"attribute vec4 _glesVertex;   uniform vec4 _Color;                      uniform highp mat4 glstate_matrix_mvp;      varying lowp vec4 xlv_COLOR;                void main()                                     {                                                   highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;                               tmpvar_1.xyz = _glesVertex.xyz;                 xlv_COLOR = _Color;                         gl_Position = (glstate_matrix_mvp * tmpvar_1);  }","materialcolor.fs.glsl":"varying lowp vec4 xlv_COLOR;          void main() {    gl_FragColor = xlv_COLOR;}","materialcolor.shader.json":"{    \"layer\": \"overlay\",    \"passes\": {        \"base\": [            {                \"showface\": \"all\",                \"vs\": \"materialcolor\",                \"fs\": \"materialcolor\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}","transparent.vs.glsl":"attribute vec4 _glesVertex;attribute vec4 _glesMultiTexCoord0;uniform highp mat4 glstate_matrix_mvp;varying highp vec2 xlv_TEXCOORD0;void main(){    highp vec4 tmpvar_1;    tmpvar_1.w = 1.0;    tmpvar_1.xyz = _glesVertex.xyz;xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;    gl_Position = (glstate_matrix_mvp * tmpvar_1);}","transparent.fs.glsl":"uniform sampler2D _MainTex;                                                                                                varying highp vec2 xlv_TEXCOORD0;void main() {    lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);    gl_FragData[0] = tmpvar_3;}","transparent.shader.json":"{    \"layer\": \"transparent\",    \"passes\": {        \"base\": [            {                \"blendmode\":  \"blend\",                \"showface\": \"ccw\",                \"vs\": \"transparent\",                \"fs\": \"transparent\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}","diffuselightmap.vs.glsl":"attribute vec4 _glesVertex;attribute vec4 _glesMultiTexCoord0;attribute vec4 _glesMultiTexCoord1;uniform highp mat4 glstate_matrix_mvp;uniform highp vec4 glstate_lightmapOffset;uniform lowp float glstate_lightmapUV;varying highp vec2 xlv_TEXCOORD0;varying highp vec2 xlv_TEXCOORD1;void main(){    highp vec4 tmpvar_1;    tmpvar_1.w = 1.0;    tmpvar_1.xyz = _glesVertex.xyz;xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;    highp vec2 beforelightUV = _glesMultiTexCoord1.xy;    if(glstate_lightmapUV == 0.0)    {        beforelightUV = _glesMultiTexCoord0.xy;    }    highp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;    highp float v = 1.0 - ((1.0 - beforelightUV.y) * glstate_lightmapOffset.y + glstate_lightmapOffset.w);    xlv_TEXCOORD1 = vec2(u,v);    gl_Position = (glstate_matrix_mvp * tmpvar_1);}","diffuselightmap.fs.glsl":"uniform sampler2D _MainTex;uniform sampler2D _LightmapTex;uniform lowp float _AlphaCut;varying highp vec2 xlv_TEXCOORD0;varying highp vec2 xlv_TEXCOORD1;lowp vec3 decode_hdr(lowp vec4 data){    highp float power =pow( 2.0 ,data.a * 255.0 - 128.0);    return data.rgb * power * 2.0 ;}void main() {    lowp vec4 outColor = texture2D(_MainTex, xlv_TEXCOORD0);    if(outColor.a < _AlphaCut)        discard;    lowp vec4 lightmap = texture2D(_LightmapTex, xlv_TEXCOORD1);    outColor.xyz *= decode_hdr(lightmap);    gl_FragData[0] = outColor;}","particles_additive.shader.json":"{  \"layer\": \"transparent\",  \"queue\": 0,  \"passes\": {    \"base\": [      {        \"blendmode\": \"add\",        \"showface\": \"all\",        \"zwrite\": \"off\",        \"vs\": \"particles_transparent\",        \"fs\": \"particles_transparent\"      }    ],    \"shadowgen\": [],    \"bone\": [],    \"shadowuse\": []  }}","particles_additive_premultiply.shader.json":"{  \"layer\": \"transparent\",  \"queue\":  0,    \"passes\": {        \"base\": [          {            \"blendmode\":  \"addpremult\",            \"showface\": \"all\",            \"zwrite\": \"off\",            \"vs\": \"particles_transparent\",            \"fs\": \"particles_transparent\"          }        ],        \"shadowgen\": [],          \"bone\": [],        \"shadowuse\": []    }}","particles_blend.shader.json":"{  \"layer\": \"transparent\",  \"queue\":  0,    \"passes\": {        \"base\": [          {            \"blendmode\":\"blend\",            \"showface\": \"all\",            \"vs\": \"particles_transparent\",            \"fs\": \"particles_transparent\"          }        ],        \"shadowgen\": [],          \"bone\": [],        \"shadowuse\": []    }}","particles_blend_renderall.shader.json":"{  \"layer\": \"transparent\",  \"queue\":  0,    \"passes\": {        \"base\": [          {            \"blendmode\":\"blend\",            \"showface\": \"all\",\"zwrite\": \"off\",\"ztest\":\"off\",            \"vs\": \"particles_transparent\",            \"fs\": \"particles_transparent\"          }        ],        \"shadowgen\": [],          \"bone\": [],        \"shadowuse\": []    }}","particles_blend_premultiply.shader.json":"{  \"layer\": \"transparent\",  \"queue\":  0,    \"passes\": {        \"base\": [          {            \"blendmode\":\"blendpremult\",            \"showface\": \"all\",            \"vs\": \"particles_transparent\",            \"fs\": \"particles_transparent\"          }        ],        \"shadowgen\": [],          \"bone\": [],        \"shadowuse\": []    }}","particles_diffuse.shader.json":"{  \"layer\": \"common\",  \"queue\":  0,    \"passes\": {        \"base\": [          {            \"blendmode\":\"close\",            \"showface\": \"all\",            \"vs\": \"particles_diffuse\",            \"fs\": \"particles_diffuse\"          }        ],        \"shadowgen\": [],          \"bone\": [],        \"shadowuse\": []    }}","particles_diffuse.fs.glsl":"uniform sampler2D _MainTex;varying lowp vec4 xlv_COLOR;uniform lowp float _AlphaCut;varying highp vec2 xlv_TEXCOORD0;          void main() {    lowp vec4 outColor = texture2D(_MainTex, xlv_TEXCOORD0);    if(outColor.a < _AlphaCut)        discard;    lowp vec4 tmpvar_3 = xlv_COLOR * outColor;    gl_FragData[0] = tmpvar_3;}","particles_diffuse.vs.glsl":"attribute vec4 _glesVertex;attribute vec4 _glesMultiTexCoord0;   attribute vec4 _glesColor;                   uniform highp mat4 glstate_matrix_mvp;      varying lowp vec4 xlv_COLOR;varying highp vec2 xlv_TEXCOORD0;                void main()                                     {                                                   highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;    tmpvar_1.xyz = _glesVertex.xyz;                 xlv_COLOR = _glesColor;xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;                         gl_Position = (glstate_matrix_mvp * tmpvar_1);  }","particles_transparent.fs.glsl":"uniform sampler2D _MainTex;varying lowp vec4 xlv_COLOR;varying highp vec2 xlv_TEXCOORD0;          void main() {    lowp vec4 tmpvar_3 = xlv_COLOR*texture2D(_MainTex, xlv_TEXCOORD0);    gl_FragData[0] = tmpvar_3;}","particles_transparent.vs.glsl":"attribute vec4 _glesVertex;attribute vec4 _glesMultiTexCoord0;   attribute vec4 _glesColor;                   uniform highp mat4 glstate_matrix_mvp;      varying lowp vec4 xlv_COLOR;varying highp vec2 xlv_TEXCOORD0;                void main()                                     {                                                   highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;    tmpvar_1.xyz = _glesVertex.xyz;                 xlv_COLOR = _glesColor;xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;                         gl_Position = (glstate_matrix_mvp * tmpvar_1);  }","streamlight.shader.json":"{    \"layer\": \"geometry\",    \"properties\": [        \"_MainTex('MainTex',Texture)='white'{}\",        \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\",        \"_LightTex('Light',Texture) = 'black' {}\",        \"_LightColor('LightColor',Color) = (1,1,1,1)\",        \"_LightRate('LightRate',Range(0.0,1.0)) = 1.0\",\"_SpeedU('SpeedU',float) = 0.5\",\"_SpeedV('SpeedV',float) = 0.5\",\"_MaskTex('Mask',Texture) = 'white' {}\"    ],    \"passes\": {        \"base\": [            {                \"showface\": \"ccw\",                \"vs\": \"streamlight\",                \"fs\": \"streamlight\"            }        ],        \"skin\": [            {                \"showface\": \"ccw\",                \"vs\": \"streamlightbone_eff\",                \"fs\": \"streamlight\"            }        ]    }}","streamlight.fs.glsl":"uniform sampler2D _MainTex;uniform sampler2D _LightTex;uniform lowp vec4 _LightColor;uniform lowp float _LightRate;uniform sampler2D _MaskTex;uniform lowp float _AlphaCut;varying highp vec2 xlv_TEXCOORD0;varying highp vec2 _StreamLightUV;void main() {    lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);    if(tmpvar_3.a < _AlphaCut)        discard;    lowp vec4 light = texture2D(_LightTex, _StreamLightUV) * _LightColor * _LightRate;    lowp vec4 mask = texture2D(_MaskTex, xlv_TEXCOORD0);    light = min(light,mask);    tmpvar_3.rgb += light.rgb;        gl_FragData[0] = tmpvar_3;}","streamlight.vs.glsl":"attribute vec4 _glesVertex;attribute vec4 _glesMultiTexCoord0;uniform highp mat4 glstate_matrix_mvp;uniform highp float _SpeedU;uniform highp float _SpeedV;uniform highp float glstate_timer;uniform highp vec4 _LightTex_ST;varying highp vec2 xlv_TEXCOORD0;varying highp vec2 _StreamLightUV;void main(){    highp vec4 tmpvar_1;    tmpvar_1.w = 1.0;    tmpvar_1.xyz = _glesVertex.xyz;xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;    highp vec2 _speed;    _speed = vec2(_SpeedU,_SpeedV);    _StreamLightUV = (_glesMultiTexCoord0.xy * _LightTex_ST.xy + _LightTex_ST.zw)  + _speed * glstate_timer;    gl_Position = (glstate_matrix_mvp * tmpvar_1);}","bone_eff.vs.glsl":"attribute vec4 _glesVertex;   attribute vec4 _glesBlendIndex4;attribute vec4 _glesBlendWeight4;attribute vec4 _glesMultiTexCoord0;uniform highp mat4 glstate_matrix_mvp;uniform highp vec4 glstate_vec4_bones[120];varying highp vec2 xlv_TEXCOORD0;mat4 buildMat4(int index){vec4 quat = glstate_vec4_bones[index * 2 + 0];vec4 translation = glstate_vec4_bones[index * 2 + 1];float xy2 = 2.0 * quat.x * quat.y;float xz2 = 2.0 * quat.x * quat.z;float xw2 = 2.0 * quat.x * quat.w;float yz2 = 2.0 * quat.y * quat.z;float yw2 = 2.0 * quat.y * quat.w;float zw2 = 2.0 * quat.z * quat.w;float xx = quat.x * quat.x;float yy = quat.y * quat.y;float zz = quat.z * quat.z;float ww = quat.w * quat.w;mat4 matrix = mat4(xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,translation.x, translation.y, translation.z, 1);return matrix;}void main(){                                                   highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;                               tmpvar_1.xyz = _glesVertex.xyz;      int i = int(_glesBlendIndex4.x);      int i2 =int(_glesBlendIndex4.y);int i3 =int(_glesBlendIndex4.z);int i4 =int(_glesBlendIndex4.w);    mat4 mat = buildMat4(i)*_glesBlendWeight4.x  + buildMat4(i2)*_glesBlendWeight4.y  + buildMat4(i3)*_glesBlendWeight4.z  + buildMat4(i4)*_glesBlendWeight4.w;     gl_Position = (glstate_matrix_mvp * mat)* tmpvar_1;xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;}","streamlightbone_eff.vs.glsl":"attribute vec4 _glesVertex;   attribute vec4 _glesBlendIndex4;attribute vec4 _glesBlendWeight4;attribute vec4 _glesMultiTexCoord0;uniform highp mat4 glstate_matrix_mvp;uniform highp vec4 glstate_vec4_bones[120];uniform highp float _SpeedU;uniform highp float _SpeedV;uniform highp float glstate_timer;uniform highp vec4 _LightTex_ST;varying highp vec2 xlv_TEXCOORD0;varying highp vec2 _StreamLightUV;mat4 buildMat4(int index){vec4 quat = glstate_vec4_bones[index * 2 + 0];vec4 translation = glstate_vec4_bones[index * 2 + 1];float xy2 = 2.0 * quat.x * quat.y;float xz2 = 2.0 * quat.x * quat.z;float xw2 = 2.0 * quat.x * quat.w;float yz2 = 2.0 * quat.y * quat.z;float yw2 = 2.0 * quat.y * quat.w;float zw2 = 2.0 * quat.z * quat.w;float xx = quat.x * quat.x;float yy = quat.y * quat.y;float zz = quat.z * quat.z;float ww = quat.w * quat.w;mat4 matrix = mat4(xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,translation.x, translation.y, translation.z, 1);return matrix;}void main(){                                                   highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;                               tmpvar_1.xyz = _glesVertex.xyz;      int i = int(_glesBlendIndex4.x);      int i2 =int(_glesBlendIndex4.y);int i3 =int(_glesBlendIndex4.z);int i4 =int(_glesBlendIndex4.w);    mat4 mat = buildMat4(i)*_glesBlendWeight4.x  + buildMat4(i2)*_glesBlendWeight4.y  + buildMat4(i3)*_glesBlendWeight4.z  + buildMat4(i4)*_glesBlendWeight4.w;     gl_Position = (glstate_matrix_mvp * mat)* tmpvar_1;xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;    highp vec2 _speed;    _speed = vec2(_SpeedU,_SpeedV);    _StreamLightUV = (_glesMultiTexCoord0.xy * _LightTex_ST.xy + _LightTex_ST.zw)  + _speed * glstate_timer;}","fakepbr.shader.json":"{    \"layer\": \"geometry\",    \"passes\": {        \"base\": [            {                \"showface\": \"all\",                \"vs\": \"fakepbr\",                \"fs\": \"fakepbr\",                \"zwrite\":\"on\",                \"ztest\":\"lequal\"            }        ],        \"skin\": [],        \"lightmap\": [],        \"quad\": [],        \"base_depth\": []    }}","fakepbr.fs.glsl":"uniform sampler2D _albedo;uniform sampler2D _normal;uniform sampler2D _gloss;uniform sampler2D _specular;uniform sampler2D _opacity;uniform lowp float _cutvalue;uniform highp vec4 glstate_eyepos;uniform highp vec4 glstate_vec4_lightposs[8];uniform highp vec4 glstate_vec4_lightdirs[8];uniform highp float glstate_float_spotangelcoss[8];varying highp vec2 xlv_TEXCOORD0;varying highp vec3 posWorld;varying highp vec3 normalDir;varying highp vec3 tangentDir;varying highp vec3 bitangentDir;    //calcDiffuse 计算漫反射强度函数//统一三种光源的传参方式，在函数内混合，方便就不高效//只需要方向光时另写//N 世界空间法线//worldpos 世界空间pos//lightPos 光源位置,w=0 表示方向光//lightDir 光源方向，W=0 表示点光源，和楼上的w一起为1 表示 探照灯 spot//cosspot cos(a) a为spot的半径 a取值0到90度，算好cos再传进来highp float calcDiffuse(highp vec3 N,highp vec3 worldpos,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot){    //求入射角，点光源&聚光灯    highp vec3 L = normalize(lightPos.xyz - worldpos);     //求张角 聚光灯 也是方向光入射角    highp vec3 L2 = -lightDir.xyz;    highp float dotSpot = dot(L,L2);    //漫反射强度    highp float diffuse =clamp(dot(N.xyz,L.xyz),0.0,1.0);     highp float diffuseD =clamp(dot(N.xyz,L2.xyz),0.0,1.0);     //pos.w 和 dir.w 至少有一个1，刚好组合出三种光源    diffuse= mix(diffuse,diffuse*smoothstep(cosspot,1.0,dotSpot),lightDir.w);    diffuse= mix(diffuseD,diffuse,lightPos.w);    return diffuse;}highp float calcSpec(highp vec3 N,highp vec3 worldpos,highp vec3 eyedir,highp vec4 lightPos,highp vec4 lightDir,highp float cosspot){    highp float shininess=30.0;//高光系数    highp vec3 L = normalize(lightPos.xyz - worldpos);     highp vec3 L2 = -lightDir.xyz;    highp float dotSpot = dot(L,L2);    //三种光源 计算出三个 高光强度，然后根据条件选出一个    highp float spec =pow(clamp(dot(N,normalize(L+eyedir)),0.0,1.0), shininess);    highp float specD =pow(clamp(dot(N,normalize(L2+eyedir)),0.0,1.0), shininess);    spec= mix(spec,spec*smoothstep(cosspot,1.0,dotSpot),lightDir.w);    spec= mix(specD,spec,lightPos.w);    //highp  float specularLight = pow(clamp(dot(N,H),0.0,1.0), shininess);    return spec;}void main() {    highp float _opacity_var = texture2D(_opacity,xlv_TEXCOORD0).g;    if(_opacity_var<0.5)  discard;    //clip(step(_cutvalue,_opacity_var) - 0.5);    highp float diff=0.0;    highp float specularPower=0.0;    highp mat3 TBNmat = mat3( tangentDir, bitangentDir, normalDir);    highp vec3 eyeDir =glstate_eyepos.xyz-posWorld;    for(int i=0;i<8;i++)    {        highp vec3 normal;// = TBN*N;normal =  texture2D(_normal, xlv_TEXCOORD0).xyz *2.0 -1.0;        normal =normalize(normal);normal =TBNmat*(normal);                diff+=calcDiffuse(normal,posWorld,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i]);        specularPower+=calcSpec(normal,posWorld,eyeDir,glstate_vec4_lightposs[i],glstate_vec4_lightdirs[i],glstate_float_spotangelcoss[i]);    }    //gloss //假的光洁度，只影响了高光    mediump float Pi = 3.141592654;    mediump float InvPi = 0.31830988618;    mediump vec4 _gloss_var = texture2D(_gloss,xlv_TEXCOORD0);    mediump float gloss = _gloss_var.r;    mediump float specPow = exp2( gloss * 10.0+1.0);    //spec //受到高光贴图的过滤    highp float normTerm = (specPow + 8.0 ) / (8.0 * Pi);    highp vec4 specularColor = texture2D(_specular,xlv_TEXCOORD0);    highp float specularMonochrome = max( max(specularColor.r, specularColor.g), specularColor.b);    specularColor*=pow(specularPower,specPow)*normTerm;    //diffuse    lowp vec4 diffuseColor= texture2D(_albedo, xlv_TEXCOORD0);//光照颜色    diffuseColor *= 1.0-specularMonochrome;//均衡能量    mediump vec3 directDiffuse = vec3(diff,diff,diff);//直接光照    mediump vec3 indirectDiffuse = vec3(0.3,0.3,0.3);//间接光照    lowp vec4 col_1;        mediump vec4 prev_2;    lowp vec4 final = (diffuseColor*vec4(directDiffuse+indirectDiffuse,1.0)  + specularColor);    gl_FragData[0] = final;}","fakepbr.vs.glsl":"attribute vec4 _glesVertex;attribute vec2 _glesMultiTexCoord0;attribute vec3 _glesTangent;attribute vec3 _glesNormal;uniform highp mat4 glstate_matrix_model;uniform highp mat4 glstate_matrix_mvp;varying highp vec2 xlv_TEXCOORD0;varying highp vec3 posWorld;varying highp vec3 normalDir;varying highp vec3 tangentDir;varying highp vec3 bitangentDir;void main(){xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;    posWorld = (glstate_matrix_model * _glesVertex).xyz;    highp mat3 normalmat = mat3(glstate_matrix_model);    normalDir = normalize(normalmat*_glesNormal);    tangentDir = normalize(normalmat*_glesTangent);    bitangentDir = cross(normalDir,tangentDir);    gl_Position = (glstate_matrix_mvp * _glesVertex);}","asi.shader.json":"{    \"layer\": \"geometry\",    \"passes\": {        \"base\": [            {                \"showface\": \"ccw\",                \"vs\": \"asi\",                \"fs\": \"asi\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}","asi.fs.glsl":"uniform sampler2D _base;  uniform sampler2D _asm;uniform sampler2D _streamlight;uniform highp float _LightRate;uniform highp vec4 _LightColor;uniform highp float _emitPow;uniform highp float _diffuse;uniform highp float _Cutoff;uniform highp vec4 glstate_vec4_lightposs[8];uniform highp vec4 glstate_vec4_lightdirs[8];uniform highp float glstate_float_spotangelcoss[8];uniform highp float glstate_lightcount;varying highp vec2 _base_uv;varying highp vec2 _asm_uv;varying highp vec2 _light_uv;void main() {    if(texture2D(_asm,_asm_uv).r<_Cutoff)    {        discard;    }    highp vec3 baseTex=texture2D(_base,_base_uv).rgb;    highp float asi_g=texture2D(_asm,_asm_uv).g;    highp vec3 d_color=baseTex*_diffuse;    lowp vec3 e_color=baseTex*_emitPow*asi_g;        lowp vec3 light = texture2D(_streamlight, _light_uv).rgb* _LightRate*_LightColor.xyz;    lowp float maskv=texture2D(_asm,_asm_uv).b;    lowp vec3 mask = vec3(maskv,maskv,maskv);    light = min(light,mask);    gl_FragData[0] = vec4(d_color+e_color+light,1.0);}","asi.vs.glsl":"attribute vec3 _glesVertex;attribute vec2 _glesMultiTexCoord0;attribute vec3 _glesNormal;uniform highp vec4 glstate_eyepos;uniform highp mat4 glstate_matrix_mvp;uniform highp mat4 glstate_matrix_model;uniform highp vec4 _base_ST;uniform highp vec4 _asm_ST;uniform highp vec4 _streamlight_ST;uniform highp float _speedu;uniform highp float _speedv;uniform highp float glstate_timer;varying highp vec2 _base_uv;varying highp vec2 _asm_uv;varying highp vec2 _light_uv;void main(){_base_uv = _glesMultiTexCoord0.xy * _base_ST.xy + _base_ST.zw;_asm_uv = _glesMultiTexCoord0.xy * _asm_ST.xy + _asm_ST.zw;highp vec2 _speed;    _speed = vec2(_speedu,_speedv);    _light_uv = (_glesMultiTexCoord0.xy * _streamlight_ST.xy + _streamlight_ST.zw)  + _speed * glstate_timer;    //求世界空间法线    // highp mat3 normalmat = mat3(glstate_matrix_model);    // Normalinworld =normalize(normalmat*_glesNormal);    // worldpos =(glstate_matrix_model * vec4(_glesVertex.xyz, 1.0)).xyz;// eyedir = glstate_eyepos.xyz - worldpos;gl_Position = (glstate_matrix_mvp * vec4(_glesVertex.xyz, 1.0));}","sample_uvsprite.shader.json":"{  \"layer\": \"transparent\",  \"properties\": [    \"_MainTex('MainTex',Texture)='white'{}\",    \"_MainTex_ST('MainTex_ST',Vector) = (1,1,1,1)\"  ],  \"passes\": {    \"base\": [      {        \"showface\": \"ccw\",        \"vs\": \"sample_uvsprite\",        \"fs\": \"sample_uvsprite\"      }    ],    \"shadowgen\": [],    \"bone\": [],    \"shadowuse\": []  }}","sample_uvsprite.fs.glsl":"uniform sampler2D _MainTex;                                                 varying lowp vec4 xlv_COLOR;                                                 varying highp vec2 xlv_TEXCOORD0;   void main() {    lowp vec4 tmpvar_3= (xlv_COLOR *  texture2D(_MainTex, xlv_TEXCOORD0));    gl_FragData[0] = tmpvar_3;}","sample_uvsprite.vs.glsl":"attribute vec4 _glesVertex;   attribute vec4 _glesNormal;   attribute vec4 _glesColor;                  attribute vec4 _glesMultiTexCoord0;        uniform highp mat4 glstate_matrix_mvp;   varying lowp vec4 xlv_COLOR;                varying highp vec2 xlv_TEXCOORD0;   uniform highp vec4 _MainTex_ST;       void main()                                     {                                                   highp vec4 tmpvar_1;                            tmpvar_1.w = 1.0;                               tmpvar_1.xyz = _glesVertex.xyz;                 xlv_COLOR = _glesColor;                         xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;    gl_Position = (glstate_matrix_mvp * tmpvar_1);  }","selftimer_uvroll.shader.json":"{    \"layer\": \"geometry\",    \"properties\": [],    \"passes\": {        \"base\": [            {                \"showface\": \"ccw\",                \"vs\": \"selftimer_uvroll\",                \"fs\": \"selftimer_uvroll\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}","selftimer_uvroll.fs.glsl":"uniform sampler2D _MainTex;uniform lowp float _AlphaCut;varying highp vec2 xlv_TEXCOORD0;void main() {    lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);    if(tmpvar_3.a < _AlphaCut)        discard;    gl_FragData[0] = tmpvar_3;}","selftimer_uvroll.vs.glsl":"attribute vec4 _glesVertex;   attribute vec4 _glesMultiTexCoord0;      uniform highp mat4 glstate_matrix_mvp;uniform highp float self_timer;uniform highp float _SpeedU;uniform highp float _SpeedV;uniform highp vec4 _MainTex_ST;varying highp vec2 xlv_TEXCOORD0;void main()                                     {                                                   highp vec4 tmpvar_1 = vec4(_glesVertex.xyz,1);    highp vec2 _speed = vec2(_SpeedU,_SpeedV);    xlv_TEXCOORD0 = (_glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw)  + _speed * self_timer;    gl_Position = (glstate_matrix_mvp * tmpvar_1);  }","transparent_bothside.shader.json":"{    \"layer\": \"transparent\",    \"passes\": {        \"base\": [            {                \"blendmode\":  \"blend\",                \"showface\": \"all\",                \"vs\": \"transparent\",                \"fs\": \"transparent\"            }        ],        \"shadowgen\": [],        \"bone\": [],        \"shadowuse\": []    }}"}