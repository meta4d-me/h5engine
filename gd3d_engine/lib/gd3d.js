var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var NotifyType;
        (function (NotifyType) {
            NotifyType[NotifyType["AddChild"] = 0] = "AddChild";
            NotifyType[NotifyType["RemoveChild"] = 1] = "RemoveChild";
            NotifyType[NotifyType["ChangeVisible"] = 2] = "ChangeVisible";
            NotifyType[NotifyType["AddCamera"] = 3] = "AddCamera";
            NotifyType[NotifyType["AddCanvasRender"] = 4] = "AddCanvasRender";
        })(NotifyType = framework.NotifyType || (framework.NotifyType = {}));
        var application = (function () {
            function application() {
                this.limitFrame = true;
                this.version = "v0.0.1";
                this.build = "b000009";
                this.beStepNumber = 0;
                this._userCode = [];
                this._userCodeNew = [];
                this._editorCode = [];
                this._editorCodeNew = [];
                this._bePlay = false;
                this.be2dstate = false;
                this.curcameraindex = -1;
                this._bePause = false;
                this._beStepForward = false;
                window["gd3d_app"] = this;
            }
            application.prototype.start = function (div) {
                console.log("version: " + this.version + "  build: " + this.build);
                framework.sceneMgr.app = this;
                this.timeScale = 1;
                this.container = div;
                var canvas = document.createElement("canvas");
                canvas.className = "full";
                canvas.style.position = "absolute";
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                canvas.style.backgroundColor = "#1e1e1e";
                canvas.setAttribute("tabindex", "1");
                div.appendChild(canvas);
                this.webgl = canvas.getContext('webgl') ||
                    canvas.getContext("experimental-webgl");
                gd3d.render.webglkit.initConst(this.webgl);
                this.initAssetMgr();
                this.initInputMgr();
                this.initScene();
                this.beginTimer = this.lastTimer = Date.now() / 1000;
                this.loop();
                gd3d.io.referenceInfo.regDefaultType();
                var initovercallback = window["initovercallback"];
                if (initovercallback != null) {
                    initovercallback(this);
                }
            };
            application.prototype.markNotify = function (trans, type) {
                this.doNotify(trans, type);
            };
            application.prototype.doNotify = function (trans, type) {
                if (trans == null)
                    return;
                if (!this.checkFilter(trans))
                    return;
                if (this.notify)
                    this.notify.notify(trans, type);
                if (trans.children != null) {
                    for (var index in trans.children) {
                        this.doNotify(trans.children[index], type);
                    }
                }
            };
            application.prototype.checkFilter = function (trans) {
                if (trans instanceof gd3d.framework.transform) {
                    if (trans.gameObject.hideFlags & gd3d.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                if (trans instanceof gd3d.framework.transform2D) {
                    if (trans.hideFlags & gd3d.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                return true;
            };
            application.prototype.showFps = function () {
                if (this.stats == null) {
                    this.stats = new Stats.Stats();
                    this.stats.container.style.position = 'absolute';
                    this.stats.container.style.left = '0px';
                    this.stats.container.style.top = '0px';
                    this.container.appendChild(this.stats.container);
                }
                else {
                    this.container.appendChild(this.stats.container);
                }
            };
            application.prototype.closeFps = function () {
                if (this.stats != null) {
                    this.container.removeChild(this.stats.container);
                }
            };
            application.prototype.update = function (delta) {
                if (this.webgl.canvas.clientWidth != this.webgl.canvas.width || this.webgl.canvas.clientHeight != this.webgl.canvas.height) {
                    this.webgl.canvas.width = this.webgl.canvas.clientWidth;
                    this.webgl.canvas.height = this.webgl.canvas.clientHeight;
                    console.log("canvas resize.");
                }
                this.width = this.webgl.canvas.width;
                this.height = this.webgl.canvas.height;
                if (this.bePlay) {
                    if (this.bePause) {
                        if (this.beStepForward && this.beStepNumber > 0) {
                            this.beStepNumber--;
                            this.updateUserCode(delta);
                        }
                    }
                    else {
                        this.updateUserCode(delta);
                    }
                }
                this.updateEditorCode(delta);
                if (this._scene != null) {
                    this._scene.update(delta);
                }
            };
            application.prototype.getTotalTime = function () {
                return this.totalTime;
            };
            Object.defineProperty(application.prototype, "deltaTime", {
                get: function () {
                    return this._deltaTime * this.timeScale;
                },
                enumerable: true,
                configurable: true
            });
            application.prototype.loop = function () {
                var now = Date.now() / 1000;
                this._deltaTime = now - this.lastTimer;
                this.totalTime = now - this.beginTimer;
                this.update(this.deltaTime);
                if (this.stats != null)
                    this.stats.update();
                this.lastTimer = now;
                if (this.limitFrame) {
                    requestAnimationFrame(this.loop.bind(this));
                }
                else {
                    setTimeout(this.loop.bind(this), 1);
                }
            };
            application.prototype.initScene = function () {
                if (this._scene == null) {
                    this._scene = new framework.scene(this);
                    framework.sceneMgr.scene = this._scene;
                }
            };
            application.prototype.getScene = function () {
                return this._scene;
            };
            application.prototype.initAssetMgr = function () {
                if (this._assetmgr == null) {
                    this._assetmgr = new framework.assetMgr(this);
                    this._assetmgr.initDefAsset();
                }
            };
            application.prototype.getAssetMgr = function () {
                return this._assetmgr;
            };
            application.prototype.initInputMgr = function () {
                if (this._inputmgr == null) {
                    this._inputmgr = new framework.inputMgr(this);
                }
            };
            application.prototype.getInputMgr = function () {
                return this._inputmgr;
            };
            Object.defineProperty(application.prototype, "bePlay", {
                get: function () {
                    return this._bePlay;
                },
                set: function (value) {
                    this._bePlay = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "bePause", {
                get: function () {
                    return this._bePause;
                },
                set: function (value) {
                    this._bePause = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "beStepForward", {
                get: function () {
                    return this._beStepForward;
                },
                set: function (value) {
                    this._beStepForward = value;
                },
                enumerable: true,
                configurable: true
            });
            application.prototype.updateUserCode = function (delta) {
                for (var i = this._userCodeNew.length - 1; i >= 0; i--) {
                    var c = this._userCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._userCode.push(c);
                        this._userCodeNew.splice(i, 1);
                    }
                }
                var closeindex = -1;
                for (var i = 0; i < this._userCode.length; i++) {
                    var c = this._userCode[i];
                    if (c.isClosed() == false) {
                        c.onUpdate(delta);
                    }
                    else if (closeindex < 0) {
                        closeindex = i;
                    }
                }
                if (closeindex >= 0) {
                    this._userCode.splice(closeindex, 1);
                }
            };
            application.prototype.updateEditorCode = function (delta) {
                for (var i = this._editorCodeNew.length - 1; i >= 0; i--) {
                    var c = this._editorCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._editorCode.push(c);
                        this._editorCodeNew.splice(i, 1);
                    }
                }
                var closeindex = -1;
                for (var i = this._editorCode.length - 1; i >= 0; i--) {
                    var c = this._editorCode[i];
                    if (c.isClosed()) {
                        this._editorCode.splice(i, 1);
                    }
                    else {
                        c.onUpdate(delta);
                    }
                }
            };
            application.prototype.addUserCodeDirect = function (program) {
                this._userCodeNew.push(program);
            };
            application.prototype.addUserCode = function (classname) {
                var prototype = gd3d.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = gd3d.reflect.createInstance(prototype, { "usercode": "1" });
                    this.addUserCodeDirect(code);
                }
            };
            application.prototype.addEditorCode = function (classname) {
                var prototype = gd3d.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = gd3d.reflect.createInstance(prototype, { "editorcode": "1" });
                    this.addEditorCodeDirect(code);
                }
            };
            application.prototype.addEditorCodeDirect = function (program) {
                this._editorCodeNew.push(program);
            };
            return application;
        }());
        framework.application = application;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var sceneMgr = (function () {
            function sceneMgr() {
            }
            Object.defineProperty(sceneMgr, "ins", {
                get: function () {
                    if (sceneMgr._ins == null)
                        sceneMgr._ins = new sceneMgr();
                    return sceneMgr._ins;
                },
                enumerable: true,
                configurable: true
            });
            return sceneMgr;
        }());
        framework.sceneMgr = sceneMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var Stats;
(function (Stats_1) {
    var Stats = (function () {
        function Stats() {
            var _this = this;
            this.mode = 0;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', function (event) {
                event.preventDefault();
                _this.showPanel(++_this.mode % _this.container.children.length);
            }, false);
            this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.frames = 0;
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            if (self.performance && self.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        Stats.prototype.update = function () {
            this.beginTime = this.end();
        };
        Stats.prototype.showPanel = function (id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        };
        Stats.prototype.addPanel = function (panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        };
        Stats.prototype.begin = function () {
            this.beginTime = (performance || Date).now();
        };
        Stats.prototype.end = function () {
            this.frames++;
            var time = (performance || Date).now();
            this.msPanel.update(time - this.beginTime, 200);
            if (time > this.prevTime + 1000) {
                this.fpsPanel.update((this.frames * 1000) / (time - this.prevTime), 100);
                this.prevTime = time;
                this.frames = 0;
                if (this.memPanel) {
                    var memory = performance["memory"];
                    this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
                }
            }
            return time;
        };
        return Stats;
    }());
    Stats_1.Stats = Stats;
    var Panel = (function () {
        function Panel(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        Panel.prototype.update = function (value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        };
        return Panel;
    }());
})(Stats || (Stats = {}));
var gd3d;
(function (gd3d) {
    var reflect;
    (function (reflect) {
        function regType(target, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"]["class"] == undefined)
                target["__gdmeta__"]["class"] = {};
            var name = target["constructor"]["name"];
            if (name == null) {
                var fs = target["constructor"].toString();
                var i = fs.indexOf("(");
                name = fs.substring(9, i);
            }
            target["__gdmeta__"]["class"]["typename"] = name;
            if (document["__gdmeta__"] == null)
                document["__gdmeta__"] = {};
            document["__gdmeta__"][name] = target;
            if (target["__gdmeta__"]["class"]["custom"] == null)
                target["__gdmeta__"]["class"]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"]["class"]["custom"][key] = customInfo[key];
                }
            }
        }
        function regFunc(target, funcname, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"][funcname] == null)
                target["__gdmeta__"][funcname] = {};
            target["__gdmeta__"][funcname]["type"] = "function";
            var tp = Reflect.getMetadata("design:paramtypes", target, funcname);
            var tr = Reflect.getMetadata("design:returntype", target, funcname);
            target["__gdmeta__"][funcname]["paramtypes"] = [];
            for (var i in tp) {
                target["__gdmeta__"][funcname]["paramtypes"][i] = tp[i]["name"];
            }
            target["__gdmeta__"][funcname]["returntype"] = tr == null ? null : tr["name"];
            if (target["__gdmeta__"][funcname]["custom"] == null)
                target["__gdmeta__"][funcname]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][funcname]["custom"][key] = customInfo[key];
                }
            }
        }
        function regField(target, fieldName, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"][fieldName] == null)
                target["__gdmeta__"][fieldName] = {};
            target["__gdmeta__"][fieldName]["type"] = "field";
            if (target["__gdmeta__"][fieldName]["custom"] == null)
                target["__gdmeta__"][fieldName]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][fieldName]["custom"][key] = customInfo[key];
                }
            }
        }
        function getPrototypes() {
            return document["__gdmeta__"];
        }
        reflect.getPrototypes = getPrototypes;
        function getPrototype(name) {
            return document["__gdmeta__"][name];
        }
        reflect.getPrototype = getPrototype;
        function createInstance(prototype, matchTag) {
            if (matchTag == null) {
                var ctor = prototype.constructor;
                return new ctor();
            }
            else {
                var info = prototype["__gdmeta__"]["class"]["custom"];
                for (var key in matchTag) {
                    if (info[key] != matchTag[key]) {
                        console.warn("createInstance:" + name + ". tag do not match.");
                        return null;
                    }
                }
                var ctor = prototype.constructor;
                return new ctor();
            }
        }
        reflect.createInstance = createInstance;
        function getClassName(prototype) {
            var info = prototype["__gdmeta__"]["class"]["typename"];
            return info;
        }
        reflect.getClassName = getClassName;
        function getClassTag(prototype, tag) {
            var info = prototype["__gdmeta__"]["class"]["custom"];
            return info[tag];
        }
        reflect.getClassTag = getClassTag;
        function getMeta(prototype) {
            var meta = prototype.__gdmeta__;
            return meta;
        }
        reflect.getMeta = getMeta;
        function attr_Class(constructorObj) {
            regType(constructorObj.prototype, null);
        }
        reflect.attr_Class = attr_Class;
        function attr_Func(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey, value) {
                regFunc(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Func = attr_Func;
        function attr_Field(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey) {
                regField(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Field = attr_Field;
        function userCode(constructorObj) {
            regType(constructorObj.prototype, { "usercode": "1" });
        }
        reflect.userCode = userCode;
        function editorCode(constructorObj) {
            regType(constructorObj.prototype, { "editorcode": "1" });
        }
        reflect.editorCode = editorCode;
        function selfClone(constructorObj) {
            regType(constructorObj.prototype, { "selfclone": "1" });
        }
        reflect.selfClone = selfClone;
        function nodeComponent(constructorObj) {
            regType(constructorObj.prototype, { "nodecomp": "1" });
        }
        reflect.nodeComponent = nodeComponent;
        function nodeComponentInspector(constructorObj) {
            regType(constructorObj.prototype, { "nodecomp_inspector": "1" });
        }
        reflect.nodeComponentInspector = nodeComponentInspector;
        function nodeRender(constructorObj) {
            regType(constructorObj.prototype, { "renderer": "1" });
        }
        reflect.nodeRender = nodeRender;
        function nodeCamera(constructorObj) {
            regType(constructorObj.prototype, { "camera": "1" });
        }
        reflect.nodeCamera = nodeCamera;
        function nodeLight(constructorObj) {
            regType(constructorObj.prototype, { "light": "1" });
        }
        reflect.nodeLight = nodeLight;
        function nodeBoxCollider(constructorObj) {
            regType(constructorObj.prototype, { "boxcollider": "1" });
        }
        reflect.nodeBoxCollider = nodeBoxCollider;
        function nodeSphereCollider(constructorObj) {
            regType(constructorObj.prototype, { "spherecollider": "1" });
        }
        reflect.nodeSphereCollider = nodeSphereCollider;
        function nodeEffectBatcher(constructorObj) {
            regType(constructorObj.prototype, { "effectbatcher": "1" });
        }
        reflect.nodeEffectBatcher = nodeEffectBatcher;
        function nodeMeshCollider(constructorObj) {
            regType(constructorObj.prototype, { "meshcollider": "1" });
        }
        reflect.nodeMeshCollider = nodeMeshCollider;
        function nodeCanvasRendererCollider(constructorObj) {
            regType(constructorObj.prototype, { "canvasRenderer": "1" });
        }
        reflect.nodeCanvasRendererCollider = nodeCanvasRendererCollider;
        function node2DComponent(constructorObj) {
            regType(constructorObj.prototype, { "2dcomp": "1" });
        }
        reflect.node2DComponent = node2DComponent;
        function pluginMenuItem(constructorObj) {
            regType(constructorObj.prototype, { "plugin_menuitem": "1" });
        }
        reflect.pluginMenuItem = pluginMenuItem;
        function pluginWindow(constructorObj) {
            regType(constructorObj.prototype, { "plugin_window": "1" });
        }
        reflect.pluginWindow = pluginWindow;
        function pluginExt(constructorObj) {
            regType(constructorObj.prototype, { "plugin_ext": "1" });
        }
        reflect.pluginExt = pluginExt;
        function compValue(integer, defvalue, min, max) {
            if (integer === void 0) { integer = false; }
            if (defvalue === void 0) { defvalue = 0; }
            if (min === void 0) { min = Number.MIN_VALUE; }
            if (max === void 0) { max = Number.MAX_VALUE; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "compValue": "1",
                    "integer": integer ? "1" : "0",
                    "defvalue": defvalue.toString(),
                    "min": min.toString(),
                    "max": max.toString(),
                });
            };
        }
        reflect.compValue = compValue;
        function compCall(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey, value) {
                regFunc(target, propertyKey, { "compcall": "1" });
                regFunc(target, propertyKey, customInfo);
            };
        }
        reflect.compCall = compCall;
        function SerializeType(constructorObj) {
            regType(constructorObj.prototype, { "SerializeType": "1" });
        }
        reflect.SerializeType = SerializeType;
        function Field(valueType, defaultValue, enumRealType) {
            if (defaultValue === void 0) { defaultValue = undefined; }
            if (enumRealType === void 0) { enumRealType = undefined; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "SerializeField": true,
                    "valueType": valueType
                });
                if (defaultValue == undefined) {
                }
                else {
                    regField(target, propertyKey, {
                        "defaultValue": defaultValue
                    });
                }
            };
        }
        reflect.Field = Field;
        function UIComment(comment) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "UIComment": comment
                });
            };
        }
        reflect.UIComment = UIComment;
        var FieldUIStyle;
        (function (FieldUIStyle) {
            FieldUIStyle[FieldUIStyle["None"] = 0] = "None";
            FieldUIStyle[FieldUIStyle["RangeFloat"] = 1] = "RangeFloat";
            FieldUIStyle[FieldUIStyle["MultiLineString"] = 2] = "MultiLineString";
            FieldUIStyle[FieldUIStyle["Enum"] = 3] = "Enum";
        })(FieldUIStyle = reflect.FieldUIStyle || (reflect.FieldUIStyle = {}));
        function UIStyle(style, min, max, defvalue) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "FieldUIStyle": style,
                    "min": min ? min : null,
                    "max": max ? max : null,
                    "defvalue": defvalue ? defvalue : null
                });
            };
        }
        reflect.UIStyle = UIStyle;
    })(reflect = gd3d.reflect || (gd3d.reflect = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var canvas = (function () {
            function canvas() {
                this.is2dUI = true;
                this.pointDown = false;
                this.pointSelect = null;
                this.pointEvent = new framework.PointEvent();
                this.pointX = 0;
                this.pointY = 0;
                this.pixelWidth = 640;
                this.pixelHeight = 480;
                this.rootNode = new framework.transform2D();
                this.rootNode.canvas = this;
            }
            canvas.prototype.addChild = function (node) {
                this.rootNode.addChild(node);
            };
            canvas.prototype.removeChild = function (node) {
                this.rootNode.removeChild(node);
            };
            canvas.prototype.getChildren = function () {
                return this.rootNode.children;
            };
            canvas.prototype.getChildCount = function () {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            };
            canvas.prototype.getChild = function (index) {
                return this.rootNode.children[index];
            };
            canvas.prototype.update = function (delta, touch, XOnScreenSpace, YOnScreenSpace) {
                var asp = this.pixelWidth / this.pixelHeight;
                this.rootNode.localScale.x = 2 / this.pixelWidth;
                this.rootNode.localScale.y = -2 / this.pixelHeight;
                this.rootNode.localTranslate.y = 1;
                this.rootNode.localTranslate.x = -1;
                this.rootNode.width = this.pixelWidth;
                this.rootNode.height = this.pixelHeight;
                this.rootNode.pivot.x = 0;
                this.rootNode.pivot.y = 0;
                this.rootNode.updateTran(false);
                {
                    this.pointEvent.eated = false;
                    this.pointEvent.x = XOnScreenSpace;
                    this.pointEvent.y = YOnScreenSpace;
                    this.pointEvent.selected = this.pointSelect;
                    var skip = false;
                    if (this.pointDown == false && touch == false) {
                        skip = true;
                    }
                    else if (this.pointDown == false && touch == true) {
                        this.pointEvent.type = framework.PointEventEnum.PointDown;
                    }
                    else if (this.pointDown == true && touch == true) {
                        this.pointEvent.type = framework.PointEventEnum.PointHold;
                        if (this.pointX == this.pointEvent.x && this.pointY == this.pointEvent.y) {
                            skip = true;
                        }
                    }
                    else if (this.pointDown == true && touch == false) {
                        this.pointEvent.type = framework.PointEventEnum.PointUp;
                    }
                    if (!skip) {
                        this.rootNode.onCapturePointEvent(this, this.pointEvent);
                        this.rootNode.onPointEvent(this, this.pointEvent);
                        this.pointSelect = this.pointEvent.selected;
                        this.pointDown = touch;
                        this.pointX = this.pointEvent.x;
                        this.pointY = this.pointEvent.y;
                    }
                }
                this.rootNode.update(delta);
            };
            canvas.prototype.render = function (context, assetmgr) {
                this.context = context;
                this.assetmgr = assetmgr;
                this.lastMat = null;
                if (this.batcher == null) {
                    this.webgl = context.webgl;
                    this.batcher = new framework.batcher2D();
                    var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0 | gd3d.render.VertexFormatMask.ColorEX;
                    this.batcher.initBuffer(context.webgl, vf, gd3d.render.DrawModeEnum.VboTri);
                }
                this.drawScene(this.rootNode, context, assetmgr);
                this.batcher.end(context.webgl);
                if (this.afterRender != null)
                    this.afterRender();
            };
            canvas.prototype.pushRawData = function (mat, data) {
                if (mat != this.lastMat) {
                    this.lastMat = mat;
                    this.batcher.end(this.webgl);
                    var pass = this.lastMat.getShader().passes["base"][0];
                    mat.setMatrix("glstate_matrix_mvp", this.context.matrixModelViewProject);
                    mat.uploadUniform(pass);
                    pass.use(this.webgl);
                    this.batcher.begin(this.webgl, pass);
                }
                this.batcher.push(this.webgl, data, null);
            };
            canvas.prototype.drawScene = function (node, context, assetmgr) {
                if (node.renderer != null) {
                    node.renderer.render(this);
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.drawScene(node.children[i], context, assetmgr);
                    }
                }
            };
            canvas.prototype.getRoot = function () {
                if (this.rootNode == null) {
                    this.rootNode = new framework.transform2D();
                    this.rootNode.canvas = this;
                    this.scene.app.markNotify(this.rootNode, framework.NotifyType.AddChild);
                }
                return this.rootNode;
            };
            return canvas;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], canvas.prototype, "pixelWidth", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], canvas.prototype, "pixelHeight", void 0);
        __decorate([
            gd3d.reflect.Field("transform2D"),
            __metadata("design:type", framework.transform2D)
        ], canvas.prototype, "rootNode", void 0);
        canvas = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [])
        ], canvas);
        framework.canvas = canvas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var batcher2D = (function () {
            function batcher2D() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            batcher2D.prototype.initBuffer = function (webgl, vf, drawMode) {
                this.mesh = new gd3d.render.glMesh();
                this.mesh.initBuffer(webgl, vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == gd3d.render.DrawModeEnum.EboLine || drawMode == gd3d.render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
            };
            batcher2D.prototype.begin = function (webgl, pass) {
                if (this.vboCount > 0)
                    this.end(webgl);
                this.curPass = pass;
            };
            batcher2D.prototype.push = function (webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > 2048
                    ||
                        (ebodata != null && this.eboCount + ebodata.length > 2048)) {
                    this.end(webgl);
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    var narr = new Float32Array(this.dataForVbo.length * 2);
                    for (var i = 0; i < this.dataForVbo.length; i++) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (var i = 0; i < vbodata.length; i++) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == gd3d.render.DrawModeEnum.VboLine || this.drawMode == gd3d.render.DrawModeEnum.VboTri)
                    return;
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        var narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (var i = 0; i < this.dataForEbo.length; i++) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (var i = 0; i < ebodata.length; i++) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            };
            batcher2D.prototype.end = function (webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexSubData(webgl, this.dataForVbo.slice(0, this.vboCount), 0);
                if (this.eboCount > 0)
                    this.mesh.uploadIndexSubData(webgl, 0, this.dataForEbo.slice(0, this.eboCount), 0);
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                this.curPass.use(webgl);
                this.mesh.bind(webgl, this.curPass.program, (this.drawMode == gd3d.render.DrawModeEnum.EboLine || this.drawMode == gd3d.render.DrawModeEnum.EboTri) ? 0 : -1);
                if (this.drawMode == gd3d.render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
            };
            return batcher2D;
        }());
        framework.batcher2D = batcher2D;
        var canvasRenderer = (function () {
            function canvasRenderer() {
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                this.renderLayer = framework.CullingMask.default;
                this.canvas = new framework.canvas();
                this.canvas.is2dUI = false;
            }
            canvasRenderer.prototype.getBound = function () {
                return null;
            };
            canvasRenderer.prototype.intersectsTransform = function (tran) {
                return false;
            };
            canvasRenderer.prototype.start = function () {
                this.canvas.scene = this.gameObject.getScene();
                this.canvas.parentTrans = this.gameObject.transform;
                this.inputmgr = this.gameObject.getScene().app.getInputMgr();
            };
            canvasRenderer.prototype.addChild = function (node) {
                this.canvas.addChild(node);
            };
            canvasRenderer.prototype.removeChild = function (node) {
                this.canvas.removeChild(node);
            };
            canvasRenderer.prototype.getChildren = function () {
                return this.canvas.getChildren();
            };
            canvasRenderer.prototype.getChildCount = function () {
                return this.canvas.getChildCount();
            };
            canvasRenderer.prototype.getChild = function (index) {
                return this.canvas.getChild(index);
            };
            canvasRenderer.prototype.update = function (delta) {
                var asp = this.canvas.pixelWidth / this.canvas.pixelHeight;
                this.gameObject.transform.localScale.x = this.gameObject.transform.localScale.y * asp;
                if (this.cameraTouch != null) {
                    var scene = this.gameObject.getScene();
                    var ray = this.cameraTouch.creatRayByScreen(new gd3d.math.vector2(this.inputmgr.point.x, this.inputmgr.point.y), scene.app);
                    var pinfo = scene.pick(ray);
                    if (pinfo != null && pinfo.pickedtran == this.gameObject.transform) {
                        var mat = this.gameObject.transform.getWorldMatrix();
                        var matinv = new gd3d.math.matrix();
                        gd3d.math.matrixInverse(mat, matinv);
                        var outv = new gd3d.math.vector3();
                        gd3d.math.matrixTransformVector3(pinfo.hitposition, matinv, outv);
                        this.canvas.update(delta, this.inputmgr.point.touch, outv.x, outv.y);
                    }
                    else {
                        this.canvas.update(delta, false, 0, 0);
                    }
                }
                else {
                    this.canvas.update(delta, false, 0, 0);
                }
            };
            canvasRenderer.prototype.pick2d = function (ray) {
                var pinfo = ray.intersectPlaneTransform(this.gameObject.transform);
                if (pinfo != null) {
                    var mat = this.gameObject.transform.getWorldMatrix();
                    var matinv = gd3d.math.pool.new_matrix();
                    gd3d.math.matrixInverse(mat, matinv);
                    var outv = gd3d.math.pool.new_vector3();
                    gd3d.math.matrixTransformVector3(pinfo.hitposition, matinv, outv);
                    var outv2 = gd3d.math.pool.new_vector2();
                    outv2.x = outv.x;
                    outv2.y = outv.y;
                    var root = this.canvas.getRoot();
                    return this.dopick2d(outv2, root);
                }
                return null;
            };
            canvasRenderer.prototype.dopick2d = function (outv, tran) {
                if (tran.components != null) {
                    for (var i = tran.components.length - 1; i >= 0; i--) {
                        var comp = tran.components[i];
                        if (comp != null)
                            if (comp.init && comp.comp.transform.ContainsCanvasPoint(outv)) {
                                return comp.comp.transform;
                            }
                    }
                }
                if (tran.children != null) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        var tran2 = this.dopick2d(outv, tran.children[i]);
                        if (tran2 != null)
                            return tran2;
                    }
                }
                return null;
            };
            canvasRenderer.prototype.render = function (context, assetmgr, camera) {
                context.updateModel(this.gameObject.transform);
                this.canvas.render(context, assetmgr);
            };
            canvasRenderer.prototype.jsonToAttribute = function (json, assetmgr) {
            };
            canvasRenderer.prototype.remove = function () {
            };
            canvasRenderer.prototype.clone = function () {
            };
            return canvasRenderer;
        }());
        __decorate([
            gd3d.reflect.Field("canvas"),
            __metadata("design:type", framework.canvas)
        ], canvasRenderer.prototype, "canvas", void 0);
        canvasRenderer = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeCanvasRendererCollider,
            __metadata("design:paramtypes", [])
        ], canvasRenderer);
        framework.canvasRenderer = canvasRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var PointEventEnum;
        (function (PointEventEnum) {
            PointEventEnum[PointEventEnum["PointNothing"] = 0] = "PointNothing";
            PointEventEnum[PointEventEnum["PointDown"] = 1] = "PointDown";
            PointEventEnum[PointEventEnum["PointHold"] = 2] = "PointHold";
            PointEventEnum[PointEventEnum["PointUp"] = 3] = "PointUp";
        })(PointEventEnum = framework.PointEventEnum || (framework.PointEventEnum = {}));
        var PointEvent = (function () {
            function PointEvent() {
            }
            return PointEvent;
        }());
        framework.PointEvent = PointEvent;
        var UIEvent = (function () {
            function UIEvent() {
                this.funcs = [];
            }
            UIEvent.prototype.addListener = function (func) {
                this.funcs.push(func);
            };
            UIEvent.prototype.excute = function () {
                for (var key in this.funcs) {
                    this.funcs[key]();
                }
            };
            UIEvent.prototype.clear = function () {
                this.funcs.length = 0;
            };
            return UIEvent;
        }());
        framework.UIEvent = UIEvent;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var overlay2D = (function () {
            function overlay2D() {
                this.init = false;
                this.autoAsp = true;
                this.renderLayer = framework.CullingMask.ui;
                this.canvas = new framework.canvas();
                framework.sceneMgr.app.markNotify(this.canvas.getRoot(), framework.NotifyType.AddChild);
            }
            overlay2D.prototype.start = function (camera) {
                this.camera = camera;
                this.app = camera.gameObject.getScene().app;
                this.canvas.scene = camera.gameObject.getScene();
                this.inputmgr = camera.gameObject.getScene().app.getInputMgr();
            };
            overlay2D.prototype.addChild = function (node) {
                this.canvas.addChild(node);
            };
            overlay2D.prototype.removeChild = function (node) {
                this.canvas.removeChild(node);
            };
            overlay2D.prototype.getChildren = function () {
                return this.canvas.getChildren();
            };
            overlay2D.prototype.getChildCount = function () {
                return this.canvas.getChildCount();
            };
            overlay2D.prototype.getChild = function (index) {
                return this.canvas.getChild(index);
            };
            overlay2D.prototype.render = function (context, assetmgr, camera) {
                if (!this.canvas.getRoot().visible)
                    return;
                if (this.camera == null || this.camera == undefined)
                    return;
                if (this.autoAsp) {
                    var vp = new gd3d.math.rect();
                    this.camera.calcViewPortPixel(assetmgr.app, vp);
                    var aspcam = vp.w / vp.h;
                    var aspc = this.canvas.pixelWidth / this.canvas.pixelHeight;
                    if (aspc != aspcam) {
                        this.canvas.pixelWidth = this.canvas.pixelHeight * aspcam;
                        this.canvas.getRoot().markDirty();
                    }
                }
                context.updateOverlay();
                this.canvas.render(context, assetmgr);
            };
            overlay2D.prototype.update = function (delta) {
                var vp = new gd3d.math.rect();
                var app = this.camera.calcViewPortPixel(this.app, vp);
                var sx = (this.inputmgr.point.x / vp.w) * 2 - 1;
                var sy = (this.inputmgr.point.y / vp.h) * -2 + 1;
                this.canvas.update(delta, this.inputmgr.point.touch, sx, sy);
            };
            overlay2D.prototype.pick2d = function (mx, my) {
                if (this.camera == null)
                    return null;
                var vp = new gd3d.math.rect();
                var app = this.camera.calcViewPortPixel(this.app, vp);
                var sx = (mx / vp.w) * 2 - 1;
                var sy = (my / vp.h) * -2 + 1;
                var outv2 = gd3d.math.pool.new_vector2();
                outv2.x = sx;
                outv2.y = sy;
                var root = this.canvas.getRoot();
                return this.dopick2d(outv2, root);
            };
            overlay2D.prototype.dopick2d = function (outv, tran) {
                if (tran.components != null) {
                    for (var i = tran.components.length - 1; i >= 0; i--) {
                        var comp = tran.components[i];
                        if (comp != null)
                            if (comp.init && comp.comp.transform.ContainsCanvasPoint(outv)) {
                                return comp.comp.transform;
                            }
                    }
                }
                if (tran.children != null) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        var tran2 = this.dopick2d(outv, tran.children[i]);
                        if (tran2 != null)
                            return tran2;
                    }
                }
                return null;
            };
            overlay2D.prototype.calScreenPosToCanvasPos = function (mousePos, canvasPos) {
                var vp = new gd3d.math.rect();
                this.camera.calcViewPortPixel(this.app, vp);
                var temt = gd3d.math.pool.new_vector2();
                temt.x = (mousePos.x / vp.w) * 2 - 1;
                temt.y = (mousePos.y / vp.h) * -2 + 1;
                var mat = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Clone(this.canvas.getRoot().getWorldMatrix(), mat);
                gd3d.math.matrix3x2Inverse(mat, mat);
                gd3d.math.matrix3x2TransformVector2(mat, temt, canvasPos);
                gd3d.math.pool.delete_vector2(temt);
            };
            return overlay2D;
        }());
        __decorate([
            gd3d.reflect.Field("canvas"),
            __metadata("design:type", framework.canvas)
        ], overlay2D.prototype, "canvas", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], overlay2D.prototype, "autoAsp", void 0);
        overlay2D = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [])
        ], overlay2D);
        framework.overlay2D = overlay2D;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        var vector2 = (function () {
            function vector2(x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                this.x = x;
                this.y = y;
            }
            vector2.prototype.toString = function () {
                return this.x + "," + this.y;
            };
            return vector2;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], vector2.prototype, "x", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], vector2.prototype, "y", void 0);
        vector2 = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number])
        ], vector2);
        math.vector2 = vector2;
        var rect = (function () {
            function rect(x, y, w, h) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (w === void 0) { w = 0; }
                if (h === void 0) { h = 0; }
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }
            rect.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.w + "," + this.h;
            };
            return rect;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], rect.prototype, "x", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], rect.prototype, "y", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], rect.prototype, "w", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], rect.prototype, "h", void 0);
        rect = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], rect);
        math.rect = rect;
        var border = (function () {
            function border(l, t, r, b) {
                if (l === void 0) { l = 0; }
                if (t === void 0) { t = 0; }
                if (r === void 0) { r = 0; }
                if (b === void 0) { b = 0; }
                this.l = l;
                this.t = t;
                this.r = r;
                this.b = b;
            }
            return border;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], border.prototype, "l", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], border.prototype, "t", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], border.prototype, "r", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], border.prototype, "b", void 0);
        border = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], border);
        math.border = border;
        var color = (function () {
            function color(r, g, b, a) {
                if (r === void 0) { r = 1; }
                if (g === void 0) { g = 1; }
                if (b === void 0) { b = 1; }
                if (a === void 0) { a = 1; }
                this.r = r;
                this.g = g;
                this.b = b;
                this.a = a;
            }
            color.prototype.toString = function () {
                return this.r + "," + this.g + "," + this.b + "," + this.a;
            };
            return color;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], color.prototype, "r", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], color.prototype, "g", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], color.prototype, "b", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], color.prototype, "a", void 0);
        color = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], color);
        math.color = color;
        var vector3 = (function () {
            function vector3(x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                this.x = x;
                this.y = y;
                this.z = z;
            }
            vector3.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z;
            };
            return vector3;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], vector3.prototype, "x", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], vector3.prototype, "y", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], vector3.prototype, "z", void 0);
        vector3 = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number])
        ], vector3);
        math.vector3 = vector3;
        var vector4 = (function () {
            function vector4(x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 0; }
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            vector4.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z + "," + this.w;
            };
            return vector4;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], vector4.prototype, "x", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], vector4.prototype, "y", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], vector4.prototype, "z", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], vector4.prototype, "w", void 0);
        vector4 = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], vector4);
        math.vector4 = vector4;
        var quaternion = (function () {
            function quaternion(x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 1; }
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            quaternion.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z + "," + this.w;
            };
            return quaternion;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], quaternion.prototype, "x", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], quaternion.prototype, "y", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], quaternion.prototype, "z", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], quaternion.prototype, "w", void 0);
        quaternion = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], quaternion);
        math.quaternion = quaternion;
        var matrix = (function () {
            function matrix(datas) {
                if (datas === void 0) { datas = null; }
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            }
            matrix.prototype.toString = function () {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "," + this.rawData[3] + "],"
                    + "[" + this.rawData[4] + "," + this.rawData[5] + "," + this.rawData[6] + "," + this.rawData[7] + "],"
                    + "[" + this.rawData[8] + "," + this.rawData[9] + "," + this.rawData[10] + "," + this.rawData[11] + "],"
                    + "[" + this.rawData[12] + "," + this.rawData[13] + "," + this.rawData[14] + "," + this.rawData[15] + "]";
            };
            return matrix;
        }());
        math.matrix = matrix;
        var matrix3x2 = (function () {
            function matrix3x2(datas) {
                if (datas === void 0) { datas = null; }
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = new Float32Array([1, 0, 0, 0, 1, 0]);
            }
            matrix3x2.prototype.toString = function () {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "],"
                    + "[" + this.rawData[3] + "," + this.rawData[4] + "," + this.rawData[5] + "]";
            };
            return matrix3x2;
        }());
        math.matrix3x2 = matrix3x2;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var C2DComponent = (function () {
            function C2DComponent(comp, init) {
                if (init === void 0) { init = false; }
                this.comp = comp;
                this.init = init;
            }
            return C2DComponent;
        }());
        __decorate([
            gd3d.reflect.Field("I2DComponent"),
            __metadata("design:type", Object)
        ], C2DComponent.prototype, "comp", void 0);
        C2DComponent = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Object, Boolean])
        ], C2DComponent);
        framework.C2DComponent = C2DComponent;
        var transform2D = (function () {
            function transform2D() {
                this.name = "noname";
                this.pivot = new gd3d.math.vector2(0, 0);
                this.hideFlags = framework.HideFlags.None;
                this._visible = true;
                this.insId = new framework.insID();
                this.dirty = true;
                this.dirtyChild = true;
                this.dirtyWorldDecompose = false;
                this.localTranslate = new gd3d.math.vector2(0, 0);
                this.localScale = new gd3d.math.vector2(1, 1);
                this.localRotate = 0;
                this.localMatrix = new gd3d.math.matrix3x2;
                this.worldMatrix = new gd3d.math.matrix3x2();
                this.worldRotate = new gd3d.math.angelref();
                this.worldTranslate = new gd3d.math.vector2(0, 0);
                this.worldScale = new gd3d.math.vector2(1, 1);
                this.components = [];
            }
            Object.defineProperty(transform2D.prototype, "canvas", {
                get: function () {
                    if (this._canvas == null) {
                        if (this.parent == null)
                            return null;
                        return this.parent.canvas;
                    }
                    return this._canvas;
                },
                set: function (val) {
                    this._canvas = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "visibleInScene", {
                get: function () {
                    var obj = this;
                    while (obj.visible) {
                        obj = obj.parent;
                    }
                    return obj.visible;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "visible", {
                get: function () {
                    return this._visible;
                },
                set: function (val) {
                    if (val != this._visible) {
                        this._visible = val;
                        framework.sceneMgr.app.markNotify(this, framework.NotifyType.ChangeVisible);
                    }
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(transform2D.prototype, "transform", {
                get: function () {
                    return this;
                },
                enumerable: true,
                configurable: true
            });
            transform2D.prototype.addChild = function (node) {
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.push(node);
                node.parent = this;
                node.canvas = this.canvas;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
            };
            transform2D.prototype.addChildAt = function (node, index) {
                if (index < 0)
                    return;
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.splice(index, 0, node);
                node.canvas = this.canvas;
                node.parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
            };
            transform2D.prototype.removeChild = function (node) {
                if (node.parent != this || this.children == null) {
                    throw new Error("not my child.");
                }
                var i = this.children.indexOf(node);
                if (i >= 0) {
                    this.children.splice(i, 1);
                }
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.RemoveChild);
            };
            transform2D.prototype.removeAllChild = function () {
                while (this.children.length > 0) {
                    this.removeChild(this.children[0]);
                }
            };
            transform2D.prototype.markDirty = function () {
                this.dirty = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p = p.parent;
                }
            };
            transform2D.prototype.updateTran = function (parentChange) {
                if (this.dirtyChild == false && this.dirty == false && parentChange == false)
                    return;
                if (this.dirty) {
                    gd3d.math.matrix3x2MakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                if (this.dirty || parentChange) {
                    if (this.parent == null) {
                        gd3d.math.matrix3x2Clone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        gd3d.math.matrix3x2Multiply(this.parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    if (this.renderer != null) {
                        this.renderer.updateTran();
                    }
                    this.dirtyWorldDecompose = true;
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].updateTran(parentChange || this.dirty);
                    }
                }
                this.dirty = false;
                this.dirtyChild = false;
            };
            transform2D.prototype.updateWorldTran = function () {
                var p = this.parent;
                var dirtylist = [];
                dirtylist.push(this);
                while (p != null) {
                    if (p.dirty)
                        dirtylist.push(p);
                    p = p.parent;
                }
                var top = dirtylist.pop();
                top.updateTran(false);
            };
            transform2D.prototype.getWorldTranslate = function () {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrix3x2Decompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldTranslate;
            };
            transform2D.prototype.getWorldScale = function () {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrix3x2Decompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldScale;
            };
            transform2D.prototype.getWorldRotate = function () {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrix3x2Decompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldRotate;
            };
            transform2D.prototype.getLocalMatrix = function () {
                return this.localMatrix;
            };
            transform2D.prototype.getWorldMatrix = function () {
                return this.worldMatrix;
            };
            transform2D.prototype.setWorldPosition = function (pos) {
                this.dirty = true;
                this.updateWorldTran();
                var thispos = this.getWorldTranslate();
                var dir = gd3d.math.pool.new_vector2();
                dir.x = pos.x - thispos.x;
                dir.y = pos.y - thispos.y;
                var pworld = gd3d.math.pool.new_matrix3x2();
                if (this.parent != null) {
                    gd3d.math.matrix3x2Clone(this.parent.worldMatrix, pworld);
                }
                else {
                    gd3d.math.matrix3x2MakeIdentity(pworld);
                }
                var matinv = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Inverse(pworld, matinv);
                var dirinv = gd3d.math.pool.new_vector2();
                gd3d.math.matrix3x2TransformNormal(matinv, dir, dirinv);
                this.localTranslate.x += dirinv.x;
                this.localTranslate.y += dirinv.y;
                gd3d.math.pool.delete_matrix3x2(matinv);
                gd3d.math.pool.delete_vector2(dir);
                gd3d.math.pool.delete_vector2(dirinv);
            };
            transform2D.prototype.dispose = function () {
                if (this.children) {
                    for (var k in this.children) {
                        this.children[k].dispose();
                    }
                    this.removeAllChild();
                }
                this.removeAllComponents();
            };
            transform2D.prototype.update = function (delta) {
                if (this.components != null) {
                    for (var i = 0; i < this.components.length; i++) {
                        if (this.components[i].init == false) {
                            this.components[i].comp.start();
                            this.components[i].init = true;
                        }
                        if (framework.sceneMgr.app.bePlay && !framework.sceneMgr.app.bePause)
                            this.components[i].comp.update(delta);
                    }
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].update(delta);
                    }
                }
            };
            transform2D.prototype.addComponentDirect = function (comp) {
                if (comp.transform != null) {
                    throw new Error("this components has added to a  gameObject");
                }
                comp.transform = this;
                if (this.components == null)
                    this.components = [];
                var _comp = new C2DComponent(comp, false);
                this.components.push(_comp);
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1") {
                    if (this.renderer == null) {
                        this.renderer = comp;
                    }
                    else {
                        throw new Error("");
                    }
                }
                return comp;
            };
            transform2D.prototype.getComponent = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return this.components[i].comp;
                    }
                }
                return null;
            };
            transform2D.prototype.getComponents = function () {
                var components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            };
            transform2D.prototype.getComponentsInChildren = function (type) {
                var components = [];
                this.getNodeCompoents(this, type, components);
                return components;
            };
            transform2D.prototype.getNodeCompoents = function (node, _type, comps) {
                for (var i in node.components) {
                    var cname = gd3d.reflect.getClassName(node.components[i].comp["__proto__"]);
                    if (cname == _type) {
                        comps.push(this.components[i].comp);
                    }
                }
                if (node.children != null) {
                    for (var i in node.children) {
                        this.getNodeCompoents(node.children[i], _type, comps);
                    }
                }
            };
            transform2D.prototype.addComponent = function (type) {
                if (this.components == null)
                    this.components = [];
                for (var key in this.components) {
                    var st = this.components[key]["comp"]["constructor"]["name"];
                    if (st == type) {
                        throw new Error("" + type + "");
                    }
                }
                var pp = gd3d.reflect.getPrototype(type);
                var comp = gd3d.reflect.createInstance(pp, { "2dcomp": "1" });
                return this.addComponentDirect(comp);
            };
            transform2D.prototype.removeComponent = function (comp) {
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        if (this.components[i].init) {
                        }
                        this.components.splice(i, 1);
                    }
                }
            };
            transform2D.prototype.removeComponentByTypeName = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    if (gd3d.reflect.getClassName(this.components[i].comp) == type) {
                        var p = this.components.splice(i, 1);
                        if (p[0].comp == this.renderer)
                            this.renderer = null;
                        return p[0];
                    }
                }
            };
            transform2D.prototype.removeAllComponents = function () {
                for (var i = 0; i < this.components.length; i++) {
                    this.components[i].comp.remove();
                    if (this.components[i].comp == this.renderer)
                        this.renderer = null;
                }
                this.components.length = 0;
            };
            transform2D.prototype.onCapturePointEvent = function (canvas, ev) {
                if (this.components != null) {
                    for (var i = 0; i <= this.components.length; i++) {
                        if (ev.eated == false) {
                            var comp = this.components[i];
                            if (comp != null)
                                if (comp.init) {
                                    comp.comp.onPointEvent(canvas, ev, true);
                                }
                        }
                    }
                }
                if (ev.eated == false) {
                    if (this.children != null) {
                        for (var i = 0; i <= this.children.length; i++) {
                            var c = this.children[i];
                            if (c != null)
                                c.onCapturePointEvent(canvas, ev);
                        }
                    }
                }
            };
            transform2D.prototype.ContainsPoint = function (p) {
                var p2 = new gd3d.math.vector2();
                p2.x = p.x + this.pivot.x * this.width;
                p2.y = p.y + this.pivot.y * this.height;
                return p2.x >= 0 && p2.y >= 0 && p2.x < this.width && p2.y < this.height;
            };
            transform2D.prototype.ContainsCanvasPoint = function (pworld) {
                var mworld = this.getWorldMatrix();
                var mout = new gd3d.math.matrix3x2();
                gd3d.math.matrix3x2Inverse(mworld, mout);
                var p2 = new gd3d.math.vector2();
                gd3d.math.matrix3x2TransformVector2(mout, pworld, p2);
                p2.x += this.pivot.x * this.width;
                p2.y += this.pivot.y * this.height;
                return p2.x >= 0 && p2.y >= 0 && p2.x < this.width && p2.y < this.height;
            };
            transform2D.prototype.onPointEvent = function (canvas, ev) {
                if (this.children != null) {
                    for (var i = this.children.length - 1; i >= 0; i--) {
                        if (ev.eated == false) {
                            var c = this.children[i];
                            if (c != null)
                                c.onPointEvent(canvas, ev);
                        }
                    }
                }
                if (ev.eated == false && this.components != null) {
                    for (var i = this.components.length - 1; i >= 0; i--) {
                        var comp = this.components[i];
                        if (comp != null)
                            if (comp.init) {
                                comp.comp.onPointEvent(canvas, ev, false);
                            }
                    }
                }
            };
            return transform2D;
        }());
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], transform2D.prototype, "name", void 0);
        __decorate([
            gd3d.reflect.Field("transform2D[]"),
            __metadata("design:type", Array)
        ], transform2D.prototype, "children", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], transform2D.prototype, "width", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], transform2D.prototype, "height", void 0);
        __decorate([
            gd3d.reflect.Field("vector2"),
            __metadata("design:type", gd3d.math.vector2)
        ], transform2D.prototype, "pivot", void 0);
        __decorate([
            gd3d.reflect.Field("vector2"),
            __metadata("design:type", gd3d.math.vector2)
        ], transform2D.prototype, "localTranslate", void 0);
        __decorate([
            gd3d.reflect.Field("vector2"),
            __metadata("design:type", gd3d.math.vector2)
        ], transform2D.prototype, "localScale", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], transform2D.prototype, "localRotate", void 0);
        __decorate([
            gd3d.reflect.Field("C2DComponent[]"),
            __metadata("design:type", Array)
        ], transform2D.prototype, "components", void 0);
        transform2D = __decorate([
            gd3d.reflect.SerializeType
        ], transform2D);
        framework.transform2D = transform2D;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var TransitionType;
        (function (TransitionType) {
            TransitionType[TransitionType["None"] = 0] = "None";
            TransitionType[TransitionType["ColorTint"] = 1] = "ColorTint";
            TransitionType[TransitionType["SpriteSwap"] = 2] = "SpriteSwap";
        })(TransitionType = framework.TransitionType || (framework.TransitionType = {}));
        var button = (function () {
            function button() {
                this._transition = TransitionType.ColorTint;
                this._normalColor = new gd3d.math.color(1, 1, 1, 1);
                this._pressedColor = new gd3d.math.color(0.5, 0.5, 0.5, 1);
                this._fadeDuration = 0.1;
                this.onClick = new framework.UIEvent();
                this._downInThis = false;
                this._dragOut = false;
            }
            Object.defineProperty(button.prototype, "transition", {
                get: function () {
                    return this._transition;
                },
                set: function (transition) {
                    this._transition = transition;
                    if (this._targetImage != null) {
                        if (transition == TransitionType.ColorTint) {
                            this._targetImage.color = this.normalColor;
                        }
                        else {
                            this._targetImage.color = this._originalColor;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "targetImage", {
                get: function () {
                    return this._targetImage;
                },
                set: function (graphic) {
                    if (this._targetImage != null) {
                        this._targetImage.color = this._originalColor;
                    }
                    if (graphic != null) {
                        this._originalColor = graphic.color;
                        this._originalSprite = graphic.sprite;
                        if (this._transition = TransitionType.ColorTint) {
                            graphic.color = this.normalColor;
                        }
                    }
                    else {
                        this._originalColor = null;
                        this._originalSprite = null;
                    }
                    this._targetImage = graphic;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "pressedGraphic", {
                get: function () {
                    return this._pressedSprite;
                },
                set: function (sprite) {
                    this._pressedSprite = sprite;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "normalColor", {
                get: function () {
                    return this._normalColor;
                },
                set: function (color) {
                    this._normalColor = color;
                    if (this._targetImage != null && this.transition == TransitionType.ColorTint) {
                        this._targetImage.color = color;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "pressedColor", {
                get: function () {
                    return this._pressedColor;
                },
                set: function (color) {
                    this._pressedColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "fadeDuration", {
                get: function () {
                    return this._fadeDuration;
                },
                set: function (duration) {
                    this._fadeDuration = duration;
                },
                enumerable: true,
                configurable: true
            });
            button.prototype.render = function (canvas) {
            };
            button.prototype.updateTran = function () {
            };
            button.prototype.start = function () {
            };
            button.prototype.update = function (delta) {
            };
            button.prototype.remove = function () {
            };
            button.prototype.onPointEvent = function (canvas, ev, oncap) {
                if (oncap == false) {
                    var b = this.transform.ContainsCanvasPoint(new gd3d.math.vector2(ev.x, ev.y));
                    if (b) {
                        if (ev.type == framework.PointEventEnum.PointDown) {
                            this._downInThis = true;
                            this.showPress();
                        }
                        else if (ev.type == framework.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == true) {
                                this._dragOut = false;
                                this.showPress();
                            }
                        }
                        else if (ev.type == framework.PointEventEnum.PointUp && this._downInThis) {
                            this._downInThis = false;
                            this.showNormal();
                            this.onClick.excute();
                        }
                    }
                    else {
                        if (ev.type == framework.PointEventEnum.PointUp) {
                            this._downInThis = false;
                        }
                        else if (ev.type == framework.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == false) {
                                this._dragOut = true;
                                this.showNormal();
                            }
                        }
                    }
                }
            };
            button.prototype.showNormal = function () {
                if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._normalColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    this.changeSprite(this._originalSprite);
                }
            };
            button.prototype.showPress = function () {
                if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._pressedColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    if (this._targetImage != null && this._targetImage.sprite != null && this._originalSprite == null) {
                        this._originalSprite = this._targetImage.sprite;
                    }
                    this.changeSprite(this._pressedSprite);
                }
            };
            button.prototype.changeColor = function (targetColor) {
                if (this._targetImage != null) {
                    this._targetImage.color = targetColor;
                    this._targetImage.transform.markDirty();
                }
            };
            button.prototype.changeSprite = function (sprite) {
                if (sprite == null)
                    return;
                if (this._targetImage != null) {
                    this._targetImage.sprite = sprite;
                    this._targetImage.transform.markDirty();
                }
            };
            return button;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], button.prototype, "transition", null);
        __decorate([
            gd3d.reflect.Field("color"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [gd3d.math.color])
        ], button.prototype, "normalColor", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], button.prototype, "fadeDuration", null);
        button = __decorate([
            gd3d.reflect.node2DComponent
        ], button);
        framework.button = button;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var image2D = (function () {
            function image2D() {
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
                this._imageType = ImageType.Simple;
                this._fillMethod = FillMethod.Horizontal;
                this._fillAmmount = 1;
                gd3d.io.enumMgr.enumMap["ImageType"] = ImageType;
                gd3d.io.enumMgr.enumMap["FillMethod"] = FillMethod;
            }
            Object.defineProperty(image2D.prototype, "imageType", {
                get: function () {
                    return this._imageType;
                },
                set: function (type) {
                    this._imageType = type;
                    this.prepareData();
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "fillMethod", {
                get: function () {
                    return this._fillMethod;
                },
                set: function (method) {
                    this._fillMethod = method;
                    this.prepareData();
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "fillAmmount", {
                get: function () {
                    return this._fillAmmount;
                },
                set: function (ammount) {
                    this._fillAmmount = ammount;
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            image2D.prototype.setTexture = function (texture, border, rect) {
                var _sprite = new framework.sprite();
                _sprite.texture = texture;
                if (border != null)
                    _sprite.border = border;
                else
                    _sprite.border = new gd3d.math.border(0, 0, 0, 0);
                if (rect != null)
                    _sprite.rect = rect;
                else
                    _sprite.rect = new gd3d.math.rect(0, 0, texture.glTexture.width, texture.glTexture.height);
                this.sprite = _sprite;
                this.prepareData();
                if (this.transform != null)
                    this.transform.markDirty();
            };
            Object.defineProperty(image2D.prototype, "sprite", {
                get: function () {
                    return this._sprite;
                },
                set: function (_sprite) {
                    if (this._sprite) {
                        this._sprite.unuse();
                    }
                    this._sprite = _sprite;
                    this._sprite.use();
                    this.prepareData();
                    this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            image2D.prototype.render = function (canvas) {
                if (this.mat == null) {
                    this.mat = new framework.material();
                    this.mat.setShader(canvas.assetmgr.getShader("shader/defui"));
                }
                var img = null;
                if (this._sprite != null && this._sprite.texture != null) {
                    img = this._sprite.texture;
                }
                this.mat.setTexture("_MainTex", img);
                canvas.pushRawData(this.mat, this.datar);
            };
            image2D.prototype.start = function () {
            };
            image2D.prototype.update = function (delta) {
            };
            image2D.prototype.remove = function () {
                this._sprite.unuse(true);
                this.datar.length = 0;
            };
            image2D.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            image2D.prototype.prepareData = function () {
                if (this._sprite == null)
                    return;
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        break;
                    case ImageType.Sliced:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                        ];
                        break;
                    case ImageType.Tiled:
                        this.datar = [];
                        break;
                    case ImageType.Filled:
                        var halfu = urange.x + 0.5 * ulen;
                        var halfv = vrange.x + 0.5 * vlen;
                        switch (this._fillMethod) {
                            case FillMethod.Horizontal:
                            case FillMethod.Vertical:
                            case FillMethod.Radial_90:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_180:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_360:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                ];
                                break;
                        }
                        break;
                }
            };
            image2D.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                if (this._sprite == null)
                    return;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.updateSimpleData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Sliced:
                        this.updateSlicedData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Tiled:
                        this.updateTiledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Filled:
                        this.updateFilledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                }
                var vertexCount = this.datar.length / 13;
                for (var i = 0; i < vertexCount; i++) {
                    this.datar[i * 13 + 3] = this.color.r;
                    this.datar[i * 13 + 4] = this.color.g;
                    this.datar[i * 13 + 5] = this.color.b;
                    this.datar[i * 13 + 6] = this.color.a;
                }
            };
            image2D.prototype.updateQuadData = function (x0, y0, x1, y1, x2, y2, x3, y3, quadIndex, mirror) {
                if (quadIndex === void 0) { quadIndex = 0; }
                if (mirror === void 0) { mirror = false; }
                var _index = quadIndex * 6;
                if (!mirror) {
                    this.datar[(_index + 0) * 13] = x0;
                    this.datar[(_index + 0) * 13 + 1] = y0;
                    this.datar[(_index + 1) * 13] = x1;
                    this.datar[(_index + 1) * 13 + 1] = y1;
                    this.datar[(_index + 2) * 13] = x2;
                    this.datar[(_index + 2) * 13 + 1] = y2;
                    this.datar[(_index + 3) * 13] = x2;
                    this.datar[(_index + 3) * 13 + 1] = y2;
                    this.datar[(_index + 4) * 13] = x1;
                    this.datar[(_index + 4) * 13 + 1] = y1;
                    this.datar[(_index + 5) * 13] = x3;
                    this.datar[(_index + 5) * 13 + 1] = y3;
                }
                else {
                    this.datar[(_index + 0) * 13] = x0;
                    this.datar[(_index + 0) * 13 + 1] = y0;
                    this.datar[(_index + 1) * 13] = x1;
                    this.datar[(_index + 1) * 13 + 1] = y1;
                    this.datar[(_index + 2) * 13] = x3;
                    this.datar[(_index + 2) * 13 + 1] = y3;
                    this.datar[(_index + 3) * 13] = x0;
                    this.datar[(_index + 3) * 13 + 1] = y0;
                    this.datar[(_index + 4) * 13] = x3;
                    this.datar[(_index + 4) * 13 + 1] = y3;
                    this.datar[(_index + 5) * 13] = x2;
                    this.datar[(_index + 5) * 13 + 1] = y2;
                }
            };
            image2D.prototype.updateSimpleData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
            };
            image2D.prototype.updateSlicedData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var border = this._sprite.border;
                var rect = this._sprite.rect;
                var r1c1 = gd3d.math.pool.new_vector2();
                var r1c4 = gd3d.math.pool.new_vector2();
                var r4c1 = gd3d.math.pool.new_vector2();
                var r4c4 = gd3d.math.pool.new_vector2();
                var r1c2 = gd3d.math.pool.new_vector2();
                var r1c3 = gd3d.math.pool.new_vector2();
                var r2c1 = gd3d.math.pool.new_vector2();
                var r3c1 = gd3d.math.pool.new_vector2();
                var r2c2 = gd3d.math.pool.new_vector2();
                var r2c3 = gd3d.math.pool.new_vector2();
                var r2c4 = gd3d.math.pool.new_vector2();
                var r3c2 = gd3d.math.pool.new_vector2();
                var r3c3 = gd3d.math.pool.new_vector2();
                var r3c4 = gd3d.math.pool.new_vector2();
                var r4c2 = gd3d.math.pool.new_vector2();
                var r4c3 = gd3d.math.pool.new_vector2();
                var r1c1_uv = gd3d.math.pool.new_vector2();
                var r1c4_uv = gd3d.math.pool.new_vector2();
                var r4c1_uv = gd3d.math.pool.new_vector2();
                var r4c4_uv = gd3d.math.pool.new_vector2();
                var r1c2_uv = gd3d.math.pool.new_vector2();
                var r1c3_uv = gd3d.math.pool.new_vector2();
                var r2c1_uv = gd3d.math.pool.new_vector2();
                var r3c1_uv = gd3d.math.pool.new_vector2();
                var r2c2_uv = gd3d.math.pool.new_vector2();
                var r2c3_uv = gd3d.math.pool.new_vector2();
                var r2c4_uv = gd3d.math.pool.new_vector2();
                var r3c2_uv = gd3d.math.pool.new_vector2();
                var r3c3_uv = gd3d.math.pool.new_vector2();
                var r3c4_uv = gd3d.math.pool.new_vector2();
                var r4c2_uv = gd3d.math.pool.new_vector2();
                var r4c3_uv = gd3d.math.pool.new_vector2();
                var help1 = gd3d.math.pool.new_vector2();
                var help2 = gd3d.math.pool.new_vector2();
                var help3 = gd3d.math.pool.new_vector2();
                r1c1.x = x0;
                r1c1.y = y0;
                r1c4.x = x1;
                r1c4.y = y1;
                r4c1.x = x2;
                r4c1.y = y2;
                r4c4.x = x3;
                r4c4.y = y3;
                var width = gd3d.math.vec2Distance(r1c1, r1c4);
                var height = gd3d.math.vec2Distance(r1c1, r4c1);
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var l_vertex = (border.l) / this.transform.width;
                var r_vertex = (border.r) / this.transform.width;
                var t_vertex = (border.t) / this.transform.height;
                var b_vertex = (border.b) / this.transform.height;
                var l = (border.l) / rect.w * (urange.y - urange.x);
                var r = (border.r) / rect.w * (urange.y - urange.x);
                var t = (border.t) / rect.h * (vrange.y - vrange.x);
                var b = (border.b) / rect.h * (vrange.y - vrange.x);
                gd3d.math.vec2Subtract(r1c4, r1c1, r1c2);
                gd3d.math.vec2ScaleByNum(r1c2, l_vertex, r1c2);
                gd3d.math.vec2Add(r1c2, r1c1, r1c2);
                gd3d.math.vec2Subtract(r1c1, r1c4, r1c3);
                gd3d.math.vec2ScaleByNum(r1c3, r_vertex, r1c3);
                gd3d.math.vec2Add(r1c3, r1c4, r1c3);
                gd3d.math.vec2Subtract(r4c1, r1c1, r2c1);
                gd3d.math.vec2ScaleByNum(r2c1, t_vertex, r2c1);
                gd3d.math.vec2Add(r2c1, r1c1, r2c1);
                gd3d.math.vec2Subtract(r1c1, r4c1, r3c1);
                gd3d.math.vec2ScaleByNum(r3c1, b_vertex, r3c1);
                gd3d.math.vec2Add(r3c1, r4c1, r3c1);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c3);
                gd3d.math.vec2Subtract(r1c4, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c4);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c3);
                gd3d.math.vec2Subtract(r1c4, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c4);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r4c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r4c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r4c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r4c3);
                r1c1_uv.x = urange.x;
                r1c1_uv.y = vrange.x;
                r1c2_uv.x = l + urange.x;
                r1c2_uv.y = vrange.x;
                r1c3_uv.x = urange.y - r;
                r1c3_uv.y = vrange.x;
                r1c4_uv.x = urange.y;
                r1c4_uv.y = vrange.x;
                r2c1_uv.x = urange.x;
                r2c1_uv.y = t + vrange.x;
                r2c2_uv.x = l + urange.x;
                r2c2_uv.y = t + vrange.x;
                r2c3_uv.x = urange.y - r;
                r2c3_uv.y = t + vrange.x;
                r2c4_uv.x = urange.y;
                r2c4_uv.y = t + vrange.x;
                r3c1_uv.x = urange.x;
                r3c1_uv.y = vrange.y - b;
                r3c2_uv.x = l + urange.x;
                r3c2_uv.y = vrange.y - b;
                r3c3_uv.x = urange.y - r;
                r3c3_uv.y = vrange.y - b;
                r3c4_uv.x = urange.y;
                r3c4_uv.y = vrange.y - b;
                r4c1_uv.x = urange.x;
                r4c1_uv.y = vrange.y;
                r4c2_uv.x = l + urange.x;
                r4c2_uv.y = vrange.y;
                r4c3_uv.x = urange.y - r;
                r4c3_uv.y = vrange.y;
                r4c4_uv.x = urange.y;
                r4c4_uv.y = vrange.y;
                var vertexs = [r1c1, r1c2, r1c3, r1c4, r2c1, r2c2, r2c3, r2c4, r3c1, r3c2, r3c3, r3c4, r4c1, r4c2, r4c3, r4c4];
                var uvs = [r1c1_uv, r1c2_uv, r1c3_uv, r1c4_uv, r2c1_uv, r2c2_uv, r2c3_uv, r2c4_uv, r3c1_uv, r3c2_uv, r3c3_uv, r3c4_uv, r4c1_uv, r4c2_uv, r4c3_uv, r4c4_uv];
                var partVertexs;
                var partUVs;
                for (var i = 0; i < 9; i++) {
                    var r_1 = Math.floor(i / 3);
                    var c = i % 3;
                    partVertexs = [vertexs[0 + c + r_1 * 4], vertexs[1 + c + r_1 * 4], vertexs[4 + c + r_1 * 4], vertexs[5 + c + r_1 * 4]];
                    partUVs = [uvs[0 + c + r_1 * 4], uvs[1 + c + r_1 * 4], uvs[4 + c + r_1 * 4], uvs[5 + c + r_1 * 4]];
                    this.updateQuadData(partVertexs[0].x, partVertexs[0].y, partVertexs[1].x, partVertexs[1].y, partVertexs[2].x, partVertexs[2].y, partVertexs[3].x, partVertexs[3].y, i);
                    this.datar[(0 + i * 6) * 13 + 7] = partUVs[0].x;
                    this.datar[(0 + i * 6) * 13 + 8] = partUVs[0].y;
                    this.datar[(1 + i * 6) * 13 + 7] = partUVs[1].x;
                    this.datar[(1 + i * 6) * 13 + 8] = partUVs[1].y;
                    this.datar[(2 + i * 6) * 13 + 7] = partUVs[2].x;
                    this.datar[(2 + i * 6) * 13 + 8] = partUVs[2].y;
                    this.datar[(3 + i * 6) * 13 + 7] = partUVs[2].x;
                    this.datar[(3 + i * 6) * 13 + 8] = partUVs[2].y;
                    this.datar[(4 + i * 6) * 13 + 7] = partUVs[1].x;
                    this.datar[(4 + i * 6) * 13 + 8] = partUVs[1].y;
                    this.datar[(5 + i * 6) * 13 + 7] = partUVs[3].x;
                    this.datar[(5 + i * 6) * 13 + 8] = partUVs[3].y;
                    partVertexs.length = 0;
                    partUVs.length = 0;
                }
                gd3d.math.pool.delete_vector2Array(vertexs);
                gd3d.math.pool.delete_vector2Array(uvs);
                gd3d.math.pool.delete_vector2Array([help1, help2, help3]);
            };
            image2D.prototype.updateFilledData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                var halfu = urange.x + 0.5 * ulen;
                var halfv = vrange.x + 0.5 * vlen;
                switch (this._fillMethod) {
                    case FillMethod.Horizontal:
                    case FillMethod.Vertical:
                    case FillMethod.Radial_90:
                        if (this._fillMethod == FillMethod.Horizontal) {
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x0);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y0);
                            x3 = x3 - (1 - this.fillAmmount) * (x3 - x2);
                            y3 = y3 - (1 - this.fillAmmount) * (y3 - y2);
                            this.datar[1 * 13 + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[4 * 13 + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[5 * 13 + 7] = urange.x + this.fillAmmount * ulen;
                        }
                        else if (this._fillMethod == FillMethod.Vertical) {
                            x0 = x0 - (1 - this.fillAmmount) * (x0 - x2);
                            y0 = y0 - (1 - this.fillAmmount) * (y0 - y2);
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x3);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y3);
                            this.datar[0 * 13 + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[1 * 13 + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[4 * 13 + 8] = (vrange.y - this.fillAmmount * vlen);
                        }
                        else if (this._fillMethod == FillMethod.Radial_90) {
                            if (this.fillAmmount >= 0.5) {
                                var _fillRate = 2 * (1 - this.fillAmmount);
                                x0 = x0 - _fillRate * (x0 - x1);
                                y0 = y0 - _fillRate * (y0 - y1);
                                this.datar[0 * 13 + 7] = urange.x + _fillRate * ulen;
                                this.datar[1 * 13 + 8] = vrange.x;
                                this.datar[4 * 13 + 8] = vrange.x;
                            }
                            else {
                                var _fillRate = 2 * (0.5 - this.fillAmmount);
                                x1 = x1 - _fillRate * (x1 - x3);
                                y1 = y1 - _fillRate * (y1 - y3);
                                x0 = x1;
                                y0 = y1;
                                this.datar[0 * 13 + 8] = vrange.x + _fillRate * vlen;
                                this.datar[1 * 13 + 8] = vrange.x + _fillRate * vlen;
                                this.datar[4 * 13 + 8] = vrange.x + _fillRate * vlen;
                            }
                        }
                        this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case FillMethod.Radial_180:
                        var tx = (x0 + x1) / 2;
                        var ty = (y0 + y1) / 2;
                        var bx = (x2 + x3) / 2;
                        var by = (y2 + y3) / 2;
                        if (this.fillAmmount >= 0.75) {
                            var _fillRate = 4 * (1 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - x0);
                            y2 = y2 - _fillRate * (y2 - y0);
                            this.datar[5 * 13 + 8] = vrange.y - _fillRate * vlen;
                            this.datar[0 * 13 + 7] = urange.x;
                            this.datar[3 * 13 + 7] = urange.x;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            var _fillRate = 4 * (0.75 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - tx);
                            y0 = y0 - _fillRate * (y0 - ty);
                            x2 = x0;
                            y2 = y0;
                            this.datar[0 * 13 + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[3 * 13 + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            var _fillRate = 4 * (0.5 - this.fillAmmount);
                            tx = tx - _fillRate * (tx - x1);
                            ty = ty - _fillRate * (ty - y1);
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[6 * 13 + 7] = halfu + 0.5 * ulen * _fillRate;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                        }
                        else {
                            var _fillRate = 4 * (0.25 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - x3);
                            y1 = y1 - _fillRate * (y1 - y3);
                            tx = x1;
                            ty = y1;
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[7 * 13 + 8] = vrange.x + _fillRate * vlen;
                            this.datar[10 * 13 + 8] = vrange.x + _fillRate * vlen;
                        }
                        this.updateQuadData(x0, y0, tx, ty, x2, y2, bx, by, 0, true);
                        this.updateQuadData(tx, ty, x1, y1, bx, by, x3, y3, 1);
                        break;
                    case FillMethod.Radial_360:
                        var t_x = (x0 + x1) / 2;
                        var t_y = (y0 + y1) / 2;
                        var l_x = (x0 + x2) / 2;
                        var l_y = (y0 + y2) / 2;
                        var b_x = (x2 + x3) / 2;
                        var b_y = (y2 + y3) / 2;
                        var r_x = (x1 + x3) / 2;
                        var r_y = (y1 + y3) / 2;
                        var c_x = (l_x + r_x) / 2;
                        var c_y = (l_y + r_y) / 2;
                        var b_x1 = b_x;
                        var b_y1 = b_y;
                        if (this.fillAmmount >= 0.875) {
                            var _fillRate = 8 * (1 - this.fillAmmount);
                            b_x = b_x - _fillRate * (b_x - x2);
                            b_y = b_y - _fillRate * (b_y - y2);
                            this.datar[17 * 13 + 7] = halfu - 0.5 * _fillRate * ulen;
                            this.datar[14 * 13 + 8] = vrange.y;
                            this.datar[15 * 13 + 8] = vrange.y;
                            this.datar[5 * 13 + 8] = halfv;
                            this.datar[0 * 13 + 7] = urange.x;
                            this.datar[3 * 13 + 7] = urange.x;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.75) {
                            var _fillRate = 8 * (0.875 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - l_x);
                            y2 = y2 - _fillRate * (y2 - l_y);
                            b_x = x2;
                            b_y = y2;
                            this.datar[14 * 13 + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[15 * 13 + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[5 * 13 + 8] = halfv;
                            this.datar[0 * 13 + 7] = urange.x;
                            this.datar[3 * 13 + 7] = urange.x;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.625) {
                            var _fillRate = 8 * (0.75 - this.fillAmmount);
                            l_x = l_x - _fillRate * (l_x - x0);
                            l_y = l_y - _fillRate * (l_y - y0);
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[5 * 13 + 8] = halfv - 0.5 * _fillRate * vlen;
                            this.datar[0 * 13 + 7] = urange.x;
                            this.datar[3 * 13 + 7] = urange.x;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            var _fillRate = 8 * (0.625 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - t_x);
                            y0 = y0 - _fillRate * (y0 - t_y);
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[0 * 13 + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[3 * 13 + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[6 * 13 + 7] = halfu;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.375) {
                            var _fillRate = 8 * (0.5 - this.fillAmmount);
                            t_x = t_x - _fillRate * (t_x - x1);
                            t_y = t_y - _fillRate * (t_y - y1);
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[6 * 13 + 7] = halfu + 0.5 * _fillRate * ulen;
                            this.datar[7 * 13 + 8] = vrange.x;
                            this.datar[10 * 13 + 8] = vrange.x;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            var _fillRate = 8 * (0.375 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - r_x);
                            y1 = y1 - _fillRate * (y1 - r_y);
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[7 * 13 + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[10 * 13 + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[19 * 13 + 8] = halfv;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.125) {
                            var _fillRate = 8 * (0.25 - this.fillAmmount);
                            r_x = r_x - _fillRate * (r_x - x3);
                            r_y = r_y - _fillRate * (r_y - y3);
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[19 * 13 + 8] = halfv + 0.5 * _fillRate * vlen;
                            this.datar[20 * 13 + 7] = urange.y;
                            this.datar[22 * 13 + 7] = urange.y;
                        }
                        else {
                            var _fillRate = 8 * (0.125 - this.fillAmmount);
                            x3 = x3 - _fillRate * (x3 - b_x);
                            y3 = y3 - _fillRate * (y3 - b_y);
                            r_x = x3;
                            r_y = y3;
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[20 * 13 + 7] = urange.y - 0.5 * _fillRate * ulen;
                            this.datar[22 * 13 + 7] = urange.y - 0.5 * _fillRate * ulen;
                        }
                        this.updateQuadData(x0, y0, t_x, t_y, l_x, l_y, c_x, c_y, 0, true);
                        this.updateQuadData(t_x, t_y, x1, y1, c_x, c_y, r_x, r_y, 1);
                        this.updateQuadData(l_x, l_y, c_x, c_y, x2, y2, b_x, b_y, 2);
                        this.updateQuadData(c_x, c_y, r_x, r_y, b_x1, b_y1, x3, y3, 3, true);
                        break;
                }
            };
            image2D.prototype.updateTiledData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var rect = this._sprite.rect;
                var border = this._sprite.border;
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                var xlen = x1 - x0;
                var ylen = y2 - y0;
                var _ul = this.transform.width / rect.w;
                var _vl = this.transform.height / rect.h;
                var inv_ul = 1 / _ul;
                var inv_vl = 1 / _vl;
                var dindex = 0;
                for (var i = 0; i < _vl - 1; i++) {
                    for (var j = 0; j < _ul - 1; j++) {
                        var tdata = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        this.datar = this.datar.concat(tdata);
                        var tx0 = x0 + inv_ul * xlen * j;
                        var ty0 = y0 + inv_vl * ylen * i;
                        var tx1 = x0 + inv_ul * xlen * (j + 1);
                        var ty1 = y0 + inv_vl * ylen * i;
                        var tx2 = x0 + inv_ul * xlen * j;
                        var ty2 = y0 + inv_vl * ylen * (i + 1);
                        var tx3 = x0 + inv_ul * xlen * (j + 1);
                        var ty3 = y0 + inv_vl * ylen * (i + 1);
                        this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                        dindex++;
                    }
                }
                var intvl = Math.ceil(_vl) - 1;
                var tvl = _vl - Math.ceil(_vl) + 1;
                for (var j = 0; j < _ul - 1; j++) {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * j;
                    var ty0 = y0 + inv_vl * ylen * intvl;
                    var tx1 = x0 + inv_ul * xlen * (j + 1);
                    var ty1 = y0 + inv_vl * ylen * intvl;
                    var tx2 = x0 + inv_ul * xlen * j;
                    var ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                    var tx3 = x0 + inv_ul * xlen * (j + 1);
                    var ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
                var intul = Math.ceil(_ul) - 1;
                var tul = _ul - Math.ceil(_ul) + 1;
                for (var i = 0; i < _vl - 1; i++) {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.y, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * intul;
                    var ty0 = y0 + inv_vl * ylen * i;
                    var tx1 = x0 + inv_ul * xlen * (intul + tul);
                    var ty1 = y0 + inv_vl * ylen * i;
                    var tx2 = x0 + inv_ul * xlen * intul;
                    var ty2 = y0 + inv_vl * ylen * (i + 1);
                    var tx3 = x0 + inv_ul * xlen * (intul + tul);
                    var ty3 = y0 + inv_vl * ylen * (i + 1);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
                {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * intul;
                    var ty0 = y0 + inv_vl * ylen * intvl;
                    var tx1 = x0 + inv_ul * xlen * (intul + tul);
                    var ty1 = y0 + inv_vl * ylen * intvl;
                    var tx2 = x0 + inv_ul * xlen * intul;
                    var ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                    var tx3 = x0 + inv_ul * xlen * (intul + tul);
                    var ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
            };
            return image2D;
        }());
        __decorate([
            gd3d.reflect.Field("color"),
            gd3d.reflect.UIStyle("vector4"),
            __metadata("design:type", gd3d.math.color)
        ], image2D.prototype, "color", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            gd3d.reflect.UIStyle("ImageType"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], image2D.prototype, "imageType", null);
        __decorate([
            gd3d.reflect.Field("number"),
            gd3d.reflect.UIStyle("FillMethod"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], image2D.prototype, "fillMethod", null);
        image2D = __decorate([
            gd3d.reflect.node2DComponent,
            gd3d.reflect.nodeRender,
            __metadata("design:paramtypes", [])
        ], image2D);
        framework.image2D = image2D;
        var ImageType;
        (function (ImageType) {
            ImageType[ImageType["Simple"] = 0] = "Simple";
            ImageType[ImageType["Sliced"] = 1] = "Sliced";
            ImageType[ImageType["Tiled"] = 2] = "Tiled";
            ImageType[ImageType["Filled"] = 3] = "Filled";
        })(ImageType = framework.ImageType || (framework.ImageType = {}));
        var FillMethod;
        (function (FillMethod) {
            FillMethod[FillMethod["Horizontal"] = 0] = "Horizontal";
            FillMethod[FillMethod["Vertical"] = 1] = "Vertical";
            FillMethod[FillMethod["Radial_90"] = 2] = "Radial_90";
            FillMethod[FillMethod["Radial_180"] = 3] = "Radial_180";
            FillMethod[FillMethod["Radial_360"] = 4] = "Radial_360";
        })(FillMethod = framework.FillMethod || (framework.FillMethod = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var label = (function () {
            function label() {
                this._fontsize = 14;
                this.linespace = 1;
                this.horizontalType = HorizontalType.Center;
                this.verticalType = VerticalType.Center;
                this.indexarr = [];
                this.remainarrx = [];
                this.data_begin = new gd3d.math.vector2(0, 0);
                this.datar = [];
                this.color = new gd3d.math.color(1, 1, 1, 1);
                this.color2 = new gd3d.math.color(0, 0, 0.5, 0.5);
                this.dirtyData = true;
            }
            Object.defineProperty(label.prototype, "text", {
                get: function () {
                    return this._text;
                },
                set: function (text) {
                    this._text = text;
                    var cachelen = 6 * 13 * this._text.length;
                    this.datar.splice(0, this.datar.length);
                    while (this.datar.length < cachelen) {
                        this.datar.push(0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
                    }
                    while (this.datar.length < cachelen) {
                        this.datar.pop();
                    }
                    this.dirtyData = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(label.prototype, "font", {
                get: function () {
                    return this._font;
                },
                set: function (font) {
                    if (this._font) {
                        this._font.unuse();
                    }
                    this._font = font;
                    this._font.use();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(label.prototype, "fontsize", {
                get: function () {
                    return this._fontsize;
                },
                set: function (size) {
                    this._fontsize = size;
                },
                enumerable: true,
                configurable: true
            });
            label.prototype.updateData = function (_font) {
                this.dirtyData = false;
                var rate = this._fontsize / _font.lineHeight;
                var m = this.transform.getWorldMatrix();
                var m11 = m.rawData[0];
                var m12 = m.rawData[2];
                var m21 = m.rawData[1];
                var m22 = m.rawData[3];
                var bx = this.data_begin.x;
                var by = this.data_begin.y;
                var txadd = 0;
                var tyadd = 0;
                this.indexarr = [];
                this.remainarrx = [];
                var remainy = 0;
                for (var i = 0; i < this._text.length; i++) {
                    var c = this._text.charAt(i);
                    var cinfo = _font.cmap[c];
                    if (cinfo == undefined) {
                        continue;
                    }
                    if (txadd + cinfo.xAddvance * rate > this.transform.width) {
                        if (tyadd + this._fontsize * this.linespace > this.transform.height) {
                            break;
                        }
                        else {
                            this.indexarr.push(i);
                            this.remainarrx.push(this.transform.width - txadd);
                            txadd = 0;
                            tyadd += this._fontsize * this.linespace;
                        }
                    }
                    txadd += cinfo.xAddvance * rate;
                }
                this.indexarr.push(i);
                this.remainarrx.push(this.transform.width - txadd);
                remainy = this.transform.height - tyadd;
                var i = 0;
                var xadd = 0;
                var yadd = 0;
                if (this.verticalType == VerticalType.Center) {
                    yadd += remainy / 2;
                }
                else if (this.verticalType == VerticalType.Boom) {
                    yadd += remainy;
                }
                for (var arri = 0; arri < this.indexarr.length; arri++) {
                    xadd = 0;
                    if (this.horizontalType == HorizontalType.Center) {
                        xadd += this.remainarrx[arri] / 2;
                    }
                    else if (this.horizontalType = HorizontalType.Right) {
                        xadd += this.remainarrx[arri];
                    }
                    for (; i < this.indexarr[arri]; i++) {
                        var c = this._text.charAt(i);
                        var cinfo = _font.cmap[c];
                        if (cinfo == undefined) {
                            continue;
                        }
                        var cx = xadd + cinfo.xOffset * rate;
                        var cy = yadd - cinfo.yOffset * rate + _font.baseline * rate;
                        var ch = rate * cinfo.ySize;
                        var cw = rate * cinfo.xSize;
                        xadd += cinfo.xAddvance * rate;
                        var x1 = cx + cw;
                        var y1 = cy;
                        var x2 = cx;
                        var y2 = cy + ch;
                        var x3 = cx + cw;
                        var y3 = cy + ch;
                        this.datar[i * 6 * 13 + 0] = bx + cx * m11 + cy * m12;
                        this.datar[i * 6 * 13 + 1] = by + cx * m21 + cy * m22;
                        this.datar[i * 6 * 13 + 13 * 1 + 0] = bx + x1 * m11 + y1 * m12;
                        this.datar[i * 6 * 13 + 13 * 1 + 1] = by + x1 * m21 + y1 * m22;
                        this.datar[i * 6 * 13 + 13 * 2 + 0] = bx + x2 * m11 + y2 * m12;
                        this.datar[i * 6 * 13 + 13 * 2 + 1] = by + x2 * m21 + y2 * m22;
                        this.datar[i * 6 * 13 + 13 * 3 + 0] = bx + x2 * m11 + y2 * m12;
                        this.datar[i * 6 * 13 + 13 * 3 + 1] = by + x2 * m21 + y2 * m22;
                        this.datar[i * 6 * 13 + 13 * 4 + 0] = bx + x1 * m11 + y1 * m12;
                        this.datar[i * 6 * 13 + 13 * 4 + 1] = by + x1 * m21 + y1 * m22;
                        this.datar[i * 6 * 13 + 13 * 5 + 0] = bx + x3 * m11 + y3 * m12;
                        this.datar[i * 6 * 13 + 13 * 5 + 1] = by + x3 * m21 + y3 * m22;
                        var u0 = cinfo.x;
                        var v0 = cinfo.y;
                        var u1 = cinfo.x + cinfo.w;
                        var v1 = cinfo.y;
                        var u2 = cinfo.x;
                        var v2 = cinfo.y + cinfo.h;
                        var u3 = cinfo.x + cinfo.w;
                        var v3 = cinfo.y + cinfo.h;
                        this.datar[i * 6 * 13 + 7] = u0;
                        this.datar[i * 6 * 13 + 8] = v0;
                        this.datar[i * 6 * 13 + 13 * 1 + 7] = u1;
                        this.datar[i * 6 * 13 + 13 * 1 + 8] = v1;
                        this.datar[i * 6 * 13 + 13 * 2 + 7] = u2;
                        this.datar[i * 6 * 13 + 13 * 2 + 8] = v2;
                        this.datar[i * 6 * 13 + 13 * 3 + 7] = u2;
                        this.datar[i * 6 * 13 + 13 * 3 + 8] = v2;
                        this.datar[i * 6 * 13 + 13 * 4 + 7] = u1;
                        this.datar[i * 6 * 13 + 13 * 4 + 8] = v1;
                        this.datar[i * 6 * 13 + 13 * 5 + 7] = u3;
                        this.datar[i * 6 * 13 + 13 * 5 + 8] = v3;
                        for (var j = 0; j < 6; j++) {
                            this.datar[i * 6 * 13 + 13 * j + 3] = this.color.r;
                            this.datar[i * 6 * 13 + 13 * j + 4] = this.color.g;
                            this.datar[i * 6 * 13 + 13 * j + 5] = this.color.b;
                            this.datar[i * 6 * 13 + 13 * j + 6] = this.color.a;
                            this.datar[i * 6 * 13 + 13 * j + 9] = this.color2.r;
                            this.datar[i * 6 * 13 + 13 * j + 10] = this.color2.g;
                            this.datar[i * 6 * 13 + 13 * j + 11] = this.color2.b;
                            this.datar[i * 6 * 13 + 13 * j + 12] = this.color2.a;
                        }
                    }
                    yadd += this._fontsize * this.linespace;
                }
            };
            label.prototype.render = function (canvas) {
                if (this._font != null) {
                    if (this.dirtyData = true) {
                        this.updateData(this._font);
                        this.dirtyData = false;
                    }
                    if (this.mat == null) {
                        this.mat = new framework.material();
                        this.mat.setShader(canvas.assetmgr.getShader("shader/defuifont"));
                    }
                    var img;
                    if (this._font != null) {
                        img = this._font.texture;
                    }
                    if (img == null) {
                        var scene = this.transform.canvas.scene;
                        img = scene.app.getAssetMgr().getDefaultTexture("grid");
                    }
                    this.mat.setTexture("_MainTex", img);
                    if (this.datar.length != 0) {
                        canvas.pushRawData(this.mat, this.datar);
                    }
                }
            };
            label.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var t = -this.transform.pivot.y * this.transform.height;
                this.data_begin.x = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                this.data_begin.y = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
            };
            label.prototype.start = function () {
            };
            label.prototype.update = function (delta) {
            };
            label.prototype.remove = function () {
                this._font.unuse(true);
                this.indexarr.length = 0;
                this.remainarrx.length = 0;
                this.datar.length = 0;
            };
            label.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            return label;
        }());
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], label.prototype, "text", null);
        __decorate([
            gd3d.reflect.Field("font"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [framework.font])
        ], label.prototype, "font", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], label.prototype, "fontsize", null);
        label = __decorate([
            gd3d.reflect.node2DComponent,
            gd3d.reflect.nodeRender
        ], label);
        framework.label = label;
        var HorizontalType;
        (function (HorizontalType) {
            HorizontalType[HorizontalType["Center"] = 0] = "Center";
            HorizontalType[HorizontalType["Left"] = 1] = "Left";
            HorizontalType[HorizontalType["Right"] = 2] = "Right";
        })(HorizontalType = framework.HorizontalType || (framework.HorizontalType = {}));
        var VerticalType;
        (function (VerticalType) {
            VerticalType[VerticalType["Center"] = 0] = "Center";
            VerticalType[VerticalType["Top"] = 1] = "Top";
            VerticalType[VerticalType["Boom"] = 2] = "Boom";
        })(VerticalType = framework.VerticalType || (framework.VerticalType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var rawImage2D = (function () {
            function rawImage2D() {
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
            }
            Object.defineProperty(rawImage2D.prototype, "image", {
                get: function () {
                    return this._image;
                },
                set: function (_image) {
                    if (this._image) {
                        this._image.unuse();
                    }
                    this._image = _image;
                    this._image.use();
                },
                enumerable: true,
                configurable: true
            });
            rawImage2D.prototype.render = function (canvas) {
                if (this.mat == null) {
                    this.mat = new framework.material();
                    this.mat.setShader(canvas.assetmgr.getShader("shader/defui"));
                }
                var img = this.image;
                if (img != null) {
                    this.mat.setTexture("_MainTex", img);
                    canvas.pushRawData(this.mat, this.datar);
                }
            };
            rawImage2D.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                this.datar[0 * 13] = x0;
                this.datar[0 * 13 + 1] = y0;
                this.datar[1 * 13] = x1;
                this.datar[1 * 13 + 1] = y1;
                this.datar[2 * 13] = x2;
                this.datar[2 * 13 + 1] = y2;
                this.datar[3 * 13] = x2;
                this.datar[3 * 13 + 1] = y2;
                this.datar[4 * 13] = x1;
                this.datar[4 * 13 + 1] = y1;
                this.datar[5 * 13] = x3;
                this.datar[5 * 13 + 1] = y3;
                for (var i = 0; i < 6; i++) {
                    this.datar[i * 13 + 3] = this.color.r;
                    this.datar[i * 13 + 4] = this.color.g;
                    this.datar[i * 13 + 5] = this.color.b;
                    this.datar[i * 13 + 6] = this.color.a;
                }
            };
            rawImage2D.prototype.start = function () {
            };
            rawImage2D.prototype.update = function (delta) {
            };
            rawImage2D.prototype.remove = function () {
                this._image.unuse(true);
            };
            rawImage2D.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            return rawImage2D;
        }());
        __decorate([
            gd3d.reflect.Field("texture"),
            __metadata("design:type", framework.texture)
        ], rawImage2D.prototype, "_image", void 0);
        __decorate([
            gd3d.reflect.Field("color"),
            gd3d.reflect.UIStyle("vector4"),
            __metadata("design:type", gd3d.math.color)
        ], rawImage2D.prototype, "color", void 0);
        __decorate([
            gd3d.reflect.Field("material"),
            gd3d.reflect.UIStyle("material"),
            __metadata("design:type", framework.material)
        ], rawImage2D.prototype, "mat", void 0);
        rawImage2D = __decorate([
            gd3d.reflect.node2DComponent,
            gd3d.reflect.nodeRender
        ], rawImage2D);
        framework.rawImage2D = rawImage2D;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var resID = (function () {
            function resID() {
                this.id = resID.next();
            }
            resID.next = function () {
                var next = resID.idAll;
                resID.idAll++;
                return next;
            };
            resID.prototype.getID = function () {
                return this.id;
            };
            return resID;
        }());
        resID.idAll = 1;
        framework.resID = resID;
        var constText = (function () {
            function constText(text) {
                this.name = text;
            }
            constText.prototype.getText = function () {
                return this.name;
            };
            return constText;
        }());
        constText = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], constText);
        framework.constText = constText;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetTypeEnum;
        (function (AssetTypeEnum) {
            AssetTypeEnum[AssetTypeEnum["Unknown"] = 0] = "Unknown";
            AssetTypeEnum[AssetTypeEnum["Auto"] = 1] = "Auto";
            AssetTypeEnum[AssetTypeEnum["Bundle"] = 2] = "Bundle";
            AssetTypeEnum[AssetTypeEnum["GLVertexShader"] = 3] = "GLVertexShader";
            AssetTypeEnum[AssetTypeEnum["GLFragmentShader"] = 4] = "GLFragmentShader";
            AssetTypeEnum[AssetTypeEnum["Shader"] = 5] = "Shader";
            AssetTypeEnum[AssetTypeEnum["Texture"] = 6] = "Texture";
            AssetTypeEnum[AssetTypeEnum["TextureDesc"] = 7] = "TextureDesc";
            AssetTypeEnum[AssetTypeEnum["Mesh"] = 8] = "Mesh";
            AssetTypeEnum[AssetTypeEnum["Prefab"] = 9] = "Prefab";
            AssetTypeEnum[AssetTypeEnum["Material"] = 10] = "Material";
            AssetTypeEnum[AssetTypeEnum["Aniclip"] = 11] = "Aniclip";
            AssetTypeEnum[AssetTypeEnum["Scene"] = 12] = "Scene";
            AssetTypeEnum[AssetTypeEnum["Atlas"] = 13] = "Atlas";
            AssetTypeEnum[AssetTypeEnum["Font"] = 14] = "Font";
            AssetTypeEnum[AssetTypeEnum["TextAsset"] = 15] = "TextAsset";
            AssetTypeEnum[AssetTypeEnum["PackBin"] = 16] = "PackBin";
            AssetTypeEnum[AssetTypeEnum["PackTxt"] = 17] = "PackTxt";
            AssetTypeEnum[AssetTypeEnum["pathAsset"] = 18] = "pathAsset";
        })(AssetTypeEnum = framework.AssetTypeEnum || (framework.AssetTypeEnum = {}));
        var stateLoad = (function () {
            function stateLoad() {
                this.iserror = false;
                this.isfinish = false;
                this.resstate = {};
                this.curtask = 0;
                this.totaltask = 0;
                this.logs = [];
                this.errs = [];
            }
            Object.defineProperty(stateLoad.prototype, "progress", {
                get: function () {
                    return this.curtask / this.totaltask;
                },
                enumerable: true,
                configurable: true
            });
            return stateLoad;
        }());
        framework.stateLoad = stateLoad;
        var assetBundle = (function () {
            function assetBundle(url) {
                this.files = [];
                this.packages = [];
                this.mapNamed = {};
                this.url = url;
                var i = url.lastIndexOf("/");
                this.path = url.substring(0, i);
            }
            assetBundle.prototype.parse = function (json) {
                var files = json["files"];
                for (var i = 0; i < files.length; i++) {
                    var item = files[i];
                    var packes = -1;
                    if (item.packes != undefined)
                        packes = item.packes;
                    this.files.push({ name: item.name, length: item.length, packes: packes });
                }
                if (json["packes"] != undefined) {
                    var packes = json["packes"];
                    for (var i = 0; i < packes.length; i++) {
                        this.packages.push(packes[i]);
                    }
                }
            };
            assetBundle.prototype.unload = function () {
                for (var key in this.mapNamed) {
                    var asset = this.assetmgr.getAssetByName(key, this.name);
                    if (asset) {
                        this.assetmgr.unuse(asset);
                    }
                }
                this.assetmgr.removeAssetBundle(this.name);
            };
            assetBundle.prototype.load = function (assetmgr, stateinfo) {
                var _this = this;
                var state = stateinfo.state;
                var onstate = stateinfo.onstate;
                var totoal = this.files.length;
                this.assetmgr = assetmgr;
                var glvshaders = [];
                var glfshaders = [];
                var shaders = [];
                var meshs = [];
                var textures = [];
                var texturedescs = [];
                var materials = [];
                var anclips = [];
                var prefabs = [];
                var scenes = [];
                var textassets = [];
                var mapPackes = {};
                for (var i = 0; i < this.files.length; i++) {
                    var fitem = this.files[i];
                    var type = assetmgr.calcType(fitem.name);
                    var url = this.path + "/" + fitem.name;
                    if (fitem.packes != -1) {
                        mapPackes[url] = fitem.packes;
                    }
                    {
                        if (type == AssetTypeEnum.GLFragmentShader)
                            glfshaders.push(url);
                        else if (type == AssetTypeEnum.GLVertexShader)
                            glvshaders.push(url);
                        else if (type == AssetTypeEnum.Shader)
                            shaders.push(url);
                        else if (type == AssetTypeEnum.Texture)
                            textures.push(url);
                        else if (type == AssetTypeEnum.TextureDesc)
                            texturedescs.push(url);
                        else if (type == AssetTypeEnum.Mesh)
                            meshs.push(url);
                        else if (type == AssetTypeEnum.Material)
                            materials.push(url);
                        else if (type == AssetTypeEnum.Aniclip)
                            anclips.push(url);
                        else if (type == AssetTypeEnum.Prefab)
                            prefabs.push(url);
                        else if (type == AssetTypeEnum.Scene)
                            scenes.push(url);
                        else if (type == AssetTypeEnum.TextAsset)
                            textassets.push(url);
                    }
                }
                var list = [];
                for (var i = 0; i < this.packages.length; i++) {
                    var pack = this.packages[i];
                    var type_1 = assetmgr.calcType(pack);
                    var url = this.path + "/" + pack;
                    list.push({ url: url, type: type_1 });
                }
                for (var i = 0; i < glvshaders.length; i++) {
                    list.push({ url: glvshaders[i], type: AssetTypeEnum.GLVertexShader });
                }
                for (var i = 0; i < glfshaders.length; i++) {
                    list.push({ url: glfshaders[i], type: AssetTypeEnum.GLFragmentShader });
                }
                for (var i = 0; i < shaders.length; i++) {
                    list.push({ url: shaders[i], type: AssetTypeEnum.Shader });
                }
                for (var i = 0; i < textures.length; i++) {
                    list.push({ url: textures[i], type: AssetTypeEnum.Texture });
                }
                for (var i = 0; i < texturedescs.length; i++) {
                    list.push({ url: texturedescs[i], type: AssetTypeEnum.TextureDesc });
                }
                for (var i = 0; i < meshs.length; i++) {
                    list.push({ url: meshs[i], type: AssetTypeEnum.Mesh });
                }
                for (var i = 0; i < materials.length; i++) {
                    list.push({ url: materials[i], type: AssetTypeEnum.Material });
                }
                for (var i = 0; i < anclips.length; i++) {
                    list.push({ url: anclips[i], type: AssetTypeEnum.Aniclip });
                }
                for (var i = 0; i < prefabs.length; i++) {
                    list.push({ url: prefabs[i], type: AssetTypeEnum.Prefab });
                }
                for (var i = 0; i < scenes.length; i++) {
                    list.push({ url: scenes[i], type: AssetTypeEnum.Scene });
                }
                for (var i = 0; i < textassets.length; i++) {
                    list.push({ url: textassets[i], type: AssetTypeEnum.TextAsset });
                }
                var realTotal = list.length;
                if (totoal > realTotal) {
                    console.log("assetBundlefile");
                }
                state.totaltask = realTotal + 1;
                state.curtask = 1;
                onstate(state);
                assetmgr.doWaitState(this.url, state);
                var loadcall = function () {
                    var surl = list[state.curtask - 1].url;
                    var type = list[state.curtask - 1].type;
                    if (mapPackes[surl] != undefined) {
                        assetmgr.loadResByPack(mapPackes[surl], surl, type, function (s) {
                            realTotal--;
                            state.curtask++;
                            var _fileName = assetmgr.getFileName(surl);
                            if (type != AssetTypeEnum.GLVertexShader && type != AssetTypeEnum.GLFragmentShader && type != AssetTypeEnum.Shader
                                && type != AssetTypeEnum.PackBin && type != AssetTypeEnum.PackTxt) {
                                var _res = s.resstate[_fileName].res;
                                _this.mapNamed[_fileName] = _res.getGUID();
                            }
                            if (realTotal === 0) {
                                state.isfinish = true;
                                onstate(state);
                                assetmgr.loadByQueue();
                            }
                            else {
                                onstate(state);
                                loadcall();
                            }
                            assetmgr.doWaitState(_this.url, state);
                        }, state);
                    }
                    else {
                        assetmgr.loadSingleRes(surl, type, function (s) {
                            realTotal--;
                            state.curtask++;
                            var _fileName = assetmgr.getFileName(surl);
                            if (type != AssetTypeEnum.GLVertexShader && type != AssetTypeEnum.GLFragmentShader && type != AssetTypeEnum.Shader
                                && type != AssetTypeEnum.PackBin && type != AssetTypeEnum.PackTxt) {
                                var _res = s.resstate[_fileName].res;
                                _this.mapNamed[_fileName] = _res.getGUID();
                            }
                            if (realTotal === 0) {
                                state.isfinish = true;
                                onstate(state);
                                assetmgr.loadByQueue();
                            }
                            else {
                                onstate(state);
                                loadcall();
                            }
                            assetmgr.doWaitState(_this.url, state);
                        }, state);
                    }
                };
                loadcall();
            };
            return assetBundle;
        }());
        framework.assetBundle = assetBundle;
        var assetMgr = (function () {
            function assetMgr(app) {
                this.mapShader = {};
                this.mapDefaultMesh = {};
                this.mapDefaultTexture = {};
                this.mapBundle = {};
                this.mapRes = {};
                this.mapNamed = {};
                this.mapInLoad = {};
                this.assetUrlDic = {};
                this.bundlePackBin = {};
                this.waitStateDic = {};
                this.queueState = [];
                this.app = app;
                this.webgl = app.webgl;
                this.shaderPool = new gd3d.render.shaderPool();
            }
            assetMgr.prototype.initDefAsset = function () {
                framework.defShader.initDefaultShader(this);
                framework.defMesh.initDefaultMesh(this);
                framework.defTexture.initDefaultTexture(this);
            };
            assetMgr.prototype.getShader = function (name) {
                return this.mapShader[name];
            };
            assetMgr.prototype.getDefaultMesh = function (name) {
                return this.mapDefaultMesh[name];
            };
            assetMgr.prototype.getDefaultTexture = function (name) {
                return this.mapDefaultTexture[name];
            };
            assetMgr.prototype.getAsset = function (id) {
                var r = this.mapRes[id];
                if (r == null)
                    return null;
                return r.asset;
            };
            assetMgr.prototype.getAssetByName = function (name, bundlename) {
                if (bundlename === void 0) { bundlename = null; }
                if (this.mapNamed[name] == null)
                    return null;
                var id = this.mapNamed[name][0];
                if (bundlename != null) {
                    var assetbundle = this.mapBundle[bundlename];
                    if (assetbundle != null)
                        id = assetbundle.mapNamed[name];
                }
                if (id == null)
                    return null;
                var r = this.mapRes[id];
                if (r == null)
                    return null;
                return r.asset;
            };
            assetMgr.prototype.getAssetBundle = function (bundlename) {
                if (this.mapBundle[bundlename])
                    return this.mapBundle[bundlename];
                return null;
            };
            assetMgr.prototype.unuse = function (res, disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                var id = res.getGUID();
                var name = res.getName();
                if (res.defaultAsset) {
                    return;
                }
                this.mapRes[id].refcount--;
                if (disposeNow && this.mapRes[id].refcount <= 0) {
                    this.mapRes[id].asset.dispose();
                    if (name != null) {
                        if (this.mapNamed[name].length <= 1) {
                            delete this.mapNamed[name];
                        }
                        else {
                            for (var key in this.mapNamed[name]) {
                                if (id == this.mapNamed[name][key]) {
                                    this.mapNamed[name].splice(parseInt(key), 1);
                                }
                            }
                        }
                    }
                    delete this.mapRes[id];
                }
            };
            assetMgr.prototype.use = function (res) {
                var id = res.getGUID();
                var name = res.getName();
                if (id <= 0) {
                    throw new Error("res guid:" + name);
                }
                if (res.defaultAsset) {
                    return;
                }
                if (this.mapRes[id] == null) {
                    this.mapRes[id] = { asset: res, refcount: 0 };
                    if (name != null) {
                        if (this.mapNamed[name] == null)
                            this.mapNamed[name] = [];
                        this.mapNamed[name].push(id);
                    }
                }
                this.mapRes[id].refcount++;
            };
            assetMgr.prototype.releaseUnuseAsset = function () {
                for (var k in this.mapRes) {
                    if (this.mapRes[k].refcount <= 0) {
                        var name_1 = this.mapRes[k].asset.getName();
                        if (this.mapNamed[name_1].length <= 1) {
                            delete this.mapNamed[name_1];
                        }
                        else {
                            for (var key in this.mapNamed[name_1]) {
                                if (this.mapRes[k].asset.getGUID() == this.mapNamed[name_1][key]) {
                                    this.mapNamed[name_1].splice(parseInt(key), 1);
                                }
                            }
                        }
                        this.mapRes[k].asset.dispose();
                        delete this.mapRes[k];
                    }
                }
            };
            assetMgr.prototype.getAssetsRefcount = function () {
                var mapRefcout = {};
                for (var k in this.mapNamed) {
                    if (this.mapNamed[k].length == 1) {
                        var res = this.mapRes[this.mapNamed[k][0]];
                        mapRefcout[k] = res.refcount;
                    }
                    else {
                        for (var key in this.mapNamed[k]) {
                            var res = this.mapRes[this.mapNamed[k][key]];
                            mapRefcout[k + "(" + key + ")"] = res.refcount;
                        }
                    }
                }
                return mapRefcout;
            };
            assetMgr.prototype.nameDuplicateCheck = function (name) {
                return true;
            };
            assetMgr.prototype.removeAssetBundle = function (name) {
                if (this.mapBundle[name] != null)
                    delete this.mapBundle[name];
                if (this.mapInLoad[name] != null)
                    delete this.mapInLoad[name];
            };
            assetMgr.prototype.getAssetUrl = function (asset) {
                return this.assetUrlDic[asset.getGUID()];
            };
            assetMgr.prototype.loadResByPack = function (packnum, url, type, onstate, state) {
                var _this = this;
                var bundlename = this.getFileName(state.url);
                var filename = this.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                var respack;
                if (packnum == 0) {
                    respack = this.bundlePackJson;
                }
                else {
                    respack = this.bundlePackBin;
                }
                if (type == AssetTypeEnum.GLVertexShader) {
                    state.resstate[filename] = { state: 0, res: null };
                    var txt = this.bundlePackJson[filename];
                    txt = decodeURI(txt);
                    state.resstate[filename].state = 1;
                    state.logs.push("load a glshader:" + filename);
                    this.shaderPool.compileVS(this.webgl, name, txt);
                    onstate(state);
                }
                else if (type == AssetTypeEnum.GLFragmentShader) {
                    state.resstate[filename] = { state: 0, res: null };
                    var txt = this.bundlePackJson[filename];
                    txt = decodeURI(txt);
                    state.resstate[filename].state = 1;
                    state.logs.push("load a glshader:" + filename);
                    this.shaderPool.compileFS(this.webgl, name, txt);
                    onstate(state);
                }
                else if (type == AssetTypeEnum.Shader) {
                    state.resstate[filename] = { state: 0, res: null };
                    var txt = this.bundlePackJson[filename];
                    state.resstate[filename].state = 1;
                    var _shader = new framework.shader(filename);
                    _shader.parse(this, JSON.parse(txt));
                    this.assetUrlDic[_shader.getGUID()] = url;
                    this.mapShader[filename] = _shader;
                    onstate(state);
                }
                else if (type == AssetTypeEnum.TextureDesc) {
                    var txt = this.bundlePackJson[filename];
                    var _texturedesc = JSON.parse(txt);
                    var _name = _texturedesc["name"];
                    var _filterMode = _texturedesc["filterMode"];
                    var _format = _texturedesc["format"];
                    var _mipmap = _texturedesc["mipmap"];
                    var _wrap = _texturedesc["wrap"];
                    var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                    if (_format == "RGB") {
                        _textureFormat = gd3d.render.TextureFormatEnum.RGB;
                    }
                    else if (_format == "Gray") {
                        _textureFormat = gd3d.render.TextureFormatEnum.Gray;
                    }
                    var _linear = true;
                    if (_filterMode.indexOf("linear") < 0) {
                        _linear = false;
                    }
                    var _repeat = false;
                    if (_wrap.indexOf("Repeat") >= 0) {
                        _repeat = true;
                    }
                    var _textureSrc = url.replace(filename, _name);
                    state.resstate[filename] = { state: 0, res: null };
                    var img = new Image();
                    img.src = _textureSrc;
                    img.crossOrigin = "anonymous";
                    img.onerror = function (error) {
                        if (error != null) {
                            state.errs.push(new Error("img load failed:" + filename + ". message:" + error.message));
                            state.iserror = true;
                            onstate(state);
                        }
                    };
                    img.onload = function () {
                        var _texture = new framework.texture(filename);
                        _texture.realName = _name;
                        _this.assetUrlDic[_texture.getGUID()] = url;
                        var t2d = new gd3d.render.glTexture2D(_this.webgl, _textureFormat);
                        t2d.uploadImage(img, _mipmap, _linear, true, _repeat);
                        _texture.glTexture = t2d;
                        _this.use(_texture);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _texture;
                        onstate(state);
                    };
                }
                else if (type == AssetTypeEnum.Material) {
                    state.resstate[filename] = { state: 0, res: null };
                    var txt = this.bundlePackJson[filename];
                    state.resstate[filename].state = 1;
                    var _material = new framework.material(filename);
                    _material.Parse(this, JSON.parse(txt));
                    this.assetUrlDic[_material.getGUID()] = url;
                    this.use(_material);
                    state.resstate[filename].state = 1;
                    state.resstate[filename].res = _material;
                    onstate(state);
                }
                else if (type == AssetTypeEnum.Mesh) {
                    state.resstate[filename] = { state: 0, res: null };
                    var _buffer = this.bundlePackBin[filename];
                    var _mesh = new framework.mesh(filename);
                    this.assetUrlDic[_mesh.getGUID()] = url;
                    _mesh.Parse(_buffer, this.webgl);
                    this.use(_mesh);
                    state.resstate[filename].state = 1;
                    state.resstate[filename].res = _mesh;
                    onstate(state);
                }
                else if (type == AssetTypeEnum.Aniclip) {
                    state.resstate[filename] = { state: 0, res: null };
                    var _buffer = this.bundlePackBin[filename];
                    var _clip = new framework.animationClip(filename);
                    this.assetUrlDic[_clip.getGUID()] = url;
                    _clip.Parse(_buffer);
                    this.use(_clip);
                    state.resstate[filename].state = 1;
                    state.resstate[filename].res = _clip;
                    onstate(state);
                }
                else if (type == AssetTypeEnum.Atlas) {
                    state.resstate[filename] = { state: 0, res: null };
                    var txt = this.bundlePackJson[filename];
                    var _atlas = new framework.atlas(filename);
                    this.assetUrlDic[_atlas.getGUID()] = url;
                    _atlas.Parse(txt, this);
                    this.use(_atlas);
                    state.resstate[filename].state = 1;
                    state.resstate[filename].res = _atlas;
                    onstate(state);
                }
                else if (type == AssetTypeEnum.Prefab) {
                    state.resstate[filename] = { state: 0, res: null };
                    var txt = this.bundlePackJson[filename];
                    var _prefab = new framework.prefab(filename);
                    _prefab.assetbundle = bundlename;
                    this.assetUrlDic[_prefab.getGUID()] = url;
                    _prefab.Parse(txt, this);
                    this.use(_prefab);
                    state.resstate[filename].state = 1;
                    state.resstate[filename].res = _prefab;
                    onstate(state);
                }
                else if (type == AssetTypeEnum.Scene) {
                    state.resstate[filename] = { state: 0, res: null };
                    var txt = this.bundlePackJson[filename];
                    var _scene = new framework.rawscene(filename);
                    _scene.assetbundle = bundlename;
                    this.assetUrlDic[_scene.getGUID()] = url;
                    _scene.Parse(txt, this);
                    this.use(_scene);
                    state.resstate[filename].state = 1;
                    state.resstate[filename].res = _scene;
                    onstate(state);
                }
                else if (type == AssetTypeEnum.Font) {
                    state.resstate[filename] = { state: 0, res: null };
                    var txt = this.bundlePackJson[filename];
                    var _font = new framework.font(filename);
                    this.assetUrlDic[_font.getGUID()] = url;
                    _font.Parse(txt, this);
                    this.use(_font);
                    state.resstate[filename].state = 1;
                    state.resstate[filename].res = _font;
                    onstate(state);
                }
                else if (type == AssetTypeEnum.TextAsset) {
                    state.resstate[filename] = { state: 0, res: null };
                    var txt = this.bundlePackJson[filename];
                    var _textasset = new framework.textasset(filename);
                    this.assetUrlDic[_textasset.getGUID()] = url;
                    _textasset.content = txt;
                    this.use(_textasset);
                    state.resstate[filename].state = 1;
                    state.resstate[filename].res = _textasset;
                    onstate(state);
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
            };
            assetMgr.prototype.loadSingleRes = function (url, type, onstate, state) {
                var _this = this;
                var bundlename = this.getFileName(state.url);
                var filename = this.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                if (type == AssetTypeEnum.PackBin) {
                    gd3d.io.loadArrayBuffer(url, function (_buffer, err) {
                        var read = new gd3d.io.binReader(_buffer);
                        var index = read.readInt32();
                        read.position = index;
                        while (read.canread()) {
                            var indindex = read.readInt32();
                            if (index == 0)
                                break;
                            var key = read.readStringUtf8FixLength(indindex);
                            var strs = key.split('|');
                            var start = parseInt(strs[1]);
                            var len = parseInt(strs[2]);
                            var bufs = _buffer.slice(start, start + len);
                            _this.bundlePackBin[strs[0]] = bufs;
                        }
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.PackTxt) {
                    gd3d.io.loadArrayBuffer(url, function (_buffer, err) {
                        var read = new gd3d.io.binReader(_buffer);
                        var arr = new Uint8Array(_buffer.byteLength);
                        read.readUint8Array(arr);
                        var txt = gd3d.io.binReader.utf8ArrayToString(arr);
                        _this.bundlePackJson = JSON.parse(txt);
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.GLVertexShader) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadText(url, function (txt, err) {
                        state.resstate[filename].state = 1;
                        state.logs.push("load a glshader:" + filename);
                        _this.shaderPool.compileVS(_this.webgl, name, txt);
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.GLFragmentShader) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadText(url, function (txt, err) {
                        state.resstate[filename].state = 1;
                        state.logs.push("load a glshader:" + filename);
                        _this.shaderPool.compileFS(_this.webgl, name, txt);
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.Shader) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadText(url, function (txt, err) {
                        state.resstate[filename].state = 1;
                        var _shader = new framework.shader(filename);
                        _shader.parse(_this, JSON.parse(txt));
                        _this.assetUrlDic[_shader.getGUID()] = url;
                        _this.mapShader[filename] = _shader;
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.Texture) {
                    state.resstate[filename] = { state: 0, res: null };
                    var img = new Image();
                    img.src = url;
                    img.crossOrigin = "anonymous";
                    img.onerror = function (error) {
                        if (error != null) {
                            state.errs.push(new Error("img load failed:" + filename + ". message:" + error.message));
                            state.iserror = true;
                            onstate(state);
                        }
                    };
                    img.onload = function () {
                        var _texture = new framework.texture(filename);
                        _this.assetUrlDic[_texture.getGUID()] = url;
                        var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                        var t2d = new gd3d.render.glTexture2D(_this.webgl, _textureFormat);
                        t2d.uploadImage(img, true, true, true, true);
                        _texture.glTexture = t2d;
                        _this.use(_texture);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _texture;
                        onstate(state);
                    };
                }
                else if (type == AssetTypeEnum.TextureDesc) {
                    gd3d.io.loadText(url, function (txt, err) {
                        var _texturedesc = JSON.parse(txt);
                        var _name = _texturedesc["name"];
                        var _filterMode = _texturedesc["filterMode"];
                        var _format = _texturedesc["format"];
                        var _mipmap = _texturedesc["mipmap"];
                        var _wrap = _texturedesc["wrap"];
                        var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                        if (_format == "RGB") {
                            _textureFormat = gd3d.render.TextureFormatEnum.RGB;
                        }
                        else if (_format == "Gray") {
                            _textureFormat = gd3d.render.TextureFormatEnum.Gray;
                        }
                        var _linear = true;
                        if (_filterMode.indexOf("linear") < 0) {
                            _linear = false;
                        }
                        var _repeat = false;
                        if (_wrap.indexOf("Repeat") >= 0) {
                            _repeat = true;
                        }
                        var _textureSrc = url.replace(filename, _name);
                        state.resstate[filename] = { state: 0, res: null };
                        var img = new Image();
                        img.src = _textureSrc;
                        img.crossOrigin = "anonymous";
                        img.onerror = function (error) {
                            if (error != null) {
                                state.errs.push(new Error("img load failed:" + filename + ". message:" + error.message));
                                state.iserror = true;
                                onstate(state);
                            }
                        };
                        img.onload = function () {
                            var _texture = new framework.texture(filename);
                            _texture.realName = _name;
                            _this.assetUrlDic[_texture.getGUID()] = url;
                            var t2d = new gd3d.render.glTexture2D(_this.webgl, _textureFormat);
                            t2d.uploadImage(img, _mipmap, _linear, true, _repeat);
                            _texture.glTexture = t2d;
                            _this.use(_texture);
                            state.resstate[filename].state = 1;
                            state.resstate[filename].res = _texture;
                            onstate(state);
                        };
                    });
                }
                else if (type == AssetTypeEnum.Material) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadText(url, function (txt, err) {
                        state.resstate[filename].state = 1;
                        var _material = new framework.material(filename);
                        _material.Parse(_this, JSON.parse(txt));
                        _this.assetUrlDic[_material.getGUID()] = url;
                        _this.use(_material);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _material;
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.Mesh) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadArrayBuffer(url, function (_buffer, err) {
                        var _mesh = new framework.mesh(filename);
                        _this.assetUrlDic[_mesh.getGUID()] = url;
                        _mesh.Parse(_buffer, _this.webgl);
                        _this.use(_mesh);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _mesh;
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.Aniclip) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadArrayBuffer(url, function (_buffer, err) {
                        var _clip = new framework.animationClip(filename);
                        _this.assetUrlDic[_clip.getGUID()] = url;
                        _clip.Parse(_buffer);
                        _this.use(_clip);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _clip;
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.Atlas) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadText(url, function (txt, err) {
                        var _atlas = new framework.atlas(filename);
                        _this.assetUrlDic[_atlas.getGUID()] = url;
                        _atlas.Parse(txt, _this);
                        _this.use(_atlas);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _atlas;
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.Prefab) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadText(url, function (txt, err) {
                        var _prefab = new framework.prefab(filename);
                        _prefab.assetbundle = bundlename;
                        _this.assetUrlDic[_prefab.getGUID()] = url;
                        _prefab.Parse(txt, _this);
                        _this.use(_prefab);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _prefab;
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.Scene) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadText(url, function (txt, err) {
                        var _scene = new framework.rawscene(filename);
                        _scene.assetbundle = bundlename;
                        _this.assetUrlDic[_scene.getGUID()] = url;
                        _scene.Parse(txt, _this);
                        _this.use(_scene);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _scene;
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.Font) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadText(url, function (txt, err) {
                        var _font = new framework.font(filename);
                        _this.assetUrlDic[_font.getGUID()] = url;
                        _font.Parse(txt, _this);
                        _this.use(_font);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _font;
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.TextAsset) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadText(url, function (txt, err) {
                        var _textasset = new framework.textasset(filename);
                        _this.assetUrlDic[_textasset.getGUID()] = url;
                        _textasset.content = txt;
                        _this.use(_textasset);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _textasset;
                        onstate(state);
                    });
                }
                else if (type == AssetTypeEnum.pathAsset) {
                    state.resstate[filename] = { state: 0, res: null };
                    gd3d.io.loadText(url, function (txt, err) {
                        var _path = new framework.pathasset(filename);
                        _this.assetUrlDic[_path.getGUID()] = url;
                        _path.Parse(JSON.parse(txt));
                        _this.use(_path);
                        state.resstate[filename].state = 1;
                        state.resstate[filename].res = _path;
                        onstate(state);
                    });
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
            };
            assetMgr.prototype.doWaitState = function (name, state) {
                if (this.waitStateDic[name] == null)
                    return;
                for (var key in this.waitStateDic[name]) {
                    this.waitStateDic[name][key](state);
                }
                if (state.isfinish) {
                    this.waitStateDic[name].length = 0;
                }
            };
            assetMgr.prototype.loadByQueue = function () {
                var _this = this;
                if (this.curloadinfo != null) {
                    if (!this.curloadinfo.state.isfinish)
                        return;
                    else {
                        this.curloadinfo = null;
                        this.bundlePackBin = {};
                        this.bundlePackJson = null;
                    }
                }
                if (this.queueState.length == 0)
                    return;
                this.curloadinfo = this.queueState.shift();
                var state = this.curloadinfo.state;
                var url = state.url;
                var type = this.curloadinfo.type;
                var onstate = this.curloadinfo.onstate;
                if (type == AssetTypeEnum.Bundle) {
                    gd3d.io.loadText(url, function (txt, err) {
                        var filename = _this.getFileName(url);
                        var ab = new assetBundle(url);
                        ab.name = filename;
                        ab.parse(JSON.parse(txt));
                        ab.load(_this, _this.curloadinfo);
                        _this.mapBundle[filename] = ab;
                    });
                }
                else {
                    state.totaltask = 1;
                    this.loadSingleRes(url, type, function (s) {
                        state.curtask = 1;
                        s.isfinish = true;
                        onstate(s);
                        _this.doWaitState(url, s);
                        _this.loadByQueue();
                    }, state);
                }
            };
            assetMgr.prototype.load = function (url, type, onstate) {
                if (type === void 0) { type = AssetTypeEnum.Auto; }
                if (onstate === void 0) { onstate = null; }
                if (onstate == null)
                    onstate = function () { };
                var name = this.getFileName(url);
                if (this.mapInLoad[name] != null) {
                    var _state = this.mapInLoad[name];
                    if (_state.isfinish) {
                        onstate(this.mapInLoad[name]);
                    }
                    else {
                        if (this.waitStateDic[name] == null)
                            this.waitStateDic[name] = [];
                        this.waitStateDic[name].push(onstate);
                    }
                    return;
                }
                var state = new stateLoad();
                this.mapInLoad[name] = state;
                state.url = url;
                if (type == AssetTypeEnum.Auto) {
                    type = this.calcType(url);
                }
                if (type == AssetTypeEnum.Unknown) {
                    state.errs.push(new Error("can not sure about type:" + url));
                    state.iserror = true;
                    onstate(state);
                    this.doWaitState(url, state);
                    return;
                }
                this.queueState.push({ state: state, type: type, onstate: onstate });
                this.loadByQueue();
            };
            assetMgr.prototype.unload = function (url, onstate) {
                if (onstate === void 0) { onstate = null; }
                var name = this.getFileName(url);
                if (this.mapInLoad[name] == null)
                    return;
                var state = this.mapInLoad[name];
                for (var key in state.resstate) {
                    state.resstate[key].res.unuse();
                }
                delete this.mapInLoad[name];
            };
            assetMgr.prototype.loadScene = function (sceneName, onComplete) {
                if (sceneName.length > 0) {
                    var _rawscene = this.getAssetByName(sceneName);
                    var willLoadRoot = _rawscene.getSceneRoot();
                    while (willLoadRoot.children.length > 0) {
                        this.app.getScene().addChild(willLoadRoot.children.shift());
                    }
                    _rawscene.useLightMap(this.app.getScene());
                }
                else {
                    var _camera = new framework.transform();
                    _camera.gameObject.addComponent("camera");
                    _camera.name = "camera";
                    this.app.getScene().addChild(_camera);
                }
                this.app.getScene().name = sceneName;
                this.app.getScene().getRoot().markDirty();
                onComplete();
            };
            assetMgr.prototype.saveScene = function (fun) {
                gd3d.io.SerializeDependent.resoursePaths = [];
                var info = new SaveInfo();
                var _scene = {};
                var _rootNode = gd3d.io.serializeObj(this.app.getScene().getRoot(), this);
                var _lightmaps = [];
                var lightmaps = this.app.getScene().lightmaps;
                for (var str in lightmaps) {
                    var _lightmap = {};
                    _lightmap["name"] = lightmaps[str].getName();
                    _lightmaps.push(_lightmap);
                }
                _scene["rootNode"] = _rootNode;
                _scene["lightmap"] = _lightmaps;
                var _sceneStr = JSON.stringify(_scene);
                var _rawscene = this.getAssetByName(this.app.getScene().name);
                _rawscene.Parse(_sceneStr, this);
                var url = this.getAssetUrl(_rawscene);
                info.files[url] = _sceneStr;
                fun(info, gd3d.io.SerializeDependent.resoursePaths);
            };
            assetMgr.prototype.savePrefab = function (trans, prefabName, fun) {
                gd3d.io.SerializeDependent.resoursePaths = [];
                var info = new SaveInfo();
                var _prefab = this.getAssetByName(prefabName);
                _prefab.apply(trans);
                var _rootTrans = gd3d.io.serializeObj(trans, null, this);
                var url = this.getAssetUrl(_prefab);
                info.files[url] = JSON.stringify(_rootTrans);
                fun(info, gd3d.io.SerializeDependent.resoursePaths);
            };
            assetMgr.prototype.saveMaterial = function (mat, fun) {
                var info = new SaveInfo();
                var data = {};
                var mapUniform = {};
                var shader = mat.getShader();
                var shaderPropertis = shader.defaultValue;
                data["shader"] = shader.getName();
                data["mapUniform"] = mapUniform;
                for (var key in shaderPropertis) {
                    if (mat.mapUniform[key] != undefined) {
                        var propertyDdata = {};
                        var uniformData = mat.mapUniform[key];
                        propertyDdata["type"] = uniformData.type;
                        switch (uniformData.type) {
                            case gd3d.render.UniformTypeEnum.Texture:
                                propertyDdata["value"] = uniformData.value != null ? uniformData.value.name.name : "";
                                break;
                            case gd3d.render.UniformTypeEnum.Float4:
                                propertyDdata["value"] = uniformData.value;
                                break;
                            case gd3d.render.UniformTypeEnum.Float:
                                propertyDdata["value"] = uniformData.value;
                                break;
                        }
                        mapUniform[key] = propertyDdata;
                    }
                }
                var url = this.getAssetUrl(mat);
                info.files[url] = JSON.stringify(data);
                fun(info);
            };
            assetMgr.prototype.loadSingleResImmediate = function (url, type) {
                var _this = this;
                var result;
                var filename = this.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                if (type == AssetTypeEnum.GLVertexShader) {
                    gd3d.io.loadText(url, function (txt, err) {
                        _this.shaderPool.compileVS(_this.webgl, name, txt);
                    });
                }
                else if (type == AssetTypeEnum.GLFragmentShader) {
                    gd3d.io.loadText(url, function (txt, err) {
                        _this.shaderPool.compileFS(_this.webgl, name, txt);
                    });
                }
                else if (type == AssetTypeEnum.Shader) {
                    result = new framework.shader(filename);
                    gd3d.io.loadText(url, function (txt, err) {
                        result.parse(_this, JSON.parse(txt));
                        _this.mapShader[filename] = result;
                    });
                }
                else if (type == AssetTypeEnum.Texture) {
                    result = new framework.texture(filename);
                    var img = new Image();
                    img.src = url;
                    img.onload = function () {
                        var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                        result.glTexture = new gd3d.render.glTexture2D(_this.webgl, _textureFormat);
                        result.glTexture.uploadImage(img, false, false);
                        _this.use(result);
                    };
                }
                else if (type == AssetTypeEnum.Mesh) {
                    result = new framework.mesh(filename);
                    gd3d.io.loadArrayBuffer(url, function (txt, err) {
                        result.Parse(txt, _this.webgl);
                        _this.use(result);
                    });
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
                return result;
            };
            assetMgr.prototype.loadImmediate = function (url, type) {
                if (type === void 0) { type = AssetTypeEnum.Auto; }
                var result;
                if (type == AssetTypeEnum.Auto) {
                    type = this.calcType(url);
                }
                if (type == AssetTypeEnum.Unknown) {
                    throw new Error("unknown format");
                }
                else if (type == AssetTypeEnum.Bundle) {
                    result = new assetBundle(url);
                    gd3d.io.loadText(url, function (txt, err) {
                        result.parse(JSON.parse(txt));
                    });
                }
                else {
                    result = this.loadSingleResImmediate(url, type);
                }
                return result;
            };
            assetMgr.prototype.getFileName = function (url) {
                var filei = url.lastIndexOf("/");
                var file = url.substr(filei + 1);
                return file;
            };
            assetMgr.prototype.calcType = function (url) {
                var filei = url.lastIndexOf("/");
                var file = url.substr(filei + 1);
                var i = file.indexOf(".", 0);
                var extname = null;
                while (i >= 0) {
                    extname = file.substr(i);
                    if (extname == ".vs.glsl") {
                        return AssetTypeEnum.GLVertexShader;
                    }
                    else if (extname == ".assetbundle.json") {
                        return AssetTypeEnum.Bundle;
                    }
                    else if (extname == ".fs.glsl") {
                        return AssetTypeEnum.GLFragmentShader;
                    }
                    else if (extname == ".shader.json") {
                        return AssetTypeEnum.Shader;
                    }
                    else if (extname == ".png" || extname == ".jpg") {
                        return AssetTypeEnum.Texture;
                    }
                    else if (extname == ".imgdesc.json") {
                        return AssetTypeEnum.TextureDesc;
                    }
                    else if (extname == ".mat.json") {
                        return AssetTypeEnum.Material;
                    }
                    else if (extname == ".mesh.bin") {
                        return AssetTypeEnum.Mesh;
                    }
                    else if (extname == ".aniclip.bin") {
                        return AssetTypeEnum.Aniclip;
                    }
                    else if (extname == ".prefab.json") {
                        return AssetTypeEnum.Prefab;
                    }
                    else if (extname == ".scene.json") {
                        return AssetTypeEnum.Scene;
                    }
                    else if (extname == ".atlas.json") {
                        return AssetTypeEnum.Atlas;
                    }
                    else if (extname == ".font.json") {
                        return AssetTypeEnum.Font;
                    }
                    else if (extname == ".json" || extname == ".txt" || extname == ".effect.json") {
                        return AssetTypeEnum.TextAsset;
                    }
                    else if (extname == ".packs.bin") {
                        return AssetTypeEnum.PackBin;
                    }
                    else if (extname == ".packs.txt") {
                        return AssetTypeEnum.PackTxt;
                    }
                    else if (extname == ".path.json") {
                        return AssetTypeEnum.pathAsset;
                    }
                    i = file.indexOf(".", i + 1);
                }
                return AssetTypeEnum.Unknown;
            };
            return assetMgr;
        }());
        framework.assetMgr = assetMgr;
        var assetRef = (function () {
            function assetRef() {
            }
            return assetRef;
        }());
        framework.assetRef = assetRef;
        var SaveInfo = (function () {
            function SaveInfo() {
                this.files = {};
            }
            return SaveInfo;
        }());
        framework.SaveInfo = SaveInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defMesh = (function () {
            function defMesh() {
            }
            defMesh.initDefaultMesh = function (assetmgr) {
                assetmgr.mapDefaultMesh["cube"] = defMesh.createDefaultMesh("cube", gd3d.render.meshData.genBoxCCW(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["quad"] = defMesh.createDefaultMesh("circleline", gd3d.render.meshData.genQuad(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["plane"] = defMesh.createDefaultMesh("plane", gd3d.render.meshData.genPlaneCCW(10), assetmgr.webgl);
                assetmgr.mapDefaultMesh["sphere"] = defMesh.createDefaultMesh("sphere", gd3d.render.meshData.genSphereCCW(), assetmgr.webgl);
                assetmgr.mapDefaultMesh["pyramid"] = defMesh.createDefaultMesh("pyramid", gd3d.render.meshData.genPyramid(2, 0.5), assetmgr.webgl);
                assetmgr.mapDefaultMesh["cylinder"] = defMesh.createDefaultMesh("cylinder", gd3d.render.meshData.genCylinderCCW(2, 0.5), assetmgr.webgl);
                assetmgr.mapDefaultMesh["circleline"] = defMesh.createDefaultMesh("circleline", gd3d.render.meshData.genCircleLineCCW(1), assetmgr.webgl);
            };
            defMesh.createDefaultMesh = function (name, meshData, webgl) {
                var _mesh = new framework.mesh(name + ".mesh.bin");
                _mesh.defaultAsset = true;
                _mesh.data = meshData;
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArray();
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexSubData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = false;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            return defMesh;
        }());
        framework.defMesh = defMesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defShader = (function () {
            function defShader() {
            }
            defShader.initDefaultShader = function (assetmgr) {
                var pool = assetmgr.shaderPool;
                pool.compileVS(assetmgr.webgl, "def", defShader.vscode);
                pool.compileFS(assetmgr.webgl, "def", defShader.fscode);
                pool.compileFS(assetmgr.webgl, "def2", defShader.fscode2);
                pool.compileFS(assetmgr.webgl, "defui", defShader.fscodeui);
                pool.compileVS(assetmgr.webgl, "defuifont", defShader.vscodeuifont);
                pool.compileFS(assetmgr.webgl, "defuifont", defShader.fscodeuifont);
                pool.compileVS(assetmgr.webgl, "diffuse", defShader.vsdiffuse);
                pool.compileFS(assetmgr.webgl, "diffuse", defShader.fsdiffuse);
                var program = pool.linkProgram(assetmgr.webgl, "def", "def");
                var program2 = pool.linkProgram(assetmgr.webgl, "def", "defui");
                var programuifont = pool.linkProgram(assetmgr.webgl, "defuifont", "defuifont");
                var programdiffuse = pool.linkProgram(assetmgr.webgl, "diffuse", "diffuse");
                {
                    var sh = new framework.shader("shader/def");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.state_ztest = true;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                    p.setProgram(program);
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    p.uniformTexture("_MainTex", null);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/def3dbeforeui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.state_ztest = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = false;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                    p.setProgram(programdiffuse);
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    p.uniformTexture("_MainTex", null);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/def2");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(program2);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(program2);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend_PreMultiply);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defuifont");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(programuifont);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend_PreMultiply);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
            };
            return defShader;
        }());
        defShader.vscode = "\
    attribute vec4 _glesVertex;   \
    attribute vec4 _glesColor;                  \
    attribute vec4 _glesMultiTexCoord0;         \
    uniform highp mat4 glstate_matrix_mvp;      \
    varying lowp vec4 xlv_COLOR;                \
    varying highp vec2 xlv_TEXCOORD0;           \
    void main()                                     \
    {                                               \
        highp vec4 tmpvar_1;                        \
        tmpvar_1.w = 1.0;                           \
        tmpvar_1.xyz = _glesVertex.xyz;             \
        xlv_COLOR = _glesColor;                     \
        xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;     \
        gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
    }";
        defShader.fscode = "         \
    uniform sampler2D _MainTex;                                                 \
    varying lowp vec4 xlv_COLOR;                                                 \
    varying highp vec2 xlv_TEXCOORD0;   \
    void main() \
    {\
        lowp vec4 col_1;    \
        mediump vec4 prev_2;\
        lowp vec4 tmpvar_3;\
        tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\
        prev_2 = tmpvar_3;\
        mediump vec4 tmpvar_4;\
        tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\
        col_1 = tmpvar_4;\
        col_1.x =xlv_TEXCOORD0.x;\
        col_1.y =xlv_TEXCOORD0.y;\
        gl_FragData[0] = col_1;\
    }\
    ";
        defShader.fscode2 = "         \
    void main() \
    {\
        gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);\
    }\
    ";
        defShader.fscodeui = "         \
    uniform sampler2D _MainTex;                                                 \
    varying lowp vec4 xlv_COLOR;                                                 \
    varying highp vec2 xlv_TEXCOORD0;   \
    void main() \
    {\
        lowp vec4 tmpvar_3;\
        tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\
        gl_FragData[0] = tmpvar_3;\
    }\
    ";
        defShader.vscodeuifont = "\
    attribute vec4 _glesVertex;   \
    attribute vec4 _glesColor;                  \
    attribute vec4 _glesColorEx;                  \
    attribute vec4 _glesMultiTexCoord0;         \
    uniform highp mat4 glstate_matrix_mvp;      \
    varying lowp vec4 xlv_COLOR;                \
    varying lowp vec4 xlv_COLOREx;                                                 \
    varying highp vec2 xlv_TEXCOORD0;           \
    void main()                                     \
    {                                               \
        highp vec4 tmpvar_1;                        \
        tmpvar_1.w = 1.0;                           \
        tmpvar_1.xyz = _glesVertex.xyz;             \
        xlv_COLOR = _glesColor;                     \
        xlv_COLOREx = _glesColorEx;                     \
        xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;     \
        gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
    }";
        defShader.fscodeuifont = "\
precision mediump float;// \n\
uniform sampler2D _MainTex; \n\
varying lowp vec4 xlv_COLOR;\n\
varying lowp vec4 xlv_COLOREx;\n\
varying highp vec2 xlv_TEXCOORD0;   \n\
void main() \n\
{\n\
float scale = 10.0;//  \n\
float d = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.5)*scale;  //0.5\n\
float bd = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.34)*scale;  //0.34\n\
\n\
float c=xlv_COLOR.a * clamp ( d,0.0,1.0); \n\
float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0); \n\
bc =min(1.0-c,bc);\n\
\n\
\n\
\n\
gl_FragData[0] =xlv_COLOR*c + xlv_COLOREx*bc;\n\
}";
        defShader.vsdiffuse = "\
    attribute vec4 _glesVertex;\
    attribute vec4 _glesMultiTexCoord0;\
    uniform highp mat4 glstate_matrix_mvp;\
    varying highp vec2 xlv_TEXCOORD0;\
    void main()\
    {\
        highp vec4 tmpvar_1;\
        tmpvar_1.w = 1.0;\
        tmpvar_1.xyz = _glesVertex.xyz;\
        xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\
        gl_Position = (glstate_matrix_mvp * tmpvar_1);\
    }";
        defShader.fsdiffuse = "\
    uniform sampler2D _MainTex;\
uniform lowp float _AlphaCut;\
varying highp vec2 xlv_TEXCOORD0;\
void main() \
{\
    lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);\
    if(tmpvar_3.a < _AlphaCut)\
        discard;\
    gl_FragData[0] = tmpvar_3;\
}";
        framework.defShader = defShader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defTexture = (function () {
            function defTexture() {
            }
            defTexture.initDefaultTexture = function (assetmgr) {
                var t = new framework.texture("white");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "white");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["white"] = t;
                var t = new framework.texture("gray");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "gray");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["gray"] = t;
                var t = new framework.texture("grid");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "grid");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["grid"] = t;
            };
            return defTexture;
        }());
        framework.defTexture = defTexture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var animationClip = (function () {
            function animationClip(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "animationClip_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            animationClip.prototype.getName = function () {
                return this.name.getText();
            };
            animationClip.prototype.getGUID = function () {
                return this.id.getID();
            };
            animationClip.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            animationClip.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            animationClip.prototype.dispose = function () {
                this.bones.length = 0;
                this.subclips.length = 0;
                delete this.frames;
            };
            animationClip.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.bones) {
                    total += gd3d.math.caclStringByteLength(this.bones[k]);
                }
                for (var k in this.frames) {
                    total += this.frames[k].byteLength;
                    total += gd3d.math.caclStringByteLength(k);
                }
                total += subClip.caclByteLength() * this.subclips.length;
                return total;
            };
            animationClip.prototype.Parse = function (buf) {
                var read = new gd3d.io.binReader(buf);
                var _name = read.readStringAnsi();
                this.fps = read.readFloat();
                this.loop = read.readBoolean();
                this.boneCount = read.readInt();
                this.bones = [];
                for (var i = 0; i < this.boneCount; i++) {
                    this.bones.push(read.readStringAnsi());
                }
                this.subclipCount = read.readInt();
                this.subclips = [];
                for (var i = 0; i < this.subclipCount; i++) {
                    var _subClip = new subClip();
                    _subClip.name = read.readStringAnsi();
                    _subClip.loop = read.readBoolean();
                    this.subclips.push(_subClip);
                }
                this.frameCount = read.readInt();
                this.frames = {};
                for (var i = 0; i < this.frameCount; i++) {
                    var _fid = read.readInt().toString();
                    var _key = read.readBoolean();
                    var _frame = new Float32Array(this.boneCount * 7 + 1);
                    _frame[0] = _key ? 1 : 0;
                    var _boneInfo = new PoseBoneMatrix();
                    for (var i_1 = 0; i_1 < this.boneCount; i_1++) {
                        _boneInfo.load(read);
                        _frame[i_1 * 7 + 1] = _boneInfo.r.x;
                        _frame[i_1 * 7 + 2] = _boneInfo.r.y;
                        _frame[i_1 * 7 + 3] = _boneInfo.r.z;
                        _frame[i_1 * 7 + 4] = _boneInfo.r.w;
                        _frame[i_1 * 7 + 5] = _boneInfo.t.x;
                        _frame[i_1 * 7 + 6] = _boneInfo.t.y;
                        _frame[i_1 * 7 + 7] = _boneInfo.t.z;
                    }
                    this.frames[_fid] = _frame;
                }
                buf = null;
            };
            return animationClip;
        }());
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], animationClip.prototype, "name", void 0);
        animationClip = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], animationClip);
        framework.animationClip = animationClip;
        var PoseBoneMatrix = PoseBoneMatrix_1 = (function () {
            function PoseBoneMatrix() {
            }
            PoseBoneMatrix.caclByteLength = function () {
                var total = 12 + 16;
                return total;
            };
            PoseBoneMatrix.prototype.Clone = function () {
                var p = new PoseBoneMatrix_1();
                p.t = new gd3d.math.vector3();
                p.r = new gd3d.math.quaternion();
                gd3d.math.vec3Clone(this.t, p.t);
                gd3d.math.quatClone(this.r, p.r);
                return p;
            };
            PoseBoneMatrix.prototype.load = function (read) {
                {
                    var x = read.readSingle();
                    var y = read.readSingle();
                    var z = read.readSingle();
                    var w = read.readSingle();
                    this.r = new gd3d.math.quaternion(x, y, z, w);
                }
                {
                    var x = read.readSingle();
                    var y = read.readSingle();
                    var z = read.readSingle();
                    this.t = new gd3d.math.vector3(x, y, z);
                }
            };
            PoseBoneMatrix.createDefault = function () {
                var pt = new PoseBoneMatrix_1();
                pt.r = new gd3d.math.quaternion(0, 0, 0, 1);
                pt.t = new gd3d.math.vector3(0, 0, 0);
                return pt;
            };
            PoseBoneMatrix.prototype.copyFrom = function (src) {
                this.r.x = src.r.x;
                this.r.y = src.r.y;
                this.r.z = src.r.z;
                this.r.w = src.r.w;
                this.t.x = src.t.x;
                this.t.y = src.t.y;
                this.t.z = src.t.z;
            };
            PoseBoneMatrix.prototype.copyFromData = function (src, seek) {
                this.r.x = src[seek + 0];
                this.r.y = src[seek + 1];
                this.r.z = src[seek + 2];
                this.r.w = src[seek + 3];
                this.t.x = src[seek + 4];
                this.t.y = src[seek + 5];
                this.t.z = src[seek + 6];
            };
            PoseBoneMatrix.prototype.invert = function () {
                gd3d.math.quatInverse(this.r, this.r);
                gd3d.math.quatTransformVector(this.r, this.t, this.t);
                this.t.x *= -1;
                this.t.y *= -1;
                this.t.z *= -1;
            };
            PoseBoneMatrix.prototype.lerpInWorld = function (_tpose, from, to, v) {
                var tpose = new gd3d.math.matrix();
                gd3d.math.matrixMakeTransformRTS(new gd3d.math.vector3(_tpose.t.x, _tpose.t.y, _tpose.t.z), new gd3d.math.vector3(1, 1, 1), new gd3d.math.quaternion(_tpose.r.x, _tpose.r.y, _tpose.r.z, _tpose.r.w), tpose);
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiply(to, _tpose);
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            };
            PoseBoneMatrix.prototype.lerpInWorldWithData = function (_tpose, from, todata, toseek, v) {
                var tpose = new gd3d.math.matrix();
                gd3d.math.matrixMakeTransformRTS(new gd3d.math.vector3(_tpose.t.x, _tpose.t.y, _tpose.t.z), new gd3d.math.vector3(1, 1, 1), new gd3d.math.quaternion(_tpose.r.x, _tpose.r.y, _tpose.r.z, _tpose.r.w), tpose);
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiplyDataAndMatrix(todata, toseek, _tpose);
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            };
            PoseBoneMatrix.sMultiply = function (left, right, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Clone(right.t, dir);
                var dirtran = new gd3d.math.vector3();
                gd3d.math.quatTransformVector(left.r, dir, dirtran);
                target.t.x = dirtran.x + left.t.x;
                target.t.y = dirtran.y + left.t.y;
                target.t.z = dirtran.z + left.t.z;
                gd3d.math.quatMultiply(left.r, right.r, target.r);
                return target;
            };
            PoseBoneMatrix.sMultiplyDataAndMatrix = function (leftdata, leftseek, right, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Clone(right.t, dir);
                var dirtran = new gd3d.math.vector3();
                gd3d.math.quatTransformVectorDataAndQuat(leftdata, leftseek + 0, dir, dirtran);
                target.t.x = dirtran.x + leftdata[leftseek + 4];
                target.t.y = dirtran.y + leftdata[leftseek + 5];
                target.t.z = dirtran.z + leftdata[leftseek + 6];
                gd3d.math.quatMultiplyDataAndQuat(leftdata, leftseek + 0, right.r, target.r);
                return target;
            };
            PoseBoneMatrix.sLerp = function (left, right, v, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                target.t.x = left.t.x * (1 - v) + right.t.x * v;
                target.t.y = left.t.y * (1 - v) + right.t.y * v;
                target.t.z = left.t.z * (1 - v) + right.t.z * v;
                gd3d.math.quatLerp(left.r, right.r, target.r, v);
                return target;
            };
            return PoseBoneMatrix;
        }());
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], PoseBoneMatrix.prototype, "t", void 0);
        __decorate([
            gd3d.reflect.Field("quaternion"),
            __metadata("design:type", gd3d.math.quaternion)
        ], PoseBoneMatrix.prototype, "r", void 0);
        PoseBoneMatrix = PoseBoneMatrix_1 = __decorate([
            gd3d.reflect.SerializeType
        ], PoseBoneMatrix);
        framework.PoseBoneMatrix = PoseBoneMatrix;
        var subClip = (function () {
            function subClip() {
            }
            subClip.caclByteLength = function () {
                var total = 0;
                total += gd3d.math.caclStringByteLength(name);
                total += 1;
                total += 8;
                return total;
            };
            return subClip;
        }());
        framework.subClip = subClip;
        var PoseBoneMatrix_1;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var atlas = (function () {
            function atlas(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.sprites = {};
                if (!assetName) {
                    assetName = "atlas_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            atlas.prototype.getName = function () {
                return this.name.getText();
            };
            atlas.prototype.getGUID = function () {
                return this.id.getID();
            };
            atlas.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            atlas.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            atlas.prototype.dispose = function () {
                for (var key in this.sprites) {
                    this.sprites[key].unuse();
                }
                this.texture.unuse();
                delete this.sprites;
            };
            atlas.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.sprites) {
                    total += this.sprites[k].caclByteLength();
                    total += gd3d.math.caclStringByteLength(k);
                }
                return total;
            };
            Object.defineProperty(atlas.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            atlas.prototype.Parse = function (jsonStr, assetmgr) {
                var json = JSON.parse(jsonStr);
                var name = json["t"];
                this.texturewidth = json["w"];
                this.textureheight = json["h"];
                var s = json["s"];
                this.texture = assetmgr.getAssetByName(name);
                if (this.texture == null) {
                    console.log("atlas");
                }
                for (var i in s) {
                    var ss = s[i];
                    var spriteName = ss[0];
                    var r = new framework.sprite(this.getName() + "_" + spriteName);
                    assetmgr.use(r);
                    if (this.texture) {
                        r.texture = this.texture;
                    }
                    r.rect = new gd3d.math.rect(ss[1], ss[2], ss[3], ss[4]);
                    r.border = new gd3d.math.border(0, 0, 0, 0);
                    r.atlas = this.getName();
                    this.sprites[spriteName] = r;
                }
            };
            return atlas;
        }());
        atlas = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], atlas);
        framework.atlas = atlas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var font = (function () {
            function font(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                if (!assetName) {
                    assetName = "font_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            font.prototype.getName = function () {
                return this.name.getText();
            };
            font.prototype.getGUID = function () {
                return this.id.getID();
            };
            font.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            font.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            font.prototype.dispose = function () {
                if (this.texture) {
                    this.texture.unuse(true);
                }
                delete this.cmap;
            };
            font.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.cmap) {
                    total += gd3d.math.caclStringByteLength(k);
                    total += charinfo.caclByteLength();
                }
                return total;
            };
            Object.defineProperty(font.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            font.prototype.Parse = function (jsonStr, assetmgr) {
                var d1 = new Date().valueOf();
                var json = JSON.parse(jsonStr);
                var font = json["font"];
                this.fontname = font[0];
                var picName = font[1];
                this.texture = assetmgr.getAssetByName(picName);
                this.pointSize = font[2];
                this.padding = font[3];
                this.lineHeight = font[4];
                this.baseline = font[5];
                this.atlasWidth = font[6];
                this.atlasHeight = font[7];
                this.cmap = {};
                var map = json["map"];
                for (var c in map) {
                    var finfo = new charinfo();
                    this.cmap[c] = finfo;
                    finfo.x = (map[c][0] - 0.5) / this.atlasWidth;
                    finfo.y = (map[c][1] - 0.5) / this.atlasHeight;
                    finfo.w = (map[c][2] + 1.0) / this.atlasWidth;
                    finfo.h = (map[c][3] + 1.0) / this.atlasHeight;
                    finfo.xSize = map[c][2];
                    finfo.ySize = map[c][3];
                    finfo.xOffset = map[c][4];
                    finfo.yOffset = map[c][5];
                    finfo.xAddvance = map[c][6];
                }
                map = null;
                json = null;
                var d2 = new Date().valueOf();
                var n = d2 - d1;
            };
            return font;
        }());
        font = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], font);
        framework.font = font;
        var charinfo = (function () {
            function charinfo() {
            }
            charinfo.caclByteLength = function () {
                return 36;
            };
            return charinfo;
        }());
        framework.charinfo = charinfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var UniformData = (function () {
            function UniformData(type, value, defaultValue) {
                if (defaultValue === void 0) { defaultValue = null; }
                this.type = type;
                this.value = value;
                this.defaultValue = defaultValue;
            }
            return UniformData;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            gd3d.reflect.UIStyle("UniformTypeEnum"),
            __metadata("design:type", Number)
        ], UniformData.prototype, "type", void 0);
        __decorate([
            gd3d.reflect.Field("any"),
            __metadata("design:type", Object)
        ], UniformData.prototype, "value", void 0);
        UniformData = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Object, Object])
        ], UniformData);
        framework.UniformData = UniformData;
        var material = material_1 = (function () {
            function material(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.name = null;
                this.id = new framework.resID();
                this.defaultAsset = false;
                this._changeShaderMap = {};
                if (!assetName) {
                    assetName = "material_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
                gd3d.io.enumMgr.enumMap["UniformTypeEnum"] = gd3d.render.UniformTypeEnum;
                this.mapUniformTemp = {};
            }
            material.prototype.getName = function () {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            };
            material.prototype.getGUID = function () {
                return this.id.getID();
            };
            material.prototype.dispose = function () {
                for (var id in this.mapUniform) {
                    switch (this.mapUniform[id].type) {
                        case gd3d.render.UniformTypeEnum.Texture:
                            if (this.mapUniform[id] != null && this.mapUniform[id].value != null)
                                this.mapUniform[id].value.unuse(true);
                            break;
                    }
                }
                delete this.mapUniform;
                delete this.mapUniformTemp;
            };
            material.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            material.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            material.prototype.caclByteLength = function () {
                var total = 0;
                if (this.shader) {
                    total += this.shader.caclByteLength();
                }
                for (var k in this.mapUniform) {
                    var type = this.mapUniform[k].type;
                    var value = this.mapUniform[k].value;
                    var defaultValue = this.mapUniform[k].defaultValue;
                    switch (type) {
                        case gd3d.render.UniformTypeEnum.Float:
                            total += 4;
                            break;
                        case gd3d.render.UniformTypeEnum.Floatv:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            total += 16;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4v:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4:
                            total += 64;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4v:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Texture:
                            if (value != null) {
                                total += value.caclByteLength();
                            }
                            else if (defaultValue != null) {
                                total += defaultValue.caclByteLength();
                            }
                            break;
                    }
                }
                for (var k in this.mapUniformTemp) {
                    var type = this.mapUniformTemp[k].type;
                    var value = this.mapUniformTemp[k].value;
                    var defaultValue = this.mapUniformTemp[k].defaultValue;
                    switch (type) {
                        case gd3d.render.UniformTypeEnum.Float:
                            total += 4;
                            break;
                        case gd3d.render.UniformTypeEnum.Floatv:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            total += 16;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4v:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4:
                            total += 64;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4v:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Texture:
                            if (value != null) {
                                total += value.caclByteLength();
                            }
                            else if (defaultValue != null) {
                                total += defaultValue.caclByteLength();
                            }
                            break;
                    }
                }
                return total;
            };
            material.prototype.initUniformData = function (passes) {
                if (passes == null)
                    return;
                for (var i = 0; i < passes.length; i++) {
                    var p = passes[i];
                    for (var key in p.uniforms) {
                        var u = p.uniforms[key];
                        var defv = this.shader.defaultValue[key];
                        if (defv != null) {
                            this.mapUniform[key] = new UniformData(u.type, defv.value, defv.defaultValue);
                            continue;
                        }
                        if (this.mapUniform[key] != null) {
                            continue;
                        }
                        if (u.type == gd3d.render.UniformTypeEnum.Float)
                            this.mapUniform[key] = new UniformData(u.type, u.value);
                        else if (u.type == gd3d.render.UniformTypeEnum.Floatv)
                            this.mapUniform[key] = new UniformData(u.type, new Float32Array(0));
                        else if (u.type == gd3d.render.UniformTypeEnum.Float4) {
                            var _v4 = new gd3d.math.vector4();
                            if (key.indexOf("_ST") > 0) {
                                _v4.x = 1;
                                _v4.y = 1;
                            }
                            this.mapUniform[key] = new UniformData(u.type, _v4);
                        }
                        else if (u.type == gd3d.render.UniformTypeEnum.Float4v)
                            this.mapUniform[key] = new UniformData(u.type, new Float32Array(0));
                        else if (u.type == gd3d.render.UniformTypeEnum.Float4x4)
                            this.mapUniform[key] = new UniformData(u.type, new gd3d.math.matrix());
                        else if (u.type == gd3d.render.UniformTypeEnum.Float4x4v)
                            this.mapUniform[key] = new UniformData(u.type, new Float32Array(0));
                        else if (u.type == gd3d.render.UniformTypeEnum.Texture)
                            this.mapUniform[key] = new UniformData(u.type, null);
                    }
                }
            };
            material.prototype.setShader = function (shader) {
                this.shader = shader;
                this.mapUniform = {};
                this.initUniformData(this.shader.passes["base"]);
            };
            material.prototype.changeShader = function (shader) {
                var map;
                if (this._changeShaderMap[shader.getName()] != undefined) {
                    map = this._changeShaderMap[shader.getName()].mapUniform;
                }
                else {
                    var mat = this.clone();
                    map = mat.mapUniform;
                    this._changeShaderMap[shader.getName()] = mat;
                }
                this.setShader(shader);
                for (var key in map) {
                    if (this.mapUniform[key] != undefined) {
                        this.mapUniform[key] = map[key];
                    }
                }
            };
            material.prototype.getLayer = function () {
                return this.shader.layer;
            };
            material.prototype.getQueue = function () {
                return this.shader.queue;
            };
            material.prototype.getShader = function () {
                return this.shader;
            };
            material.prototype.setFloat = function (_id, _number) {
                if (this.mapUniform[_id] != undefined)
                    this.mapUniform[_id].value = _number;
                else
                    this.mapUniformTemp[_id] = new UniformData(gd3d.render.UniformTypeEnum.Float, _number);
            };
            material.prototype.setFloatv = function (_id, _numbers) {
                if (this.mapUniform[_id] != undefined)
                    this.mapUniform[_id].value = _numbers;
                else
                    this.mapUniformTemp[_id] = new UniformData(gd3d.render.UniformTypeEnum.Floatv, _numbers);
            };
            material.prototype.setVector4 = function (_id, _vector4) {
                if (this.mapUniform[_id] != undefined)
                    this.mapUniform[_id].value = _vector4;
                else
                    this.mapUniformTemp[_id] = new UniformData(gd3d.render.UniformTypeEnum.Float4, _vector4);
            };
            material.prototype.setVector4v = function (_id, _vector4v) {
                if (this.mapUniform[_id] != undefined)
                    this.mapUniform[_id].value = _vector4v;
                else
                    this.mapUniformTemp[_id] = new UniformData(gd3d.render.UniformTypeEnum.Float4v, _vector4v);
            };
            material.prototype.setMatrix = function (_id, _matrix) {
                if (this.mapUniform[_id] != undefined)
                    this.mapUniform[_id].value = _matrix;
                else
                    this.mapUniformTemp[_id] = new UniformData(gd3d.render.UniformTypeEnum.Float4x4, _matrix);
            };
            material.prototype.setMatrixv = function (_id, _matrixv) {
                if (this.mapUniform[_id] != undefined)
                    this.mapUniform[_id].value = _matrixv;
                else
                    this.mapUniformTemp[_id] = new UniformData(gd3d.render.UniformTypeEnum.Float4x4v, _matrixv);
            };
            material.prototype.setTexture = function (_id, _texture) {
                if (this.mapUniform[_id] != undefined) {
                    if (this.mapUniform[_id].value) {
                        this.mapUniform[_id].value.unuse();
                    }
                    this.mapUniform[_id].value = _texture;
                    if (_texture != null)
                        _texture.use();
                }
                else {
                    this.mapUniformTemp[_id] = new UniformData(gd3d.render.UniformTypeEnum.Texture, _texture);
                }
            };
            material.prototype.uploadUniform = function (pass) {
                for (var id in this.mapUniform) {
                    var type = this.mapUniform[id].type;
                    var value = this.mapUniform[id].value;
                    var defaultValue = this.mapUniform[id].defaultValue;
                    var target = pass.uniforms[id];
                    if (target == null)
                        continue;
                    switch (type) {
                        case gd3d.render.UniformTypeEnum.Float:
                            pass.uniformFloat(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Floatv:
                            pass.uniformFloatv(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            pass.uniformVec4(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4v:
                            pass.uniformVec4v(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4:
                            pass.uniformMatrix(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4v:
                            pass.uniformMatrixV(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Texture:
                            if (value != null) {
                                pass.uniformTexture(id, value.glTexture);
                            }
                            else if (defaultValue != null) {
                                pass.uniformTexture(id, defaultValue.glTexture);
                            }
                            else {
                                pass.uniformTexture(id, null);
                            }
                            break;
                    }
                }
                for (var id in this.mapUniformTemp) {
                    var type = this.mapUniformTemp[id].type;
                    var value = this.mapUniformTemp[id].value;
                    var target = pass.uniforms[id];
                    if (target == null)
                        continue;
                    switch (type) {
                        case gd3d.render.UniformTypeEnum.Float:
                            pass.uniformFloat(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Floatv:
                            pass.uniformFloatv(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            pass.uniformVec4(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4v:
                            pass.uniformVec4v(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4:
                            pass.uniformMatrix(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4v:
                            pass.uniformMatrixV(id, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Texture:
                            if (value != null)
                                pass.uniformTexture(id, value.glTexture);
                            else
                                pass.uniformTexture(id, null);
                            break;
                    }
                }
            };
            material.prototype.draw = function (context, mesh, sm, basetype) {
                if (basetype === void 0) { basetype = "base"; }
                var drawPasses = this.shader.passes[basetype + context.drawtype];
                if (drawPasses == undefined)
                    drawPasses = this.shader.passes["base" + context.drawtype];
                if (drawPasses == undefined)
                    return;
                for (var i = 0; i < drawPasses.length; i++) {
                    var pass = drawPasses[i];
                    for (var key in pass.uniforms) {
                        switch (key) {
                            case "glstate_matrix_model":
                                this.setMatrix(key, context.matrixModel);
                                break;
                            case "glstate_matrix_view":
                                this.setMatrix(key, context.matrixView);
                                break;
                            case "glstate_matrix_project":
                                this.setMatrix(key, context.matrixProject);
                                break;
                            case "glstate_matrix_modelview":
                                this.setMatrix(key, context.matrixModelView);
                                break;
                            case "glstate_matrix_viewproject":
                                this.setMatrix(key, context.matrixViewProject);
                                break;
                            case "glstate_matrix_mvp":
                                this.setMatrix(key, context.matrixModelViewProject);
                                break;
                            case "glstate_timer":
                                this.setFloat(key, context.floatTimer);
                                break;
                            case "glstate_lightcount":
                                this.setFloat(key, context.intLightCount);
                                break;
                            case "glstate_vec4_lightposs":
                                if (context.vec4LightPos.length > 0) {
                                    this.setVector4v(key, context.vec4LightPos);
                                }
                                break;
                            case "glstate_vec4_lightdirs":
                                if (context.vec4LightDir.length > 0) {
                                    this.setVector4v(key, context.vec4LightDir);
                                }
                                break;
                            case "glstate_float_spotangelcoss":
                                if (context.floatLightSpotAngleCos.length > 0) {
                                    this.setFloatv(key, context.floatLightSpotAngleCos);
                                }
                                break;
                            case "glstate_eyepos":
                                this.setVector4(key, context.eyePos);
                                break;
                            case "_LightmapTex":
                                this.setTexture(key, context.lightmap);
                                break;
                            case "glstate_lightmapOffset":
                                this.setVector4(key, context.lightmapOffset);
                                break;
                            case "glstate_lightmapUV":
                                this.setFloat(key, context.lightmapUV);
                                break;
                        }
                    }
                    this.uploadUniform(pass);
                    pass.use(context.webgl);
                    mesh.glMesh.bind(context.webgl, pass.program, sm.useVertexIndex);
                    if (sm.useVertexIndex < 0) {
                        if (sm.line) {
                            mesh.glMesh.drawArrayLines(context.webgl, sm.start, sm.size);
                        }
                        else {
                            mesh.glMesh.drawArrayTris(context.webgl, sm.start, sm.size);
                        }
                    }
                    else {
                        if (sm.line) {
                            mesh.glMesh.drawElementLines(context.webgl, sm.start, sm.size);
                        }
                        else {
                            mesh.glMesh.drawElementTris(context.webgl, sm.start, sm.size);
                        }
                    }
                }
                this.mapUniformTemp = {};
            };
            material.prototype.Parse = function (assetmgr, json) {
                var shaderName = json["shader"];
                this.setShader(assetmgr.getShader(shaderName));
                var mapUniform = json["mapUniform"];
                for (var i in mapUniform) {
                    var jsonChild = mapUniform[i];
                    var _uniformType = jsonChild["type"];
                    switch (_uniformType) {
                        case gd3d.render.UniformTypeEnum.Texture:
                            var _value = jsonChild["value"];
                            var _texture = assetmgr.getAssetByName(_value);
                            if (_texture == undefined) {
                                _texture = assetmgr.getDefaultTexture("grid");
                            }
                            this.setTexture(i, _texture);
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            var _value = jsonChild["value"];
                            this.setFloat(i, parseFloat(_value));
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            var tempValue = jsonChild["value"];
                            try {
                                var values = tempValue.match(framework.RegexpUtil.vector4Regexp);
                                if (values != null) {
                                    var _float4 = new gd3d.math.vector4(parseFloat(values[1]), parseFloat(values[2]), parseFloat(values[3]), parseFloat(values[4]));
                                    this.setVector4(i, _float4);
                                }
                            }
                            catch (e) {
                            }
                            break;
                        default:
                            console.log("materialJsonmapuniformtype" + jsonChild["type"] + "0-2");
                    }
                }
            };
            material.prototype.clone = function () {
                var mat = new material_1(this.getName());
                mat.setShader(this.shader);
                for (var i in this.mapUniform) {
                    var data = this.mapUniform[i];
                    var _uniformType = data.type;
                    switch (_uniformType) {
                        case gd3d.render.UniformTypeEnum.Texture:
                            mat.setTexture(i, data.value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            mat.setFloat(i, data.value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            mat.setVector4(i, data.value);
                            break;
                        default:
                            break;
                    }
                }
                return mat;
            };
            return material;
        }());
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], material.prototype, "name", void 0);
        __decorate([
            gd3d.reflect.Field("shader"),
            __metadata("design:type", framework.shader)
        ], material.prototype, "shader", void 0);
        __decorate([
            gd3d.reflect.Field("UniformDataDic"),
            __metadata("design:type", Object)
        ], material.prototype, "mapUniform", void 0);
        material = material_1 = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], material);
        framework.material = material;
        var material_1;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var mesh = (function () {
            function mesh(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.submesh = [];
                if (!assetName) {
                    assetName = "mesh_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            mesh.prototype.getName = function () {
                if (!this.name) {
                    return null;
                }
                return this.name.getText();
            };
            mesh.prototype.getGUID = function () {
                return this.id.getID();
            };
            mesh.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            mesh.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            mesh.prototype.dispose = function () {
                this.glMesh.dispose(framework.sceneMgr.app.getAssetMgr().webgl);
                this.data = null;
                delete this.submesh;
            };
            mesh.prototype.caclByteLength = function () {
                var total = 0;
                total += this.glMesh.caclByteLength();
                if (this.data) {
                    total += this.data.caclByteLength();
                }
                return total;
            };
            mesh.prototype.Parse = function (buf, webgl) {
                var vf = 0;
                var data = new gd3d.render.meshData();
                var read = new gd3d.io.binReader(buf);
                var meshName = read.readStringAnsi();
                read.position = read.position + 24;
                var vcount = read.readUInt32();
                var vec10tpose = [];
                while (true) {
                    var tag = read.readUInt8();
                    if (tag == 255)
                        break;
                    if (tag == 1) {
                        if (data.pos == undefined) {
                            data.pos = [];
                            vf = vf | gd3d.render.VertexFormatMask.Position;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var _position = new gd3d.math.vector3();
                            _position.x = read.readSingle();
                            _position.y = read.readSingle();
                            _position.z = read.readSingle();
                            data.pos.push(_position);
                        }
                    }
                    else if (tag == 2) {
                        if (data.color == undefined) {
                            data.color = [];
                            vf = vf | gd3d.render.VertexFormatMask.Color;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var _color = new gd3d.math.color();
                            _color.a = read.readUInt8();
                            _color.r = read.readUInt8();
                            _color.g = read.readUInt8();
                            _color.b = read.readUInt8();
                            data.color.push(_color);
                        }
                    }
                    else if (tag == 3) {
                        if (data.normal == undefined) {
                            data.normal = [];
                            vf = vf | gd3d.render.VertexFormatMask.Normal;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var _normal = new gd3d.math.vector3();
                            _normal.x = read.readSingle();
                            _normal.y = read.readSingle();
                            _normal.z = read.readSingle();
                            data.normal.push(_normal);
                        }
                    }
                    else if (tag == 4) {
                        if (data.uv == undefined) {
                            data.uv = [];
                            vf = vf | gd3d.render.VertexFormatMask.UV0;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var uv = new gd3d.math.vector2();
                            uv.x = read.readSingle();
                            uv.y = 1 - read.readSingle();
                            data.uv.push(uv);
                        }
                    }
                    else if (tag == 5) {
                        if (data.uv2 == undefined) {
                            data.uv2 = [];
                            vf = vf | gd3d.render.VertexFormatMask.UV1;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var uv = new gd3d.math.vector2();
                            uv.x = read.readSingle();
                            uv.y = 1 - read.readSingle();
                            data.uv2.push(uv);
                        }
                    }
                    else if (tag == 6) {
                        for (var i = 0; i < vcount; i++) {
                            read.readSingle();
                            1 - read.readSingle();
                        }
                    }
                    else if (tag == 7) {
                        if (data.tangent == undefined) {
                            data.tangent = [];
                            vf = vf | gd3d.render.VertexFormatMask.Tangent;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var tangent = new gd3d.math.vector3();
                            var x = read.readSingle();
                            var y = read.readSingle();
                            var z = read.readSingle();
                            var w = read.readSingle();
                            tangent.x = x / w;
                            tangent.y = y / w;
                            tangent.z = z / w;
                            data.tangent.push(tangent);
                        }
                    }
                    else if (tag == 8) {
                        for (var i = 0; i < vcount; i++) {
                            read.readSingle();
                            1 - read.readSingle();
                        }
                    }
                    else if (tag == 16) {
                        var tposelen = read.readUInt8();
                        for (var i = 0; i < tposelen; i++) {
                            vec10tpose[i * 10 + 0] = read.readSingle();
                            vec10tpose[i * 10 + 1] = read.readSingle();
                            vec10tpose[i * 10 + 2] = read.readSingle();
                            vec10tpose[i * 10 + 3] = read.readSingle();
                            vec10tpose[i * 10 + 4] = read.readSingle();
                            vec10tpose[i * 10 + 5] = read.readSingle();
                            vec10tpose[i * 10 + 6] = read.readSingle();
                            vec10tpose[i * 10 + 7] = read.readSingle();
                            vec10tpose[i * 10 + 8] = read.readSingle();
                            vec10tpose[i * 10 + 9] = read.readSingle();
                        }
                    }
                    else if (tag == 17) {
                        if (data.blendIndex == undefined) {
                            data.blendIndex = [];
                            vf = vf | gd3d.render.VertexFormatMask.BlendIndex4;
                        }
                        if (data.blendWeight == undefined) {
                            data.blendWeight = [];
                            vf = vf | gd3d.render.VertexFormatMask.BlendWeight4;
                        }
                        for (var i = 0; i < vcount; i++) {
                            var _boneIndex = new gd3d.render.number4();
                            _boneIndex.v0 = read.readUInt32();
                            _boneIndex.v1 = read.readUInt32();
                            _boneIndex.v2 = read.readUInt32();
                            _boneIndex.v3 = read.readUInt32();
                            var _boneWeight = new gd3d.render.number4();
                            _boneWeight.v0 = read.readSingle();
                            _boneWeight.v1 = read.readSingle();
                            _boneWeight.v2 = read.readSingle();
                            _boneWeight.v3 = read.readSingle();
                            data.blendIndex.push(_boneIndex);
                            data.blendWeight.push(_boneWeight);
                        }
                    }
                    else {
                        throw "notwrite" + tag;
                    }
                }
                var subcount = read.readUInt8();
                data.trisindex = [];
                this.submesh = [];
                for (var i = 0; i < subcount; i++) {
                    var _submeshinfo = new subMeshInfo();
                    var tv = read.readUInt32();
                    var sublen = read.readUInt32();
                    _submeshinfo.start = data.trisindex.length;
                    _submeshinfo.size = sublen;
                    _submeshinfo.matIndex = i;
                    this.submesh.push(_submeshinfo);
                    for (var j = 0; j < sublen; j++) {
                        var index = read.readUInt32();
                        data.trisindex.push(index);
                    }
                }
                buf = null;
                this.data = data;
                this.glMesh = new gd3d.render.glMesh();
                var vertexs = this.data.genVertexDataArray(vf);
                var indices = this.data.genIndexDataArray();
                this.glMesh.initBuffer(webgl, vf, this.data.pos.length);
                this.glMesh.uploadVertexSubData(webgl, vertexs);
                this.glMesh.addIndex(webgl, indices.length);
                this.glMesh.uploadIndexSubData(webgl, 0, indices);
            };
            mesh.prototype.intersects = function (ray, matrix) {
                var pickinfo = null;
                for (var i = 0; i < this.submesh.length; i++) {
                    var submesh = this.submesh[i];
                    if (submesh.line) {
                    }
                    else {
                        if (submesh.useVertexIndex < 0) {
                        }
                        else {
                            var t0 = gd3d.math.pool.new_vector3();
                            var t1 = gd3d.math.pool.new_vector3();
                            var t2 = gd3d.math.pool.new_vector3();
                            for (var index = submesh.start; index < submesh.size; index += 3) {
                                var p0 = this.data.pos[this.data.trisindex[index]];
                                var p1 = this.data.pos[this.data.trisindex[index + 1]];
                                var p2 = this.data.pos[this.data.trisindex[index + 2]];
                                gd3d.math.matrixTransformVector3(p0, matrix, t0);
                                gd3d.math.matrixTransformVector3(p1, matrix, t1);
                                gd3d.math.matrixTransformVector3(p2, matrix, t2);
                                var result = ray.intersectsTriangle(t0, t1, t2);
                                if (result) {
                                    if (result.distance < 0)
                                        continue;
                                    if (!pickinfo || pickinfo.distance > result.distance) {
                                        pickinfo = result;
                                        pickinfo.faceId = index / 3;
                                        pickinfo.subMeshId = i;
                                        var tdir = gd3d.math.pool.new_vector3();
                                        gd3d.math.vec3ScaleByNum(ray.direction, result.distance, tdir);
                                        gd3d.math.vec3Add(ray.origin, tdir, pickinfo.hitposition);
                                    }
                                }
                            }
                            gd3d.math.pool.delete_vector3(t0);
                            gd3d.math.pool.delete_vector3(t1);
                            gd3d.math.pool.delete_vector3(t2);
                        }
                    }
                }
                return pickinfo;
            };
            return mesh;
        }());
        mesh = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], mesh);
        framework.mesh = mesh;
        var subMeshInfo = (function () {
            function subMeshInfo() {
                this.useVertexIndex = 0;
                this.line = false;
            }
            return subMeshInfo;
        }());
        framework.subMeshInfo = subMeshInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var pathasset = (function () {
            function pathasset(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.paths = [];
                this.items = [];
                this.lines = [];
                if (!assetName) {
                    assetName = "path_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            pathasset.prototype.getName = function () {
                return this.name.getText();
            };
            pathasset.prototype.getGUID = function () {
                return this.id.getID();
            };
            pathasset.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            pathasset.prototype.unuse = function () {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            };
            pathasset.prototype.dispose = function () {
                this.paths.length = 0;
            };
            pathasset.prototype.caclByteLength = function () {
                if (this.paths) {
                    var length = this.paths.length;
                    var value = length * 12;
                    return value;
                }
            };
            pathasset.prototype.Parse = function (json) {
                var type = json["type"];
                switch (type) {
                    case "once":
                        this.type = pathtype.once;
                        break;
                    case "loop":
                        this.type = pathtype.loop;
                        break;
                    case "pingpong":
                        this.type = pathtype.pingpong;
                }
                this.instertPointcount = json["insertPointcount"];
                var paths = json["path"];
                for (var key in paths) {
                    var item = new pointitem();
                    var pointnode = paths[key];
                    var pointtype = pointnode["type"];
                    switch (pointtype) {
                        case "VertexPoint":
                            item.type = epointtype.VertexPoint;
                            break;
                        case "ControlPoint":
                            item.type = epointtype.ControlPoint;
                            break;
                    }
                    var pointlocation = pointnode["point"];
                    var arr = pointlocation.split(",");
                    item.point = new gd3d.math.vector3(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]));
                    this.items.push(item);
                }
                this.getpaths();
                this.items.length = 0;
                for (var i = 0; i < this.lines.length; i++) {
                    this.lines[i].length = 0;
                }
                this.lines.length = 0;
            };
            pathasset.prototype.getpaths = function () {
                var line = new Array();
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (i == 0) {
                        line.push(item.point);
                        this.lines.push(line);
                    }
                    else if (i == this.items.length - 1) {
                        if (this.type == pathtype.loop) {
                            if (item.type == epointtype.VertexPoint) {
                                line.push(item.point);
                                line = new Array();
                                line.push(item.point);
                                line.push(this.items[0].point);
                                this.lines.push(line);
                            }
                            else {
                                line.push(item.point);
                                line.push(this.items[0].point);
                            }
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                    else {
                        if (item.type == epointtype.VertexPoint) {
                            line.push(item.point);
                            line = new Array();
                            line.push(item.point);
                            this.lines.push(line);
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                }
                var linecount = this.lines.length;
                var pathindex = 0;
                for (var i = 0; i < linecount; i++) {
                    if (i == linecount - 1) {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / (this.instertPointcount - 1);
                            this.paths[pathindex] = this.getBeisaierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                    else {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / this.instertPointcount;
                            this.paths[pathindex] = this.getBeisaierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                }
            };
            pathasset.prototype.getBeisaierPointAlongCurve = function (points, rate, clearflag) {
                if (clearflag === void 0) { clearflag = false; }
                var length = points.length;
                if (points.length < 2) {
                    console.log("2");
                    return;
                }
                if (length == 2) {
                    var out = new gd3d.math.vector3();
                    this.vec3Lerp(points[0], points[1], rate, out);
                    if (clearflag) {
                        points.length = 0;
                    }
                    return out;
                }
                var temptpoints = [];
                for (var i = 0; i < length - 1; i++) {
                    var temp = gd3d.math.pool.new_vector3();
                    this.vec3Lerp(points[i], points[i + 1], rate, temp);
                    temptpoints[i] = temp;
                }
                if (clearflag) {
                    points.length = 0;
                }
                return this.getBeisaierPointAlongCurve(temptpoints, rate, true);
            };
            pathasset.prototype.vec3Lerp = function (start, end, lerp, out) {
                gd3d.math.vec3Subtract(end, start, out);
                gd3d.math.vec3ScaleByNum(out, lerp, out);
                gd3d.math.vec3Add(start, out, out);
            };
            return pathasset;
        }());
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], pathasset.prototype, "name", void 0);
        pathasset = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], pathasset);
        framework.pathasset = pathasset;
        var pathtype;
        (function (pathtype) {
            pathtype[pathtype["once"] = 0] = "once";
            pathtype[pathtype["loop"] = 1] = "loop";
            pathtype[pathtype["pingpong"] = 2] = "pingpong";
        })(pathtype = framework.pathtype || (framework.pathtype = {}));
        var epointtype;
        (function (epointtype) {
            epointtype[epointtype["VertexPoint"] = 0] = "VertexPoint";
            epointtype[epointtype["ControlPoint"] = 1] = "ControlPoint";
        })(epointtype = framework.epointtype || (framework.epointtype = {}));
        var pointitem = (function () {
            function pointitem() {
            }
            return pointitem;
        }());
        framework.pointitem = pointitem;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var prefab = (function () {
            function prefab(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "prefab_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            prefab.prototype.getName = function () {
                return this.name.getText();
            };
            prefab.prototype.getGUID = function () {
                return this.id.getID();
            };
            prefab.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            prefab.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            prefab.prototype.dispose = function () {
                this.trans.dispose();
                this.jsonstr = null;
            };
            prefab.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            prefab.prototype.getCloneTrans = function () {
                return gd3d.io.cloneObj(this.trans);
            };
            prefab.prototype.apply = function (trans) {
                this.trans = trans;
            };
            prefab.prototype.Parse = function (jsonStr, assetmgr) {
                this.jsonstr = jsonStr;
                this.trans = new framework.transform();
                gd3d.io.deSerialize(JSON.parse(jsonStr), this.trans, assetmgr, this.assetbundle);
            };
            return prefab;
        }());
        prefab = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], prefab);
        framework.prefab = prefab;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var rawscene = (function () {
            function rawscene(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "rawscene_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            rawscene.prototype.getName = function () {
                return this.name.getText();
            };
            rawscene.prototype.getGUID = function () {
                return this.id.getID();
            };
            rawscene.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            rawscene.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            rawscene.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            rawscene.prototype.Parse = function (txt, assetmgr) {
                var _json = JSON.parse(txt);
                this.rootNode = new framework.transform();
                this.rootNode.name = this.getName();
                gd3d.io.deSerialize(_json["rootNode"], this.rootNode, assetmgr, this.assetbundle);
                this.lightmaps = [];
                var lightmapData = _json["lightmap"];
                var lightmapCount = lightmapData.length;
                for (var i = 0; i < lightmapCount; i++) {
                    if (lightmapData[i] == null) {
                        this.lightmaps.push(null);
                    }
                    else {
                        var lightmapName = lightmapData[i].name;
                        var lightmap = assetmgr.getAssetByName(lightmapName, this.assetbundle);
                        lightmap.use();
                        this.lightmaps.push(lightmap);
                    }
                }
            };
            rawscene.prototype.getSceneRoot = function () {
                return gd3d.io.cloneObj(this.rootNode);
            };
            rawscene.prototype.useLightMap = function (scene) {
                scene.lightmaps.length = 0;
                for (var i = 0; i < this.lightmaps.length; i++) {
                    scene.lightmaps.push(this.lightmaps[i]);
                }
            };
            rawscene.prototype.dispose = function () {
                if (this.rootNode) {
                    this.rootNode.dispose();
                }
                for (var key in this.lightmaps) {
                    this.lightmaps[key].unuse(true);
                }
            };
            return rawscene;
        }());
        rawscene = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], rawscene);
        framework.rawscene = rawscene;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var shader = (function () {
            function shader(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.name = null;
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.passes = {};
                this.defaultValue = {};
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                if (!assetName) {
                    assetName = "shader_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            shader.prototype.getName = function () {
                return this.name.getText();
            };
            shader.prototype.getGUID = function () {
                return this.id.getID();
            };
            shader.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            shader.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            shader.prototype.dispose = function () {
            };
            shader.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            shader.prototype.parse = function (assetmgr, json) {
                this._parseProperties(assetmgr, json.properties);
                if (json.layer) {
                    var layer = json.layer;
                    if (layer == "transparent")
                        this.layer = framework.RenderLayerEnum.Transparent;
                    else if (layer == "overlay")
                        this.layer = framework.RenderLayerEnum.Overlay;
                    else if (layer == "common")
                        this.layer = framework.RenderLayerEnum.Common;
                }
                if (json.queue) {
                    this.queue = json.queue;
                }
                var passes = json.passes;
                this.passes = {};
                for (var key in passes) {
                    var passbass = passes[key];
                    var curpasses;
                    if (key == "base" || key == "lightmap" || key == "skin" || key == "quad") {
                    }
                    else if (key.indexOf("base_") == 0 || key.indexOf("lightmap_") == 0 || key.indexOf("skin_") == 0) {
                    }
                    else {
                        continue;
                    }
                    this.passes[key] = [];
                    for (var i = 0; i < passbass.length; i++) {
                        this.passes[key].push(this._parsePass(assetmgr, passbass[i]));
                    }
                }
                if (this.passes["base"] == undefined) {
                    throw new Error("do not have base passgroup.");
                }
            };
            shader.prototype._parseProperties = function (assetmgr, properties) {
                this.defaultValue = {};
                for (var index in properties) {
                    var property = properties[index];
                    var words = property.match(framework.RegexpUtil.floatRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.rangeRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.vectorRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.textureRegexp);
                    if (words == null) {
                        alert(this.getName() + " property error! info:\n" + property);
                        return;
                    }
                    if (words != null && words.length >= 4) {
                        var key = words[1];
                        var showName = words[2];
                        var type = words[3].toLowerCase();
                        switch (type) {
                            case "float":
                                this.defaultValue[key] = { type: type, value: parseFloat(words[4]) };
                                break;
                            case "range":
                                this.defaultValue[key] = { type: type, min: parseFloat(words[4]), max: parseFloat(words[5]), value: parseFloat(words[6]) };
                                break;
                            case "vector":
                            case "color":
                                var _vector = new gd3d.math.vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                                this.defaultValue[key] = { type: type, value: _vector };
                                break;
                            case "texture":
                                this.defaultValue[key] = { type: type, defaultValue: assetmgr.getDefaultTexture(words[4]) };
                                break;
                            default:
                                alert(this.getName() + " property error! unknown type : " + type);
                                break;
                        }
                    }
                }
            };
            shader.prototype._parsePass = function (assetmgr, json) {
                var pass = new gd3d.render.glDrawPass();
                var vs = json["vs"];
                var fs = json["fs"];
                switch (json["showface"]) {
                    case "cw":
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.CW;
                        break;
                    case "ccw":
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                        break;
                    default:
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                        break;
                }
                var blendmode = gd3d.render.BlendModeEnum.Close;
                switch (json["zwrite"]) {
                    case "off":
                        pass.state_zwrite = false;
                        break;
                    case "on":
                    default:
                        pass.state_zwrite = true;
                        break;
                }
                pass.state_ztest = true;
                switch (json["ztest"]) {
                    case "greater":
                        pass.state_ztest_method = gd3d.render.webglkit.GREATER;
                        break;
                    case "gequal":
                        pass.state_ztest_method = gd3d.render.webglkit.GEQUAL;
                        break;
                    case "less":
                        pass.state_ztest_method = gd3d.render.webglkit.LESS;
                        break;
                    case "equal":
                        pass.state_ztest_method = gd3d.render.webglkit.EQUAL;
                        break;
                    case "notequal":
                        pass.state_ztest_method = gd3d.render.webglkit.NOTEQUAL;
                        break;
                    case "always":
                    case "off":
                        pass.state_ztest = false;
                        break;
                    case "never":
                        pass.state_ztest_method = gd3d.render.webglkit.NEVER;
                        break;
                    case "lequal":
                    default:
                        pass.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                        break;
                }
                switch (json["blendmode"]) {
                    case "add":
                        blendmode = gd3d.render.BlendModeEnum.Add;
                        break;
                    case "addpremult":
                        blendmode = gd3d.render.BlendModeEnum.Add_PreMultiply;
                        break;
                    case "blend":
                        blendmode = gd3d.render.BlendModeEnum.Blend;
                        break;
                    case "blendpremult":
                        blendmode = gd3d.render.BlendModeEnum.Blend_PreMultiply;
                        break;
                }
                pass.setAlphaBlend(blendmode);
                var program = assetmgr.shaderPool.linkProgram(assetmgr.webgl, vs, fs);
                pass.setProgram(program);
                if (this.layer == framework.RenderLayerEnum.Overlay) {
                    pass.state_ztest = true;
                    pass.state_zwrite = true;
                    pass.state_ztest_method = gd3d.render.webglkit.ALWAYS;
                }
                return pass;
            };
            return shader;
        }());
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], shader.prototype, "name", void 0);
        shader = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], shader);
        framework.shader = shader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var sprite = (function () {
            function sprite(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                if (!assetName) {
                    assetName = "sprite_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            sprite.prototype.getName = function () {
                return this.name.getText();
            };
            sprite.prototype.getGUID = function () {
                return this.id.getID();
            };
            sprite.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            sprite.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            sprite.prototype.dispose = function () {
                if (this.texture != null) {
                    this.texture.unuse(true);
                }
            };
            sprite.prototype.caclByteLength = function () {
                var total = 0;
                if (this._texture) {
                    total += this._texture.caclByteLength();
                }
                return total;
            };
            Object.defineProperty(sprite.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(sprite.prototype, "urange", {
                get: function () {
                    if (this._urange == null) {
                        this._urange = new gd3d.math.vector2();
                        this._urange.x = this.rect.x / this._texture.glTexture.width;
                        this._urange.y = (this.rect.x + this.rect.w) / this._texture.glTexture.width;
                    }
                    return this._urange;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(sprite.prototype, "vrange", {
                get: function () {
                    if (this._vrange == null) {
                        this._vrange = new gd3d.math.vector2();
                        this._vrange.x = this.rect.y / this._texture.glTexture.height;
                        this._vrange.y = (this.rect.y + this.rect.h) / this._texture.glTexture.height;
                    }
                    return this._vrange;
                },
                enumerable: true,
                configurable: true
            });
            return sprite;
        }());
        sprite = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], sprite);
        framework.sprite = sprite;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var textasset = (function () {
            function textasset(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "texture_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            textasset.prototype.getName = function () {
                return this.name.getText();
            };
            textasset.prototype.getGUID = function () {
                return this.id.getID();
            };
            textasset.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            textasset.prototype.unuse = function () {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            };
            textasset.prototype.dispose = function () {
                this.content == null;
            };
            textasset.prototype.caclByteLength = function () {
                if (this.content) {
                    return gd3d.math.caclStringByteLength(this.content);
                }
            };
            return textasset;
        }());
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], textasset.prototype, "name", void 0);
        textasset = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], textasset);
        framework.textasset = textasset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var texture = (function () {
            function texture(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "texture_" + this.getGUID();
                }
                if (!framework.sceneMgr.app.getAssetMgr().nameDuplicateCheck(assetName)) {
                    throw new Error("already have name.");
                }
                this.name = new framework.constText(assetName);
            }
            texture.prototype.getName = function () {
                return this.name.getText();
            };
            texture.prototype.getGUID = function () {
                return this.id.getID();
            };
            texture.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            texture.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            texture.prototype.dispose = function () {
                this.glTexture.dispose(framework.sceneMgr.app.getAssetMgr().webgl);
            };
            texture.prototype.caclByteLength = function () {
                if (this.glTexture) {
                    return this.glTexture.caclByteLength();
                }
            };
            Object.defineProperty(texture.prototype, "realName", {
                get: function () {
                    return this._realName;
                },
                set: function (name) {
                    this._realName = name;
                },
                enumerable: true,
                configurable: true
            });
            return texture;
        }());
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], texture.prototype, "name", void 0);
        texture = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], texture);
        framework.texture = texture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AudioChannel = (function () {
            function AudioChannel() {
            }
            Object.defineProperty(AudioChannel.prototype, "volume", {
                get: function () {
                    return this.gainNode.gain.value;
                },
                set: function (val) {
                    val = val > 1 ? 1 : val;
                    val = val <= -1 ? -0.999 : val;
                    this.gainNode.gain.value = val;
                },
                enumerable: true,
                configurable: true
            });
            AudioChannel.prototype.stop = function () {
                if (this.source != null) {
                    this.source.stop();
                    this.source = null;
                }
                this.isplay = false;
            };
            return AudioChannel;
        }());
        framework.AudioChannel = AudioChannel;
        var AudioEx = (function () {
            function AudioEx() {
                this.channelOnce = {};
                this.channelLoop = {};
                this._soundVolume = 0;
                this._musicVolume = 0;
                try {
                    var _AudioContext = window["AudioContext"] || window["webkitAudioContext"] || window["mozAudioContext"] || window["msAudioContext"];
                    this.audioContext = new _AudioContext();
                    console.log("audio Context inited");
                }
                catch (e) {
                    throw new Error("!Your browser does not support AudioContext");
                }
            }
            AudioEx.prototype.clickInit = function () {
                if (!this.isAvailable())
                    return;
                if (this.audioContext != null) {
                    var buffer = this.audioContext.createBuffer(1, 1, 22050);
                    var source = this.audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(this.audioContext.destination);
                    source.start();
                }
            };
            AudioEx.instance = function () {
                if (AudioEx.g_this == null)
                    AudioEx.g_this = new AudioEx();
                return AudioEx.g_this;
            };
            AudioEx.loadArrayBuffer = function (url, fun) {
                var req = new XMLHttpRequest();
                req.open("GET", url);
                req.responseType = "arraybuffer";
                req.onreadystatechange = function () {
                    if (req.readyState == 4) {
                        if (req.status == 404)
                            fun(null, new Error("onerr 404"));
                        else
                            fun(req.response, null);
                    }
                };
                req.onerror = function () {
                    fun(null, new Error("onerr in req:"));
                };
                req.send();
            };
            AudioEx.prototype.isAvailable = function () {
                return this.audioContext ? true : false;
            };
            AudioEx.prototype.loadAudioBufferFromArrayBuffer = function (ab, fun) {
                this.audioContext.decodeAudioData(ab, function (audiobuffer) {
                    fun(audiobuffer, null);
                });
            };
            AudioEx.prototype.loadAudioBuffer = function (url, fun) {
                var _this = this;
                AudioEx.loadArrayBuffer(url, function (_ab, __err) {
                    if (__err != null)
                        fun(null, __err);
                    else {
                        _this.audioContext.decodeAudioData(_ab, function (audiobuffer) {
                            fun(audiobuffer, null);
                        });
                    }
                });
            };
            AudioEx.prototype.getNewChannel = function () {
                var cc = new AudioChannel();
                cc.source = this.audioContext.createBufferSource();
                cc.pannerNode = this.audioContext.createPanner();
                cc.source.connect(this.audioContext.destination);
                cc.gainNode = AudioEx.instance().audioContext.createGain();
                cc.source.connect(cc.gainNode);
                cc.gainNode.connect(AudioEx.instance().audioContext.destination);
                cc.gainNode.gain.value = 1;
                return cc;
            };
            AudioEx.prototype.getFreeChannelOnce = function () {
                for (var key in this.channelOnce) {
                    if (this.channelOnce[key].isplay == false) {
                        var cc_1 = this.getNewChannel();
                        this.channelOnce[key] = cc_1;
                        return this.channelOnce[key];
                    }
                }
                var cc = this.getNewChannel();
                return cc;
            };
            AudioEx.prototype.playOnce = function (name, buf, x, y, z) {
                var c = this.getFreeChannelOnce();
                c.source.loop = false;
                c.source.buffer = buf;
                c.volume = this._soundVolume;
                c.source.start();
                if (x && y && z)
                    c.pannerNode.setPosition(x, y, z);
                c.isplay = true;
                c.source.onended = function () {
                    c.isplay = false;
                    c.source = null;
                };
                this.channelOnce[name] = c;
                return c;
            };
            AudioEx.prototype.playOnceInterrupt = function (name, buf, x, y, z) {
                for (var key in this.channelOnce) {
                    if (key == name && this.channelOnce[key].isplay) {
                        this.channelOnce[key].stop();
                    }
                }
                var cc = this.getFreeChannelOnce();
                cc.source.loop = false;
                cc.source.buffer = buf;
                cc.volume = this._soundVolume;
                if (x && y && z)
                    cc.pannerNode.setPosition(x, y, z);
                cc.source.start();
                cc.isplay = true;
                cc.source.onended = function () {
                    cc.isplay = false;
                    cc.source = null;
                };
                this.channelOnce[name] = cc;
                return cc;
            };
            AudioEx.prototype.playOnceBlocking = function (name, buf, x, y, z) {
                for (var key in this.channelOnce) {
                    if (key == name && this.channelOnce[key].isplay) {
                        return;
                    }
                }
                var cc = this.getFreeChannelOnce();
                cc.source.loop = false;
                cc.source.buffer = buf;
                cc.volume = this._soundVolume;
                if (x && y && z)
                    cc.pannerNode.setPosition(x, y, z);
                cc.source.start();
                cc.isplay = true;
                cc.source.onended = function () {
                    cc.isplay = false;
                    cc.source = null;
                };
                this.channelOnce[name] = cc;
                return cc;
            };
            AudioEx.prototype.playLooped = function (name, buf) {
                if (this.channelLoop[name] != undefined) {
                    if (this.channelLoop[name].isplay) {
                        this.channelLoop[name].source.stop();
                        this.channelLoop[name].isplay = false;
                    }
                }
                var cc = this.getNewChannel();
                cc.source.loop = true;
                cc.volume = this._musicVolume;
                this.channelLoop[name] = cc;
                this.channelLoop[name].source.buffer = buf;
                this.channelLoop[name].source.start();
                this.channelLoop[name].isplay = true;
            };
            AudioEx.prototype.stopLooped = function (name) {
                if (this.channelLoop[name] == undefined || this.channelLoop[name] == null || this.channelLoop[name].source == null)
                    return;
                this.channelLoop[name].source.stop();
                this.channelLoop[name].source = null;
                this.channelLoop[name].isplay = false;
            };
            AudioEx.prototype.setSoundVolume = function (val) {
                this._soundVolume = val;
                for (var key in this.channelOnce) {
                    if (this.channelOnce[key]) {
                        this.channelOnce[key].volume = this._soundVolume;
                    }
                }
            };
            AudioEx.prototype.setMusicVolume = function (val) {
                this._musicVolume = val;
                for (var key in this.channelLoop) {
                    if (this.channelLoop[key]) {
                        this.channelLoop[key].volume = this._musicVolume;
                    }
                }
            };
            return AudioEx;
        }());
        framework.AudioEx = AudioEx;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var aniplayer = (function () {
            function aniplayer() {
                this._clipnameCount = 0;
                this._clipnames = null;
                this.autoplay = true;
                this.playIndex = 0;
                this._playClip = null;
                this.tpose = {};
                this.nowpose = {};
                this.lerppose = {};
                this.carelist = {};
                this._playFrameid = 0;
                this._playTimer = 0;
                this.speed = 1.0;
                this.crossdelta = 0;
                this.crossspeed = 0;
                this.beRevert = false;
                this.playStyle = PlayStyle.NormalPlay;
                this.percent = 0;
            }
            Object.defineProperty(aniplayer.prototype, "clipnames", {
                get: function () {
                    if (this._clipnames == null || this._clipnameCount != this.clips.length) {
                        this._clipnameCount = this.clips.length;
                        this._clipnames = {};
                        for (var key in this.clips) {
                            this.clipnames[this.clips[key].getName()] = parseInt(key);
                        }
                    }
                    return this._clipnames;
                },
                enumerable: true,
                configurable: true
            });
            aniplayer.prototype.init = function () {
                for (var i = 0; i < this.bones.length; i++) {
                    var _info = this.bones[i];
                    var name_2 = _info.name;
                    var nb = new framework.PoseBoneMatrix();
                    nb.r = _info.tposeq;
                    nb.t = _info.tposep;
                    nb.invert();
                    this.tpose[name_2] = nb;
                    this.nowpose[name_2] = this.startPos[i].Clone();
                }
                var asbones = this.gameObject.getComponentsInChildren("asbone");
                for (var key in asbones) {
                    this.care(asbones[key].gameObject.transform);
                }
                if (this.autoplay && this.clips != null) {
                    this.playByIndex(this.playIndex);
                }
            };
            aniplayer.prototype.start = function () {
                if (this.bones != null) {
                    this.init();
                }
            };
            aniplayer.prototype.update = function (delta) {
                if (this._playClip == null)
                    return;
                this.checkFrameId(delta);
                var mix = false;
                if (this.crossdelta > 0) {
                    this.crossdelta -= delta / this.speed * this.crossspeed;
                    mix = true;
                }
                for (var i = 0; i < this._playClip.boneCount; i++) {
                    var bone = this._playClip.bones[i];
                    var frame = this._playClip.frames[this._playFrameid];
                    var nextseek = i * 7 + 1;
                    var outb = this.nowpose[bone];
                    var tpose = this.tpose[bone];
                    if (outb != undefined) {
                        if (mix) {
                            var last = this.lerppose[bone];
                            if (last != undefined) {
                                outb.lerpInWorldWithData(tpose, last, frame, nextseek, 1 - this.crossdelta);
                            }
                            else {
                                outb.copyFromData(frame, nextseek);
                            }
                        }
                        else {
                            outb.copyFromData(frame, nextseek);
                        }
                    }
                    var careobj = this.carelist[bone];
                    if (careobj != undefined) {
                        var fmat = framework.PoseBoneMatrix.sMultiply(outb, tpose);
                        var _matrix = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMakeTransformRTS(fmat.t, gd3d.math.pool.vector3_one, fmat.r, _matrix);
                        var _newmatrix = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(this.gameObject.transform.getWorldMatrix(), _matrix, _newmatrix);
                        careobj.setWorldMatrix(_newmatrix);
                        careobj.updateTran(false);
                        gd3d.math.pool.delete_matrix(_matrix);
                        gd3d.math.pool.delete_matrix(_newmatrix);
                    }
                }
            };
            aniplayer.prototype.playByIndex = function (animIndex, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                this.playIndex = animIndex;
                if (this.clips.length <= animIndex) {
                    console.error("animIndex out Array of clips");
                    return;
                }
                this.playAniamtion(animIndex.toString(), speed, beRevert);
                this.crossdelta = 0;
            };
            aniplayer.prototype.playCrossByIndex = function (animIndex, crosstimer, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                this.playIndex = animIndex;
                if (this.clips.length <= animIndex) {
                    console.error("animIndex out Array of clips");
                    return;
                }
                this.playAniamtion(animIndex.toString(), speed, beRevert);
                this.crossspeed = 1.0 / crosstimer;
                this.crossdelta = 1;
            };
            aniplayer.prototype.play = function (animName, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                if (this.clipnames[animName] == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                this.playByIndex(this.clipnames[animName], speed, beRevert);
            };
            aniplayer.prototype.playCross = function (animName, crosstimer, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                if (this.clipnames[animName] == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                if (crosstimer <= 0) {
                    this.playByIndex(this.clipnames[animName], speed, beRevert);
                }
                else {
                    this.playCrossByIndex(this.clipnames[animName], crosstimer, speed, beRevert);
                }
            };
            aniplayer.prototype.playAniamtion = function (index, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                if (this.clips[index] == undefined)
                    return;
                this._playClip = this.clips[index];
                this._playTimer = 0;
                this._playFrameid = 0;
                this.speed = speed;
                this.beRevert = beRevert;
                this.playStyle = PlayStyle.NormalPlay;
                this.speed = speed;
                this.lerppose = {};
                for (var key in this.nowpose) {
                    var src = this.nowpose[key];
                    this.lerppose[key] = src.Clone();
                }
            };
            aniplayer.prototype.stop = function () {
                this._playClip = null;
            };
            aniplayer.prototype.isPlay = function () {
                return this._playClip != null;
            };
            aniplayer.prototype.isStop = function () {
                if (this._playClip == null)
                    return false;
                if (this.playStyle != PlayStyle.NormalPlay)
                    return false;
                if (this._playClip.loop)
                    return false;
                if (this._playFrameid == this._playClip.frameCount - 1)
                    return true;
                return false;
            };
            aniplayer.prototype.remove = function () {
                this.clips.length = 0;
                this.bones.length = 0;
                this.startPos.length = 0;
                delete this.tpose;
                delete this.nowpose;
                delete this.lerppose;
                delete this.carelist;
                delete this._clipnames;
            };
            aniplayer.prototype.clone = function () {
            };
            aniplayer.prototype.addFinishedEventListener = function (finishCallBack, thisObject) {
                this.finishCallBack = finishCallBack;
                this.thisObject = thisObject;
            };
            aniplayer.prototype.checkFrameId = function (delay) {
                if (this.playStyle == PlayStyle.NormalPlay) {
                    this._playTimer += delay * this.speed;
                    this._playFrameid = (this._playClip.fps * this._playTimer) | 0;
                    if (this._playClip.loop) {
                        this._playFrameid %= this._playClip.frameCount;
                    }
                    else if (this._playFrameid > this._playClip.frameCount - 1) {
                        this._playFrameid = this._playClip.frameCount - 1;
                    }
                    if (this.beRevert) {
                        this._playFrameid = this._playClip.frameCount - this._playFrameid - 1;
                    }
                }
                else if (this.playStyle == PlayStyle.FramePlay) {
                    this._playFrameid = (this._playClip.frameCount * this.percent) - 1;
                    this._playFrameid = Math.round(this._playFrameid);
                }
                if (this._playFrameid < 0) {
                    this._playFrameid = 0;
                }
                if (this._playFrameid > this._playClip.frameCount - 1) {
                    this._playFrameid = this._playClip.frameCount - 1;
                }
                if (this.isStop()) {
                    if (this.finishCallBack) {
                        this.finishCallBack(this.thisObject);
                        this.finishCallBack = null;
                    }
                }
            };
            aniplayer.prototype.fillPoseData = function (data, bones, efficient) {
                if (efficient === void 0) { efficient = true; }
                var seek = 0;
                for (var i in bones) {
                    var key = bones[i].name;
                    var obj = this.nowpose[key];
                    if (obj == undefined) {
                        if (efficient) {
                            data[seek * 8 + 0] = 0;
                            data[seek * 8 + 1] = 0;
                            data[seek * 8 + 2] = 0;
                            data[seek * 8 + 3] = 1;
                            data[seek * 8 + 4] = 0;
                            data[seek * 8 + 5] = 0;
                            data[seek * 8 + 6] = 0;
                            data[seek * 8 + 7] = 1;
                        }
                        else {
                            data[seek * 16 + 0] = 1;
                            data[seek * 16 + 1] = 0;
                            data[seek * 16 + 2] = 0;
                            data[seek * 16 + 3] = 0;
                            data[seek * 16 + 4] = 0;
                            data[seek * 16 + 5] = 1;
                            data[seek * 16 + 6] = 0;
                            data[seek * 16 + 7] = 0;
                            data[seek * 16 + 8] = 0;
                            data[seek * 16 + 9] = 0;
                            data[seek * 16 + 10] = 1;
                            data[seek * 16 + 11] = 0;
                            data[seek * 16 + 12] = 0;
                            data[seek * 16 + 13] = 0;
                            data[seek * 16 + 14] = 0;
                            data[seek * 16 + 15] = 1;
                        }
                    }
                    else {
                        var _mat = gd3d.math.pool.new_matrix();
                        if (efficient) {
                            data[seek * 8 + 0] = obj.r.x;
                            data[seek * 8 + 1] = obj.r.y;
                            data[seek * 8 + 2] = obj.r.z;
                            data[seek * 8 + 3] = obj.r.w;
                            data[seek * 8 + 4] = obj.t.x;
                            data[seek * 8 + 5] = obj.t.y;
                            data[seek * 8 + 6] = obj.t.z;
                            data[seek * 8 + 7] = 1;
                        }
                        else {
                            gd3d.math.matrixMakeTransformRTS(obj.t, gd3d.math.pool.vector3_one, obj.r, _mat);
                            for (var j = 0; j < 16; j++) {
                                data[seek * 16 + j] = _mat.rawData[j];
                            }
                        }
                    }
                    seek++;
                }
            };
            aniplayer.prototype.care = function (node) {
                var pnode = node;
                while (true) {
                    if (this.nowpose[pnode.name] != undefined) {
                        this.carelist[pnode.name] = pnode;
                        return;
                    }
                    pnode = pnode.parent;
                }
            };
            return aniplayer;
        }());
        __decorate([
            gd3d.reflect.Field("animationClip[]"),
            __metadata("design:type", Array)
        ], aniplayer.prototype, "clips", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], aniplayer.prototype, "autoplay", void 0);
        __decorate([
            gd3d.reflect.Field("tPoseInfo[]"),
            __metadata("design:type", Array)
        ], aniplayer.prototype, "bones", void 0);
        __decorate([
            gd3d.reflect.Field("PoseBoneMatrix[]"),
            __metadata("design:type", Array)
        ], aniplayer.prototype, "startPos", void 0);
        aniplayer = __decorate([
            gd3d.reflect.nodeComponent
        ], aniplayer);
        framework.aniplayer = aniplayer;
        var tPoseInfo = (function () {
            function tPoseInfo() {
            }
            return tPoseInfo;
        }());
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], tPoseInfo.prototype, "name", void 0);
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], tPoseInfo.prototype, "tposep", void 0);
        __decorate([
            gd3d.reflect.Field("quaternion"),
            __metadata("design:type", gd3d.math.quaternion)
        ], tPoseInfo.prototype, "tposeq", void 0);
        tPoseInfo = __decorate([
            gd3d.reflect.SerializeType
        ], tPoseInfo);
        framework.tPoseInfo = tPoseInfo;
        var PlayStyle;
        (function (PlayStyle) {
            PlayStyle[PlayStyle["NormalPlay"] = 0] = "NormalPlay";
            PlayStyle[PlayStyle["FramePlay"] = 1] = "FramePlay";
            PlayStyle[PlayStyle["PingPang"] = 2] = "PingPang";
        })(PlayStyle = framework.PlayStyle || (framework.PlayStyle = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var asbone = (function () {
            function asbone() {
            }
            asbone.prototype.start = function () {
            };
            asbone.prototype.update = function (delta) {
            };
            asbone.prototype.remove = function () {
            };
            asbone.prototype.clone = function () {
            };
            return asbone;
        }());
        asbone = __decorate([
            gd3d.reflect.nodeComponent,
            __metadata("design:paramtypes", [])
        ], asbone);
        framework.asbone = asbone;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var boxcollider = (function () {
            function boxcollider() {
                this._colliderVisible = false;
            }
            boxcollider.prototype.getBound = function () {
                return this.obb;
            };
            Object.defineProperty(boxcollider.prototype, "matrix", {
                get: function () {
                    if (this.gameObject)
                        return this.gameObject.transform.getWorldMatrix();
                    return new gd3d.math.matrix();
                },
                enumerable: true,
                configurable: true
            });
            boxcollider.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.build();
            };
            boxcollider.prototype.update = function (delta) {
                if (this.obb) {
                    this.obb.update(this.matrix);
                }
            };
            Object.defineProperty(boxcollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            boxcollider.prototype.intersectsTransform = function (tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.obb == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.obb.intersects(_obb);
            };
            boxcollider.prototype.build = function () {
                this.obb = new framework.obb();
                if (this.center && this.size) {
                    this.obb.buildByCenterSize(this.center, this.size);
                }
                else {
                    var minimum = new gd3d.math.vector3();
                    var maximum = new gd3d.math.vector3();
                    if (this.filter) {
                        var meshdata = this.filter.getMeshOutput().data;
                        gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                        gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                        for (var i = 0; i < meshdata.pos.length; i++) {
                            gd3d.math.vec3Max(meshdata.pos[i], maximum, maximum);
                            gd3d.math.vec3Min(meshdata.pos[i], minimum, minimum);
                        }
                        console.log("add obb filter " + minimum + "  " + maximum);
                    }
                    else {
                        minimum.x = -1;
                        minimum.y = -1;
                        minimum.z = -1;
                        maximum.x = 1;
                        maximum.y = 1;
                        maximum.z = 1;
                    }
                    this.obb.buildByMaxMin(minimum, maximum);
                }
                this.buildMesh();
            };
            boxcollider.prototype.buildMesh = function () {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "boxcollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
            };
            boxcollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                _mesh.data = gd3d.render.meshData.genBoxByArray_Quad(this.obb.vectors);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayQuad2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexSubData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = true;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            boxcollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
                if (this.obb) {
                    this.obb.dispose();
                }
            };
            boxcollider.prototype.clone = function () {
            };
            return boxcollider;
        }());
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], boxcollider.prototype, "center", void 0);
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], boxcollider.prototype, "size", void 0);
        boxcollider = __decorate([
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeBoxCollider
        ], boxcollider);
        framework.boxcollider = boxcollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var cameraPostQueue_Depth = (function () {
            function cameraPostQueue_Depth() {
                this.renderTarget = null;
            }
            cameraPostQueue_Depth.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                context.webgl.depthMask(true);
                context.webgl.clearColor(0, 0, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                camera._renderOnce(scene, context, "_depth");
                gd3d.render.glRenderTarget.useNull(context.webgl);
            };
            return cameraPostQueue_Depth;
        }());
        framework.cameraPostQueue_Depth = cameraPostQueue_Depth;
        var cameraPostQueue_Quad = (function () {
            function cameraPostQueue_Quad() {
                this.renderTarget = null;
                this.material = new framework.material();
            }
            cameraPostQueue_Quad.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                context.webgl.depthMask(true);
                context.webgl.clearColor(0, 0.3, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                var mesh = scene.app.getAssetMgr().getDefaultMesh("quad");
                context.drawtype = "";
                this.material.draw(context, mesh, mesh.submesh[0], "quad");
            };
            return cameraPostQueue_Quad;
        }());
        framework.cameraPostQueue_Quad = cameraPostQueue_Quad;
        var cameraPostQueue_Color = (function () {
            function cameraPostQueue_Color() {
                this.renderTarget = null;
            }
            cameraPostQueue_Color.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, false);
                camera._renderOnce(scene, context, "");
                gd3d.render.glRenderTarget.useNull(context.webgl);
            };
            return cameraPostQueue_Color;
        }());
        framework.cameraPostQueue_Color = cameraPostQueue_Color;
        var camera = (function () {
            function camera() {
                this._near = 0.01;
                this._far = 1000;
                this.isMainCamera = false;
                this.CullingMask = CullingMask.default | CullingMask.ui;
                this.clearOption_Color = true;
                this.clearOption_Depth = true;
                this.backgroundColor = new gd3d.math.color(0.5, 0.8, 1, 1);
                this.viewport = new gd3d.math.rect(0, 0, 1, 1);
                this.renderTarget = null;
                this.order = 0;
                this.overlays = [];
                this.matView = new gd3d.math.matrix;
                this.matProjP = new gd3d.math.matrix;
                this.matProjO = new gd3d.math.matrix;
                this.matProj = new gd3d.math.matrix;
                this.fov = Math.PI * 0.25;
                this.size = 2;
                this.opvalue = 1;
                this.postQueues = [];
            }
            Object.defineProperty(camera.prototype, "near", {
                get: function () {
                    return this._near;
                },
                set: function (val) {
                    if (val >= this.far)
                        val = this.far - 1;
                    if (val < 0.01)
                        val = 0.01;
                    this._near = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(camera.prototype, "far", {
                get: function () {
                    return this._far;
                },
                set: function (val) {
                    if (val <= this.near)
                        val = this.near + 1;
                    if (val >= 1000)
                        val = 1000;
                    this._far = val;
                },
                enumerable: true,
                configurable: true
            });
            camera.prototype.markDirty = function () {
            };
            camera.prototype.start = function () {
            };
            camera.prototype.update = function (delta) {
                for (var i = 0; i < this.overlays.length; i++) {
                    if (!this.overlays[i].init) {
                        this.overlays[i].start(this);
                        this.overlays[i].init = true;
                    }
                    this.overlays[i].update(delta);
                }
            };
            camera.prototype.addOverLay = function (overLay) {
                this.overlays.push(overLay);
            };
            camera.prototype.addOverLayAt = function (overLay, index) {
                this.overlays.splice(index, 0, overLay);
            };
            camera.prototype.getOverLays = function () {
                return this.overlays;
            };
            camera.prototype.removeOverLay = function (overLay) {
                if (this.overlays == null)
                    return;
                var index = this.overlays.indexOf(overLay);
                if (index >= 0)
                    this.overlays.splice(index, 1);
            };
            camera.prototype.calcViewMatrix = function (matrix) {
                var camworld = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixInverse(camworld, this.matView);
                gd3d.math.matrixClone(this.matView, matrix);
                return;
            };
            camera.prototype.calcViewPortPixel = function (app, viewPortPixel) {
                var w;
                var h;
                if (this.renderTarget == null) {
                    w = app.width;
                    h = app.height;
                }
                else {
                    w = this.renderTarget.width;
                    h = this.renderTarget.height;
                }
                viewPortPixel.x = w * this.viewport.x;
                viewPortPixel.y = h * this.viewport.y;
                viewPortPixel.w = w * this.viewport.w;
                viewPortPixel.h = h * this.viewport.h;
            };
            camera.prototype.calcProjectMatrix = function (asp, matrix) {
                if (this.opvalue > 0)
                    gd3d.math.matrixProject_PerspectiveLH(this.fov, asp, this.near, this.far, this.matProjP);
                if (this.opvalue < 1)
                    gd3d.math.matrixProject_OrthoLH(this.size * asp, this.size, this.near, this.far, this.matProjO);
                if (this.opvalue == 0)
                    gd3d.math.matrixClone(this.matProjO, this.matProj);
                else if (this.opvalue == 1)
                    gd3d.math.matrixClone(this.matProjP, this.matProj);
                else
                    gd3d.math.matrixLerp(this.matProjO, this.matProjP, this.opvalue, this.matProj);
                gd3d.math.matrixClone(this.matProj, matrix);
            };
            camera.prototype.creatRayByScreen = function (screenpos, app) {
                var src1 = gd3d.math.pool.new_vector3();
                src1.x = screenpos.x;
                src1.y = screenpos.y;
                src1.z = 0;
                var src2 = gd3d.math.pool.new_vector3();
                src2.x = screenpos.x;
                src2.y = screenpos.y;
                src2.z = 1;
                var dest1 = gd3d.math.pool.new_vector3();
                var dest2 = gd3d.math.pool.new_vector3();
                this.calcWorldPosFromScreenPos(app, src1, dest1);
                this.calcWorldPosFromScreenPos(app, src2, dest2);
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(dest2, dest1, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var ray = new gd3d.framework.ray(dest1, dir);
                gd3d.math.pool.delete_vector3(src1);
                gd3d.math.pool.delete_vector3(src2);
                gd3d.math.pool.delete_vector3(dest1);
                gd3d.math.pool.delete_vector3(dest2);
                gd3d.math.pool.delete_vector3(dir);
                return ray;
            };
            camera.prototype.calcWorldPosFromScreenPos = function (app, screenPos, outWorldPos) {
                var vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, vpp);
                var vppos = new gd3d.math.vector2(screenPos.x / vpp.w * 2 - 1, 1 - screenPos.y / vpp.h * 2);
                var matrixView = new gd3d.math.matrix();
                var matrixProject = new gd3d.math.matrix();
                var asp = vpp.w / vpp.h;
                this.calcViewMatrix(matrixView);
                this.calcProjectMatrix(asp, matrixProject);
                var matrixViewProject = new gd3d.math.matrix();
                var matinv = new gd3d.math.matrix();
                gd3d.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                gd3d.math.matrixInverse(matrixViewProject, matinv);
                var src1 = new gd3d.math.vector3(vppos.x, vppos.y, screenPos.z);
                gd3d.math.matrixTransformVector3(src1, matinv, outWorldPos);
            };
            camera.prototype.calcScreenPosFromWorldPos = function (app, worldPos, outScreenPos) {
                var vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, vpp);
                var matrixView = new gd3d.math.matrix();
                var matrixProject = new gd3d.math.matrix();
                var asp = vpp.w / vpp.h;
                this.calcViewMatrix(matrixView);
                this.calcProjectMatrix(asp, matrixProject);
                var matrixViewProject = new gd3d.math.matrix();
                var matinv = new gd3d.math.matrix();
                gd3d.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                var ndcPos = gd3d.math.pool.new_vector3();
                gd3d.math.matrixTransformVector3(worldPos, matrixViewProject, ndcPos);
                outScreenPos.x = (ndcPos.x + 1) * vpp.w / 2;
                outScreenPos.y = (1 - ndcPos.y) * vpp.h / 2;
            };
            camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, app, z, out) {
                var vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, vpp);
                var nearpos = new gd3d.math.vector3;
                nearpos.z = -this.near;
                nearpos.x = screenPos.x - vpp.w * 0.5;
                nearpos.y = vpp.h * 0.5 - screenPos.y;
                var farpos = new gd3d.math.vector3;
                farpos.z = -this.far;
                farpos.x = this.far * nearpos.x / this.near;
                farpos.y = this.far * nearpos.y / this.near;
                ;
                var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
                out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
                out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
            };
            camera.prototype.fillRenderer = function (scene) {
                scene.renderList.clear();
                this._fillRenderer(scene, scene.getRoot());
            };
            camera.prototype._fillRenderer = function (scene, node) {
                if (node.gameObject != null && node.gameObject.renderer != null && node.gameObject.visible) {
                    scene.renderList.addRenderer(node.gameObject.renderer);
                }
                if (node.children != null && node.gameObject.visible) {
                    for (var i = 0; i < node.children.length; i++) {
                        this._fillRenderer(scene, node.children[i]);
                    }
                }
            };
            camera.prototype._targetAndViewport = function (target, scene, context, withoutClear) {
                {
                    var w;
                    var h;
                    if (target == null) {
                        w = scene.app.width;
                        h = scene.app.height;
                        gd3d.render.glRenderTarget.useNull(context.webgl);
                    }
                    else {
                        w = target.width;
                        h = target.height;
                        target.use(context.webgl);
                    }
                    context.webgl.viewport(w * this.viewport.x, h * this.viewport.y, w * this.viewport.w, h * this.viewport.h);
                    context.webgl.depthRange(0, 1);
                    if (withoutClear == false) {
                        if (this.clearOption_Color && this.clearOption_Depth) {
                            context.webgl.depthMask(true);
                            context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            context.webgl.clearDepth(1.0);
                            context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                        }
                        else if (this.clearOption_Depth) {
                            context.webgl.depthMask(true);
                            context.webgl.clearDepth(1.0);
                            context.webgl.clear(context.webgl.DEPTH_BUFFER_BIT);
                        }
                        else if (this.clearOption_Color) {
                            context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            context.webgl.clear(context.webgl.COLOR_BUFFER_BIT);
                        }
                        else {
                        }
                    }
                }
            };
            camera.prototype._renderOnce = function (scene, context, drawtype) {
                context.drawtype = drawtype;
                var assetmgr = scene.app.getAssetMgr();
                for (var i = 0; i < scene.renderList.renderLayers.length; i++) {
                    var layer = scene.renderList.renderLayers[i];
                    var list = layer.list;
                    for (var j = 0; j < list.length; j++) {
                        if (this.CullingMask & list[j].renderLayer) {
                            list[j].render(context, assetmgr, this);
                        }
                    }
                }
            };
            camera.prototype.renderScene = function (scene, context) {
                var _this = this;
                for (var i = 0; i < scene.renderList.renderLayers.length; i++) {
                    var layer = scene.renderList.renderLayers[i];
                    var list = layer.list;
                    if (layer.needSort) {
                        if (list.length > 1) {
                            list.sort(function (a, b) {
                                if (a.queue != b.queue) {
                                    return a.queue - b.queue;
                                }
                                else {
                                    var matrixView = gd3d.math.pool.new_matrix();
                                    _this.calcViewMatrix(matrixView);
                                    var az = gd3d.math.pool.new_vector3();
                                    var bz = gd3d.math.pool.new_vector3();
                                    gd3d.math.matrixTransformVector3(a.gameObject.transform.getWorldTranslate(), matrixView, az);
                                    gd3d.math.matrixTransformVector3(b.gameObject.transform.getWorldTranslate(), matrixView, bz);
                                    return az.z - bz.z;
                                }
                            });
                        }
                    }
                }
                if (this.postQueues.length == 0) {
                    this._targetAndViewport(this.renderTarget, scene, context, false);
                    this._renderOnce(scene, context, "");
                    context.webgl.flush();
                }
                else {
                    for (var i = 0; i < this.postQueues.length; i++) {
                        this.postQueues[i].render(scene, context, this);
                    }
                    context.webgl.flush();
                }
            };
            camera.prototype.remove = function () {
            };
            camera.prototype.clone = function () {
            };
            return camera;
        }());
        __decorate([
            gd3d.reflect.UIStyle("rangeFloat", 1, 1000, 2),
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], camera.prototype, "near", null);
        __decorate([
            gd3d.reflect.UIStyle("rangeFloat", 1, 1000, 999),
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], camera.prototype, "far", null);
        __decorate([
            gd3d.reflect.compCall({ "use": "dirty", "display": "camera" }),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], camera.prototype, "markDirty", null);
        __decorate([
            gd3d.reflect.Field("IOverLay[]"),
            __metadata("design:type", Array)
        ], camera.prototype, "overlays", void 0);
        camera = __decorate([
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeCamera
        ], camera);
        framework.camera = camera;
        var CullingMask;
        (function (CullingMask) {
            CullingMask[CullingMask["ui"] = 1] = "ui";
            CullingMask[CullingMask["default"] = 2] = "default";
            CullingMask[CullingMask["editor"] = 4] = "editor";
            CullingMask[CullingMask["model"] = 8] = "model";
            CullingMask[CullingMask["everything"] = 4294967295] = "everything";
            CullingMask[CullingMask["nothing"] = 0] = "nothing";
            CullingMask[CullingMask["modelbeforeui"] = 8] = "modelbeforeui";
        })(CullingMask = framework.CullingMask || (framework.CullingMask = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var effectSystem = effectSystem_1 = (function () {
            function effectSystem() {
                this.layer = framework.RenderLayerEnum.Transparent;
                this.renderLayer = framework.CullingMask.default;
                this.queue = 0;
                this.autoplay = true;
                this.state = framework.EffectPlayStateEnum.None;
                this.curFrameId = -1;
                this.frameId = 0;
                this.playTimer = 0;
                this.speed = 1;
                this.parser = new gd3d.framework.EffectParser();
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.effectBatchers = [];
                this.matDataGroups = [];
            }
            effectSystem.prototype.setEffect = function (effectConfig) {
                this.data = this.parser.Parse(effectConfig, gd3d.framework.sceneMgr.app.getAssetMgr());
            };
            effectSystem.prototype.setJsonData = function (_jsonData) {
                this.jsonData = _jsonData;
                this.data = this.parser.Parse(this.jsonData.content, gd3d.framework.sceneMgr.app.getAssetMgr());
            };
            Object.defineProperty(effectSystem.prototype, "data", {
                get: function () {
                    return this._data;
                },
                set: function (value) {
                    this._data = value;
                    this.addElements();
                },
                enumerable: true,
                configurable: true
            });
            effectSystem.prototype.start = function () {
            };
            effectSystem.prototype.update = function (delta) {
                if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined)
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play) {
                    this.playTimer += delta * this.speed;
                    if (this.playTimer >= this.data.life) {
                        if (this.beLoop) {
                            this.reset();
                            this.play();
                        }
                        else {
                            this.stop();
                        }
                    }
                    this._update(delta);
                }
                else if (this.state == framework.EffectPlayStateEnum.BeReady) {
                    if (this.autoplay) {
                        this.play();
                    }
                    else {
                        this.gameObject.visible = false;
                        this.gameObject.transform.markDirty();
                    }
                }
            };
            effectSystem.prototype._update = function (delta) {
                if (this.checkFrameId()) {
                    for (var i in this.effectBatchers) {
                        var subEffectBatcher = this.effectBatchers[i];
                        for (var key in subEffectBatcher.effectElements) {
                            var element = subEffectBatcher.effectElements[key];
                            var frameId = this.curFrameId % element.loopFrame;
                            if (element.active) {
                                element.actionActive = false;
                                this.mergeLerpAttribData(element.curAttrData, element.timelineFrame[frameId]);
                                if (element.actions != undefined) {
                                    element.actionActive = true;
                                    for (var j in element.actions) {
                                        element.actions[j].update(frameId);
                                    }
                                }
                            }
                            element.update();
                            if (element.isActiveFrame(frameId)) {
                                this.updateEffectBatcher(element.effectBatcher, element.curAttrData, element.data.initFrameData, element.startIndex);
                            }
                        }
                    }
                    if (this.particles != undefined) {
                        this.frameId = this.curFrameId % this.particles.loopFrame;
                        this.particles.update(1 / effectSystem_1.fps);
                    }
                }
            };
            effectSystem.prototype.mergeLerpAttribData = function (realUseCurFrameData, curFrameData) {
                if (curFrameData == undefined)
                    return;
                if (realUseCurFrameData == undefined)
                    return;
                for (var key in curFrameData.attrsData) {
                    if (curFrameData.attrsData[key] != undefined && realUseCurFrameData[key] != undefined) {
                        var val = curFrameData.attrsData.getAttribute(key);
                        if (val == null)
                            continue;
                        if (val instanceof gd3d.math.vector3 || val instanceof gd3d.math.vector2 || typeof (val) === 'number') {
                            if (key != "renderModel")
                                realUseCurFrameData[key] = val;
                        }
                    }
                }
            };
            effectSystem.prototype.updateEffectBatcher = function (effectBatcher, curAttrsData, initFrameData, vertexStartIndex) {
                var mesh = curAttrsData.mesh;
                if (mesh == undefined) {
                    mesh = initFrameData.attrsData.mesh;
                }
                if (mesh == undefined)
                    return;
                if (curAttrsData.meshdataVbo == undefined) {
                    curAttrsData.meshdataVbo = mesh.data.genVertexDataArray(this.vf);
                }
                var vertexCount = mesh.data.pos.length;
                var vertexArr = curAttrsData.meshdataVbo;
                var vertexSize = effectBatcher.vertexSize;
                for (var i = 0; i < vertexCount; i++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = vertexArr[i * vertexSize + 0];
                        vertex.y = vertexArr[i * vertexSize + 1];
                        vertex.z = vertexArr[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, curAttrsData.matrix, vertex);
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 0] = vertex.x;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 1] = vertex.y;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        var r = gd3d.math.floatClamp(vertexArr[i * vertexSize + 9], 0, 1);
                        var g = gd3d.math.floatClamp(vertexArr[i * vertexSize + 10], 0, 1);
                        var b = gd3d.math.floatClamp(vertexArr[i * vertexSize + 11], 0, 1);
                        var a = gd3d.math.floatClamp(vertexArr[i * vertexSize + 12], 0, 1);
                        if (curAttrsData.color != undefined) {
                            r = gd3d.math.floatClamp(curAttrsData.color.x, 0, 1);
                            g = gd3d.math.floatClamp(curAttrsData.color.y, 0, 1);
                            b = gd3d.math.floatClamp(curAttrsData.color.z, 0, 1);
                        }
                        if (curAttrsData.alpha != undefined)
                            a = gd3d.math.floatClamp(curAttrsData.alpha * a, 0, 1);
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 9] = r;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 10] = g;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 11] = b;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 12] = a;
                    }
                    {
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 13] = vertexArr[i * vertexSize + 13] * curAttrsData.tilling.x + curAttrsData.uv.x;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 14] = vertexArr[i * vertexSize + 14] * curAttrsData.tilling.y + curAttrsData.uv.y;
                    }
                }
            };
            effectSystem.prototype.render = function (context, assetmgr, camera) {
                if (this.state == framework.EffectPlayStateEnum.Play) {
                    context.updateModel(this.gameObject.transform);
                    for (var i in this.effectBatchers) {
                        var subEffectBatcher = this.effectBatchers[i];
                        var mesh_1 = subEffectBatcher.mesh;
                        if (!subEffectBatcher.beBufferInited) {
                            mesh_1.glMesh.initBuffer(context.webgl, this.vf, subEffectBatcher.curTotalVertexCount);
                            if (mesh_1.glMesh.ebos.length == 0) {
                                mesh_1.glMesh.addIndex(context.webgl, subEffectBatcher.dataForEbo.length);
                            }
                            else {
                                mesh_1.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
                            }
                            mesh_1.glMesh.uploadIndexSubData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh_1.submesh[0].size = subEffectBatcher.dataForEbo.length;
                            subEffectBatcher.beBufferInited = true;
                        }
                        mesh_1.glMesh.uploadVertexSubData(context.webgl, subEffectBatcher.dataForVbo);
                        subEffectBatcher.mat.draw(context, mesh_1, mesh_1.submesh[0], "base");
                    }
                    if (this.particles != undefined) {
                        this.particles.render(context, assetmgr, camera);
                    }
                }
            };
            effectSystem.prototype.clone = function () {
                var effect = new effectSystem_1();
                effect.data = this.data.clone();
                return effect;
            };
            effectSystem.prototype.play = function (speed) {
                if (speed === void 0) { speed = 1; }
                this.speed = speed;
                this.state = framework.EffectPlayStateEnum.Play;
                this.gameObject.visible = true;
                this.gameObject.transform.markDirty();
            };
            effectSystem.prototype.pause = function () {
                this.state = framework.EffectPlayStateEnum.Pause;
            };
            effectSystem.prototype.stop = function () {
                this.reset();
                this.state = framework.EffectPlayStateEnum.Stop;
            };
            effectSystem.prototype.reset = function () {
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.gameObject.visible = false;
                this.playTimer = 0;
                for (var i in this.effectBatchers) {
                    var subEffectBatcher = this.effectBatchers[i];
                    for (var key in subEffectBatcher.effectElements) {
                        var element = subEffectBatcher.effectElements[key];
                        element.setActive(true);
                        if (element.data.initFrameData != undefined)
                            element.curAttrData = element.data.initFrameData.attrsData.clone();
                    }
                }
            };
            effectSystem.prototype.addElements = function () {
                for (var index in this.data.elements) {
                    var data = this.data.elements[index];
                    if (data.type == framework.EffectElementTypeEnum.EmissionType) {
                        if (this.particles == undefined) {
                            this.particles = new framework.Particles(this);
                        }
                        this.particles.addEmission(data.emissionData);
                    }
                    else if (data.type == framework.EffectElementTypeEnum.SingleMeshType) {
                        this.addInitFrame(data);
                    }
                }
                this.state = framework.EffectPlayStateEnum.BeReady;
                if (this.data.life == 0)
                    this.beLoop = true;
                else
                    this.beLoop = false;
            };
            effectSystem.prototype.addInitFrame = function (elementData) {
                var element = new framework.EffectElement(elementData);
                element.transform = this.gameObject.transform;
                var _initFrameData = element.data.initFrameData;
                if (_initFrameData == undefined || _initFrameData.attrsData == undefined || _initFrameData.attrsData.mesh == undefined)
                    return;
                var index = -1;
                if (_initFrameData.attrsData.mat != null) {
                    for (var i_2 = 0; i_2 < this.matDataGroups.length; i_2++) {
                        if (framework.EffectMatData.beEqual(this.matDataGroups[i_2], _initFrameData.attrsData.mat)) {
                            index = i_2;
                            break;
                        }
                    }
                }
                var vertexStartIndex = 0;
                var vertexCount = _initFrameData.attrsData.mesh.data.pos.length;
                var subEffectBatcher = null;
                if (index >= 0) {
                    subEffectBatcher = this.effectBatchers[index];
                    vertexStartIndex = subEffectBatcher.curTotalVertexCount;
                    subEffectBatcher.curTotalVertexCount += vertexCount;
                }
                else {
                    subEffectBatcher = new framework.EffectBatcher(this.vf);
                    subEffectBatcher.curTotalVertexCount = vertexCount;
                    subEffectBatcher.mesh = new framework.mesh();
                    subEffectBatcher.mesh.data = new gd3d.render.meshData();
                    subEffectBatcher.mesh.glMesh = new gd3d.render.glMesh();
                    subEffectBatcher.mat = new framework.material();
                    subEffectBatcher.mesh.submesh = [];
                    {
                        var sm = new framework.subMeshInfo();
                        sm.matIndex = 0;
                        sm.useVertexIndex = 0;
                        sm.start = 0;
                        sm.size = 0;
                        sm.line = false;
                        subEffectBatcher.mesh.submesh.push(sm);
                    }
                    vertexStartIndex = 0;
                    index = 0;
                    if (_initFrameData.attrsData.mat.shader == null) {
                        subEffectBatcher.mat.setShader(framework.sceneMgr.app.getAssetMgr().getShader("diffuse.shader.json"));
                        console.error("{0}shader", elementData.name);
                    }
                    else {
                        subEffectBatcher.mat.setShader(_initFrameData.attrsData.mat.shader);
                    }
                    if (_initFrameData.attrsData.mat.alphaCut != undefined)
                        subEffectBatcher.mat.setFloat("_AlphaCut", _initFrameData.attrsData.mat.alphaCut);
                    if (_initFrameData.attrsData.mat.diffuseTexture != null)
                        subEffectBatcher.mat.setTexture("_MainTex", _initFrameData.attrsData.mat.diffuseTexture);
                    this.effectBatchers.push(subEffectBatcher);
                    this.matDataGroups.push(_initFrameData.attrsData.mat);
                }
                element.effectBatcher = subEffectBatcher;
                element.startIndex = vertexStartIndex;
                element.curAttrData = elementData.initFrameData.attrsData.clone();
                var vertexSize = subEffectBatcher.vertexSize;
                var vertexArr = _initFrameData.attrsData.mesh.data.genVertexDataArray(this.vf);
                element.update();
                subEffectBatcher.effectElements.push(element);
                for (var i_3 = 0; i_3 < vertexCount; i_3++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = vertexArr[i_3 * vertexSize + 0];
                        vertex.y = vertexArr[i_3 * vertexSize + 1];
                        vertex.z = vertexArr[i_3 * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, element.curAttrData.matrix, vertex);
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 0] = vertex.x;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 1] = vertex.y;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 3] = vertexArr[i_3 * vertexSize + 3];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 4] = vertexArr[i_3 * vertexSize + 4];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 5] = vertexArr[i_3 * vertexSize + 5];
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 6] = vertexArr[i_3 * vertexSize + 6];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 7] = vertexArr[i_3 * vertexSize + 7];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 8] = vertexArr[i_3 * vertexSize + 8];
                    }
                    {
                        var r = gd3d.math.floatClamp(element.curAttrData.color.x, 0, 1);
                        var g = gd3d.math.floatClamp(element.curAttrData.color.y, 0, 1);
                        var b = gd3d.math.floatClamp(element.curAttrData.color.z, 0, 1);
                        var a = gd3d.math.floatClamp(vertexArr[i_3 * vertexSize + 12] * element.curAttrData.alpha, 0, 1);
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 9] = r;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 10] = g;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 11] = b;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * 15 + 12] = a;
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 13] = vertexArr[i_3 * vertexSize + 13] * element.curAttrData.tilling.x;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_3) * vertexSize + 14] = vertexArr[i_3 * vertexSize + 14] * element.curAttrData.tilling.y;
                    }
                }
                var indexArray = _initFrameData.attrsData.mesh.data.genIndexDataArray();
                var _startIndex = subEffectBatcher.indexStartIndex;
                subEffectBatcher.indexStartIndex += indexArray.length;
                for (var i = 0; i < indexArray.length; i++) {
                    subEffectBatcher.dataForEbo[_startIndex + i] = indexArray[i] + vertexStartIndex;
                }
                this.effectBatchers[index].beBufferInited = false;
            };
            effectSystem.prototype.checkFrameId = function () {
                var curid = (effectSystem_1.fps * this.playTimer) | 0;
                if (curid != this.curFrameId) {
                    this.curFrameId = curid;
                    return true;
                }
                return false;
            };
            effectSystem.prototype.remove = function () {
                this.state = framework.EffectPlayStateEnum.Dispose;
                this.data.dispose();
                for (var key in this.effectBatchers) {
                    this.effectBatchers[key].dispose();
                }
                if (this.particles)
                    this.particles.dispose();
            };
            Object.defineProperty(effectSystem.prototype, "leftLifeTime", {
                get: function () {
                    if (this.data != null) {
                        return this.data.life - this.playTimer;
                    }
                    else
                        return 9999999999;
                },
                enumerable: true,
                configurable: true
            });
            return effectSystem;
        }());
        effectSystem.fps = 30;
        __decorate([
            gd3d.reflect.Field("textasset"),
            __metadata("design:type", framework.textasset)
        ], effectSystem.prototype, "jsonData", void 0);
        effectSystem = effectSystem_1 = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent,
            gd3d.reflect.selfClone
        ], effectSystem);
        framework.effectSystem = effectSystem;
        var effectSystem_1;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var guidpath = (function () {
            function guidpath() {
                this.speed = 1;
                this.isactived = false;
                this.datasafe = false;
                this.folowindex = 0;
                this.isloop = false;
                this.lookforward = false;
                this.adjustDir = false;
            }
            Object.defineProperty(guidpath.prototype, "pathasset", {
                get: function () {
                    return this._pathasset;
                },
                set: function (pathasset) {
                    if (this._pathasset) {
                        this._pathasset.unuse();
                    }
                    this._pathasset = pathasset;
                    if (this._pathasset) {
                        this._pathasset.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            guidpath.prototype.play = function () {
                this.isactived = true;
            };
            guidpath.prototype.pause = function () {
                this.isactived = false;
            };
            guidpath.prototype.stop = function () {
                this.isactived = false;
                this.folowindex = 0;
            };
            guidpath.prototype.replay = function () {
                this.isactived = true;
                this.folowindex = 0;
            };
            guidpath.prototype.setpathasset = function (pathasset, speed, oncomplete) {
                if (speed === void 0) { speed = 1; }
                if (oncomplete === void 0) { oncomplete = null; }
                this.pathasset = pathasset;
                if (pathasset == null) {
                    console.log(this.gameObject.getName().toString + ":are you sure set the right pathasseterrornull");
                    return;
                }
                this.paths = pathasset.paths;
                if (this.paths[0] != null) {
                    gd3d.math.vec3Clone(this.paths[0], this.gameObject.transform.localTranslate);
                    this.gameObject.transform.markDirty();
                    this.datasafe = true;
                }
                this.mystrans = this.gameObject.transform;
                this.speed = speed;
                this.oncomplete = oncomplete;
            };
            guidpath.prototype.start = function () {
            };
            guidpath.prototype.update = function (delta) {
                if (!this.isactived || !this.datasafe)
                    return;
                this.followmove(delta);
            };
            guidpath.prototype.followmove = function (delta) {
                var dist = gd3d.math.vec3Distance(this.mystrans.localTranslate, this.paths[this.folowindex]);
                if (dist < 0.01) {
                    if (this.folowindex < this.paths.length - 1) {
                        var dir = new gd3d.math.vector3();
                        gd3d.math.vec3Clone(this.paths[this.folowindex], this.mystrans.localTranslate);
                        this.folowindex++;
                        this.adjustDir = true;
                        this.mystrans.markDirty();
                    }
                    else {
                        this.folowindex = 0;
                        if (!this.isloop) {
                            this.isactived = false;
                            if (this.oncomplete) {
                                this.oncomplete();
                            }
                        }
                    }
                }
                else {
                    var dir = new gd3d.math.vector3();
                    gd3d.math.vec3Subtract(this.paths[this.folowindex], this.mystrans.localTranslate, dir);
                    if (this.adjustDir) {
                        var targetpos = this.paths[this.folowindex];
                        var localppos = this.mystrans.localTranslate;
                        var quat = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatLookat(localppos, targetpos, quat);
                        gd3d.math.quatClone(quat, this.mystrans.localRotate);
                        gd3d.math.pool.delete_quaternion(quat);
                        this.adjustDir = false;
                    }
                    var distadd = this.speed * delta;
                    if (distadd > dist)
                        distadd = dist;
                    var lerp = distadd / dist;
                    gd3d.math.vec3SLerp(this.mystrans.localTranslate, this.paths[this.folowindex], lerp, this.mystrans.localTranslate);
                    this.mystrans.markDirty();
                }
            };
            guidpath.prototype.remove = function () {
                if (this._pathasset) {
                    this._pathasset.unuse();
                }
            };
            guidpath.prototype.clone = function () {
            };
            return guidpath;
        }());
        guidpath = __decorate([
            gd3d.reflect.nodeComponent
        ], guidpath);
        framework.guidpath = guidpath;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var LightTypeEnum;
        (function (LightTypeEnum) {
            LightTypeEnum[LightTypeEnum["Direction"] = 0] = "Direction";
            LightTypeEnum[LightTypeEnum["Point"] = 1] = "Point";
            LightTypeEnum[LightTypeEnum["Spot"] = 2] = "Spot";
        })(LightTypeEnum = framework.LightTypeEnum || (framework.LightTypeEnum = {}));
        var light = (function () {
            function light() {
                this.isOpen = false;
                this.spotAngelCos = 0.9;
            }
            light.prototype.start = function () {
            };
            light.prototype.update = function (delta) {
            };
            light.prototype.remove = function () {
            };
            light.prototype.clone = function () {
            };
            return light;
        }());
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], light.prototype, "isOpen", void 0);
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], light.prototype, "lightName", void 0);
        light = __decorate([
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeLight
        ], light);
        framework.light = light;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var meshcollider = (function () {
            function meshcollider() {
                this._colliderVisible = false;
            }
            meshcollider.prototype.getBound = function () {
                return this.mesh;
            };
            meshcollider.prototype.start = function () {
                var filter = this.gameObject.getComponent("meshFilter");
                if (filter != null) {
                    this.mesh = filter.getMeshOutput();
                    this.buildMesh();
                }
            };
            meshcollider.prototype.update = function (delta) {
            };
            Object.defineProperty(meshcollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            meshcollider.prototype.intersectsTransform = function (tran) {
                return false;
            };
            meshcollider.prototype.buildMesh = function () {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "meshcollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
            };
            meshcollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                _mesh.data = this.mesh.data;
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayTri2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexSubData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = true;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            meshcollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
            };
            meshcollider.prototype.clone = function () {
            };
            return meshcollider;
        }());
        meshcollider = __decorate([
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeMeshCollider
        ], meshcollider);
        framework.meshcollider = meshcollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var meshFilter = (function () {
            function meshFilter() {
            }
            meshFilter.prototype.start = function () {
            };
            meshFilter.prototype.update = function (delta) {
            };
            Object.defineProperty(meshFilter.prototype, "mesh", {
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            meshFilter.prototype.getMeshOutput = function () {
                return this._mesh;
            };
            meshFilter.prototype.remove = function () {
                if (this.mesh)
                    this.mesh.unuse(true);
            };
            meshFilter.prototype.clone = function () {
            };
            return meshFilter;
        }());
        __decorate([
            gd3d.reflect.Field("mesh"),
            gd3d.reflect.UIStyle("WidgetDragSelect"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [framework.mesh])
        ], meshFilter.prototype, "mesh", null);
        meshFilter = __decorate([
            gd3d.reflect.nodeComponent
        ], meshFilter);
        framework.meshFilter = meshFilter;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var meshRenderer = (function () {
            function meshRenderer() {
                this.lightmapIndex = -1;
                this.lightmapScaleOffset = new gd3d.math.vector4(1, 1, 0, 0);
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.default;
                this.issetq = false;
                this._queue = 0;
            }
            Object.defineProperty(meshRenderer.prototype, "queue", {
                get: function () {
                    return this._queue;
                },
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: true,
                configurable: true
            });
            meshRenderer.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
            };
            meshRenderer.prototype.update = function (delta) {
            };
            meshRenderer.prototype.render = function (context, assetmgr, camera) {
                if (this.materials == null || this.materials.length == 0) {
                    this.materials = [];
                    this.materials.push(new framework.material());
                    this.materials[0].setShader(assetmgr.getShader("shader/def"));
                }
                this.layer = this.materials[0].getLayer();
                if (!this.issetq)
                    this._queue = this.materials[0].getQueue();
                context.updateModel(this.gameObject.transform);
                if (this.filter != null) {
                    var mesh = this.filter.getMeshOutput();
                    if (mesh != null) {
                        if (mesh.submesh != null) {
                            for (var i = 0; i < mesh.submesh.length; i++) {
                                var sm = mesh.submesh[i];
                                var mid = mesh.submesh[i].matIndex;
                                var usemat = this.materials[mid];
                                var drawtype = "base";
                                if (this.lightmapIndex >= 0) {
                                    drawtype = "lightmap";
                                    if (this.gameObject.transform.scene.lightmaps.length > this.lightmapIndex) {
                                        context.lightmap = this.gameObject.transform.scene.lightmaps[this.lightmapIndex];
                                        context.lightmapOffset = this.lightmapScaleOffset;
                                        context.lightmapUV = mesh.glMesh.vertexFormat & gd3d.render.VertexFormatMask.UV1 ? 1 : 0;
                                    }
                                }
                                else {
                                }
                                if (usemat != null)
                                    usemat.draw(context, mesh, sm, drawtype);
                            }
                        }
                    }
                }
            };
            meshRenderer.prototype.remove = function () {
            };
            meshRenderer.prototype.clone = function () {
            };
            return meshRenderer;
        }());
        __decorate([
            gd3d.reflect.Field("material[]"),
            __metadata("design:type", Array)
        ], meshRenderer.prototype, "materials", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], meshRenderer.prototype, "lightmapIndex", void 0);
        __decorate([
            gd3d.reflect.Field("vector4"),
            __metadata("design:type", gd3d.math.vector4)
        ], meshRenderer.prototype, "lightmapScaleOffset", void 0);
        meshRenderer = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent,
            __metadata("design:paramtypes", [])
        ], meshRenderer);
        framework.meshRenderer = meshRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var particleSystem = (function () {
            function particleSystem() {
                this.particleMethodType = framework.ParticleMethodType.Normal;
                this.meshBatchers = [];
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                this.isTrail = false;
                this.timer = 0;
                this.speed = 1;
                this.batchervercountLimit = 4096;
                this.renderLayer = framework.CullingMask.default;
            }
            particleSystem.prototype.start = function () {
                if (this.particleData == null) {
                    this.particleData = new framework.ParticleData();
                }
                var assetmgr = this.gameObject.getScene().app.getAssetMgr();
                this.assetmgr = assetmgr;
                this.initByData(assetmgr);
            };
            particleSystem.prototype.initByData = function (assetmgr) {
                var emissionData = this.particleData.emissionData;
                var materialData = this.particleData.materialData;
                this.isTrail = this.particleData.particleDetailData.istrail;
                var meshName = this.particleData.particleDetailData.type;
                if ((meshName.substr(meshName.indexOf(".")) == ".mesh.bin.js") || (meshName.substr(meshName.indexOf(".")) == ".mesh.bin")) {
                    this.particleMesh = assetmgr.getAssetByName(meshName);
                }
                else {
                    this.particleMesh = assetmgr.getDefaultMesh(meshName);
                }
                this.startLifeTime = this.particleData.particleDetailData.life.getValue();
                this.delayTime = this.particleData.particleDetailData.delayTime.getValue();
                this.emission = new Emission(emissionData.type, emissionData.count, emissionData.time);
                var shaderName = materialData.shaderName + ".json";
                this.material = new gd3d.framework.material();
                var shader = assetmgr.getShader(shaderName);
                this.material.setShader(shader);
                var textureName = materialData.diffuseTexture;
                var texture = assetmgr.getAssetByName(textureName);
                this.material.setFloat("_AlphaCut", materialData.alphaCut);
                this.material.setTexture("_MainTex", texture);
                this.layer = this.material.getLayer();
                this.queue = this.material.getQueue();
                this.particleMethodType = this.particleData.particleDetailData.particleMethodType;
            };
            particleSystem.prototype.update = function (delta) {
                this.timer += delta;
                var realdelta = this.speed * delta;
                for (var i = 0; i < this.meshBatchers.length; i++) {
                    var batcher = this.meshBatchers[i];
                    for (var j = 0; j < batcher.parlist.length; j++) {
                        var p = batcher.parlist[j];
                        p.update(realdelta);
                    }
                    if (batcher.parlist.length > 0) {
                        batcher.update(realdelta);
                    }
                }
                if (!this.emission.isOver()) {
                    if (this.emission.update(realdelta)) {
                        var count = 1;
                        if (this.emission.emissionType == framework.ParticleEmissionType.burst) {
                            count = this.emission.emissionCount;
                        }
                        for (var i = 0; i < count; i++) {
                            this.checkEmissionBatcher(this.emission);
                            this.curBather.addParticle(this.particleMesh, this.particleData);
                        }
                    }
                }
            };
            particleSystem.prototype.render = function (context, assetmgr, camera) {
                if (this.timer < this.delayTime) {
                    return;
                }
                for (var i in this.meshBatchers) {
                    this.meshBatchers[i].render(context, assetmgr);
                }
            };
            particleSystem.prototype.creatMeshbatcher = function (mat, needCount) {
                if (needCount === void 0) { needCount = 128; }
                if (needCount > this.batchervercountLimit) {
                    needCount = this.batchervercountLimit;
                }
                this.curBather = new framework.MeshBatcher(mat, needCount, this);
                this.curBather.camera = this.camera;
                this.meshBatchers.push(this.curBather);
                if (needCount > this.batchervercountLimit) {
                    needCount = needCount - this.batchervercountLimit;
                    this.creatMeshbatcher(mat, needCount);
                }
            };
            particleSystem.prototype.checkEmissionBatcher = function (emission, count) {
                if (count === void 0) { count = 1; }
                if (this.curBather == null) {
                    this.creatMeshbatcher(this.material, this.particleMesh.data.pos.length * count);
                }
                else {
                    var tcount = this.curBather.vercount + this.particleMesh.data.pos.length * count;
                    if (tcount > this.curBather.maxvercount) {
                        this.creatMeshbatcher(this.material, tcount);
                    }
                }
            };
            particleSystem.prototype.remove = function () {
                for (var k in this.meshBatchers) {
                    this.meshBatchers[k].dispose();
                }
                this.meshBatchers.length = 0;
                this.emission = null;
                this.material.dispose();
            };
            particleSystem.prototype.clone = function () {
            };
            return particleSystem;
        }());
        particleSystem = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent
        ], particleSystem);
        framework.particleSystem = particleSystem;
        var Emission = (function () {
            function Emission(_type, count, time) {
                if (_type === void 0) { _type = framework.ParticleEmissionType.burst; }
                if (count === void 0) { count = 1; }
                if (time === void 0) { time = 0; }
                this.isover = false;
                this.emissionType = _type;
                this.emissionCount = count;
                switch (this.emissionType) {
                    case framework.ParticleEmissionType.burst:
                        this.burstDelayTime = time;
                        break;
                    case framework.ParticleEmissionType.continue:
                        this.emissionKeepTime = time;
                        this._continueSpaceTime = this.emissionKeepTime / this.emissionCount;
                        break;
                }
                this.curTime = 0;
                this.numcount = 0;
            }
            Emission.prototype.update = function (delta) {
                this.curTime += delta;
                this.b = false;
                if (this.emissionType == framework.ParticleEmissionType.continue) {
                    if (this.curTime > this._continueSpaceTime) {
                        this.b = true;
                        if (this.numcount < this.emissionCount) {
                            this.curTime = 0;
                            this.numcount++;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
                else if (this.emissionType == framework.ParticleEmissionType.burst) {
                    if (this.curTime > this.burstDelayTime) {
                        this.b = true;
                        this.isover = true;
                    }
                }
                return this.b;
            };
            Emission.prototype.isOver = function () {
                return this.isover;
            };
            return Emission;
        }());
        framework.Emission = Emission;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var skinnedMeshRenderer = (function () {
            function skinnedMeshRenderer() {
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.default;
                this.issetq = false;
                this._queue = 0;
                this.maxBoneCount = 0;
                this._efficient = true;
            }
            Object.defineProperty(skinnedMeshRenderer.prototype, "queue", {
                get: function () {
                    return this._queue;
                },
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "player", {
                get: function () {
                    if (this._player == null) {
                        this._player = this.gameObject.getComponentInParent("aniplayer");
                    }
                    return this._player;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "mesh", {
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            skinnedMeshRenderer.prototype.start = function () {
            };
            skinnedMeshRenderer.prototype.getMatByIndex = function (index) {
                var data = this.mesh.data;
                if (data.blendIndex[index].v0 >= this.maxBoneCount || data.blendIndex[index].v1 >= this.maxBoneCount || data.blendIndex[index].v2 >= this.maxBoneCount || data.blendIndex[index].v3 >= this.maxBoneCount) {
                    return null;
                }
                var mat = new gd3d.math.matrix();
                if (this._efficient) {
                    var vec40r = gd3d.math.pool.new_vector4();
                    var vec30p = gd3d.math.pool.new_vector3();
                    vec40r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 0];
                    vec40r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 1];
                    vec40r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 2];
                    vec40r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 3];
                    vec30p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 4];
                    vec30p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 5];
                    vec30p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 6];
                    var vec41r = gd3d.math.pool.new_vector4();
                    var vec31p = gd3d.math.pool.new_vector3();
                    vec41r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 0];
                    vec41r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 1];
                    vec41r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 2];
                    vec41r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 3];
                    vec31p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 4];
                    vec31p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 5];
                    vec31p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 6];
                    var vec42r = gd3d.math.pool.new_vector4();
                    var vec32p = gd3d.math.pool.new_vector3();
                    vec42r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 0];
                    vec42r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 1];
                    vec42r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 2];
                    vec42r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 3];
                    vec32p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 4];
                    vec32p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 5];
                    vec32p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 6];
                    var vec43r = gd3d.math.pool.new_vector4();
                    var vec33p = gd3d.math.pool.new_vector3();
                    vec43r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 0];
                    vec43r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 1];
                    vec43r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 2];
                    vec43r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 3];
                    vec33p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 4];
                    vec33p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 5];
                    vec33p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 6];
                    var mat0 = gd3d.math.pool.new_matrix();
                    var mat1 = gd3d.math.pool.new_matrix();
                    var mat2 = gd3d.math.pool.new_matrix();
                    var mat3 = gd3d.math.pool.new_matrix();
                    gd3d.math.matrixMakeTransformRTS(vec30p, gd3d.math.pool.vector3_one, vec40r, mat0);
                    gd3d.math.matrixMakeTransformRTS(vec31p, gd3d.math.pool.vector3_one, vec41r, mat1);
                    gd3d.math.matrixMakeTransformRTS(vec32p, gd3d.math.pool.vector3_one, vec42r, mat2);
                    gd3d.math.matrixMakeTransformRTS(vec33p, gd3d.math.pool.vector3_one, vec43r, mat3);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    gd3d.math.matrixAdd(mat0, mat1, mat);
                    gd3d.math.matrixAdd(mat, mat2, mat);
                    gd3d.math.matrixAdd(mat, mat3, mat);
                    gd3d.math.pool.delete_vector4(vec40r);
                    gd3d.math.pool.delete_vector4(vec41r);
                    gd3d.math.pool.delete_vector4(vec42r);
                    gd3d.math.pool.delete_vector4(vec43r);
                    gd3d.math.pool.delete_vector3(vec30p);
                    gd3d.math.pool.delete_vector3(vec31p);
                    gd3d.math.pool.delete_vector3(vec32p);
                    gd3d.math.pool.delete_vector3(vec33p);
                    gd3d.math.pool.delete_matrix(mat0);
                    gd3d.math.pool.delete_matrix(mat1);
                    gd3d.math.pool.delete_matrix(mat2);
                    gd3d.math.pool.delete_matrix(mat3);
                }
                else {
                    var mat0 = gd3d.math.pool.new_matrix();
                    mat0.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v0, 16 * data.blendIndex[index].v0 + 16);
                    var mat1 = gd3d.math.pool.new_matrix();
                    mat1.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v1, 16 * data.blendIndex[index].v1 + 16);
                    var mat2 = gd3d.math.pool.new_matrix();
                    mat2.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v2, 16 * data.blendIndex[index].v2 + 16);
                    var mat3 = gd3d.math.pool.new_matrix();
                    mat3.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v3, 16 * data.blendIndex[index].v3 + 16);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    gd3d.math.matrixAdd(mat0, mat1, mat);
                    gd3d.math.matrixAdd(mat, mat2, mat);
                    gd3d.math.matrixAdd(mat, mat3, mat);
                    gd3d.math.pool.delete_matrix(mat0);
                    gd3d.math.pool.delete_matrix(mat1);
                    gd3d.math.pool.delete_matrix(mat2);
                    gd3d.math.pool.delete_matrix(mat3);
                }
                return mat;
            };
            skinnedMeshRenderer.prototype.intersects = function (ray) {
                var mvpmat = this.player.gameObject.transform.getWorldMatrix();
                var pickinfo = null;
                var data = this.mesh.data;
                for (var i = 0; i < this.mesh.submesh.length; i++) {
                    var submesh = this.mesh.submesh[i];
                    var t0 = gd3d.math.pool.new_vector3();
                    var t1 = gd3d.math.pool.new_vector3();
                    var t2 = gd3d.math.pool.new_vector3();
                    for (var index = submesh.start; index < submesh.size; index += 3) {
                        var verindex0 = data.trisindex[index];
                        var verindex1 = data.trisindex[index + 1];
                        var verindex2 = data.trisindex[index + 2];
                        var p0 = data.pos[verindex0];
                        var p1 = data.pos[verindex1];
                        var p2 = data.pos[verindex2];
                        var mat0 = this.getMatByIndex(verindex0);
                        var mat1 = this.getMatByIndex(verindex1);
                        var mat2 = this.getMatByIndex(verindex2);
                        if (mat0 == null || mat1 == null || mat2 == null)
                            continue;
                        var mat00 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat0, mat00);
                        var mat11 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat1, mat11);
                        var mat22 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat2, mat22);
                        gd3d.math.matrixTransformVector3(p0, mat00, t0);
                        gd3d.math.matrixTransformVector3(p1, mat11, t1);
                        gd3d.math.matrixTransformVector3(p2, mat22, t2);
                        var result = ray.intersectsTriangle(t0, t1, t2);
                        if (result) {
                            if (result.distance < 0)
                                continue;
                            if (!pickinfo || pickinfo.distance > result.distance) {
                                pickinfo = result;
                                pickinfo.faceId = index / 3;
                                pickinfo.subMeshId = i;
                                var tdir = gd3d.math.pool.new_vector3();
                                gd3d.math.vec3ScaleByNum(ray.direction, result.distance, tdir);
                                gd3d.math.vec3Add(ray.origin, tdir, pickinfo.hitposition);
                            }
                        }
                    }
                    gd3d.math.pool.delete_vector3(t0);
                    gd3d.math.pool.delete_vector3(t1);
                    gd3d.math.pool.delete_vector3(t2);
                }
                return pickinfo;
            };
            skinnedMeshRenderer.prototype.update = function (delta) {
                var skintype = this.useBoneShader(this.materials[0]);
                if (skintype == 1 && this._skeletonMatrixData == null) {
                    this.maxBoneCount = 24;
                    this._skeletonMatrixData = new Float32Array(16 * this.maxBoneCount);
                    this._efficient = false;
                }
                if (skintype == 2 && this._skeletonMatrixData == null) {
                    this.maxBoneCount = 60;
                    this._skeletonMatrixData = new Float32Array(8 * this.maxBoneCount);
                    this._efficient = true;
                }
                if (this.player != null && this._skeletonMatrixData != null) {
                    this.player.fillPoseData(this._skeletonMatrixData, this.bones, this._efficient);
                }
            };
            skinnedMeshRenderer.prototype.render = function (context, assetmgr, camera) {
                this.layer = this.materials[0].getLayer();
                if (!this.issetq)
                    this._queue = this.materials[0].getQueue();
                if (this.player != null) {
                    context.updateModel(this.player.gameObject.transform);
                }
                for (var i_4 = 0; i_4 < this.materials.length; i_4++) {
                    if (this._skeletonMatrixData != null) {
                        if (this._efficient) {
                            this.materials[i_4].setVector4v("glstate_vec4_bones", this._skeletonMatrixData);
                        }
                        else {
                            this.materials[i_4].setMatrixv("glstate_matrix_bones", this._skeletonMatrixData);
                        }
                    }
                }
                if (this._mesh != null) {
                    if (this._mesh != null) {
                        if (this._mesh.submesh != null) {
                            for (var i = 0; i < this._mesh.submesh.length; i++) {
                                var sm = this._mesh.submesh[i];
                                var mid = this._mesh.submesh[i].matIndex;
                                var usemat = this.materials[mid];
                                if (usemat != null)
                                    usemat.draw(context, this._mesh, sm, "skin");
                            }
                        }
                    }
                }
            };
            skinnedMeshRenderer.prototype.remove = function () {
                if (this.mesh)
                    this.mesh.unuse(true);
                this.bones.length = 0;
            };
            skinnedMeshRenderer.prototype.clone = function () {
            };
            skinnedMeshRenderer.prototype.useBoneShader = function (mat) {
                var matpasses = mat.getShader().passes["skin"];
                if (matpasses == null || matpasses.length == 0)
                    return 0;
                if (matpasses[0].uniforms["glstate_vec4_bones"] != null)
                    return 2;
                else if (matpasses[0].uniforms["glstate_matrix_bones"] != null)
                    return 1;
                return 0;
            };
            return skinnedMeshRenderer;
        }());
        __decorate([
            gd3d.reflect.Field("material[]"),
            __metadata("design:type", Array)
        ], skinnedMeshRenderer.prototype, "materials", void 0);
        __decorate([
            gd3d.reflect.Field("mesh"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [framework.mesh])
        ], skinnedMeshRenderer.prototype, "mesh", null);
        __decorate([
            gd3d.reflect.Field("transform[]"),
            __metadata("design:type", Array)
        ], skinnedMeshRenderer.prototype, "bones", void 0);
        __decorate([
            gd3d.reflect.Field("transform"),
            __metadata("design:type", framework.transform)
        ], skinnedMeshRenderer.prototype, "rootBone", void 0);
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], skinnedMeshRenderer.prototype, "center", void 0);
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], skinnedMeshRenderer.prototype, "size", void 0);
        skinnedMeshRenderer = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent,
            __metadata("design:paramtypes", [])
        ], skinnedMeshRenderer);
        framework.skinnedMeshRenderer = skinnedMeshRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var spherestruct = (function () {
            function spherestruct(_center, _r) {
                this.center = _center;
                this.srcradius = _r;
                this.tempScale = new gd3d.math.vector3();
            }
            spherestruct.prototype.update = function (worldmatrix) {
                gd3d.math.matrixGetTranslation(worldmatrix, this.center);
                gd3d.math.matrixGetScale(worldmatrix, this.tempScale);
                if (this.tempScale.x < this.tempScale.y)
                    this.tempScale.x = this.tempScale.y;
                if (this.tempScale.x < this.tempScale.z)
                    this.tempScale.x = this.tempScale.z;
                this.radius = this.srcradius * this.tempScale.x;
            };
            spherestruct.prototype.intersects = function (bound) {
                if (bound instanceof spherestruct) {
                    var dis = gd3d.math.vec3Distance(this.center, bound.center);
                    if (dis > this.radius + bound.radius)
                        return false;
                    return true;
                }
                else if (bound instanceof framework.obb) {
                }
            };
            return spherestruct;
        }());
        framework.spherestruct = spherestruct;
        var spherecollider = (function () {
            function spherecollider() {
                this._colliderVisible = false;
            }
            spherecollider.prototype.getBound = function () {
                return this.spherestruct;
            };
            Object.defineProperty(spherecollider.prototype, "matrix", {
                get: function () {
                    if (this.gameObject)
                        return this.gameObject.transform.getWorldMatrix();
                    return new gd3d.math.matrix();
                },
                enumerable: true,
                configurable: true
            });
            spherecollider.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.build();
            };
            spherecollider.prototype.update = function (delta) {
                if (this.spherestruct) {
                    this.spherestruct.update(this.matrix);
                }
            };
            Object.defineProperty(spherecollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            spherecollider.prototype.intersectsTransform = function (tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.spherestruct == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.spherestruct.intersects(_obb);
            };
            spherecollider.prototype.build = function () {
                if (this.center && this.radius) {
                    this.spherestruct = new spherestruct(this.center, this.radius);
                }
                this.buildMesh();
            };
            spherecollider.prototype.buildMesh = function () {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "spherecollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
            };
            spherecollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                return _mesh;
            };
            spherecollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
            };
            spherecollider.prototype.clone = function () {
            };
            return spherecollider;
        }());
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], spherecollider.prototype, "center", void 0);
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", Number)
        ], spherecollider.prototype, "radius", void 0);
        spherecollider = __decorate([
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeSphereCollider
        ], spherecollider);
        framework.spherecollider = spherecollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var trailRender_recorde = (function () {
            function trailRender_recorde() {
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.default;
                this.queue = 0;
                this._startWidth = 1;
                this._endWidth = 0;
                this.lifetime = 0.35;
                this.minStickDistance = 0.1;
                this.maxStickCout = 12;
                this.nodes = [];
                this.interpolate = false;
                this.interpNumber = 3;
                this.interpPath = [];
                this.activeMaxpointlimit = false;
                this.notRender = false;
            }
            Object.defineProperty(trailRender_recorde.prototype, "material", {
                get: function () {
                    if (this._material != undefined) {
                        return this._material;
                    }
                    else {
                        var mat = new gd3d.framework.material();
                        mat.setShader(this.app.getAssetMgr().getShader("shader/def"));
                        this._material = mat;
                        return this._material;
                    }
                },
                set: function (material) {
                    this._material = material;
                    this.layer = this._material.getLayer();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(trailRender_recorde.prototype, "startColor", {
                get: function () {
                    if (this._startColor == undefined) {
                        this._startColor = new gd3d.math.color(1, 1, 1, 1);
                    }
                    return this._startColor;
                },
                set: function (color) {
                    this._startColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(trailRender_recorde.prototype, "endColor", {
                get: function () {
                    if (this._endColor == undefined) {
                        this._endColor = new gd3d.math.color(this.startColor.r, this.startColor.g, this.startColor.b, 0);
                    }
                    return this._endColor;
                },
                set: function (color) {
                    this._endColor = color;
                },
                enumerable: true,
                configurable: true
            });
            trailRender_recorde.prototype.setWidth = function (startWidth, endWidth) {
                if (endWidth === void 0) { endWidth = 0; }
                this._startWidth = startWidth;
                this._endWidth = endWidth;
            };
            trailRender_recorde.prototype.setMaxpointcontroll = function (value) {
                if (value === void 0) { value = false; }
                this.activeMaxpointlimit = value;
            };
            trailRender_recorde.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                this.webgl = this.app.webgl;
                this.mesh = new gd3d.framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                if (this.interpolate) {
                    this.maxStickCout *= this.interpNumber;
                    this.targetPath = this.interpPath;
                }
                else {
                    this.targetPath = this.nodes;
                }
            };
            trailRender_recorde.prototype.update = function (delta) {
                var _time = this.app.getTotalTime();
                this.refreshTrailNode(_time);
                this.updateTrailData(_time);
            };
            trailRender_recorde.prototype.remove = function () {
            };
            trailRender_recorde.prototype.refreshTrailNode = function (curTime) {
                while (this.targetPath.length > 0 && curTime > this.targetPath[this.targetPath.length - 1].time + this.lifetime) {
                    this.targetPath.pop();
                }
                var pos = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), pos);
                var length = this.targetPath.length;
                if (length != 0) {
                    if (gd3d.math.vec3Distance(pos, this.targetPath[0].location) < this.minStickDistance)
                        return;
                }
                var updir = new gd3d.math.vector3();
                this.gameObject.transform.getUpInWorld(updir);
                var newNode = new trailNode(pos, updir, curTime);
                this.nodes.unshift(newNode);
                if (this.interpolate) {
                    if (this.nodes.length > 2) {
                        var handle1 = new gd3d.math.vector3();
                        gd3d.math.vec3Subtract(this.nodes[2].location, this.nodes[0].location, handle1);
                        gd3d.math.vec3Normalize(handle1, handle1);
                        this.nodes[1].handle = handle1;
                        if (this.nodes[2].handle == undefined) {
                            var handdle = new gd3d.math.vector3();
                            gd3d.math.vec3Subtract(this.nodes[2].location, this.nodes[1].location, handdle);
                            gd3d.math.vec3Normalize(handdle, handdle);
                            this.nodes[2].handle = handdle;
                        }
                        var vec3Distance = gd3d.math.vec3Distance(this.nodes[2].location, this.nodes[1].location);
                        for (var i = 0; i < this.interpNumber; i++) {
                            var lerp = (i + 1) / (this.interpNumber + 1);
                            var inter_pos = new gd3d.math.vector3();
                            var tempRhandle = gd3d.math.pool.new_vector3();
                            var tempLhandle = gd3d.math.pool.new_vector3();
                            tempLhandle.x = -this.nodes[2].handle.x;
                            tempLhandle.y = -this.nodes[2].handle.y;
                            tempLhandle.z = -this.nodes[2].handle.z;
                            gd3d.math.vec3ScaleByNum(tempLhandle, vec3Distance / 2, tempLhandle);
                            gd3d.math.vec3Add(tempLhandle, this.nodes[2].location, tempLhandle);
                            gd3d.math.vec3ScaleByNum(this.nodes[1].handle, vec3Distance / 2, tempRhandle);
                            gd3d.math.vec3Add(tempRhandle, this.nodes[1].location, tempRhandle);
                            gd3d.math.GetPointAlongCurve(this.nodes[2].location, tempLhandle, this.nodes[1].location, tempRhandle, (i + 1) / (this.interpNumber + 1), inter_pos);
                            var inter_updir = new gd3d.math.vector3();
                            gd3d.math.vec3SLerp(this.nodes[1].updir, this.nodes[2].updir, lerp, inter_updir);
                            var inter_node = new trailNode(inter_pos, inter_updir, curTime);
                            this.interpPath.splice(1, 0, inter_node);
                            gd3d.math.pool.delete_vector3(tempRhandle);
                            gd3d.math.pool.delete_vector3(tempLhandle);
                        }
                        this.interpPath.unshift(newNode);
                    }
                }
                if (this.activeMaxpointlimit) {
                    while (this.targetPath.length > this.maxStickCout) {
                        this.targetPath.pop();
                    }
                }
            };
            trailRender_recorde.prototype.updateTrailData = function (curTime) {
                if (this.nodes.length < 2) {
                    this.notRender = true;
                    return;
                }
                else {
                    this.notRender = false;
                }
                this.checkBufferSize();
                for (var i = 0; i < this.targetPath.length; i++) {
                    var curNode = this.targetPath[i];
                    var u = i / this.targetPath.length;
                    var timeAlong = (curTime - curNode.time) / this.lifetime;
                    var _updir = new gd3d.math.vector3();
                    gd3d.math.vec3Clone(curNode.updir, _updir);
                    var _width = this._startWidth + (this._endWidth - this._startWidth) * timeAlong;
                    gd3d.math.vec3ScaleByNum(_updir, _width, _updir);
                    var tempPos = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Add(curNode.location, _updir, tempPos);
                    this.dataForVbo[2 * i * 9 + 0] = tempPos.x;
                    this.dataForVbo[2 * i * 9 + 1] = tempPos.y;
                    this.dataForVbo[2 * i * 9 + 2] = tempPos.z;
                    var tempColor = gd3d.math.pool.new_color();
                    gd3d.math.colorLerp(this.startColor, this.endColor, timeAlong, tempColor);
                    this.dataForVbo[2 * i * 9 + 3] = tempColor.r;
                    this.dataForVbo[2 * i * 9 + 4] = tempColor.g;
                    this.dataForVbo[2 * i * 9 + 5] = tempColor.b;
                    this.dataForVbo[2 * i * 9 + 6] = tempColor.a;
                    this.dataForVbo[2 * i * 9 + 7] = u;
                    this.dataForVbo[2 * i * 9 + 8] = 1.0;
                    this.dataForVbo[(2 * i + 1) * 9 + 0] = curNode.location.x;
                    this.dataForVbo[(2 * i + 1) * 9 + 1] = curNode.location.y;
                    this.dataForVbo[(2 * i + 1) * 9 + 2] = curNode.location.z;
                    this.dataForVbo[(2 * i + 1) * 9 + 3] = tempColor.r;
                    this.dataForVbo[(2 * i + 1) * 9 + 4] = tempColor.g;
                    this.dataForVbo[(2 * i + 1) * 9 + 5] = tempColor.b;
                    this.dataForVbo[(2 * i + 1) * 9 + 6] = tempColor.a;
                    var u = i / this.nodes.length;
                    this.dataForVbo[(2 * i + 1) * 9 + 7] = u;
                    this.dataForVbo[(2 * i + 1) * 9 + 8] = 0;
                    gd3d.math.pool.delete_vector3(tempPos);
                    gd3d.math.pool.delete_color(tempColor);
                }
                for (var k = 0; k < this.nodes.length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
            };
            trailRender_recorde.prototype.checkBufferSize = function () {
                var stickNumber = this.targetPath.length;
                if (stickNumber * 2 * 9 > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    this.dataForVbo = new Float32Array(length * 2);
                }
                if ((stickNumber - 1) * 6 > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    this.dataForEbo = new Uint16Array(length * 2);
                }
            };
            trailRender_recorde.prototype.render = function (context, assetmgr, camera) {
                if (this.notRender)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexSubData(context.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = (this.targetPath.length - 1) * 6;
                this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
            };
            trailRender_recorde.prototype.clone = function () {
            };
            return trailRender_recorde;
        }());
        trailRender_recorde = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent
        ], trailRender_recorde);
        framework.trailRender_recorde = trailRender_recorde;
        var trailNode = (function () {
            function trailNode(p, updir, t) {
                this.location = p;
                this.updir = updir;
                this.time = t;
            }
            return trailNode;
        }());
        framework.trailNode = trailNode;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var trailRender = (function () {
            function trailRender() {
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.default;
                this.queue = 0;
                this.width = 1.0;
                this.vertexcount = 24;
                this.active = false;
                this.reInit = false;
                this.extenedOneSide = true;
                this.lookAtCamera = false;
                this.speed = 0.5;
            }
            trailRender.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                this.webgl = this.app.webgl;
                this.initmesh();
            };
            trailRender.prototype.update = function (delta) {
                if (!this.active)
                    return;
                if (this.reInit) {
                    this.intidata();
                    this.reInit = false;
                }
                var targetpos = this.gameObject.transform.getWorldTranslate();
                if (this.lookAtCamera) {
                    this.camerapositon = framework.sceneMgr.app.getScene().mainCamera.gameObject.transform.getWorldTranslate();
                    var camdir = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Subtract(this.camerapositon, this.sticks[0].location, camdir);
                    gd3d.math.vec3Normalize(camdir, camdir);
                    var direction = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Subtract(targetpos, this.sticks[0].location, direction);
                    gd3d.math.vec3Normalize(direction, direction);
                    gd3d.math.vec3Cross(camdir, direction, this.sticks[0].updir);
                    gd3d.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    gd3d.math.pool.delete_vector3(direction);
                }
                gd3d.math.vec3Clone(targetpos, this.sticks[0].location);
                var length = this.sticks.length;
                for (var i = 1; i < length; i++) {
                    gd3d.math.vec3SLerp(this.sticks[i].location, this.sticks[i - 1].location, this.speed, this.sticks[i].location);
                }
                if (this.lookAtCamera) {
                    for (var i = 1; i < length; i++) {
                        var tocamdir = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Subtract(this.camerapositon, this.sticks[i].location, tocamdir);
                        gd3d.math.vec3Normalize(tocamdir, tocamdir);
                        var movedir = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Subtract(this.sticks[i - 1].location, this.sticks[i].location, movedir);
                        gd3d.math.vec3Normalize(movedir, movedir);
                        gd3d.math.vec3Cross(tocamdir, movedir, this.sticks[i].updir);
                        gd3d.math.vec3ScaleByNum(this.sticks[i].updir, this.width, this.sticks[i].updir);
                        gd3d.math.pool.delete_vector3(tocamdir);
                    }
                }
                else {
                    this.gameObject.transform.getUpInWorld(this.sticks[0].updir);
                    gd3d.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    for (var i = 1; i < length; i++) {
                        gd3d.math.vec3SLerp(this.sticks[i].updir, this.sticks[i - 1].updir, this.speed, this.sticks[i].updir);
                    }
                }
                this.updateTrailData();
            };
            trailRender.prototype.remove = function () {
            };
            Object.defineProperty(trailRender.prototype, "material", {
                get: function () {
                    if (this._material != undefined) {
                        return this._material;
                    }
                    else {
                        var mat = new gd3d.framework.material();
                        mat.setShader(this.app.getAssetMgr().getShader("shader/def"));
                        this.material = mat;
                        return this._material;
                    }
                },
                set: function (material) {
                    this._material = material;
                    this.layer = this.material.getLayer();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(trailRender.prototype, "color", {
                get: function () {
                    if (this._color == undefined) {
                        this._color = new gd3d.math.color(1, 1, 1, 1);
                    }
                    return this._color;
                },
                set: function (color) {
                    this._color = color;
                },
                enumerable: true,
                configurable: true
            });
            trailRender.prototype.setspeed = function (upspeed) {
                this.speed = upspeed;
            };
            trailRender.prototype.setWidth = function (Width) {
                this.width = Width;
            };
            trailRender.prototype.play = function () {
                this.reInit = true;
                this.active = true;
            };
            trailRender.prototype.stop = function () {
                this.active = false;
            };
            trailRender.prototype.initmesh = function () {
                this.mesh = new gd3d.framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.dataForVbo = new Float32Array(this.vertexcount * 9);
                this.dataForEbo = new Uint16Array((this.vertexcount / 2 - 1) * 6);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, this.vertexcount, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            };
            trailRender.prototype.intidata = function () {
                this.sticks = [];
                for (var i = 0; i < this.vertexcount / 2; i++) {
                    var ts = new trailStick();
                    this.sticks.push(ts);
                    ts.location = new gd3d.math.vector3();
                    gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), ts.location);
                    ts.updir = new gd3d.math.vector3();
                    this.gameObject.transform.getUpInWorld(ts.updir);
                    gd3d.math.vec3ScaleByNum(ts.updir, this.width, ts.updir);
                }
                var length = this.vertexcount / 2;
                var updir = gd3d.math.pool.new_vector3();
                this.gameObject.transform.getUpInWorld(updir);
                gd3d.math.vec3ScaleByNum(updir, this.width, updir);
                var pos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), pos);
                var uppos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Add(pos, updir, uppos);
                var downpos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(pos, updir, downpos);
                for (var i = 0; i < length; i++) {
                    this.dataForVbo[i * 2 * 9] = uppos.x;
                    this.dataForVbo[i * 2 * 9 + 1] = uppos.y;
                    this.dataForVbo[i * 2 * 9 + 2] = uppos.z;
                    this.dataForVbo[i * 2 * 9 + 3] = this.color.r;
                    this.dataForVbo[i * 2 * 9 + 4] = this.color.g;
                    this.dataForVbo[i * 2 * 9 + 5] = this.color.b;
                    this.dataForVbo[i * 2 * 9 + 6] = this.color.a;
                    this.dataForVbo[i * 2 * 9 + 7] = i / (length - 1);
                    this.dataForVbo[i * 2 * 9 + 8] = 0;
                    this.dataForVbo[(i * 2 + 1) * 9] = downpos.x;
                    this.dataForVbo[(i * 2 + 1) * 9 + 1] = downpos.y;
                    this.dataForVbo[(i * 2 + 1) * 9 + 2] = downpos.z;
                    this.dataForVbo[(i * 2 + 1) * 9 + 3] = this.color.r;
                    this.dataForVbo[(i * 2 + 1) * 9 + 4] = this.color.g;
                    this.dataForVbo[(i * 2 + 1) * 9 + 5] = this.color.b;
                    this.dataForVbo[(i * 2 + 1) * 9 + 6] = this.color.a;
                    this.dataForVbo[(i * 2 + 1) * 9 + 7] = i / (length - 1);
                    this.dataForVbo[(i * 2 + 1) * 9 + 8] = 1;
                }
                for (var k = 0; k < length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
                this.mesh.glMesh.uploadVertexSubData(this.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexSubData(this.webgl, 0, this.dataForEbo);
                gd3d.math.pool.delete_vector3(updir);
                gd3d.math.pool.delete_vector3(pos);
                gd3d.math.pool.delete_vector3(uppos);
                gd3d.math.pool.delete_vector3(downpos);
            };
            trailRender.prototype.updateTrailData = function () {
                var length = this.vertexcount / 2;
                if (this.extenedOneSide) {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
                else {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x - up.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y - up.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z - up.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
            };
            trailRender.prototype.render = function (context, assetmgr, camera) {
                if (!this.active)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
            };
            trailRender.prototype.clone = function () {
            };
            return trailRender;
        }());
        trailRender = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent
        ], trailRender);
        framework.trailRender = trailRender;
        var trailStick = (function () {
            function trailStick() {
            }
            return trailStick;
        }());
        framework.trailStick = trailStick;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var pointinfo = (function () {
            function pointinfo() {
            }
            return pointinfo;
        }());
        framework.pointinfo = pointinfo;
        var inputMgr = (function () {
            function inputMgr(app) {
                var _this = this;
                this.inputlast = null;
                this.point = new pointinfo();
                this.touches = {};
                this.keyboardMap = {};
                app.container.addEventListener("touchstart", function (ev) {
                    if (_this.inputlast != null) {
                        _this.inputlast.blur();
                    }
                    if (ev.target instanceof HTMLInputElement) {
                        _this.inputlast = ev.target;
                        _this.inputlast.focus();
                        ev.preventDefault();
                        return;
                    }
                    _this.point.x = ev.touches[0].clientX;
                    _this.point.y = ev.touches[0].clientY;
                    _this.point.touch = true;
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (_this.touches[id] == null) {
                            _this.touches[id] = new pointinfo();
                            _this.touches[id].id = id;
                        }
                        _this.touches[id].touch = true;
                        _this.touches[id].x = touch.clientX;
                        _this.touches[id].y = touch.clientY;
                    }
                });
                document.addEventListener("mousedown", function (ev) {
                    _this.point.x = ev.clientX;
                    _this.point.y = ev.clientY;
                    _this.point.touch = true;
                });
                document.addEventListener("touchend", function (ev) {
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (_this.touches[id] == null) {
                            _this.touches[id] = new pointinfo();
                            _this.touches[id].id = id;
                        }
                        _this.touches[id].touch = false;
                    }
                    for (var key in _this.touches) {
                        if (_this.touches[key].touch == true)
                            return;
                    }
                    _this.point.touch = false;
                });
                document.addEventListener("touchcancel", function (ev) {
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (_this.touches[id] == null) {
                            _this.touches[id] = new pointinfo();
                            _this.touches[id].id = id;
                        }
                        _this.touches[id].touch = false;
                    }
                    for (var key in _this.touches) {
                        if (_this.touches[key].touch == true)
                            return;
                    }
                    _this.point.touch = false;
                });
                document.addEventListener("mouseup", function (ev) {
                    _this.point.touch = false;
                });
                document.addEventListener("touchmove", function (ev) {
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (_this.touches[id] == null) {
                            _this.touches[id] = new pointinfo();
                            _this.touches[id].id = id;
                        }
                        _this.touches[id].touch = true;
                        _this.touches[id].x = touch.clientX;
                        _this.touches[id].y = touch.clientY;
                    }
                    var count = 0;
                    var x = 0;
                    var y = 0;
                    for (var key in _this.touches) {
                        if (_this.touches[key].touch == true) {
                            x += _this.touches[key].x;
                            y += _this.touches[key].y;
                            count++;
                        }
                    }
                    _this.point.x = x / count;
                    _this.point.y = y / count;
                });
                document.addEventListener("mousemove", function (ev) {
                    _this.point.x = ev.clientX;
                    _this.point.y = ev.clientY;
                });
                document.addEventListener("keydown", function (ev) {
                    _this.keyboardMap[ev.keyCode] = true;
                }, false);
                document.addEventListener("keyup", function (ev) {
                    _this.keyboardMap[ev.keyCode] = false;
                }, false);
            }
            return inputMgr;
        }());
        framework.inputMgr = inputMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var binBuffer = (function () {
            function binBuffer(bufSize) {
                if (bufSize === void 0) { bufSize = 65536; }
                if (bufSize < 1024)
                    bufSize = 1024;
                if (bufSize > 1024 * 256)
                    bufSize = 1024 * 256;
                this._bufSize = bufSize;
                this._buf = [];
                this._seekWritePos = 0;
                this._seekWriteIndex = 0;
                this._buf[0] = new Uint8Array(bufSize);
                this._seekReadPos = 0;
            }
            binBuffer.prototype.getLength = function () {
                return (this._seekWriteIndex * this._bufSize + this._seekWritePos) - (this._seekReadPos);
            };
            binBuffer.prototype.getBufLength = function () {
                return this._buf.length * this._bufSize;
            };
            binBuffer.prototype.getBytesAvailable = function () {
                return this.getLength();
            };
            binBuffer.prototype.read = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = offset; i < offset + length; i++) {
                    if (this._seekReadPos >= this._seekWritePos && 0 == this._seekWriteIndex) {
                        throw new Error("no data to read.");
                    }
                    target[i] = this._buf[0][this._seekReadPos];
                    this._seekReadPos++;
                    if (this._seekReadPos >= this._bufSize) {
                        this._seekWriteIndex--;
                        this._seekReadPos = 0;
                        var freebuf = this._buf.shift();
                        this._buf.push(freebuf);
                    }
                }
            };
            binBuffer.prototype.write = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                for (var i = offset; i < offset + length; i++) {
                    this._buf[this._seekWriteIndex][this._seekWritePos] = array[i];
                    this._seekWritePos++;
                    if (this._seekWritePos >= this._bufSize) {
                        this._seekWriteIndex++;
                        this._seekWritePos = 0;
                        if (this._buf.length <= this._seekWriteIndex) {
                            this._buf.push(new Uint8Array(this._bufSize));
                        }
                    }
                }
            };
            binBuffer.prototype.getBuffer = function () {
                var length = 0;
                if (this._seekWriteIndex > 0) {
                    length = this._bufSize * (this._seekWriteIndex - 1) + this._seekWritePos;
                }
                else {
                    length = this._seekWritePos;
                }
                var array = new Uint8Array(length);
                for (var i = 0; i < this._seekWriteIndex - 1; i++) {
                    array.set(this._buf[i], i * this._bufSize);
                }
                for (var i = 0; i < this._seekWritePos; i++) {
                    array[length - this._seekWritePos + i] = this._buf[this._seekWriteIndex][i];
                }
                return array;
            };
            binBuffer.prototype.getUint8Array = function () {
                return new Uint8Array(this.getBuffer());
            };
            return binBuffer;
        }());
        io.binBuffer = binBuffer;
        var converter = (function () {
            function converter() {
            }
            converter.getApplyFun = function (value) {
                return Array.prototype.concat.apply([], value);
            };
            converter.ULongToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                converter.dataView.setUint32(0, uint1, true);
                converter.dataView.setUint32(4, uint2, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = new Uint8Array(converter.dataView.buffer);
                }
                else {
                    for (var i = 0; i < 8; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.LongToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                converter.dataView.setInt32(0, uint1, true);
                converter.dataView.setInt32(4, uint2, true);
                var _array = new Int8Array(converter.dataView.buffer);
                if (target == null) {
                    target = new Int8Array(converter.dataView.buffer);
                }
                else {
                    for (var i = 0; i < 8; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Float64ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setFloat64(0, value, false);
                if (target == null) {
                    target = new Uint8Array(converter.dataView.buffer);
                }
                else {
                    for (var i = 0; i < 8; i++) {
                        target[offset + i] = converter.dataView.buffer[i];
                    }
                }
                return target;
            };
            converter.Float32ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setFloat32(0, value, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 4);
                }
                else {
                    for (var i = 0; i < 4; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Int32ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt32(0, value, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 4);
                }
                else {
                    for (var i = 0; i < 4; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Int16ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt16(0, value, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 2);
                }
                else {
                    for (var i = 0; i < 2; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Int8ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt8(0, value);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 1);
                }
                else {
                    for (var i = 0; i < 1; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Uint32toArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt32(0, value, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 4);
                }
                else {
                    for (var i = 0; i < 4; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Uint16ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setUint16(0, value, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 2);
                }
                else {
                    for (var i = 0; i < 2; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Uint8ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setUint8(0, value);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 1);
                }
                else {
                    for (var i = 0; i < 1; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.StringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return new Uint8Array(bstr);
            };
            converter.ArrayToLong = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    converter.dataView.setInt8(i, buf[offset + i]);
                }
                var n1 = converter.dataView.getInt32(0, true);
                for (var i = 4; i < 8; i++) {
                    converter.dataView.setInt8(i, buf[offset + i]);
                }
                var n2 = converter.dataView.getInt32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            };
            converter.ArrayToULong = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                var n1 = converter.dataView.getUint32(0, true);
                for (var i = 4; i < 8; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                var n2 = converter.dataView.getUint32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            };
            converter.ArrayToFloat64 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 8; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getFloat64(0, true);
            };
            converter.ArrayToFloat32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getFloat32(0, true);
            };
            converter.ArrayToInt32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getInt32(0, true);
            };
            converter.ArrayToInt16 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 2; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getInt16(0, true);
            };
            converter.ArrayToInt8 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 1; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getInt8(0);
            };
            converter.ArraytoUint32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getUint32(0, true);
            };
            converter.ArrayToUint16 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 2; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getUint16(0, true);
            };
            converter.ArrayToUint8 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 1; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getUint8(0);
            };
            converter.ArrayToString = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                var ret = [];
                for (var i = 0; i < buf.length; i++) {
                    var cc = buf[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = buf[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(buf[i]));
                    }
                }
                return ret.join('');
            };
            return converter;
        }());
        converter.dataView = new DataView(new ArrayBuffer(8), 0, 8);
        io.converter = converter;
        var binTool = (function (_super) {
            __extends(binTool, _super);
            function binTool() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            binTool.prototype.readSingle = function () {
                var array = new Uint8Array(4);
                this.read(array);
                return converter.ArrayToFloat32(array);
            };
            binTool.prototype.readLong = function () {
                var array = new Uint8Array(8);
                this.read(array);
                return converter.ArrayToLong(array);
            };
            binTool.prototype.readULong = function () {
                var array = new Uint8Array(8);
                this.read(array);
                return converter.ArrayToULong(array);
            };
            binTool.prototype.readDouble = function () {
                var array = new Uint8Array(8);
                this.read(array);
                return converter.ArrayToFloat64(array);
            };
            binTool.prototype.readInt8 = function () {
                var array = new Uint8Array(1);
                this.read(array);
                return converter.ArrayToInt8(array);
            };
            binTool.prototype.readUInt8 = function () {
                var array = new Uint8Array(1);
                this.read(array);
                return converter.ArrayToUint8(array);
            };
            binTool.prototype.readInt16 = function () {
                var array = new Uint8Array(2);
                this.read(array);
                return converter.ArrayToInt16(array);
            };
            binTool.prototype.readUInt16 = function () {
                var array = new Uint8Array(2);
                this.read(array);
                return converter.ArrayToUint16(array);
            };
            binTool.prototype.readInt32 = function () {
                var array = new Uint8Array(4);
                this.read(array);
                return converter.ArrayToInt32(array);
            };
            binTool.prototype.readUInt32 = function () {
                var array = new Uint8Array(4);
                this.read(array);
                return converter.ArraytoUint32(array);
            };
            binTool.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            binTool.prototype.readByte = function () {
                return this.readUInt8();
            };
            binTool.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            binTool.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            binTool.prototype.readFloat = function () {
                return this.readSingle();
            };
            binTool.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            binTool.prototype.readShort = function () {
                return this.readInt16();
            };
            binTool.prototype.readInt = function () {
                return this.readInt32();
            };
            binTool.prototype.readBytes = function (length) {
                var array = new Uint8Array(length);
                this.read(array);
                return array;
            };
            binTool.prototype.readStringUtf8 = function () {
                var length = this.readInt8();
                var array = new Uint8Array(length);
                this.read(array);
                return converter.ArrayToString(array);
            };
            binTool.prototype.readStringUtf8FixLength = function (length) {
                var array = new Uint8Array(length);
                this.read(array);
                return converter.ArrayToString(array);
            };
            binTool.prototype.readUTFBytes = function (length) {
                var array = new Uint8Array(length);
                this.read(array);
                return converter.ArrayToString(array);
            };
            binTool.prototype.readStringAnsi = function () {
                var slen = this.readUInt8();
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this.readByte());
                }
                return bs;
            };
            Object.defineProperty(binTool.prototype, "length", {
                get: function () {
                    return this.getLength();
                },
                enumerable: true,
                configurable: true
            });
            binTool.prototype.writeInt8 = function (num) {
                this.write(converter.Int8ToArray(num));
            };
            binTool.prototype.writeUInt8 = function (num) {
                this.write(converter.Uint8ToArray(num));
            };
            binTool.prototype.writeInt16 = function (num) {
                this.write(converter.Int16ToArray(num));
            };
            binTool.prototype.writeUInt16 = function (num) {
                this.write(converter.Uint16ToArray(num));
            };
            binTool.prototype.writeInt32 = function (num) {
                this.write(converter.Int32ToArray(num));
            };
            binTool.prototype.writeUInt32 = function (num) {
                this.write(converter.Uint32toArray(num));
            };
            binTool.prototype.writeSingle = function (num) {
                this.write(converter.Float32ToArray(num));
            };
            binTool.prototype.writeLong = function (num) {
                this.write(converter.LongToArray(num));
            };
            binTool.prototype.writeULong = function (num) {
                this.write(converter.ULongToArray(num));
            };
            binTool.prototype.writeDouble = function (num) {
                this.write(converter.Float64ToArray(num));
            };
            binTool.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.writeUInt8(slen);
                for (var i = 0; i < slen; i++) {
                    this.writeUInt8(str.charCodeAt(i));
                }
            };
            binTool.prototype.writeStringUtf8 = function (str) {
                var bstr = converter.StringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.write(bstr);
            };
            binTool.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = converter.StringToUtf8Array(str);
                this.write(bstr);
            };
            binTool.prototype.writeByte = function (num) {
                this.write(converter.Uint8ToArray(num));
            };
            binTool.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                this.write(array, offset, length);
            };
            binTool.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                this.write(array, offset, length);
            };
            binTool.prototype.writeUnsignedShort = function (num) {
                this.write(converter.Uint16ToArray(num));
            };
            binTool.prototype.writeUnsignedInt = function (num) {
                this.write(converter.Uint32toArray(num));
            };
            binTool.prototype.writeFloat = function (num) {
                this.write(converter.Float32ToArray(num));
            };
            binTool.prototype.writeUTFBytes = function (str) {
                this.write(converter.StringToUtf8Array(str));
            };
            binTool.prototype.writeSymbolByte = function (num) {
                this.write(converter.Int8ToArray(num));
            };
            binTool.prototype.writeShort = function (num) {
                this.write(converter.Int16ToArray(num));
            };
            binTool.prototype.writeInt = function (num) {
                this.write(converter.Int32ToArray(num));
            };
            binTool.prototype.dispose = function () {
                this._buf.splice(0);
            };
            return binTool;
        }(binBuffer));
        io.binTool = binTool;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        function cloneObj(instanceObj, clonedObj) {
            if (clonedObj === void 0) { clonedObj = undefined; }
            io.referenceInfo.oldmap = {};
            clonedObj = _cloneObj(instanceObj, clonedObj);
            io.referenceInfo.oldmap[instanceObj["insId"].getInsID()] = clonedObj;
            fillCloneReference(instanceObj, clonedObj);
            return clonedObj;
        }
        io.cloneObj = cloneObj;
        function fillCloneReference(instanceObj, clonedObj) {
            var _flag = gd3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.DontSaveInBuild) || (_flag & gd3d.framework.HideFlags.DontSaveInEditor) || (_flag & gd3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        io.fillCloneReference = fillCloneReference;
        function fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    fillCloneReferenceType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    for (var newkey in instanceObj[key]) {
                        var field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            var _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                            }
                            else {
                                fillCloneReferenceType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                    }
                }
            }
        }
        io.fillCloneReferenceTypeOrArray = fillCloneReferenceTypeOrArray;
        function fillCloneReferenceType(instanceObj, clonedObj, key, instanceParent, clonedParent, instanceKey) {
            if (instanceParent === void 0) { instanceParent = null; }
            if (clonedParent === void 0) { clonedParent = null; }
            if (instanceKey === void 0) { instanceKey = ""; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_1 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    var instance = void 0;
                    if ((isArray_1 && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_1 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid].gameObject.getComponent(type);
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid].getComponent(type);
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid];
                        }
                    }
                    if (isreference) {
                        if (isArray_1) {
                            clonedObj.push(instance);
                        }
                        else {
                            clonedObj[key] = instance;
                        }
                    }
                    else {
                        fillCloneReference(instanceObj[key], clonedObj[key]);
                    }
                }
            }
        }
        io.fillCloneReferenceType = fillCloneReferenceType;
        function _cloneObj(instanceObj, clonedObj) {
            if (clonedObj === void 0) { clonedObj = undefined; }
            var _flag = gd3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.DontSaveInBuild) || (_flag & gd3d.framework.HideFlags.DontSaveInEditor) || (_flag & gd3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            if (clonedObj == undefined) {
                var insid = -1;
                clonedObj = gd3d.reflect.createInstance(instanceObj, null);
                if (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"]) {
                    insid = instanceObj["gameObject"]["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]) {
                    insid = instanceObj["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["typename"] == "transform" || instanceObj["__gdmeta__"]["class"]["typename"] == "transform2D") {
                    insid = instanceObj["insId"].getInsID();
                    io.referenceInfo.oldmap[insid] = clonedObj;
                }
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        clonedObj[key] = instanceObj[key];
                        break;
                    default:
                        cloneOtherTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        io._cloneObj = _cloneObj;
        function cloneOtherTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    cloneOtherType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_2 = instanceObj[key] instanceof Array;
                    if (isArray_2)
                        clonedObj[key] = [];
                    else
                        clonedObj[key] = {};
                    for (var newkey in instanceObj[key]) {
                        var field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            var _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                            }
                            else {
                                cloneOtherType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (field);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        if (isArray_2) {
                                            clonedObj[key].push(field);
                                        }
                                        else {
                                            clonedObj[key][newkey] = field;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        io.cloneOtherTypeOrArray = cloneOtherTypeOrArray;
        function cloneOtherType(instanceObj, clonedObj, key, instanceParent, clonedParent, instanceKey) {
            if (instanceParent === void 0) { instanceParent = null; }
            if (clonedParent === void 0) { clonedParent = null; }
            if (instanceKey === void 0) { instanceKey = ""; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_3 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    if (isArray_3) {
                        clonedObj.push(instanceObj[key]);
                    }
                    else {
                        clonedObj[key] = instanceObj[key];
                    }
                }
                else {
                    var isreference = false;
                    if ((isArray_3 && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_3 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"] || type == "transform" || type == "transform2D") {
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray_3) {
                        }
                        else {
                        }
                    }
                    else {
                        var _clonedObj = void 0;
                        if (_meta["class"]["custom"]["selfclone"]) {
                            _clonedObj = instanceObj[key].clone();
                        }
                        else {
                            _clonedObj = _cloneObj(instanceObj[key], clonedObj[key]);
                        }
                        if (_clonedObj != null) {
                            if (isArray_3) {
                                if (type == "nodeComponent" && instanceKey == "components" && gd3d.reflect.getClassName(instanceParent) == "gameObject") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "transform" && instanceKey == "children" && gd3d.reflect.getClassName(instanceParent) == "transform") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else if (type == "C2DComponent" && instanceKey == "components" && gd3d.reflect.getClassName(instanceParent) == "transform2D") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "transform2D" && instanceKey == "children" && gd3d.reflect.getClassName(instanceParent) == "transform2D") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else {
                                    clonedObj.push(_clonedObj);
                                }
                            }
                            else {
                                clonedObj[key] = _clonedObj;
                            }
                        }
                    }
                }
            }
        }
        io.cloneOtherType = cloneOtherType;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        function stringToBlob(content) {
            var u8 = new Uint8Array(stringToUtf8Array(content));
            var blob = new Blob([u8]);
            return blob;
        }
        io.stringToBlob = stringToBlob;
        function stringToUtf8Array(str) {
            var bstr = [];
            for (var i = 0; i < str.length; i++) {
                var c = str.charAt(i);
                var cc = c.charCodeAt(0);
                if (cc > 0xFFFF) {
                    throw new Error("InvalidCharacterError");
                }
                if (cc > 0x80) {
                    if (cc < 0x07FF) {
                        var c1 = (cc >>> 6) | 0xC0;
                        var c2 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2);
                    }
                    else {
                        var c1 = (cc >>> 12) | 0xE0;
                        var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                        var c3 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2, c3);
                    }
                }
                else {
                    bstr.push(cc);
                }
            }
            return bstr;
        }
        io.stringToUtf8Array = stringToUtf8Array;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var SerializeDependent = (function () {
            function SerializeDependent() {
            }
            SerializeDependent.GetAssetUrl = function (asset, assetMgr) {
                if (!assetMgr || !asset)
                    return;
                var url = assetMgr.getAssetUrl(asset);
                if (!url)
                    return;
                SerializeDependent.resoursePaths.push(url);
                if (asset instanceof gd3d.framework.material) {
                    var _mapUniform = asset.mapUniform;
                    if (!_mapUniform)
                        return;
                    for (var newKey in _mapUniform) {
                        if (!_mapUniform[newKey])
                            continue;
                        if (_mapUniform[newKey].type != gd3d.render.UniformTypeEnum.Texture)
                            continue;
                        var _texture = _mapUniform[newKey].value;
                        if (!_texture)
                            continue;
                        url = assetMgr.getAssetUrl(_texture);
                        if (!url)
                            continue;
                        SerializeDependent.resoursePaths.push(url);
                        if (url.indexOf(".imgdesc.json") < 0)
                            continue;
                        if (!_texture.realName)
                            continue;
                        url = url.replace(_texture.getName(), _texture.realName);
                        SerializeDependent.resoursePaths.push(url);
                    }
                }
            };
            return SerializeDependent;
        }());
        SerializeDependent.resoursePaths = [];
        io.SerializeDependent = SerializeDependent;
        function SerializeForInspector(obj) {
            var str = JSON.stringify(serializeObjForInspector(obj, false));
            return str;
        }
        io.SerializeForInspector = SerializeForInspector;
        function serializeObjForInspector(instanceObj, beComponent, serializedObj) {
            if (serializedObj === void 0) { serializedObj = undefined; }
            var _flag = gd3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.HideInInspector)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = {};
            }
            for (var key in instanceObj["__gdmeta__"]) {
                if (key == "children")
                    continue;
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        var info = new inspectorValueInfo(instanceObj[key], valueType);
                        if (t["custom"]["FieldUIStyle"])
                            info.UIStyle = t["custom"]["FieldUIStyle"];
                        if (t["custom"]["defvalue"])
                            info.defvalue = t["custom"]["defvalue"];
                        if (t["custom"]["min"])
                            info.min = t["custom"]["min"];
                        if (t["custom"]["max"])
                            info.max = t["custom"]["max"];
                        serializedObj[key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObjForInspector = serializeObjForInspector;
        function serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_4 = instanceObj[key] instanceof Array;
                    if (isArray_4)
                        serializedObj[key] = new inspectorValueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    else
                        serializedObj[key] = new inspectorValueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey]["__gdmeta__"]) {
                            var _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                            }
                            else {
                                serializeOtherTypeForInspector(instanceObj[key], serializedObj[key]["value"], newkey, beComponent, instanceObj);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        var info_1 = new inspectorValueInfo(instanceObj[key][newkey], baseType);
                                        if (isArray_4) {
                                            serializedObj[key]["value"].push(info_1);
                                        }
                                        else {
                                            serializedObj[key]["value"][newkey] = info_1;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            else {
                var isArray_5 = instanceObj instanceof Array;
                if (instanceObj["__gdmeta__"][key]) {
                    if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"]) {
                        var custom = instanceObj["__gdmeta__"][key]["custom"];
                        var info = new inspectorValueInfo(null, custom["valueType"]);
                        if (custom["FieldUIStyle"])
                            info.UIStyle = custom["FieldUIStyle"];
                        if (custom["defvalue"])
                            info.defvalue = custom;
                        if (custom["min"])
                            info.min = custom["min"];
                        if (custom["max"])
                            info.max = custom["max"];
                        if (isArray_5) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeOrArrayForInspector = serializeOtherTypeOrArrayForInspector;
        function serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent, arrayInst) {
            if (arrayInst === void 0) { arrayInst = null; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_6 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (isAssetInspector(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    var _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        var info = new inspectorValueInfo(_assetName, type);
                        if (isArray_6) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    if ((isArray_6 && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_6 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        beComponent = true;
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (!referenceInfo.isRegType(type)) {
                            return;
                        }
                    }
                    if (isreference) {
                        var info = new inspectorValueInfo(insid, type, "reference");
                        if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                            var custom = instanceObj["__gdmeta__"][key]["custom"];
                            info.UIStyle = instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"];
                            if (custom["defvalue"])
                                info.defvalue = custom;
                            if (custom["min"])
                                info.min = custom["min"];
                            if (custom["max"])
                                info.max = custom["max"];
                        }
                        if (isArray_6) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                    else {
                        if (!referenceInfo.isRegType(type) && beComponent)
                            return;
                        var _serializeObj = serializeObjForInspector(instanceObj[key], beComponent, serializedObj[key]);
                        if (_serializeObj != null) {
                            var info = new inspectorValueInfo(_serializeObj, type);
                            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                                var custom = instanceObj["__gdmeta__"][key]["custom"];
                                info.UIStyle = custom["FieldUIStyle"];
                                if (custom["defvalue"])
                                    info.defvalue = custom;
                                if (custom["min"])
                                    info.min = custom["min"];
                                if (custom["max"])
                                    info.max = custom["max"];
                            }
                            if (isArray_6) {
                                serializedObj.push(info);
                            }
                            else {
                                serializedObj[key] = info;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeForInspector = serializeOtherTypeForInspector;
        function Serialize(obj, assetMgr) {
            if (assetMgr === void 0) { assetMgr = null; }
            return JSON.stringify(serializeObj(obj, null, assetMgr));
        }
        io.Serialize = Serialize;
        function serializeObj(instanceObj, serializedObj, assetMgr) {
            if (serializedObj === void 0) { serializedObj = undefined; }
            if (assetMgr === void 0) { assetMgr = null; }
            var _flag = gd3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.DontSaveInBuild) || (_flag & gd3d.framework.HideFlags.DontSaveInEditor) || (_flag & gd3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = new valueInfo({}, _type);
                if (instanceObj["insId"] != undefined) {
                    serializedObj["insid"] = instanceObj["insId"].getInsID();
                }
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        var info = new valueInfo(instanceObj[key], valueType);
                        serializedObj["value"][key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArray(instanceObj, serializedObj["value"], key, assetMgr);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObj = serializeObj;
        function serializeOtherTypeOrArray(instanceObj, serializedObj, key, assetMgr) {
            if (assetMgr === void 0) { assetMgr = null; }
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherType(instanceObj, serializedObj, key, null, assetMgr);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_7 = instanceObj[key] instanceof Array;
                    if (isArray_7)
                        serializedObj[key] = new valueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    else
                        serializedObj[key] = new valueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey]["__gdmeta__"]) {
                            var _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                            }
                            else {
                                serializeOtherType(instanceObj[key], serializedObj[key]["value"], newkey, instanceObj, assetMgr);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        var info = new valueInfo(instanceObj[key][newkey], baseType);
                                        if (isArray_7) {
                                            serializedObj[key]["value"].push(info);
                                        }
                                        else {
                                            serializedObj[key]["value"][newkey] = info;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeOrArray = serializeOtherTypeOrArray;
        function serializeOtherType(instanceObj, serializedObj, key, arrayInst, assetMgr) {
            if (arrayInst === void 0) { arrayInst = null; }
            if (assetMgr === void 0) { assetMgr = null; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_8 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (isAsset(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    var _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        else {
                            if (assetMgr) {
                                SerializeDependent.GetAssetUrl(instanceObj[key], assetMgr);
                            }
                        }
                        if (isArray_8) {
                            serializedObj.push(new valueInfo(_assetName, type));
                        }
                        else {
                            serializedObj[key] = new valueInfo(_assetName, type);
                        }
                    }
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    if ((isArray_8 && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_8 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray_8) {
                            serializedObj.push(new valueInfo(insid, type, "reference"));
                        }
                        else {
                            serializedObj[key] = new valueInfo(insid, type, "reference");
                        }
                    }
                    else {
                        var _serializeObj = serializeObj(instanceObj[key], serializedObj[key], assetMgr);
                        if (_serializeObj != null) {
                            if (isArray_8) {
                                serializedObj.push(_serializeObj);
                            }
                            else {
                                serializedObj[key] = _serializeObj;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherType = serializeOtherType;
        function deSerialize(serializedObj, instanceObj, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            referenceInfo.oldmap = {};
            deSerializeObj(serializedObj["value"], instanceObj, assetMgr, bundlename);
            referenceInfo.oldmap[serializedObj["insid"]] = instanceObj;
            fillReference(serializedObj["value"], instanceObj);
        }
        io.deSerialize = deSerialize;
        function fillReference(serializedObj, instanceObj) {
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        dofillReferenceOrArray(serializedObj, instanceObj, key);
                        break;
                }
            }
        }
        io.fillReference = fillReference;
        function dofillReferenceOrArray(serializedObj, instanceObj, key) {
            if (serializedObj[key]) {
                var type = serializedObj[key].type;
                if (isArrayOrDic(type.toLowerCase())) {
                    var _isArray = serializedObj[key].value instanceof Array;
                    if (!instanceObj[key]) {
                        if (_isArray)
                            instanceObj[key] = [];
                        else
                            instanceObj[key] = {};
                    }
                    var arrayObj = null;
                    if (instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        var baseType = arrayObj[newkey].type;
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                break;
                            default:
                                dofillReference(serializedObj[key]["value"], instanceObj[key], newkey);
                                break;
                        }
                    }
                }
                else {
                    dofillReference(serializedObj, instanceObj, key);
                }
            }
        }
        io.dofillReferenceOrArray = dofillReferenceOrArray;
        function dofillReference(serializedObj, instanceObj, key) {
            var _isArray = instanceObj instanceof Array;
            var type = serializedObj[key].type;
            var _parentType = typeof (instanceObj);
            if (isAsset(type)) {
            }
            else {
                if (serializedObj[key].parse == "reference") {
                    var instance = referenceInfo.oldmap[serializedObj[key].value];
                    if (type == "transform" || type == "transform2D") {
                    }
                    else {
                        if (instance instanceof gd3d.framework.transform2D) {
                            instance = instance.getComponent(type);
                        }
                        else if (instance instanceof gd3d.framework.transform) {
                            instance = instance.gameObject.getComponent(type);
                        }
                    }
                    if (_isArray) {
                        instanceObj.push(instance);
                    }
                    else {
                        instanceObj[key] = instance;
                    }
                }
                else {
                    fillReference(serializedObj[key].value, instanceObj[key]);
                }
            }
        }
        io.dofillReference = dofillReference;
        function deSerializeObj(serializedObj, instanceObj, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (instanceObj == undefined) {
                throw new Error("");
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        if (serializedObj[key] == undefined || valueType != serializedObj[key].type) {
                            continue;
                        }
                        else {
                            instanceObj[key] = serializedObj[key].value;
                        }
                        break;
                    default:
                        deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, assetMgr, bundlename);
                        break;
                }
            }
        }
        io.deSerializeObj = deSerializeObj;
        function deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (serializedObj[key]) {
                var type = serializedObj[key].type;
                if (isArrayOrDic(type.toLowerCase())) {
                    var _isArray = serializedObj[key].value instanceof Array;
                    if (!instanceObj[key]) {
                        if (_isArray)
                            instanceObj[key] = [];
                        else
                            instanceObj[key] = {};
                    }
                    var arrayObj = null;
                    if (instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        var baseType = arrayObj[newkey].type;
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                if (baseType != serializedObj[key][newkey].type) {
                                    throw new Error("" + baseType + " as " + serializedObj[key].type);
                                }
                                if (_isArray) {
                                    instanceObj[key].push(serializedObj[key][newkey].value);
                                }
                                else {
                                    instanceObj[key][newkey] = serializedObj[key][newkey].value;
                                }
                                break;
                            default:
                                if (baseType == "nodeComponent" && key == "components" && gd3d.reflect.getClassName(instanceObj) == "gameObject") {
                                    var _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, assetMgr, bundlename);
                                    instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "transform" && key == "children" && gd3d.reflect.getClassName(instanceObj) == "transform") {
                                    var _transforms = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms, newkey, assetMgr, bundlename);
                                    instanceObj.addChild(_transforms[0]);
                                }
                                else if (baseType == "C2DComponent" && key == "components" && gd3d.reflect.getClassName(instanceObj) == "transform2D") {
                                    var _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, assetMgr, bundlename);
                                    instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "transform2D" && key == "children" && gd3d.reflect.getClassName(instanceObj) == "transform2D") {
                                    var _transforms2D = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms2D, newkey, assetMgr, bundlename);
                                    instanceObj.addChild(_transforms2D[0]);
                                }
                                else {
                                    deSerializeOtherType(serializedObj[key]["value"], instanceObj[key], newkey, assetMgr, bundlename);
                                }
                                break;
                        }
                    }
                }
                else {
                    deSerializeOtherType(serializedObj, instanceObj, key, assetMgr, bundlename);
                }
            }
        }
        io.deSerializeOtherTypeOrArray = deSerializeOtherTypeOrArray;
        function deSerializeOtherType(serializedObj, instanceObj, key, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            var _isArray = instanceObj instanceof Array;
            var type = serializedObj[key].type;
            var _parentType = typeof (instanceObj);
            if (isAsset(type)) {
                var assetName = serializedObj[key].value;
                var _asset = void 0;
                if (assetName.indexOf("SystemDefaultAsset-") >= 0) {
                    assetName = assetName.replace("SystemDefaultAsset-", "");
                    if (type == "mesh") {
                        _asset = assetMgr.getDefaultMesh(assetName);
                    }
                    else if (type == "texture") {
                        _asset = assetMgr.getDefaultTexture(assetName);
                    }
                }
                else {
                    _asset = assetMgr.getAssetByName(assetName, bundlename);
                }
                {
                    if (instanceObj instanceof Array) {
                        instanceObj.push(_asset);
                    }
                    else {
                        instanceObj[key] = _asset;
                    }
                }
            }
            else {
                if (serializedObj[key].parse == "reference") {
                }
                else {
                    var _newInstance = void 0;
                    if (type == "gameObject" && key == "gameObject" && gd3d.reflect.getClassName(instanceObj) == "transform") {
                        _newInstance = instanceObj.gameObject;
                    }
                    else if (type == "transform2D" && key == "rootNode" && gd3d.reflect.getClassName(instanceObj) == "canvas") {
                        _newInstance = gd3d.reflect.createInstance(document["__gdmeta__"][type], null);
                        instanceObj.rootNode = _newInstance;
                        _newInstance.canvas = instanceObj;
                    }
                    else {
                        _newInstance = gd3d.reflect.createInstance(document["__gdmeta__"][type], null);
                        if (_isArray)
                            instanceObj.push(_newInstance);
                        else
                            instanceObj[key] = _newInstance;
                    }
                    deSerializeObj(serializedObj[key].value, _newInstance, assetMgr, bundlename);
                    referenceInfo.oldmap[serializedObj[key].insid] = _newInstance;
                }
            }
        }
        io.deSerializeOtherType = deSerializeOtherType;
        function isArray(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0) {
                return true;
            }
            return false;
        }
        io.isArray = isArray;
        function isArrayOrDic(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0 || type.indexOf("dic") >= 0) {
                return true;
            }
            return false;
        }
        io.isArrayOrDic = isArrayOrDic;
        function isAsset(type) {
            if (type == "mesh" || type == "texture" || type == "shader" ||
                type == "material" || type == "animationClip" || type == "atlas" ||
                type == "font" || type == "prefab" || type == "sprite")
                return true;
            return false;
        }
        io.isAsset = isAsset;
        function isAssetInspector(type) {
            if (type == "prefab")
                return true;
        }
        io.isAssetInspector = isAssetInspector;
        var valueInfo = (function () {
            function valueInfo(value, type, _parse) {
                if (_parse === void 0) { _parse = "direct"; }
                this.value = value;
                this.type = type;
                if (isAsset(type)) {
                    _parse = "nameonly";
                }
                this.parse = _parse;
            }
            return valueInfo;
        }());
        var inspectorValueInfo = (function () {
            function inspectorValueInfo(_value, _type, _parse) {
                if (_parse === void 0) { _parse = "direct"; }
                this.value = _value;
                this.type = _type;
                if (isAssetInspector(_type)) {
                    _parse = "nameonly";
                }
                this.parse = _parse;
            }
            return inspectorValueInfo;
        }());
        var referenceInfo = (function () {
            function referenceInfo() {
            }
            referenceInfo.regDefaultType = function () {
                referenceInfo.regType("vector3");
                referenceInfo.regType("vector4");
                referenceInfo.regType("color");
                referenceInfo.regType("quaternion");
                referenceInfo.regType("material");
                referenceInfo.regType("gameObject");
                referenceInfo.regType("transform2D");
                referenceInfo.regType("shader");
                referenceInfo.regType("atlas");
                referenceInfo.regType("font");
                referenceInfo.regType("sprite");
                referenceInfo.regType("texture");
                referenceInfo.regType("mesh");
                referenceInfo.regType("animationclip");
                referenceInfo.regType("constText");
                referenceInfo.regType("UniformData");
            };
            referenceInfo.regType = function (type) {
                referenceInfo.regtypelist.push(type);
            };
            referenceInfo.isRegType = function (type) {
                return this.regtypelist.indexOf(type) >= 0;
            };
            return referenceInfo;
        }());
        referenceInfo.oldmap = {};
        referenceInfo.regtypelist = [];
        io.referenceInfo = referenceInfo;
        var enumMgr = (function () {
            function enumMgr() {
            }
            return enumMgr;
        }());
        enumMgr.enumMap = {};
        io.enumMgr = enumMgr;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var binReader = (function () {
            function binReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            binReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            binReader.prototype.peek = function () {
                return this._seek;
            };
            binReader.prototype.length = function () {
                return this._data.byteLength;
            };
            binReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            binReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            binReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            binReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return binReader.utf8ArrayToString(arr);
            };
            binReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return binReader.utf8ArrayToString(arr);
            };
            binReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            binReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            binReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            binReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            binReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            binReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readUint8Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            binReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            Object.defineProperty(binReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            binReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            binReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            binReader.prototype.readBytes = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            binReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            binReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            binReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            binReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return binReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            binReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            binReader.prototype.readShort = function () {
                return this.readInt16();
            };
            binReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return binReader;
        }());
        io.binReader = binReader;
        var binWriter = (function () {
            function binWriter() {
                {
                    var buf = new ArrayBuffer(1024);
                    this._length = 0;
                }
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            binWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            binWriter.prototype.getLength = function () {
                return length;
            };
            binWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            binWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            binWriter.prototype.peek = function () {
                return this._seek;
            };
            binWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            binWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            binWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            binWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            binWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            binWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            binWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = binWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            binWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            binWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = binWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            binWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(binWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            binWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            binWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            binWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            binWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            binWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            binWriter.prototype.writeUTFBytes = function (str) {
                var strArray = binWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            binWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            binWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            binWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return binWriter;
        }());
        io.binWriter = binWriter;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function colorSet_White(out) {
            out.r = 1;
            out.g = 1;
            out.b = 1;
            out.a = 1;
        }
        math.colorSet_White = colorSet_White;
        function colorSet_Black(out) {
            out.r = 0;
            out.g = 0;
            out.b = 0;
            out.a = 1;
        }
        math.colorSet_Black = colorSet_Black;
        function colorSet_Gray(out) {
            out.r = 0.5;
            out.g = 0.5;
            out.b = 0.5;
            out.a = 1;
        }
        math.colorSet_Gray = colorSet_Gray;
        function colorMultiply(srca, srcb, out) {
            out.r = srca.r * srcb.r;
            out.g = srca.g * srcb.g;
            out.b = srca.b * srcb.b;
            out.a = srca.a * srcb.a;
        }
        math.colorMultiply = colorMultiply;
        function scaleToRef(src, scale, out) {
            out.r = src.r * scale;
            out.g = src.g * scale;
            out.b = src.b * scale;
            out.a = src.a * scale;
        }
        math.scaleToRef = scaleToRef;
        function colorClone(src, out) {
            out.a = src.a;
            out.r = src.r;
            out.g = src.g;
            out.b = src.b;
        }
        math.colorClone = colorClone;
        function colorLerp(srca, srcb, t, out) {
            out.a = t * (srcb.a - srca.a) + srca.a;
            out.r = t * (srcb.r - srca.r) + srca.r;
            out.g = t * (srcb.g - srca.g) + srca.g;
            out.b = t * (srcb.b - srca.b) + srca.b;
            out.a = Math.floor(out.a);
            out.r = Math.floor(out.r);
            out.g = Math.floor(out.g);
            out.b = Math.floor(out.b);
        }
        math.colorLerp = colorLerp;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
            var vp1 = planeVector.x;
            var vp2 = planeVector.y;
            var vp3 = planeVector.z;
            var n1 = planePoint.x;
            var n2 = planePoint.y;
            var n3 = planePoint.z;
            var v1 = lineVector.x;
            var v2 = lineVector.y;
            var v3 = lineVector.z;
            var m1 = linePoint.x;
            var m2 = linePoint.y;
            var m3 = linePoint.z;
            var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
            if (vpt === 0) {
                out = null;
            }
            else {
                var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                out.x = m1 + v1 * t;
                out.y = m2 + v2 * t;
                out.z = m3 + v3 * t;
            }
        }
        math.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
        function isContain(p1, p2, p3, p4, mp) {
            if (Multiply(mp, p1, p2) * Multiply(mp, p4, p3) <= 0 && Multiply(mp, p4, p1) * Multiply(mp, p3, p2) <= 0)
                return true;
            return false;
        }
        math.isContain = isContain;
        function Multiply(p1, p2, p0) {
            return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
        }
        math.Multiply = Multiply;
        function getPointByTwoline(index, p2, dir2, outpoint) {
            var matrix = new gd3d.math.matrix();
            var dir1;
            if (index == 1) {
                dir1 = new gd3d.math.vector3(1, 0, 0);
                matrix.rawData[0] = 1;
            }
            else if (index == 2) {
                dir1 = new gd3d.math.vector3(0, 1, 0);
                matrix.rawData[0] = 0;
                matrix.rawData[1] = 1;
            }
            else if (index == 3) {
                dir1 = new gd3d.math.vector3(0, 0, 1);
                matrix.rawData[0] = 0;
                matrix.rawData[2] = 1;
            }
            var dirBt = new gd3d.math.vector3();
            gd3d.math.vec3Cross(dir1, dir2, dirBt);
            matrix.rawData[4] = dirBt.x;
            matrix.rawData[5] = dirBt.y;
            matrix.rawData[6] = dirBt.z;
            matrix.rawData[8] = -dir2.x;
            matrix.rawData[9] = -dir2.y;
            matrix.rawData[10] = -dir2.z;
            gd3d.math.matrixInverse(matrix, matrix);
            var outnode = new gd3d.math.vector3();
            gd3d.math.matrixTransformVector3(p2, matrix, outnode);
            if (index == 1) {
                outpoint = new gd3d.math.vector3(outnode.x, 0, 0);
            }
            else if (index == 2) {
                outpoint = new gd3d.math.vector3(0, outnode.y, 0);
            }
            else if (index == 3) {
                outpoint = new gd3d.math.vector3(0, 0, outnode.z);
            }
        }
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function matrixGetTranslation(src, out) {
            out.x = src.rawData[12];
            out.y = src.rawData[13];
            out.z = src.rawData[14];
        }
        math.matrixGetTranslation = matrixGetTranslation;
        function matrixTranspose(src, out) {
            out.rawData[1] = src.rawData[4];
            out.rawData[2] = src.rawData[8];
            out.rawData[3] = src.rawData[12];
            out.rawData[4] = src.rawData[1];
            out.rawData[6] = src.rawData[9];
            out.rawData[7] = src.rawData[13];
            out.rawData[8] = src.rawData[2];
            out.rawData[9] = src.rawData[6];
            out.rawData[11] = src.rawData[14];
            out.rawData[12] = src.rawData[3];
            out.rawData[13] = src.rawData[7];
            out.rawData[14] = src.rawData[11];
        }
        math.matrixTranspose = matrixTranspose;
        function matrixDecompose(src, scale, rotation, translation) {
            translation.x = src.rawData[12];
            translation.y = src.rawData[13];
            translation.z = src.rawData[14];
            var xs = math.sign(src.rawData[0] * src.rawData[1] * src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[4] * src.rawData[5] * src.rawData[6] * src.rawData[7]) < 0 ? -1 : 1;
            var zs = math.sign(src.rawData[8] * src.rawData[9] * src.rawData[10] * src.rawData[11]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            scale.y = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            scale.z = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
            if (scale.x === 0 || scale.y === 0 || scale.z === 0) {
                rotation.x = 0;
                rotation.y = 0;
                rotation.z = 0;
                rotation.w = 1;
                return false;
            }
            var mat = math.pool.new_matrix();
            mat.rawData[0] = src.rawData[0] / scale.x;
            mat.rawData[1] = src.rawData[1] / scale.x;
            mat.rawData[2] = src.rawData[2] / scale.x;
            mat.rawData[3] = 0;
            mat.rawData[4] = src.rawData[4] / scale.y;
            mat.rawData[5] = src.rawData[5] / scale.y;
            mat.rawData[6] = src.rawData[6] / scale.y;
            mat.rawData[7] = 0;
            mat.rawData[8] = src.rawData[8] / scale.z;
            mat.rawData[9] = src.rawData[9] / scale.z;
            mat.rawData[10] = src.rawData[10] / scale.z;
            mat.rawData[11] = 0;
            matrix2Quaternion(mat, rotation);
            return true;
        }
        math.matrixDecompose = matrixDecompose;
        var angelref = (function () {
            function angelref() {
            }
            return angelref;
        }());
        math.angelref = angelref;
        function matrix3x2Decompose(src, scale, rotation, translation) {
            translation.x = src.rawData[4];
            translation.y = src.rawData[5];
            var xs = math.sign(src.rawData[0] * src.rawData[1]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1]);
            scale.y = ys * Math.sqrt(src.rawData[2] * src.rawData[2] + src.rawData[3] * src.rawData[3]);
            if (scale.x === 0 || scale.y === 0) {
                rotation.v = 0;
                return false;
            }
            var sx = src.rawData[0] / scale.x;
            var csx = src.rawData[1] / scale.x;
            var r1 = Math.asin(sx);
            var r2 = Math.acos(csx);
            rotation.v = r1;
            return true;
        }
        math.matrix3x2Decompose = matrix3x2Decompose;
        function matrix2Quaternion(matrix, result) {
            var data = matrix.rawData;
            var m11 = data[0], m12 = data[4], m13 = data[8];
            var m21 = data[1], m22 = data[5], m23 = data[9];
            var m31 = data[2], m32 = data[6], m33 = data[10];
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                result.w = 0.25 / s;
                result.x = (m32 - m23) * s;
                result.y = (m13 - m31) * s;
                result.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                result.w = (m32 - m23) / s;
                result.x = 0.25 * s;
                result.y = (m12 + m21) / s;
                result.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                result.w = (m13 - m31) / s;
                result.x = (m12 + m21) / s;
                result.y = 0.25 * s;
                result.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                result.w = (m21 - m12) / s;
                result.x = (m13 + m31) / s;
                result.y = (m23 + m32) / s;
                result.z = 0.25 * s;
            }
        }
        math.matrix2Quaternion = matrix2Quaternion;
        function matrixClone(src, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = src.rawData[i];
            }
        }
        math.matrixClone = matrixClone;
        function matrix3x2Clone(src, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = src.rawData[i];
            }
        }
        math.matrix3x2Clone = matrix3x2Clone;
        function matrixMakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = 1;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = 1;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeIdentity = matrixMakeIdentity;
        function matrix3x2MakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 1;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeIdentity = matrix3x2MakeIdentity;
        function matrixInverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l3 = src.rawData[2];
            var l4 = src.rawData[3];
            var l5 = src.rawData[4];
            var l6 = src.rawData[5];
            var l7 = src.rawData[6];
            var l8 = src.rawData[7];
            var l9 = src.rawData[8];
            var l10 = src.rawData[9];
            var l11 = src.rawData[10];
            var l12 = src.rawData[11];
            var l13 = src.rawData[12];
            var l14 = src.rawData[13];
            var l15 = src.rawData[14];
            var l16 = src.rawData[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            out.rawData[0] = l23 * l27;
            out.rawData[4] = l24 * l27;
            out.rawData[8] = l25 * l27;
            out.rawData[12] = l26 * l27;
            out.rawData[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            out.rawData[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            out.rawData[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            out.rawData[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            out.rawData[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            out.rawData[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            out.rawData[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            out.rawData[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            out.rawData[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            out.rawData[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            out.rawData[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            out.rawData[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
        }
        math.matrixInverse = matrixInverse;
        function matrix3x2Inverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l5 = src.rawData[2];
            var l6 = src.rawData[3];
            var l13 = src.rawData[4];
            var l14 = src.rawData[5];
            var l26 = -(((l5 * -l14) - (l6 * -l13)));
            var l27 = 1.0 / ((((l1 * l6) + (l2 * -l5))));
            out.rawData[0] = l6 * l27;
            out.rawData[2] = -l5 * l27;
            out.rawData[4] = l26 * l27;
            out.rawData[1] = -(((l2))) * l27;
            out.rawData[3] = (((l1))) * l27;
            out.rawData[5] = (((l1 * -l14) - (l2 * -l13))) * l27;
        }
        math.matrix3x2Inverse = matrix3x2Inverse;
        function matrixMakeTransformRTS(pos, scale, rot, out) {
            var matS = gd3d.math.pool.new_matrix();
            matrixMakeScale(scale.x, scale.y, scale.z, matS);
            var matR = gd3d.math.pool.new_matrix();
            math.quatToMatrix(rot, matR);
            matrixMultiply(matR, matS, out);
            out.rawData[12] = pos.x;
            out.rawData[13] = pos.y;
            out.rawData[14] = pos.z;
            out.rawData[15] = 1;
            gd3d.math.pool.delete_matrix(matS);
            gd3d.math.pool.delete_matrix(matR);
        }
        math.matrixMakeTransformRTS = matrixMakeTransformRTS;
        function matrix3x2MakeTransformRTS(pos, scale, rot, out) {
            var matS = gd3d.math.pool.new_matrix3x2();
            matrix3x2MakeScale(scale.x, scale.y, matS);
            var matR = gd3d.math.pool.new_matrix3x2();
            matrix3x2MakeRotate(rot, matR);
            matrix3x2Multiply(matR, matS, out);
            out.rawData[4] = pos.x;
            out.rawData[5] = pos.y;
            gd3d.math.pool.delete_matrix3x2(matS);
            gd3d.math.pool.delete_matrix3x2(matR);
        }
        math.matrix3x2MakeTransformRTS = matrix3x2MakeTransformRTS;
        function matrixMakeTranslate(x, y, z, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0;
            out.rawData[4] = 0.0;
            out.rawData[5] = 1.0;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = 1.0;
            out.rawData[11] = 0.0;
            out.rawData[12] = x;
            out.rawData[13] = y;
            out.rawData[14] = z;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeTranslate = matrixMakeTranslate;
        function matrix3x2MakeTranslate(x, y, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 1.0;
            out.rawData[4] = x;
            out.rawData[5] = y;
        }
        math.matrix3x2MakeTranslate = matrix3x2MakeTranslate;
        function matrixGetScale(src, scale) {
            scale.x = src.rawData[0];
            scale.y = src.rawData[5];
            scale.z = src.rawData[10];
        }
        math.matrixGetScale = matrixGetScale;
        function matrixMakeScale(xScale, yScale, zScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0.0;
            out.rawData[4] = 0.0;
            out.rawData[5] = yScale;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = zScale;
            out.rawData[11] = 0.0;
            out.rawData[12] = 0.0;
            out.rawData[13] = 0.0;
            out.rawData[14] = 0.0;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeScale = matrixMakeScale;
        function matrix3x2TransformVector2(mat, inp, out) {
            out.x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2] + mat.rawData[4];
            out.y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3] + mat.rawData[5];
        }
        math.matrix3x2TransformVector2 = matrix3x2TransformVector2;
        function matrix3x2TransformNormal(mat, inp, out) {
            out.x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2];
            out.y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3];
        }
        math.matrix3x2TransformNormal = matrix3x2TransformNormal;
        function matrix3x2MakeScale(xScale, yScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = yScale;
            out.rawData[4] = 0.0;
            out.rawData[5] = 0.0;
        }
        math.matrix3x2MakeScale = matrix3x2MakeScale;
        function matrixMakeRotateAxisAngle(axis, angle, out) {
            var x = axis.x, y = axis.y, z = axis.z;
            var length = Math.sqrt(x * x + y * y + z * z);
            if (!length)
                return;
            if (length !== 1) {
                length = 1 / length;
                x *= length;
                y *= length;
                z *= length;
            }
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var t = 1.0 - c;
            var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
            out.rawData[0] = b00;
            out.rawData[1] = b01;
            out.rawData[2] = b02;
            out.rawData[3] = 0;
            out.rawData[4] = b10;
            out.rawData[5] = b11;
            out.rawData[6] = b12;
            out.rawData[7] = 0;
            out.rawData[8] = b20;
            out.rawData[9] = b21;
            out.rawData[10] = b22;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeRotateAxisAngle = matrixMakeRotateAxisAngle;
        function matrix3x2MakeRotate(angle, out) {
            var x = 0, y = 0, z = 1;
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            out.rawData[0] = c;
            out.rawData[1] = s;
            out.rawData[2] = -s;
            out.rawData[3] = c;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeRotate = matrix3x2MakeRotate;
        function matrixMultiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = lhs.rawData[2], a03 = lhs.rawData[3];
            var a10 = lhs.rawData[4], a11 = lhs.rawData[5], a12 = lhs.rawData[6], a13 = lhs.rawData[7];
            var a20 = lhs.rawData[8], a21 = lhs.rawData[9], a22 = lhs.rawData[10], a23 = lhs.rawData[11];
            var a30 = lhs.rawData[12], a31 = lhs.rawData[13], a32 = lhs.rawData[14], a33 = lhs.rawData[15];
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b2 = rhs.rawData[2], b3 = rhs.rawData[3];
            out.rawData[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b2 = rhs.rawData[6];
            b3 = rhs.rawData[7];
            out.rawData[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[8];
            b1 = rhs.rawData[9];
            b2 = rhs.rawData[10];
            b3 = rhs.rawData[11];
            out.rawData[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[12];
            b1 = rhs.rawData[13];
            b2 = rhs.rawData[14];
            b3 = rhs.rawData[15];
            out.rawData[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        }
        math.matrixMultiply = matrixMultiply;
        function matrix3x2Multiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = 0;
            var a10 = lhs.rawData[2], a11 = lhs.rawData[3], a12 = 0;
            var a30 = lhs.rawData[4], a31 = lhs.rawData[5], a32 = 1;
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b3 = 0;
            out.rawData[0] = b0 * a00 + b1 * a10 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[2];
            b1 = rhs.rawData[3];
            b3 = 0;
            out.rawData[2] = b0 * a00 + b1 * a10 + b3 * a30;
            out.rawData[3] = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b3 = 1;
            out.rawData[4] = b0 * a00 + b1 * a10 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b3 * a31;
        }
        math.matrix3x2Multiply = matrix3x2Multiply;
        function matrixProject_PerspectiveLH(fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = -zfar / (znear - zfar);
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = (znear * zfar) / (znear - zfar);
        }
        math.matrixProject_PerspectiveLH = matrixProject_PerspectiveLH;
        function matrixProject_OrthoLH(width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 1.0 / (zfar - znear);
            var nid = znear / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
        }
        math.matrixProject_OrthoLH = matrixProject_OrthoLH;
        function matrixLookatLH(forward, up, out) {
            var z = new math.vector3(-forward.x, -forward.y, -forward.z);
            math.vec3Normalize(z, z);
            var y = new math.vector3();
            math.vec3Clone(up, y);
            math.vec3Normalize(y, y);
            var x = new math.vector3();
            math.vec3Cross(y, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            var y = new math.vector3();
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixLookatLH = matrixLookatLH;
        function matrixViewLookatLH(eye, forward, up, out) {
            var z = new math.vector3(forward.x, forward.y, forward.z);
            math.vec3Normalize(z, z);
            var y = new math.vector3();
            math.vec3Clone(up, y);
            math.vec3Normalize(y, y);
            var x = new math.vector3();
            math.vec3Cross(y, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            var y = new math.vector3();
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            var ex = -math.vec3Dot(x, eye);
            var ey = -math.vec3Dot(y, eye);
            var ez = -math.vec3Dot(z, eye);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = ex;
            out.rawData[13] = ey;
            out.rawData[14] = ez;
            out.rawData[15] = 1;
        }
        math.matrixViewLookatLH = matrixViewLookatLH;
        function matrixLerp(left, right, v, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = left.rawData[i] * (1 - v) + right.rawData[i] * v;
            }
        }
        math.matrixLerp = matrixLerp;
        function matrixTransformVector3(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]) + transformation.rawData[12];
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]) + transformation.rawData[13];
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]) + transformation.rawData[14];
            var w = (vector.x * transformation.rawData[3]) + (vector.y * transformation.rawData[7]) + (vector.z * transformation.rawData[11]) + transformation.rawData[15];
            result.x = x / w;
            result.y = y / w;
            result.z = z / w;
        }
        math.matrixTransformVector3 = matrixTransformVector3;
        function matrixTransformNormal(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]);
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]);
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]);
            result.x = x;
            result.y = y;
            result.z = z;
        }
        math.matrixTransformNormal = matrixTransformNormal;
        function matrixGetVector3ByOffset(src, offset, result) {
            result.x = src.rawData[offset];
            result.y = src.rawData[offset + 1];
            result.z = src.rawData[offset + 2];
        }
        math.matrixGetVector3ByOffset = matrixGetVector3ByOffset;
        function matrixReset(mat) {
            mat.rawData[0] = 1;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 1;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 1;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixReset = matrixReset;
        function matrixZero(mat) {
            mat.rawData[0] = 0;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 0;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 0;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 0;
        }
        math.matrixZero = matrixZero;
        function matrixScaleByNum(value, mat) {
            mat.rawData[0] *= value;
            mat.rawData[1] *= value;
            mat.rawData[2] *= value;
            mat.rawData[3] *= value;
            mat.rawData[4] *= value;
            mat.rawData[5] *= value;
            mat.rawData[6] *= value;
            mat.rawData[7] *= value;
            mat.rawData[8] *= value;
            mat.rawData[9] *= value;
            mat.rawData[10] *= value;
            mat.rawData[11] *= value;
            mat.rawData[12] *= value;
            mat.rawData[13] *= value;
            mat.rawData[14] *= value;
            mat.rawData[15] *= value;
        }
        math.matrixScaleByNum = matrixScaleByNum;
        function matrixAdd(left, right, out) {
            out.rawData[0] = left.rawData[0] + right.rawData[0];
            out.rawData[1] = left.rawData[1] + right.rawData[1];
            out.rawData[2] = left.rawData[2] + right.rawData[2];
            out.rawData[3] = left.rawData[3] + right.rawData[3];
            out.rawData[4] = left.rawData[4] + right.rawData[4];
            out.rawData[5] = left.rawData[5] + right.rawData[5];
            out.rawData[6] = left.rawData[6] + right.rawData[6];
            out.rawData[7] = left.rawData[7] + right.rawData[7];
            out.rawData[8] = left.rawData[8] + right.rawData[8];
            out.rawData[9] = left.rawData[9] + right.rawData[9];
            out.rawData[10] = left.rawData[10] + right.rawData[10];
            out.rawData[11] = left.rawData[11] + right.rawData[11];
            out.rawData[12] = left.rawData[12] + right.rawData[12];
            out.rawData[13] = left.rawData[13] + right.rawData[13];
            out.rawData[14] = left.rawData[14] + right.rawData[14];
            out.rawData[15] = left.rawData[15] + right.rawData[15];
        }
        math.matrixAdd = matrixAdd;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function floatClamp(v, min, max) {
            if (min === void 0) { min = 0; }
            if (max === void 0) { max = 1; }
            if (v < min)
                return min;
            else if (v > max)
                return max;
            else
                return v;
        }
        math.floatClamp = floatClamp;
        function sign(value) {
            value = +value;
            if (value === 0 || isNaN(value))
                return value;
            return value > 0 ? 1 : -1;
        }
        math.sign = sign;
        function getKeyCodeByAscii(ev) {
            if (ev.shiftKey) {
                return ev.keyCode - 32;
            }
            else {
                return ev.keyCode;
            }
        }
        math.getKeyCodeByAscii = getKeyCodeByAscii;
        function numberLerp(fromV, toV, v) {
            return fromV * (1 - v) + toV * v;
        }
        math.numberLerp = numberLerp;
        function x_AXIS() {
            return commonStatic.x_axis;
        }
        math.x_AXIS = x_AXIS;
        function y_AXIS() {
            return commonStatic.y_axis;
        }
        math.y_AXIS = y_AXIS;
        function z_AXIS() {
            return commonStatic.z_axis;
        }
        math.z_AXIS = z_AXIS;
        var commonStatic = (function () {
            function commonStatic() {
            }
            return commonStatic;
        }());
        commonStatic.x_axis = new gd3d.math.vector3(1, 0, 0);
        commonStatic.y_axis = new gd3d.math.vector3(0, 1, 0);
        commonStatic.z_axis = new gd3d.math.vector3(0, 0, 1);
        math.commonStatic = commonStatic;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function quatNormalize(src, out) {
            var mag = 1 / Math.sqrt(src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w);
            out.x *= mag;
            out.y *= mag;
            out.z *= mag;
            out.w *= mag;
        }
        math.quatNormalize = quatNormalize;
        function quatTransformVector(src, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            w1 = -src.x * x2 - src.y * y2 - src.z * z2;
            x1 = src.w * x2 + src.y * z2 - src.z * y2;
            y1 = src.w * y2 - src.x * z2 + src.z * x2;
            z1 = src.w * z2 + src.x * y2 - src.y * x2;
            out.x = -w1 * src.x + x1 * src.w - y1 * src.z + z1 * src.y;
            out.y = -w1 * src.y + x1 * src.z + y1 * src.w - z1 * src.x;
            out.z = -w1 * src.z - x1 * src.y + y1 * src.x + z1 * src.w;
        }
        math.quatTransformVector = quatTransformVector;
        function quatTransformVectorDataAndQuat(src, srcseek, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            var srcx = src[srcseek];
            var srcy = src[srcseek + 1];
            var srcz = src[srcseek + 2];
            var srcw = src[srcseek + 3];
            w1 = -srcx * x2 - srcy * y2 - srcz * z2;
            x1 = srcw * x2 + srcy * z2 - srcz * y2;
            y1 = srcw * y2 - srcx * z2 + srcz * x2;
            z1 = srcw * z2 + srcx * y2 - srcy * x2;
            out.x = -w1 * srcx + x1 * srcw - y1 * srcz + z1 * srcy;
            out.y = -w1 * srcy + x1 * srcz + y1 * srcw - z1 * srcx;
            out.z = -w1 * srcz - x1 * srcy + y1 * srcx + z1 * srcw;
        }
        math.quatTransformVectorDataAndQuat = quatTransformVectorDataAndQuat;
        function quatMagnitude(src) {
            return Math.sqrt(src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z);
        }
        math.quatMagnitude = quatMagnitude;
        function quatClone(src, out) {
            out.x = src.x;
            out.y = src.y;
            out.z = src.z;
            out.w = src.w;
        }
        math.quatClone = quatClone;
        function quatToMatrix(src, out) {
            var xy2 = 2.0 * src.x * src.y, xz2 = 2.0 * src.x * src.z, xw2 = 2.0 * src.x * src.w;
            var yz2 = 2.0 * src.y * src.z, yw2 = 2.0 * src.y * src.w, zw2 = 2.0 * src.z * src.w;
            var xx = src.x * src.x, yy = src.y * src.y, zz = src.z * src.z, ww = src.w * src.w;
            out.rawData[0] = xx - yy - zz + ww;
            out.rawData[4] = xy2 - zw2;
            out.rawData[8] = xz2 + yw2;
            out.rawData[12] = 0;
            out.rawData[1] = xy2 + zw2;
            out.rawData[5] = -xx + yy - zz + ww;
            out.rawData[9] = yz2 - xw2;
            out.rawData[13] = 0;
            out.rawData[2] = xz2 - yw2;
            out.rawData[6] = yz2 + xw2;
            out.rawData[10] = -xx - yy + zz + ww;
            out.rawData[14] = 0;
            out.rawData[3] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[11] = 0;
            out.rawData[15] = 1;
        }
        math.quatToMatrix = quatToMatrix;
        function quatInverse(src, out) {
            var norm = src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z;
            if (norm > 0.0) {
                var invNorm = 1.0 / norm;
                out.w = src.w * invNorm;
                out.x = -src.x * invNorm;
                out.y = -src.y * invNorm;
                out.z = -src.z * invNorm;
            }
        }
        math.quatInverse = quatInverse;
        function quatFromYawPitchRoll(yaw, pitch, roll, result) {
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            result.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            result.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            result.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            result.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }
        math.quatFromYawPitchRoll = quatFromYawPitchRoll;
        function quatMultiply(srca, srcb, out) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
        }
        math.quatMultiply = quatMultiply;
        function quatMultiplyDataAndQuat(srca, srcaseek, srcb, out) {
            var w1 = srca[srcaseek + 3], x1 = srca[srcaseek + 0], y1 = srca[srcaseek + 1], z1 = srca[srcaseek + 2];
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
        }
        math.quatMultiplyDataAndQuat = quatMultiplyDataAndQuat;
        function quatMultiplyVector(vector, scr, out) {
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            out.w = -scr.x * x2 - scr.y * y2 - scr.z * z2;
            out.x = scr.w * x2 + scr.y * z2 - scr.z * y2;
            out.y = scr.w * y2 - scr.x * z2 + scr.z * x2;
            out.z = scr.w * z2 + scr.x * y2 - scr.y * x2;
        }
        math.quatMultiplyVector = quatMultiplyVector;
        function quatLerp(srca, srcb, out, t) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            out.w = w1 + t * (w2 - w1);
            out.x = x1 + t * (x2 - x1);
            out.y = y1 + t * (y2 - y1);
            out.z = z1 + t * (z2 - z1);
            var len = 1.0 / Math.sqrt(out.w * out.w + out.x * out.x + out.y * out.y + out.z * out.z);
            out.w *= len;
            out.x *= len;
            out.y *= len;
            out.z *= len;
        }
        math.quatLerp = quatLerp;
        function quatFromAxisAngle(axis, angle, out) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            out.w = Math.cos(halfAngle);
            out.x = axis.x * sin_a;
            out.y = axis.y * sin_a;
            out.z = axis.z * sin_a;
            math.quatNormalize(out, out);
        }
        math.quatFromAxisAngle = quatFromAxisAngle;
        function quatToAxisAngle(src, axis) {
            var sqrLength = src.x * src.x + src.y * src.y + src.z * src.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(src.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = src.x * sqrLength;
                axis.y = src.y * sqrLength;
                axis.z = src.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        }
        math.quatToAxisAngle = quatToAxisAngle;
        function quatFromEulerAngles(ax, ay, az, out) {
            ax *= Math.PI / 180;
            ay *= Math.PI / 180;
            az *= Math.PI / 180;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            out.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            out.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
            out.y = cosX * sinY * cosZ - sinX * cosY * sinZ;
            out.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            math.quatNormalize(out, out);
        }
        math.quatFromEulerAngles = quatFromEulerAngles;
        function quatToEulerAngles(src, out) {
            var temp = 2.0 * (src.w * src.x - src.y * src.z);
            temp = math.floatClamp(temp, -1.0, 1.0);
            out.x = Math.asin(temp);
            out.y = Math.atan2(2.0 * (src.w * src.y + src.z * src.x), 1.0 - 2.0 * (src.y * src.y + src.x * src.x));
            out.z = Math.atan2(2.0 * (src.w * src.z + src.y * src.x), 1.0 - 2.0 * (src.x * src.x + src.z * src.z));
            out.x /= Math.PI / 180;
            out.y /= Math.PI / 180;
            out.z /= Math.PI / 180;
        }
        math.quatToEulerAngles = quatToEulerAngles;
        function quatReset(src) {
            src.x = 0;
            src.y = 0;
            src.z = 0;
            src.w = 1;
        }
        math.quatReset = quatReset;
        function quatLookat(pos, targetpos, out) {
            var dir = new math.vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dirxz = new math.vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            var dirxz1 = new math.vector3(dir.x, 0, dir.z);
            var v3length = math.vec3Length(dirxz1);
            if (v3length > 0.999)
                v3length = 1;
            if (v3length < -0.999)
                v3length = -1;
            var pitch = Math.acos(v3length);
            if (dir.y > 0) {
                pitch = -pitch;
            }
            quatFromYawPitchRoll(yaw, pitch, 0, out);
            math.quatNormalize(out, out);
        }
        math.quatLookat = quatLookat;
        function quat2Lookat(pos, targetpos, out) {
            var dir = gd3d.math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dot = gd3d.math.vec3Dot(gd3d.math.pool.vector3_forward, dir);
            if (Math.abs(dot - (-1.0)) < 0.000001) {
                gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_up, 180, out);
                return;
            }
            if (Math.abs(dot - 1.0) < 0.000001) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
            }
            dot = gd3d.math.floatClamp(dot, -1, 1);
            var rotangle = Math.acos(dot);
            var rotAxis = gd3d.math.pool.new_vector3();
            gd3d.math.vec3Cross(gd3d.math.pool.vector3_forward, dir, rotAxis);
            gd3d.math.quatFromAxisAngle(rotAxis, rotangle, out);
        }
        math.quat2Lookat = quat2Lookat;
        function quatYAxis(pos, targetpos, out) {
            var dir = new math.vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dirxz = new math.vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            quatFromYawPitchRoll(yaw, 0, 0, out);
            math.quatNormalize(out, out);
        }
        math.quatYAxis = quatYAxis;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function rectSet_One(out) {
            out.x = 0;
            out.y = 0;
            out.w = 1;
            out.h = 1;
        }
        math.rectSet_One = rectSet_One;
        function rectSet_Zero(out) {
            out.x = 0;
            out.y = 0;
            out.w = 0;
            out.h = 0;
        }
        math.rectSet_Zero = rectSet_Zero;
        function rectEqul(src1, src2) {
            return !((src1.x != src2.x) ||
                (src1.y != src2.y) ||
                (src1.w != src2.w) ||
                (src1.h != src2.h));
        }
        math.rectEqul = rectEqul;
        function rectInner(x, y, src) {
            if (x < src.x || x > src.x + src.w ||
                y < src.y || y > src.y + src.h) {
                return false;
            }
            return true;
        }
        math.rectInner = rectInner;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function caclStringByteLength(value) {
            var total = 0;
            for (var i = 0; i < value.length; i++) {
                var charCode = value.charCodeAt(i);
                if (charCode <= 0x007f) {
                    total += 1;
                }
                else if (charCode <= 0x07ff) {
                    total += 2;
                }
                else if (charCode <= 0xffff) {
                    total += 3;
                }
                else {
                    total += 4;
                }
            }
            return total;
        }
        math.caclStringByteLength = caclStringByteLength;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function spriteAnimation(row, column, index, out) {
            var width = 1 / column;
            var height = 1 / row;
            var offsetx = width * (index % column);
            var offsety = height * Math.floor(index / column);
            out.x = width;
            out.y = height;
            out.z = offsetx;
            out.w = offsety;
        }
        math.spriteAnimation = spriteAnimation;
        function GetPointAlongCurve(curveStart, curveStartHandle, curveEnd, curveEndHandle, t, out, crease) {
            if (crease === void 0) { crease = 0.3; }
            var oneMinT = 1 - t;
            var oneMinTPow3 = Math.pow(oneMinT, 3);
            var oneMinTPow2 = Math.pow(oneMinT, 2);
            var oneMinCrease = 1 - crease;
            var tempt1 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveStart, oneMinTPow3 * oneMinCrease, tempt1);
            var tempt2 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveStartHandle, 3 * oneMinTPow2 * t * crease, tempt2);
            var tempt3 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveEndHandle, 3 * oneMinT * Math.pow(t, 2) * crease, tempt3);
            var tempt4 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveEnd, Math.pow(t, 3) * oneMinCrease, tempt4);
            var tempt5 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3Add(tempt1, tempt2, tempt5);
            gd3d.math.vec3Add(tempt5, tempt3, tempt5);
            gd3d.math.vec3Add(tempt5, tempt4, tempt5);
            gd3d.math.vec3ScaleByNum(tempt5, 1 / (oneMinTPow3 * oneMinCrease + 3 * oneMinTPow2 * t * crease + 3 * oneMinT * Math.pow(t, 2) * crease + Math.pow(t, 3) * oneMinCrease), out);
            gd3d.math.pool.delete_vector3(tempt1);
            gd3d.math.pool.delete_vector3(tempt2);
            gd3d.math.pool.delete_vector3(tempt3);
            gd3d.math.pool.delete_vector3(tempt4);
            gd3d.math.pool.delete_vector3(tempt5);
        }
        math.GetPointAlongCurve = GetPointAlongCurve;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function vec2Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
        }
        math.vec2Subtract = vec2Subtract;
        function vec2Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
        }
        math.vec2Add = vec2Add;
        function vec2Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
        }
        math.vec2Clone = vec2Clone;
        function vec2Distance(a, b) {
            var out = math.pool.new_vector2();
            vec2Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y);
            math.pool.delete_vector2(out);
            return result;
        }
        math.vec2Distance = vec2Distance;
        function vec2ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
        }
        math.vec2ScaleByNum = vec2ScaleByNum;
        function vec4Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
            to.z = from.z;
            to.w = from.w;
        }
        math.vec4Clone = vec4Clone;
        function vec2Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y);
        }
        math.vec2Length = vec2Length;
        function vec2SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
        }
        math.vec2SLerp = vec2SLerp;
        function vec2Normalize(from, out) {
            var num = vec2Length(from);
            if (num > Number.MIN_VALUE) {
                out.x = from.x / num;
                out.y = from.y / num;
            }
            else {
                out.x = 0;
                out.y = 0;
            }
        }
        math.vec2Normalize = vec2Normalize;
        function vec2Multiply(a, b) {
            return a.x * b.x + a.y * b.y;
        }
        math.vec2Multiply = vec2Multiply;
        function vec2Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            return true;
        }
        math.vec2Equal = vec2Equal;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function vec3Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
            to.z = from.z;
        }
        math.vec3Clone = vec3Clone;
        function vec3ToString(result) {
            result = this.x + "," + this.y + "," + this.z;
        }
        math.vec3ToString = vec3ToString;
        function vec3Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
        }
        math.vec3Add = vec3Add;
        function vec3Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            out.z = a.z - b.z;
        }
        math.vec3Subtract = vec3Subtract;
        function vec3Minus(a, out) {
            out.x = -a.x;
            out.y = -a.y;
            out.z = -a.z;
        }
        math.vec3Minus = vec3Minus;
        function vec3Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
        }
        math.vec3Length = vec3Length;
        function vec3SqrLength(value) {
            return value.x * value.x + value.y * value.y + value.z * value.z;
        }
        math.vec3SqrLength = vec3SqrLength;
        function vec3Set_One(value) {
            value.x = value.y = value.z = 1;
        }
        math.vec3Set_One = vec3Set_One;
        function vec3Set_Forward(value) {
            value.x = value.y = 0;
            value.z = 1;
        }
        math.vec3Set_Forward = vec3Set_Forward;
        function vec3Set_Back(value) {
            value.x = value.y = 0;
            value.z = -1;
        }
        math.vec3Set_Back = vec3Set_Back;
        function vec3Set_Up(value) {
            value.x = value.z = 0;
            value.y = 1;
        }
        math.vec3Set_Up = vec3Set_Up;
        function vec3Set_Down(value) {
            value.x = value.z = 0;
            value.y = -1;
        }
        math.vec3Set_Down = vec3Set_Down;
        function vec3Set_Left(value) {
            value.x = -1;
            value.y = value.z = 0;
        }
        math.vec3Set_Left = vec3Set_Left;
        function vec3Set_Right(value) {
            value.x = 1;
            value.y = value.z = 0;
        }
        math.vec3Set_Right = vec3Set_Right;
        function vec3Normalize(value, out) {
            var num = vec3Length(value);
            if (num > Number.MIN_VALUE) {
                out.x = value.x / num;
                out.y = value.y / num;
                out.z = value.z / num;
            }
            else {
                out.x = 0;
                out.y = 0;
                out.z = 0;
            }
        }
        math.vec3Normalize = vec3Normalize;
        function vec3ScaleByVec3(from, scale, out) {
            out.x = from.x * scale.x;
            out.y = from.y * scale.y;
            out.z = from.z * scale.z;
        }
        math.vec3ScaleByVec3 = vec3ScaleByVec3;
        function vec3ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
            out.z = from.z * scale;
        }
        math.vec3ScaleByNum = vec3ScaleByNum;
        function vec3Product(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
        }
        math.vec3Product = vec3Product;
        function vec3Cross(lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
        }
        math.vec3Cross = vec3Cross;
        function vec3Reflect(inDirection, inNormal, out) {
            var v1 = 0;
            v1 = vec3Dot(inNormal, inDirection);
            vec3ScaleByNum(out, v1 * -2, out);
            vec3Add(out, inDirection, out);
        }
        math.vec3Reflect = vec3Reflect;
        function vec3Dot(lhs, rhs) {
            return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
        }
        math.vec3Dot = vec3Dot;
        function vec3Project(vector, onNormal, out) {
            var num = 0;
            num = vec3Dot(onNormal, onNormal);
            if (num < Number.MIN_VALUE) {
                out.x = out.y = out.z = 0;
            }
            else {
                var num2 = 0;
                num2 = vec3Dot(vector, onNormal);
                vec3ScaleByNum(onNormal, num2 / num, out);
            }
        }
        math.vec3Project = vec3Project;
        function vec3ProjectOnPlane(vector, planeNormal, out) {
            vec3Project(vector, planeNormal, out);
            vec3Subtract(vector, out, out);
        }
        math.vec3ProjectOnPlane = vec3ProjectOnPlane;
        function vec3Exclude(excludeThis, fromThat, out) {
            vec3Project(fromThat, excludeThis, out);
            vec3Subtract(fromThat, out, out);
        }
        math.vec3Exclude = vec3Exclude;
        function vec3Angle(from, to) {
            var out1 = math.pool.new_vector3();
            var out2 = math.pool.new_vector3();
            vec3Normalize(from, out1);
            vec3Normalize(to, out2);
            var result = vec3Dot(out1, out2);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result) * 57.29578;
            math.pool.delete_vector3(out1);
            math.pool.delete_vector3(out1);
            return result;
        }
        math.vec3Angle = vec3Angle;
        function vec3Distance(a, b) {
            var out = math.pool.new_vector3();
            vec3Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y + out.z * out.z);
            math.pool.delete_vector3(out);
            return result;
        }
        math.vec3Distance = vec3Distance;
        function vec3ClampLength(vector, maxLength, out) {
            var val = 0;
            val = vec3SqrLength(vector);
            if (val > maxLength * maxLength) {
                vec3Normalize(vector, out);
                vec3ScaleByNum(out, maxLength, out);
            }
            out = vector;
        }
        math.vec3ClampLength = vec3ClampLength;
        function vec3Min(lhs, rhs, out) {
            out.x = Math.min(lhs.x, rhs.x);
            out.y = Math.min(lhs.y, rhs.y);
            out.z = Math.min(lhs.z, rhs.z);
        }
        math.vec3Min = vec3Min;
        function vec3Max(lhs, rhs, out) {
            out.x = Math.max(lhs.x, rhs.x);
            out.y = Math.max(lhs.y, rhs.y);
            out.z = Math.max(lhs.z, rhs.z);
        }
        math.vec3Max = vec3Max;
        function vec3AngleBetween(from, to) {
            vec3Normalize(from, from);
            vec3Normalize(to, to);
            var result = vec3Dot(from, to);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result);
            return result;
        }
        math.vec3AngleBetween = vec3AngleBetween;
        function vec3Reset(val) {
            val.x = 0;
            val.y = 0;
            val.z = 0;
        }
        math.vec3Reset = vec3Reset;
        function vec3SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
            out.z = vector.z * (1 - v) + vector2.z * v;
        }
        math.vec3SLerp = vec3SLerp;
        function vec3SetByFloat(x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
        }
        math.vec3SetByFloat = vec3SetByFloat;
        function vec3Format(vector, maxDot, out) {
            out.x = floatFormat(vector.x, maxDot);
            out.y = floatFormat(vector.y, maxDot);
            out.z = floatFormat(vector.z, maxDot);
        }
        math.vec3Format = vec3Format;
        function quaternionFormat(vector, maxDot, out) {
            out.x = floatFormat(vector.x, maxDot);
            out.y = floatFormat(vector.y, maxDot);
            out.z = floatFormat(vector.z, maxDot);
            out.w = floatFormat(vector.w, maxDot);
        }
        math.quaternionFormat = quaternionFormat;
        function floatFormat(num, maxDot) {
            var vv = Math.pow(10, maxDot);
            return Math.round(num * vv) / vv;
        }
        math.floatFormat = floatFormat;
        function vec3Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            if (Math.abs(vector.z - vector2.z) > threshold)
                return false;
            return true;
        }
        math.vec3Equal = vec3Equal;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectSystemData = (function () {
            function EffectSystemData() {
                this.elements = [];
            }
            EffectSystemData.prototype.clone = function () {
                var data = new EffectSystemData();
                data.life = this.life;
                for (var key in this.elements) {
                    data.elements[key] = this.elements[key].clone();
                }
                return data;
            };
            EffectSystemData.prototype.dispose = function () {
                for (var key in this.elements) {
                    this.elements[key].dispose();
                }
                this.elements.length = 0;
            };
            return EffectSystemData;
        }());
        framework.EffectSystemData = EffectSystemData;
        var EffectElement = (function () {
            function EffectElement(_data) {
                this.startIndex = 0;
                this.actionActive = false;
                this.loopFrame = Number.MAX_VALUE;
                this.active = true;
                this.data = _data;
                this.name = this.data.name;
                this.timelineFrame = {};
                this.initActions();
                this.recordElementLerpAttributes();
            }
            EffectElement.prototype.recordElementLerpAttributes = function () {
                if (this.data.timelineFrame != undefined) {
                    for (var i in this.data.timelineFrame) {
                        var frameData = this.data.timelineFrame[i];
                        if (frameData.frameIndex != -1 && frameData.lerpDatas != undefined) {
                            this.recordLerpValues(frameData);
                        }
                    }
                }
            };
            EffectElement.prototype.recordLerpValues = function (effectFrameData) {
                for (var i in effectFrameData.lerpDatas) {
                    if (effectFrameData.lerpDatas[i].type == EffectLerpTypeEnum.Linear) {
                        for (var key in effectFrameData.lerpDatas[i].attrsList) {
                            var attrname = effectFrameData.lerpDatas[i].attrsList[key];
                            this.recordLerp(effectFrameData, effectFrameData.lerpDatas[i], attrname);
                        }
                    }
                }
            };
            EffectElement.prototype.recordLerp = function (effectFrameData, lerpData, key) {
                var fromFrame = lerpData.fromFrame;
                var toFrame = lerpData.toFrame.getValue();
                var toVal = lerpData.attrsData.getAttribute(key);
                if (effectFrameData.attrsData[key] == undefined) {
                    effectFrameData.attrsData.initAttribute(key);
                }
                var fromVal = effectFrameData.attrsData.getAttribute(key);
                for (var i = fromFrame + 1; i <= toFrame; i++) {
                    var outVal = void 0;
                    if (fromVal instanceof gd3d.math.vector3) {
                        outVal = new gd3d.math.vector3();
                        gd3d.math.vec3SLerp(fromVal, toVal, i / (toFrame - fromFrame), outVal);
                    }
                    else if (fromVal instanceof gd3d.math.vector2) {
                        outVal = new gd3d.math.vector2();
                        gd3d.math.vec2SLerp(fromVal, toVal, i / (toFrame - fromFrame), outVal);
                    }
                    else if (typeof (fromVal) === 'number') {
                        outVal = gd3d.math.numberLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame));
                    }
                    var newFrameData = this.timelineFrame[i];
                    if (newFrameData == undefined) {
                        newFrameData = new EffectFrameData();
                        newFrameData.attrsData = new EffectAttrsData();
                        newFrameData.frameIndex = i;
                        this.timelineFrame[i] = newFrameData;
                    }
                    newFrameData.attrsData.setLerpAttribute(key, outVal);
                }
            };
            EffectElement.prototype.initActions = function () {
                this.actions = [];
                var action;
                for (var key in this.data.actionData) {
                    var actiondata = this.data.actionData[key];
                    switch (actiondata.actionType) {
                        case "linear":
                            action = new framework.LinearAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "loop":
                            action = new framework.LoopAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "rotation":
                            action = new framework.RotationAction();
                            break;
                        case "breath":
                            action = new framework.BreathAction();
                            break;
                        case "uvroll":
                            action = new framework.UVRollAction();
                            break;
                        case "uvsprite":
                            action = new framework.UVSpriteAnimationAction();
                            break;
                        case "rosepath":
                            action = new framework.RoseCurveAction();
                            break;
                        case "trail":
                            action = new framework.TrailAction();
                            break;
                    }
                    action.init(actiondata.startFrame, actiondata.endFrame, actiondata.params, this);
                    this.actions.push(action);
                }
            };
            EffectElement.prototype.update = function () {
                if (this.curAttrData == undefined || this.curAttrData == null)
                    return;
                if (this.active) {
                    if (this.curAttrData.euler != undefined) {
                        gd3d.math.quatFromEulerAngles(this.curAttrData.euler.x, this.curAttrData.euler.y, this.curAttrData.euler.z, this.curAttrData.rotationByEuler);
                    }
                    this.updateElementRotation();
                    gd3d.math.matrixMakeTransformRTS(this.curAttrData.pos, this.curAttrData.scale, this.curAttrData.localRotation, this.curAttrData.matrix);
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElement.prototype.updateElementRotation = function () {
                var cameraTransform = gd3d.framework.sceneMgr.app.getScene().mainCamera.gameObject.transform;
                var worldRotation = gd3d.math.pool.new_quaternion();
                var localRotation = gd3d.math.pool.new_quaternion();
                if (this.curAttrData.renderModel != framework.RenderModel.None) {
                    var invTransformRotation = gd3d.math.pool.new_quaternion();
                    var worldTranslation = gd3d.math.pool.new_vector3();
                    var translation = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Clone(this.curAttrData.pos, translation);
                    if (this.transform != undefined) {
                        gd3d.math.matrixTransformVector3(translation, this.transform.getWorldMatrix(), worldTranslation);
                    }
                    if (this.curAttrData.renderModel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(cameraTransform.getWorldTranslate(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                        var lookRot = new gd3d.math.quaternion();
                        gd3d.math.quatClone(this.transform.getWorldRotate(), invTransformRotation);
                        gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                        gd3d.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        var inverRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatInverse(this.curAttrData.localRotation, inverRot);
                        gd3d.math.quatMultiply(inverRot, lookRot, lookRot);
                        var angle = gd3d.math.pool.new_vector3();
                        gd3d.math.quatToEulerAngles(lookRot, angle);
                        gd3d.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        gd3d.math.quatMultiply(this.curAttrData.localRotation, lookRot, this.curAttrData.localRotation);
                        gd3d.math.pool.delete_quaternion(inverRot);
                        gd3d.math.pool.delete_vector3(angle);
                        gd3d.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, worldRotation);
                    gd3d.math.quatClone(this.transform.gameObject.transform.getWorldRotate(), invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.curAttrData.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                }
                gd3d.math.pool.delete_quaternion(localRotation);
                gd3d.math.pool.delete_quaternion(worldRotation);
            };
            EffectElement.prototype.isActiveFrame = function (frameIndex) {
                if (this.timelineFrame[frameIndex] != undefined) {
                    return true;
                }
                if (this.curAttrData != undefined && this.curAttrData.renderModel != framework.RenderModel.None) {
                    return true;
                }
                return this.actionActive;
            };
            EffectElement.prototype.setActive = function (_active) {
                if (this.active == _active)
                    return;
                this.active = _active;
                if (this.active) {
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElement.prototype.dispose = function () {
                this.data.dispose();
                this.curAttrData = null;
                this.actions.length = 0;
                delete this.timelineFrame;
            };
            return EffectElement;
        }());
        framework.EffectElement = EffectElement;
        var EffectElementData = (function () {
            function EffectElementData() {
            }
            EffectElementData.prototype.clone = function () {
                var elementdata = new EffectElementData();
                elementdata.name = this.name;
                elementdata.type = this.type;
                elementdata.ref = this.ref;
                if (this.initFrameData)
                    elementdata.initFrameData = this.initFrameData.clone();
                if (this.emissionData) {
                    elementdata.emissionData = this.emissionData.clone();
                }
                for (var key in this.timelineFrame) {
                    if (this.initFrameData[key]) {
                        elementdata.timelineFrame[key] = this.initFrameData[key].clone();
                    }
                }
                for (var key in this.actionData) {
                    if (this.actionData[key]) {
                        elementdata.actionData[key] = this.actionData[key].clone();
                    }
                }
                return elementdata;
            };
            EffectElementData.prototype.dispose = function () {
                if (this.actionData)
                    this.actionData.length = 0;
                if (this.initFrameData)
                    this.initFrameData.dispose();
                for (var key in this.timelineFrame) {
                    this.timelineFrame[key].dispose();
                }
                delete this.timelineFrame;
            };
            return EffectElementData;
        }());
        framework.EffectElementData = EffectElementData;
        var EffectAttrsData = (function () {
            function EffectAttrsData() {
                this.renderModel = framework.RenderModel.None;
                this.matrix = new gd3d.math.matrix();
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localRotation = new gd3d.math.quaternion();
            }
            EffectAttrsData.prototype.setLerpAttribute = function (attribute, val) {
                switch (attribute) {
                    case "pos":
                        this.pos = val;
                        break;
                    case "scale":
                        this.scale = val;
                        break;
                    case "euler":
                        this.euler = val;
                        break;
                    case "alpha":
                        this.alpha = val;
                        break;
                    case "uv":
                        this.uv = val;
                        break;
                    case "color":
                        this.color = val;
                        break;
                    case "tilling":
                        console.log("tilling ");
                        break;
                }
            };
            EffectAttrsData.prototype.getAttribute = function (attribute) {
                switch (attribute) {
                    case "pos":
                        return gd3d.math.pool.clone_vector3(this.pos);
                    case "scale":
                        return gd3d.math.pool.clone_vector3(this.scale);
                    case "euler":
                        return gd3d.math.pool.clone_vector3(this.euler);
                    case "alpha":
                        return this.alpha;
                    case "color":
                        return gd3d.math.pool.clone_vector3(this.color);
                    case "tilling":
                        return gd3d.math.pool.clone_vector2(this.tilling);
                    case "mat":
                        return this.mat.clone();
                    case "renderModel":
                        return this.renderModel;
                    case "rotationByEuler":
                        return gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                    case "localRotation":
                        return gd3d.math.pool.clone_quaternion(this.localRotation);
                    case "matrix":
                        return gd3d.math.pool.clone_matrix(this.matrix);
                }
            };
            EffectAttrsData.prototype.initAttribute = function (attribute) {
                switch (attribute) {
                    case "pos":
                        this.pos = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "scale":
                        this.scale = new gd3d.math.vector3(1, 1, 1);
                        break;
                    case "euler":
                        this.euler = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "alpha":
                        this.alpha = 0;
                        break;
                    case "color":
                        this.color = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "uv":
                        this.uv = new gd3d.math.vector2(0, 0);
                        break;
                    case "tilling":
                        this.tilling = new gd3d.math.vector2(1, 1);
                        break;
                    default:
                        console.log("" + attribute);
                        break;
                }
            };
            EffectAttrsData.prototype.resetMatrix = function () {
                gd3d.math.matrixZero(this.matrix);
            };
            EffectAttrsData.prototype.clone = function () {
                var data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = gd3d.math.pool.clone_vector3(this.pos);
                else
                    data.initAttribute("pos");
                if (this.euler != undefined)
                    data.euler = gd3d.math.pool.clone_vector3(this.euler);
                else
                    data.initAttribute("euler");
                if (this.color != undefined)
                    data.color = gd3d.math.pool.clone_vector3(this.color);
                else
                    data.initAttribute("color");
                if (this.scale != undefined)
                    data.scale = gd3d.math.pool.clone_vector3(this.scale);
                else
                    data.initAttribute("scale");
                if (this.tilling != undefined)
                    data.tilling = gd3d.math.pool.clone_vector2(this.tilling);
                else
                    data.initAttribute("tilling");
                if (this.uv != undefined)
                    data.uv = gd3d.math.pool.clone_vector2(this.uv);
                else
                    data.initAttribute("uv");
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = gd3d.math.pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo;
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            };
            return EffectAttrsData;
        }());
        framework.EffectAttrsData = EffectAttrsData;
        var EffectFrameData = (function () {
            function EffectFrameData() {
            }
            EffectFrameData.prototype.clone = function () {
                var framedata = new EffectFrameData();
                framedata.frameIndex = this.frameIndex;
                framedata.attrsData = this.attrsData.clone();
                for (var key in this.lerpDatas) {
                    framedata.lerpDatas[key] = this.lerpDatas[key].clone();
                }
                return framedata;
            };
            EffectFrameData.prototype.dispose = function () {
                this.attrsData = null;
                if (this.lerpDatas)
                    this.lerpDatas.length = 0;
            };
            return EffectFrameData;
        }());
        framework.EffectFrameData = EffectFrameData;
        var EffectLerpData = (function () {
            function EffectLerpData() {
                this.attrsList = [];
            }
            EffectLerpData.prototype.clone = function () {
                var lerpdata = new EffectLerpData();
                lerpdata.type = this.type;
                lerpdata.fromFrame = this.fromFrame;
                lerpdata.toFrame = this.toFrame;
                lerpdata.attrsData = this.attrsData.clone();
                for (var key in this.attrsList) {
                    lerpdata.attrsList[key] = this.attrsList[key];
                }
                return lerpdata;
            };
            return EffectLerpData;
        }());
        framework.EffectLerpData = EffectLerpData;
        var EffectActionData = (function () {
            function EffectActionData() {
            }
            EffectActionData.prototype.clone = function () {
                var actiondata = new EffectActionData();
                actiondata.actionType = this.actionType;
                actiondata.startFrame = this.startFrame;
                actiondata.endFrame = this.endFrame;
                for (var key in this.params) {
                    actiondata.params[key] = this.params[key];
                }
                return actiondata;
            };
            return EffectActionData;
        }());
        framework.EffectActionData = EffectActionData;
        var EffectMatData = (function () {
            function EffectMatData() {
            }
            EffectMatData.beEqual = function (data0, data1) {
                return data0.alphaCut == data1.alphaCut && data0.diffuseTexture == data1.diffuseTexture && data0.shader == data1.shader;
            };
            EffectMatData.prototype.clone = function () {
                var data = new EffectMatData();
                data.shader = this.shader;
                data.diffuseTexture = this.diffuseTexture;
                data.alphaCut = this.alphaCut;
                return data;
            };
            return EffectMatData;
        }());
        framework.EffectMatData = EffectMatData;
        var EffectBatcher = (function () {
            function EffectBatcher(formate) {
                this.beBufferInited = false;
                this.effectElements = [];
                this._totalVertexCount = 0;
                this._indexStartIndex = 0;
                this._vbosize = 0;
                this.vertexSize = 0;
                this.vertexSize = gd3d.render.meshData.calcByteSize(formate) / 4;
            }
            Object.defineProperty(EffectBatcher.prototype, "curTotalVertexCount", {
                get: function () {
                    return this._totalVertexCount;
                },
                set: function (val) {
                    this._totalVertexCount = val;
                    this.resizeVboSize(this._totalVertexCount * this.vertexSize);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EffectBatcher.prototype, "indexStartIndex", {
                get: function () {
                    return this._indexStartIndex;
                },
                set: function (value) {
                    this._indexStartIndex = value;
                    if (this.dataForEbo != null) {
                        var ebo = new Uint16Array(this._indexStartIndex);
                        ebo.set(this.dataForEbo, 0);
                        this.dataForEbo = ebo;
                    }
                    else {
                        this.dataForEbo = new Uint16Array(this._indexStartIndex);
                    }
                },
                enumerable: true,
                configurable: true
            });
            EffectBatcher.prototype.resizeVboSize = function (value) {
                if (this._vbosize > value)
                    return;
                this._vbosize = value;
                if (this.dataForVbo != null) {
                    var vbo = new Float32Array(this._vbosize);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                else {
                    this.dataForVbo = new Float32Array(this._vbosize);
                }
            };
            EffectBatcher.prototype.dispose = function () {
                this.mesh.dispose();
                this.mat.dispose();
                this.dataForVbo = null;
                this.dataForEbo = null;
                for (var key in this.effectElements) {
                    this.effectElements[key].dispose();
                }
            };
            return EffectBatcher;
        }());
        framework.EffectBatcher = EffectBatcher;
        var EffectPlayStateEnum;
        (function (EffectPlayStateEnum) {
            EffectPlayStateEnum[EffectPlayStateEnum["None"] = 0] = "None";
            EffectPlayStateEnum[EffectPlayStateEnum["BeReady"] = 1] = "BeReady";
            EffectPlayStateEnum[EffectPlayStateEnum["Play"] = 2] = "Play";
            EffectPlayStateEnum[EffectPlayStateEnum["Pause"] = 3] = "Pause";
            EffectPlayStateEnum[EffectPlayStateEnum["Stop"] = 4] = "Stop";
            EffectPlayStateEnum[EffectPlayStateEnum["Dispose"] = 5] = "Dispose";
        })(EffectPlayStateEnum = framework.EffectPlayStateEnum || (framework.EffectPlayStateEnum = {}));
        var EffectElementTypeEnum;
        (function (EffectElementTypeEnum) {
            EffectElementTypeEnum[EffectElementTypeEnum["SingleMeshType"] = 0] = "SingleMeshType";
            EffectElementTypeEnum[EffectElementTypeEnum["EmissionType"] = 1] = "EmissionType";
            EffectElementTypeEnum[EffectElementTypeEnum["MultiMeshType"] = 2] = "MultiMeshType";
        })(EffectElementTypeEnum = framework.EffectElementTypeEnum || (framework.EffectElementTypeEnum = {}));
        var EffectLerpTypeEnum;
        (function (EffectLerpTypeEnum) {
            EffectLerpTypeEnum[EffectLerpTypeEnum["Linear"] = 0] = "Linear";
        })(EffectLerpTypeEnum = framework.EffectLerpTypeEnum || (framework.EffectLerpTypeEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectData = (function () {
            function EffectData() {
                this.name = null;
                this.particlelist = new Array();
                this.dependImgList = new Array();
                this.dependShapeList = new Array();
            }
            return EffectData;
        }());
        framework.EffectData = EffectData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ParticleEmissionType;
        (function (ParticleEmissionType) {
            ParticleEmissionType[ParticleEmissionType["burst"] = 0] = "burst";
            ParticleEmissionType[ParticleEmissionType["continue"] = 1] = "continue";
        })(ParticleEmissionType = framework.ParticleEmissionType || (framework.ParticleEmissionType = {}));
        var EmissionData = (function () {
            function EmissionData() {
                this.type = ParticleEmissionType.burst;
            }
            return EmissionData;
        }());
        framework.EmissionData = EmissionData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EmissionNew = (function () {
            function EmissionNew() {
                this.renderModel = framework.RenderModel.None;
                this.particleStartData = new gd3d.framework.ParticleStartData();
            }
            EmissionNew.prototype.getVboData = function (vf) {
                if (this.dataForVbo == undefined) {
                    this.dataForVbo = this.mesh.data.genVertexDataArray(vf);
                }
                return this.dataForVbo;
            };
            EmissionNew.prototype.clone = function () {
                var emission = new EmissionNew();
                if (this.emissionType != undefined)
                    emission.emissionType = this.emissionType;
                if (this.maxEmissionCount != undefined)
                    emission.maxEmissionCount = this.maxEmissionCount;
                if (this.emissionCount != undefined)
                    emission.emissionCount = this.emissionCount;
                if (this.time != undefined)
                    emission.time = this.time;
                if (this.pos != undefined)
                    emission.pos = this.pos.clone();
                if (this.simulationSpeed != undefined) {
                    emission.simulationSpeed = this.simulationSpeed.clone();
                }
                if (this.moveSpeed != undefined)
                    emission.moveSpeed = this.moveSpeed.clone();
                if (this.gravity != undefined)
                    emission.gravity = this.gravity;
                if (this.euler != undefined)
                    emission.euler = this.euler.clone();
                if (this.eulerNodes != undefined)
                    emission.eulerNodes = this.cloneParticleNodeArray(this.eulerNodes);
                if (this.eulerSpeed != undefined)
                    emission.eulerSpeed = this.eulerSpeed.clone();
                if (this.scale != undefined)
                    emission.scale = this.scale.clone();
                if (this.scaleNodes != undefined)
                    emission.scaleNodes = this.cloneParticleNodeArray(this.scaleNodes);
                if (this.scaleSpeed != undefined)
                    emission.scaleSpeed = this.scaleSpeed.clone();
                if (this.color != undefined)
                    emission.color = this.color.clone();
                if (this.colorNodes != undefined)
                    emission.colorNodes = this.cloneParticleNodeArray(this.colorNodes);
                if (this.colorSpeed != undefined)
                    emission.colorSpeed = this.colorSpeed.clone();
                if (this.simulationSpeed != undefined)
                    emission.simulationSpeed = this.simulationSpeed.clone();
                if (this.alpha != undefined)
                    emission.alpha = this.alpha.clone();
                if (this.alphaNodes != undefined)
                    emission.alphaNodes = this.cloneParticleNodeNumberArray(this.alphaNodes);
                if (this.alphaSpeed != undefined)
                    emission.alphaSpeed = this.alphaSpeed.clone();
                if (this.uv != undefined)
                    emission.uv = this.uv.clone();
                if (this.uvType != undefined)
                    emission.uvType = this.uvType;
                if (this.uvRoll != undefined)
                    emission.uvRoll = this.uvRoll.clone();
                if (this.uvSprite != undefined)
                    emission.uvSprite = this.uvSprite.clone();
                if (this.mat != undefined)
                    emission.mat = this.mat.clone();
                if (this.life != undefined)
                    emission.life = this.life.clone();
                if (this.renderModel != undefined)
                    emission.renderModel = this.renderModel;
                if (this.mesh != undefined)
                    emission.mesh = this.mesh;
                if (this.dataForVbo != undefined)
                    emission.dataForVbo = this.dataForVbo;
                if (this.particleStartData != undefined)
                    emission.particleStartData = this.particleStartData.clone();
                return emission;
            };
            EmissionNew.prototype.cloneParticleNodeArray = function (_array) {
                var array = new Array();
                for (var i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            };
            EmissionNew.prototype.cloneParticleNodeNumberArray = function (_array) {
                var array = new Array();
                for (var i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            };
            return EmissionNew;
        }());
        framework.EmissionNew = EmissionNew;
        var UVSpriteNew = (function () {
            function UVSpriteNew() {
            }
            UVSpriteNew.prototype.clone = function () {
                var sprite = new UVSpriteNew();
                sprite.row = this.row;
                sprite.column = this.column;
                sprite.totalCount = this.totalCount;
                return sprite;
            };
            return UVSpriteNew;
        }());
        framework.UVSpriteNew = UVSpriteNew;
        var UVRollNew = (function () {
            function UVRollNew() {
            }
            UVRollNew.prototype.clone = function () {
                var roll = new UVRollNew();
                if (this.uvSpeed != undefined)
                    roll.uvSpeed = this.uvSpeed;
                if (this.uvSpeedNodes != undefined) {
                    var array = new Array();
                    for (var i in this.uvSpeedNodes) {
                        array.push(this.uvSpeedNodes[i].clone());
                    }
                    roll.uvSpeedNodes = array;
                }
                return roll;
            };
            return UVRollNew;
        }());
        framework.UVRollNew = UVRollNew;
        var UVTypeEnum;
        (function (UVTypeEnum) {
            UVTypeEnum[UVTypeEnum["NONE"] = 0] = "NONE";
            UVTypeEnum[UVTypeEnum["UVRoll"] = 1] = "UVRoll";
            UVTypeEnum[UVTypeEnum["UVSprite"] = 2] = "UVSprite";
        })(UVTypeEnum = framework.UVTypeEnum || (framework.UVTypeEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var MaterialData = (function () {
            function MaterialData() {
                this.tiling = new gd3d.math.vector2(1.0, 1.0);
                this.offset = new gd3d.math.vector2(0, 0);
                this.alphaCut = 0.5;
                this.mapData = {};
            }
            return MaterialData;
        }());
        framework.MaterialData = MaterialData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ParticleNode = (function () {
            function ParticleNode() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
                this.z = new framework.ValueData();
            }
            ParticleNode.prototype.getValue = function () {
                return new gd3d.math.vector3(this.x.getValue(), this.y.getValue(), this.z.getValue());
            };
            ParticleNode.prototype.getValueRandom = function () {
                return new gd3d.math.vector3(this.x.getValueRandom(), this.y.getValueRandom(), this.z.getValueRandom());
            };
            ParticleNode.prototype.clone = function () {
                var node = new ParticleNode();
                if (this.x != undefined)
                    node.x = this.x.clone();
                if (this.y != undefined)
                    node.y = this.y.clone();
                if (this.z != undefined)
                    node.z = this.z.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            };
            return ParticleNode;
        }());
        framework.ParticleNode = ParticleNode;
        var AlphaNode = (function () {
            function AlphaNode() {
                this.alpha = new framework.ValueData();
            }
            AlphaNode.prototype.getValue = function () {
                return this.alpha.getValue();
            };
            return AlphaNode;
        }());
        framework.AlphaNode = AlphaNode;
        var UVSpeedNode = (function () {
            function UVSpeedNode() {
                this.u = new framework.ValueData();
                this.v = new framework.ValueData();
            }
            UVSpeedNode.prototype.getValue = function () {
                return new gd3d.math.vector2(this.u.getValue(), this.v.getValue());
            };
            UVSpeedNode.prototype.getValueRandom = function () {
                return new gd3d.math.vector2(this.u.getValueRandom(), this.v.getValueRandom());
            };
            UVSpeedNode.prototype.clone = function () {
                var node = new UVSpeedNode();
                node.u = this.u.clone();
                node.v = this.v.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            };
            return UVSpeedNode;
        }());
        framework.UVSpeedNode = UVSpeedNode;
        var ParticleNodeVec2 = (function () {
            function ParticleNodeVec2() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
            }
            ParticleNodeVec2.prototype.getValue = function () {
                return new gd3d.math.vector2(this.x.getValue(), this.y.getValue());
            };
            ParticleNodeVec2.prototype.getValueRandom = function () {
                return new gd3d.math.vector2(this.x.getValueRandom(), this.y.getValueRandom());
            };
            ParticleNodeVec2.prototype.clone = function () {
                var vec = new ParticleNodeVec2();
                vec.x = this.x.clone();
                vec.y = this.y.clone();
                if (this.key != undefined)
                    vec.key = this.key;
                return vec;
            };
            return ParticleNodeVec2;
        }());
        framework.ParticleNodeVec2 = ParticleNodeVec2;
        var ParticleNodeNumber = (function () {
            function ParticleNodeNumber() {
                this.num = new framework.ValueData();
            }
            ParticleNodeNumber.prototype.getValue = function () {
                return this.num.getValue();
            };
            ParticleNodeNumber.prototype.getValueRandom = function () {
                return this.num.getValueRandom();
            };
            ParticleNodeNumber.prototype.clone = function () {
                var num = new ParticleNodeNumber();
                num.num = this.num.clone();
                if (this.key != undefined) {
                    num.key = this.key;
                }
                return num;
            };
            return ParticleNodeNumber;
        }());
        framework.ParticleNodeNumber = ParticleNodeNumber;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ParticleSystemShape;
        (function (ParticleSystemShape) {
            ParticleSystemShape[ParticleSystemShape["NORMAL"] = 0] = "NORMAL";
            ParticleSystemShape[ParticleSystemShape["BOX"] = 1] = "BOX";
            ParticleSystemShape[ParticleSystemShape["SPHERE"] = 2] = "SPHERE";
            ParticleSystemShape[ParticleSystemShape["HEMISPHERE"] = 3] = "HEMISPHERE";
            ParticleSystemShape[ParticleSystemShape["CONE"] = 4] = "CONE";
            ParticleSystemShape[ParticleSystemShape["EDGE"] = 5] = "EDGE";
            ParticleSystemShape[ParticleSystemShape["CIRCLE"] = 6] = "CIRCLE";
        })(ParticleSystemShape = framework.ParticleSystemShape || (framework.ParticleSystemShape = {}));
        var ParticleStartData = (function () {
            function ParticleStartData() {
                this.shapeType = ParticleSystemShape.BOX;
                this._position = new gd3d.math.vector3(0, 0, 0);
                this._direction = new gd3d.math.vector3(0, 0, 0);
                this._width = 0;
                this._bottomRadius = 0;
                this._height = 0;
                this.depth = 0;
                this._radius = 0;
                this._angle = 0;
                this.randomPosition = new gd3d.math.vector3(0, 0, 0);
                this._randomDirection = new gd3d.math.vector3(0, 0, 0);
                this._boxDirection = new gd3d.math.vector3(0, 0, 1);
                this._sphereDirection = new gd3d.math.vector3(0, 0, 1);
                this._hemisphereDirection = new gd3d.math.vector3(0, 0, 1);
                this.bottomRidus = 1000;
                this._coneDirection = new gd3d.math.vector3(0, 0, 1);
                this._circleDirection = new gd3d.math.vector3(0, 0, 1);
                this._edgeDirection = new gd3d.math.vector3(0, 0, 1);
                gd3d.math.vec3Normalize(this.direction, this.direction);
            }
            Object.defineProperty(ParticleStartData.prototype, "position", {
                get: function () {
                    return this._position;
                },
                set: function (_pos) {
                    gd3d.math.vec3Clone(_pos, this._position);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                set: function (_dir) {
                    gd3d.math.vec3Clone(_dir, this._direction);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "width", {
                get: function () {
                    return this._width;
                },
                set: function (_w) {
                    this._width = _w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "bottomRadius", {
                get: function () {
                    return this._bottomRadius;
                },
                set: function (_r) {
                    this._bottomRadius = _r;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "height", {
                get: function () {
                    return this._width;
                },
                set: function (_h) {
                    this._height = _h;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "radius", {
                get: function () {
                    return this._radius;
                },
                set: function (_r) {
                    this._radius = _r;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "angle", {
                get: function () {
                    return this._angle;
                },
                set: function (_a) {
                    this._angle = _a;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "randomDirection", {
                get: function () {
                    switch (this.shapeType) {
                        case ParticleSystemShape.BOX:
                            gd3d.math.vec3Clone(this.boxDirection, this._randomDirection);
                            break;
                        case ParticleSystemShape.SPHERE:
                            gd3d.math.vec3Clone(this.sphereDirection, this._randomDirection);
                            break;
                        case ParticleSystemShape.HEMISPHERE:
                            gd3d.math.vec3Clone(this.hemisphereDirection, this._randomDirection);
                            break;
                        case ParticleSystemShape.CONE:
                            gd3d.math.vec3Clone(this.coneDirection, this._randomDirection);
                            break;
                        case ParticleSystemShape.CIRCLE:
                            gd3d.math.vec3Clone(this.circleDirection, this._randomDirection);
                            break;
                        case ParticleSystemShape.EDGE:
                            gd3d.math.vec3Clone(this.edgeDirection, this._randomDirection);
                            break;
                        default:
                            gd3d.math.vec3Clone(this.direction, this._randomDirection);
                            break;
                    }
                    gd3d.math.vec3Normalize(this._randomDirection, this._randomDirection);
                    return this._randomDirection;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "boxDirection", {
                get: function () {
                    var boxpos = new gd3d.math.vector3(0, 0, 0);
                    boxpos.x = framework.ValueData.RandomRange(-this.width / 2, this.width / 2);
                    boxpos.y = framework.ValueData.RandomRange(-this.height / 2, this.height / 2);
                    boxpos.z = framework.ValueData.RandomRange(-this.depth / 2, this.depth / 2);
                    var length = gd3d.math.vec3Length(boxpos);
                    framework.EffectUtil.RotateVector3(boxpos, this.direction, boxpos);
                    this.getRandomPosition(boxpos, length);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "sphereDirection", {
                get: function () {
                    var _radius = framework.ValueData.RandomRange(0, this.radius);
                    var  = framework.ValueData.RandomRange(0, Math.PI);
                    var  = framework.ValueData.RandomRange(-Math.PI, Math.PI);
                    this._sphereDirection.x = _radius * Math.sin() * Math.cos();
                    this._sphereDirection.y = _radius * Math.sin() * Math.sin();
                    this._sphereDirection.z = _radius * Math.cos();
                    gd3d.math.vec3Normalize(this._sphereDirection, this._sphereDirection);
                    this.getRandomPosition(this._sphereDirection, _radius);
                    return this._sphereDirection;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "hemisphereDirection", {
                get: function () {
                    var _radius = framework.ValueData.RandomRange(0, this.radius);
                    var  = framework.ValueData.RandomRange(0, Math.PI / 2);
                    var  = framework.ValueData.RandomRange(-Math.PI, Math.PI);
                    this._hemisphereDirection.z = _radius * Math.cos();
                    this._hemisphereDirection.y = _radius * Math.sin() * Math.sin();
                    this._hemisphereDirection.x = _radius * Math.sin() * Math.cos();
                    gd3d.math.vec3Normalize(this._hemisphereDirection, this._hemisphereDirection);
                    framework.EffectUtil.RotateVector3(this._hemisphereDirection, this.direction, this._hemisphereDirection);
                    this.getRandomPosition(this._hemisphereDirection, _radius);
                    return this._hemisphereDirection;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "coneDirection", {
                get: function () {
                    if (this.radius > this.bottomRidus) {
                        this.bottomRidus = this.radius;
                    }
                    var height = this.bottomRidus / (Math.tan(this.angle * (Math.PI / 180)));
                    var subHeight = height * (this.radius / this.bottomRidus);
                    var a = framework.ValueData.RandomRange(0.01, this.angle * (Math.PI / 180));
                    var b = framework.ValueData.RandomRange(-Math.PI, Math.PI);
                    var _height = framework.ValueData.RandomRange(subHeight, this.height);
                    var _raidus = _height * Math.tan(a);
                    this._coneDirection.z = _height;
                    this._coneDirection.y = _raidus * Math.sin(b);
                    this._coneDirection.x = _raidus * Math.cos(b);
                    var length = gd3d.math.vec3Length(this._coneDirection);
                    gd3d.math.vec3Normalize(this._coneDirection, this._coneDirection);
                    framework.EffectUtil.RotateVector3(this._coneDirection, this.direction, this._coneDirection);
                    this.getRandomPosition(this._coneDirection, length);
                    return this._coneDirection;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "circleDirection", {
                get: function () {
                    var _arc = this.angle * (Math.PI / 180);
                    var a = framework.ValueData.RandomRange(-_arc / 2, _arc / 2);
                    var _radius = framework.ValueData.RandomRange(0, this.radius);
                    this._circleDirection.x = _radius * Math.cos(a);
                    this._circleDirection.z = _radius * Math.sin(a);
                    this._circleDirection.y = 0;
                    var length = gd3d.math.vec3Length(this._circleDirection);
                    gd3d.math.vec3Normalize(this._circleDirection, this._circleDirection);
                    framework.EffectUtil.RotateVector3(this._circleDirection, this.direction, this._circleDirection);
                    this.getRandomPosition(this._circleDirection, length);
                    return this._circleDirection;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "edgeDirection", {
                get: function () {
                    var edgePos = new gd3d.math.vector3(0, 0, 0);
                    edgePos.y += framework.ValueData.RandomRange(-this.radius / 2, this.radius / 2);
                    var lenght = gd3d.math.vec3Length(edgePos);
                    framework.EffectUtil.RotateVector3(edgePos, this.direction, edgePos);
                    gd3d.math.vec3Clone(this.direction, this._edgeDirection);
                    this.getRandomPosition(edgePos, length);
                    return this._edgeDirection;
                },
                enumerable: true,
                configurable: true
            });
            ParticleStartData.prototype.getRandomPosition = function (dir, length) {
                gd3d.math.vec3ScaleByNum(dir, length, dir);
                this.randomPosition.x = dir.x;
                this.randomPosition.y = dir.y;
                this.randomPosition.z = dir.z;
            };
            ParticleStartData.prototype.clone = function () {
                var data = new ParticleStartData();
                data.shapeType = this.shapeType;
                data._position = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._position, data._position);
                data._direction = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._direction, data._direction);
                data._width = this._width;
                data._bottomRadius = this._bottomRadius;
                data._height = this._height;
                data.depth = this.depth;
                data._radius = this._radius;
                data._angle = this._angle;
                data._randomDirection = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._randomDirection, data._randomDirection);
                data.randomPosition = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.randomPosition, data.randomPosition);
                data._boxDirection = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._boxDirection, data._boxDirection);
                data._sphereDirection = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._sphereDirection, data._sphereDirection);
                data._hemisphereDirection = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._hemisphereDirection, data._hemisphereDirection);
                data.bottomRidus = this.bottomRidus;
                data._coneDirection = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._coneDirection, data._coneDirection);
                data._circleDirection = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._circleDirection, data._circleDirection);
                data._edgeDirection = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._edgeDirection, data._edgeDirection);
                return data;
            };
            return ParticleStartData;
        }());
        framework.ParticleStartData = ParticleStartData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var RenderModel;
        (function (RenderModel) {
            RenderModel[RenderModel["None"] = 0] = "None";
            RenderModel[RenderModel["BillBoard"] = 1] = "BillBoard";
            RenderModel[RenderModel["StretchedBillBoard"] = 2] = "StretchedBillBoard";
            RenderModel[RenderModel["HorizontalBillBoard"] = 3] = "HorizontalBillBoard";
            RenderModel[RenderModel["VerticalBillBoard"] = 4] = "VerticalBillBoard";
            RenderModel[RenderModel["Mesh"] = 5] = "Mesh";
        })(RenderModel = framework.RenderModel || (framework.RenderModel = {}));
        var ParticleCurveType;
        (function (ParticleCurveType) {
            ParticleCurveType[ParticleCurveType["LINEAR"] = 0] = "LINEAR";
            ParticleCurveType[ParticleCurveType["CURVE"] = 1] = "CURVE";
        })(ParticleCurveType = framework.ParticleCurveType || (framework.ParticleCurveType = {}));
        var ParticleData = (function () {
            function ParticleData() {
                this.emissionData = new framework.EmissionData();
                this.materialData = new framework.MaterialData();
                this.particleDetailData = new ParticleDetailData();
            }
            return ParticleData;
        }());
        framework.ParticleData = ParticleData;
        var ParticleMethodType;
        (function (ParticleMethodType) {
            ParticleMethodType[ParticleMethodType["Normal"] = 0] = "Normal";
            ParticleMethodType[ParticleMethodType["UVSPRITE"] = 1] = "UVSPRITE";
            ParticleMethodType[ParticleMethodType["UVROLL"] = 2] = "UVROLL";
        })(ParticleMethodType = framework.ParticleMethodType || (framework.ParticleMethodType = {}));
        var ParticleDetailData = (function () {
            function ParticleDetailData() {
                this.renderModel = gd3d.framework.RenderModel.BillBoard;
                this.bindAxis = false;
                this.bindx = false;
                this.bindy = false;
                this.bindz = false;
                this.type = "plane";
                this.isLoop = false;
                this.isLookAtCamera = false;
                this.gravity = new framework.ValueData();
                this.gravitySpeed = new framework.ValueData();
                this.life = new framework.ValueData();
                this.speed = new framework.ValueData();
                this.startPitchYawRoll = new framework.ParticleNode();
                this.angularVelocity = new framework.ParticleNode();
                this.velocity = new framework.ParticleNode();
                this.acceleration = new framework.ParticleNode();
                this.scale = new framework.ParticleNode();
                this.scaleNode = new Array();
                this.color = new framework.ParticleNode();
                this.colorNode = new Array();
                this.alpha = new framework.ValueData();
                this.alphaNode = new Array();
                this.positionNode = new Array();
                this.particleStartData = new gd3d.framework.ParticleStartData();
                this.isRotation = false;
                this.infinite = false;
                this.delayTime = new framework.ValueData();
                this.interpolationType = ParticleCurveType.CURVE;
                this.particleMethodType = ParticleMethodType.Normal;
                this.istrail = false;
                this.angleSpeedForbillboard = new framework.ValueData();
            }
            return ParticleDetailData;
        }());
        framework.ParticleDetailData = ParticleDetailData;
        var UVSprite = (function () {
            function UVSprite() {
                this.startFrame = 0;
                this.cycles = 1;
            }
            return UVSprite;
        }());
        framework.UVSprite = UVSprite;
        var UVRoll = (function () {
            function UVRoll() {
                this.uvSpeed = new framework.UVSpeedNode();
                this.uvSpeedNodes = new Array();
            }
            return UVRoll;
        }());
        framework.UVRoll = UVRoll;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ValueData = (function () {
            function ValueData() {
                this.isRandom = true;
                this._value = 0;
                this._valueLimitMin = 0;
                this._valueLimitMax = 0;
                this.beInited = false;
            }
            Object.defineProperty(ValueData.prototype, "value", {
                set: function (_v) {
                    this._value = _v;
                    this.isRandom = false;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ValueData.prototype, "valueLimitMin", {
                set: function (_v) {
                    this._valueLimitMin = _v;
                    this.isRandom = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ValueData.prototype, "valueLimitMax", {
                set: function (_v) {
                    this._valueLimitMax = _v;
                    this.isRandom = true;
                },
                enumerable: true,
                configurable: true
            });
            ValueData.prototype.clone = function () {
                var valu = new ValueData();
                valu.isRandom = this.isRandom;
                valu._value = this._value;
                valu._valueLimitMin = this._valueLimitMin;
                valu._valueLimitMax = this._valueLimitMax;
                return valu;
            };
            ValueData.prototype.getValue = function () {
                if (this.isRandom) {
                    if (!this.beInited) {
                        this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                        this.beInited = true;
                    }
                }
                return this._value;
            };
            ValueData.prototype.getValueRandom = function () {
                if (this.isRandom) {
                    this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                }
                return this._value;
            };
            ValueData.RandomRange = function (min, max, isInteger) {
                if (isInteger === void 0) { isInteger = false; }
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            };
            return ValueData;
        }());
        framework.ValueData = ValueData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Curve3 = (function () {
            function Curve3(points, nbPoints) {
                this._beizerPoints = points;
                this._bezierPointNum = nbPoints;
            }
            Object.defineProperty(Curve3.prototype, "beizerPoints", {
                get: function () {
                    return this._beizerPoints;
                },
                set: function (value) {
                    this._beizerPoints = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Curve3.prototype, "bezierPointNum", {
                get: function () {
                    return this._bezierPointNum;
                },
                set: function (value) {
                    this._bezierPointNum = value;
                },
                enumerable: true,
                configurable: true
            });
            Curve3.CreateLinearBezier = function (start, end, indices) {
                indices = indices > 2 ? indices : 3;
                var bez = new Array();
                var equation = function (t, va10, va11) {
                    var res = (1.0 - t) * va10 + t * va11;
                    return res;
                };
                bez.push(start);
                for (var i = 1; i <= indices; i++) {
                    bez.push(new gd3d.math.vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
                }
                return new Curve3(bez, indices);
            };
            Curve3.GetLerpBezier = function (nodes) {
                var beizerPoint = new Array();
                for (var n = 0; n < nodes.length; n++) {
                    beizerPoint.push(nodes[n].getValue());
                }
                return new Curve3(beizerPoint, nodes.length);
            };
            Curve3.CreateQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
                bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
                var beizerPoint = new Array();
                var equation = function (t, val0, val1, val2) {
                    var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new gd3d.math.vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            };
            Curve3.CreateCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
                bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
                var beizerPoint = new Array();
                var equation = function (t, val0, val1, val2, val3) {
                    var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new gd3d.math.vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            };
            Curve3.prototype.getPoints = function () {
                return this._beizerPoints;
            };
            return Curve3;
        }());
        framework.Curve3 = Curve3;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var LinearAction = (function () {
            function LinearAction() {
            }
            LinearAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.attrival = framework.EffectUtil.parseEffectVec3(this.params["value"]);
                            break;
                        case "uv":
                            this.attrival = framework.EffectUtil.parseEffectUVSpeed(this.params["value"]);
                            break;
                        case "alpha":
                            this.attrival = this.params["value"];
                            break;
                    }
                }
            };
            LinearAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                var baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos.x = baseValue.pos.x + this.attrival.x.getValue();
                        baseValue.pos.y = baseValue.pos.y + this.attrival.y.getValue();
                        baseValue.pos.z = baseValue.pos.z + this.attrival.z.getValue();
                        break;
                    case "scale":
                        baseValue.scale.x = baseValue.scale.x + this.attrival.x.getValue();
                        baseValue.scale.y = baseValue.scale.y + this.attrival.y.getValue();
                        baseValue.scale.z = baseValue.scale.z + this.attrival.z.getValue();
                        break;
                    case "euler":
                        baseValue.euler.x = baseValue.euler.x + this.attrival.x.getValue();
                        baseValue.euler.y = baseValue.euler.y + this.attrival.y.getValue();
                        baseValue.euler.z = baseValue.euler.z + this.attrival.z.getValue();
                        break;
                    case "color":
                        baseValue.color.x = baseValue.color.x + this.attrival.x.getValue();
                        baseValue.color.y = baseValue.color.y + this.attrival.y.getValue();
                        baseValue.color.z = baseValue.color.z + this.attrival.z.getValue();
                        break;
                    case "uv":
                        baseValue.uv.x = baseValue.uv.x + this.attrival.u.getValue();
                        baseValue.uv.y = baseValue.uv.y + this.attrival.v.getValue();
                        break;
                    case "alpha":
                        baseValue.alpha = baseValue.alpha + this.attrival;
                        break;
                }
            };
            return LinearAction;
        }());
        framework.LinearAction = LinearAction;
        var DestroyAction = (function () {
            function DestroyAction() {
            }
            DestroyAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            };
            DestroyAction.prototype.update = function (frameIndex) {
                if (frameIndex >= this.startFrame) {
                    this.elements.setActive(false);
                }
            };
            return DestroyAction;
        }());
        framework.DestroyAction = DestroyAction;
        var LoopAction = (function () {
            function LoopAction() {
            }
            LoopAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            };
            LoopAction.prototype.update = function (frameIndex) {
                if (frameIndex == this.startFrame) {
                    this.elements.loopFrame = this.startFrame + 1;
                    this.elements.curAttrData = this.elements.data.initFrameData.attrsData.clone();
                }
            };
            return LoopAction;
        }());
        framework.LoopAction = LoopAction;
        var UVRollAction = (function () {
            function UVRollAction() {
                this.speedu = 0;
                this.speedv = 0;
                this.startu = 0;
                this.startv = 0;
            }
            UVRollAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["speedu"] != undefined) {
                    this.speedu = this.params["speedu"];
                }
                if (this.params["speedv"] != undefined) {
                    this.speedv = this.params["speedv"];
                }
                if (this.params["startu"] != undefined) {
                    this.startu = this.params["startu"];
                }
                if (this.params["startv"] != undefined) {
                    this.startv = this.params["startv"];
                }
            };
            UVRollAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                if (this.startFrame == frameIndex) {
                    this.elements.curAttrData.uv.x = this.startu;
                    this.elements.curAttrData.uv.y = this.startv;
                    return;
                }
                this.elements.curAttrData.uv.x += this.speedu;
                this.elements.curAttrData.uv.y += this.speedv;
            };
            return UVRollAction;
        }());
        framework.UVRollAction = UVRollAction;
        var UVSpriteAnimationAction = (function () {
            function UVSpriteAnimationAction() {
                this.fps = 30;
                this.row = 1;
                this.colum = 1;
                this.frameInternal = 1;
                this.spriteIndex = 0;
            }
            UVSpriteAnimationAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["fps"] != undefined) {
                    this.fps = this.params["fps"];
                    this.frameInternal = framework.effectSystem.fps / this.fps;
                }
                if (this.params["row"] != undefined) {
                    this.row = this.params["row"];
                }
                if (this.params["colum"] != undefined) {
                    this.colum = this.params["colum"];
                }
            };
            UVSpriteAnimationAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                if ((frameIndex - this.startFrame) % this.frameInternal == 0) {
                    this.spriteIndex = (frameIndex - this.startFrame) / this.frameInternal;
                    this.spriteIndex %= (this.colum * this.row);
                    this.elements.curAttrData.uv.x = (this.spriteIndex % this.colum) / this.colum;
                    this.elements.curAttrData.uv.y = Math.floor((this.spriteIndex / this.colum)) / this.row;
                    this.elements.curAttrData.tilling.x = 1 / this.colum;
                    this.elements.curAttrData.tilling.y = 1 / this.row;
                }
            };
            return UVSpriteAnimationAction;
        }());
        framework.UVSpriteAnimationAction = UVSpriteAnimationAction;
        var RotationAction = (function () {
            function RotationAction() {
            }
            RotationAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["velocity"] != undefined) {
                    this.velocity = framework.EffectUtil.parseEffectVec3(this.params["velocity"]);
                }
                this.frameInternal = 1 / framework.effectSystem.fps;
            };
            RotationAction.prototype.update = function (frameIndex) {
                this.elements.curAttrData.euler.z = this.elements.curAttrData.euler.z + (this.velocity.z.getValue()) * this.frameInternal;
                if (this.elements.curAttrData.renderModel == framework.RenderModel.None) {
                    this.elements.curAttrData.euler.x = this.elements.curAttrData.euler.x + (this.velocity.x.getValue()) * this.frameInternal;
                    this.elements.curAttrData.euler.y = this.elements.curAttrData.euler.y + (this.velocity.y.getValue()) * this.frameInternal;
                }
            };
            return RotationAction;
        }());
        framework.RotationAction = RotationAction;
        var RoseCurveAction = (function () {
            function RoseCurveAction() {
            }
            RoseCurveAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["radius"] != undefined) {
                    this.radius = this.params["radius"];
                }
                if (this.params["level"] != undefined) {
                    this.level = this.params["radius"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["polar"] != undefined) {
                    this.polar = framework.EffectUtil.parseEffectVec3(this.params["polar"]);
                }
                this.frameInternal = 1 / framework.effectSystem.fps;
            };
            RoseCurveAction.prototype.update = function (frameIndex) {
                var initFrameDataPos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.elements.data.initFrameData.attrsData.pos, initFrameDataPos);
                var radius = this.radius;
                var curFrame = frameIndex % 360;
                var x = this.polar.x.getValue();
                var y = this.polar.y.getValue();
                var z = this.polar.z.getValue();
                {
                    var theta = frameIndex * this.speed;
                    this.elements.curAttrData.pos.x = initFrameDataPos.x + radius * Math.cos(3 * theta + x) * Math.cos(theta);
                    this.elements.curAttrData.pos.z = initFrameDataPos.z + radius * Math.cos(3 * theta + x) * Math.sin(theta);
                    this.elements.curAttrData.pos.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                }
                {
                    var deltaTheta = frameIndex * this.speed + 0.001;
                    var targetPoint = gd3d.math.pool.new_vector3();
                    targetPoint.x = initFrameDataPos.x + radius * Math.cos(3 * deltaTheta + x) * Math.cos(deltaTheta);
                    targetPoint.z = initFrameDataPos.z + radius * Math.cos(3 * deltaTheta + x) * Math.sin(deltaTheta);
                    targetPoint.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                    var rotation = gd3d.math.pool.new_quaternion();
                    gd3d.math.quatLookat(this.elements.curAttrData.pos, targetPoint, rotation);
                    gd3d.math.quatToEulerAngles(rotation, this.elements.curAttrData.euler);
                    gd3d.math.pool.delete_vector3(targetPoint);
                    gd3d.math.pool.delete_quaternion(rotation);
                }
                gd3d.math.pool.delete_vector3(initFrameDataPos);
            };
            return RoseCurveAction;
        }());
        framework.RoseCurveAction = RoseCurveAction;
        var TrailAction = (function () {
            function TrailAction() {
                this.offsetTransalte = new gd3d.math.vector3();
            }
            TrailAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["pos"] != undefined) {
                    this.position = framework.EffectUtil.parseEffectVec3(this.params["pos"]);
                }
                this.offsetTransalte.x = this.position.x.getValue();
                this.offsetTransalte.y = this.position.y.getValue();
                this.offsetTransalte.z = this.position.z.getValue();
                if (this.params["eular"] != undefined) {
                    this.eular = framework.EffectUtil.parseEffectVec3(this.params["eular"]);
                }
                if (this.params["color"] != undefined) {
                    this.color = framework.EffectUtil.parseEffectVec3(this.params["color"]);
                }
                if (this.params["width"] != undefined) {
                    this.width = this.params["width"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["alpha"] != undefined) {
                    this.alpha = this.params["alpha"];
                }
                var mat = new gd3d.framework.material();
                var shader = new gd3d.framework.shader();
                var texture = new gd3d.framework.texture();
                if (this.params["shader"] != undefined)
                    shader = framework.sceneMgr.app.getAssetMgr().getShader(this.params["shader"]);
                else
                    shader = framework.sceneMgr.app.getAssetMgr().getShader("shader/def");
                mat.setShader(shader);
                if (this.params["diffuseTexture"] != undefined)
                    texture = framework.sceneMgr.app.getAssetMgr().getAssetByName(this.params["diffuseTexture"]);
                mat.setTexture("_MainTex", texture);
                this.frameInternal = 1 / framework.effectSystem.fps;
                this.transform = new gd3d.framework.transform();
                framework.sceneMgr.scene.addChild(this.transform);
                var curAttrData = this.elements.data.initFrameData.attrsData.clone();
                var worldTranslate = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    gd3d.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                gd3d.math.vec3Clone(worldTranslate, this.transform.localTranslate);
                gd3d.math.pool.delete_vector3(worldTranslate);
                var trailTransform = new gd3d.framework.transform();
                this.transform.addChild(trailTransform);
                var x = this.eular.x.getValue();
                var y = this.eular.y.getValue();
                var z = this.eular.z.getValue();
                this.startRotation = new gd3d.math.quaternion();
                gd3d.math.quatFromEulerAngles(x, y, z, this.startRotation);
                gd3d.math.quatMultiply(this.startRotation, curAttrData.localRotation, this.transform.localRotate);
                this.transform.markDirty();
                trailTransform.markDirty();
                var trailrender = trailTransform.gameObject.addComponent("trailRender");
                trailrender.color = new gd3d.math.color(this.color.x.getValue(), this.color.y.getValue(), this.color.z.getValue(), this.alpha);
                trailrender.setspeed(this.speed);
                trailrender.setWidth(this.width);
                trailrender.material = mat;
            };
            TrailAction.prototype.update = function (frameIndex) {
                var worldTranslate = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.elements.curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    gd3d.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                gd3d.math.vec3Clone(worldTranslate, this.transform.localTranslate);
                gd3d.math.vec3Add(this.transform.localTranslate, this.offsetTransalte, this.transform.localTranslate);
                gd3d.math.pool.delete_vector3(worldTranslate);
                gd3d.math.quatMultiply(this.startRotation, this.elements.curAttrData.localRotation, this.transform.localRotate);
                this.transform.markDirty();
            };
            return TrailAction;
        }());
        framework.TrailAction = TrailAction;
        var BreathAction = (function () {
            function BreathAction() {
            }
            BreathAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    this.loopframe = this.params["loopframe"];
                    this.halfloopframe = this.loopframe / 2;
                    this.curTargetFrame = this.startFrame + this.halfloopframe;
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.startvalue = framework.EffectUtil.parseEffectVec3(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectVec3(this.params["targetvalue"]).getValue();
                            break;
                        case "uv":
                            this.startvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["targetvalue"]).getValue();
                            break;
                        case "alpha":
                            this.startvalue = this.params["startvalue"];
                            this.targetvalue = this.params["targetvalue"];
                            break;
                    }
                }
            };
            BreathAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex)
                    return;
                if (frameIndex >= this.curTargetFrame) {
                    this.swap();
                    this.curTargetFrame += this.halfloopframe;
                }
                var baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos = this.getLerpValue(frameIndex);
                        break;
                    case "scale":
                        baseValue.scale = this.getLerpValue(frameIndex);
                        break;
                    case "euler":
                        baseValue.euler = this.getLerpValue(frameIndex);
                        break;
                    case "color":
                        baseValue.color = this.getLerpValue(frameIndex);
                        break;
                    case "uv":
                        baseValue.uv = this.getLerpValue(frameIndex);
                        break;
                    case "alpha":
                        baseValue.alpha = this.getLerpValue(frameIndex);
                        break;
                }
            };
            BreathAction.prototype.swap = function () {
                var temp;
                if (this.startvalue instanceof gd3d.math.vector3) {
                    temp = gd3d.math.pool.clone_vector3(this.startvalue);
                    this.startvalue = gd3d.math.pool.clone_vector3(this.targetvalue);
                    this.targetvalue = temp;
                }
                else if (this.startvalue instanceof gd3d.math.vector2) {
                    temp = gd3d.math.pool.clone_vector2(this.startvalue);
                    this.startvalue = gd3d.math.pool.clone_vector2(this.targetvalue);
                    this.targetvalue = temp;
                }
                else {
                    temp = this.startvalue;
                    this.startvalue = this.targetvalue;
                    this.targetvalue = temp;
                }
            };
            BreathAction.prototype.getLerpValue = function (frameIndex) {
                var curframe = (frameIndex - this.startFrame) % this.halfloopframe;
                var outVal;
                if (this.startvalue instanceof gd3d.math.vector3) {
                    outVal = new gd3d.math.vector3();
                    gd3d.math.vec3SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else if (this.startvalue instanceof gd3d.math.vector2) {
                    outVal = new gd3d.math.vector2();
                    gd3d.math.vec2SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else {
                    outVal = gd3d.math.numberLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe);
                }
                return outVal;
            };
            return BreathAction;
        }());
        framework.BreathAction = BreathAction;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectParser = (function () {
            function EffectParser() {
            }
            EffectParser.prototype.Parse = function (str, assetmgr) {
                if (str == null)
                    return null;
                this.asMgr = assetmgr;
                var effectData = new framework.EffectSystemData();
                var content = JSON.parse(str);
                if (content["life"] != undefined)
                    effectData.life = content["life"];
                if (content["elements"] != undefined) {
                    effectData.elements = [];
                    var elements = content["elements"];
                    for (var i in elements) {
                        var element = new framework.EffectElementData();
                        effectData.elements.push(element);
                        var elementData = elements[i];
                        if (elementData["name"] != undefined)
                            element.name = elementData["name"];
                        if (elementData["ref"] != undefined)
                            element.ref = elementData["ref"];
                        if (elementData["type"] != undefined) {
                            switch (elementData["type"]) {
                                case "singlemesh":
                                    element.type = framework.EffectElementTypeEnum.SingleMeshType;
                                    break;
                                case "emission":
                                    element.type = framework.EffectElementTypeEnum.EmissionType;
                                    break;
                            }
                        }
                        switch (element.type) {
                            case framework.EffectElementTypeEnum.SingleMeshType:
                                this._parseSingleMeshTypeData(elementData, element);
                                break;
                            case framework.EffectElementTypeEnum.EmissionType:
                                this._parseEmissionTypeData(elementData, element);
                                break;
                        }
                    }
                }
                return effectData;
            };
            EffectParser.prototype._parseSingleMeshTypeData = function (elementData, element) {
                if (elementData["timeline"] != undefined) {
                    element.timelineFrame = {};
                    element.actionData = [];
                    var _timelineArray = elementData["timeline"];
                    for (var j in _timelineArray) {
                        var _timeline = _timelineArray[j];
                        if (_timeline["frame"] == undefined) {
                            console.error("");
                            continue;
                        }
                        var frame = new framework.EffectFrameData();
                        frame.frameIndex = _timeline["frame"];
                        element.timelineFrame[frame.frameIndex] = frame;
                        frame.attrsData = new framework.EffectAttrsData();
                        if (_timeline["attrs"] != undefined) {
                            var _attrs = _timeline["attrs"];
                            for (var key in _attrs) {
                                var val = this._parseToObjData(key, _attrs[key]);
                                if (key == "mat") {
                                    frame.attrsData.mat = val;
                                }
                                else if (key == "pos") {
                                    frame.attrsData.pos = val.getValue();
                                }
                                else if (key == "scale") {
                                    frame.attrsData.scale = val.getValue();
                                }
                                else if (key == "euler") {
                                    frame.attrsData.euler = val.getValue();
                                }
                                else if (key == "mesh") {
                                    frame.attrsData.mesh = val;
                                }
                                else if (key == "color") {
                                    frame.attrsData.color = val.getValue();
                                }
                                else if (key == "alpha") {
                                    frame.attrsData.alpha = val.getValue();
                                    ;
                                }
                                else if (key == "tilling") {
                                    frame.attrsData.tilling = val.getValue();
                                }
                                else if (key == "billboard") {
                                    frame.attrsData.renderModel = val;
                                }
                            }
                        }
                        if (frame.frameIndex == -1) {
                            element.initFrameData = frame;
                        }
                        if (_timeline["lerp"] != undefined) {
                            frame.lerpDatas = [];
                            for (var x in _timeline["lerp"]) {
                                var lerp = new framework.EffectLerpData();
                                lerp.fromFrame = frame.frameIndex;
                                frame.lerpDatas.push(lerp);
                                var _lerp = _timeline["lerp"][x];
                                if (_lerp["type"] != undefined) {
                                    switch (_lerp["type"]) {
                                        case "linear":
                                            lerp.type = framework.EffectLerpTypeEnum.Linear;
                                            break;
                                    }
                                }
                                if (_lerp["to"] != undefined)
                                    lerp.toFrame = this._parseToValueData(_lerp["to"]);
                                if (_lerp["attribute"] != undefined) {
                                    lerp.attrsData = new framework.EffectAttrsData();
                                    var _attribs = _lerp["attribute"];
                                    for (var key in _attribs) {
                                        lerp.attrsList.push(key);
                                        var val = this._parseToObjData(key, _attribs[key]);
                                        if (key == "pos") {
                                            lerp.attrsData.pos = val.getValue();
                                        }
                                        else if (key == "scale") {
                                            lerp.attrsData.scale = val.getValue();
                                        }
                                        else if (key == "euler") {
                                            lerp.attrsData.euler = val.getValue();
                                        }
                                        else if (key == "color") {
                                            lerp.attrsData.color = val.getValue();
                                        }
                                        else if (key == "alpha") {
                                            lerp.attrsData.alpha = val.getValue();
                                        }
                                    }
                                }
                            }
                        }
                        if (_timeline["actions"] != undefined) {
                            var _actions = _timeline["actions"];
                            for (var k in _actions) {
                                var action = new framework.EffectActionData();
                                var _action = _actions[k];
                                action.actionType = _action["action"];
                                action.startFrame = frame.frameIndex;
                                if (_action["end"] != undefined) {
                                    action.endFrame = _action["end"];
                                }
                                else {
                                    action.endFrame = -1;
                                }
                                if (_action["param"] != undefined) {
                                    action.params = _action["param"];
                                }
                                element.actionData.push(action);
                            }
                        }
                    }
                }
            };
            EffectParser.prototype._parseEmissionTypeData = function (elementData, element) {
                if (elementData["timeline"] != undefined) {
                    if (elementData["timeline"]["attrs"] != undefined) {
                        var _data = elementData["timeline"]["attrs"];
                        var data = new framework.EmissionNew();
                        element.emissionData = data;
                        if (_data["emissionType"] != undefined) {
                            switch (_data["emissionType"]) {
                                case "burst":
                                    data.emissionType = framework.ParticleEmissionType.burst;
                                    break;
                                case "continue":
                                    data.emissionType = framework.ParticleEmissionType.continue;
                                    break;
                            }
                            if (_data["maxcount"] != undefined)
                                data.maxEmissionCount = _data["maxcount"];
                            if (_data["emissioncount"] != undefined)
                                data.emissionCount = _data["emissioncount"];
                            if (_data["time"] != undefined)
                                data.time = _data["time"];
                            if (_data["mesh"] != undefined)
                                data.mesh = this._parseToObjData("mesh", _data["mesh"]);
                            if (_data["mat"] != undefined)
                                data.mat = this._parseToObjData("mat", _data["mat"]);
                            if (_data["moveSpeed"] != undefined)
                                data.moveSpeed = this._parseToObjData("moveSpeed", _data["moveSpeed"]);
                            if (_data["gravity"] != undefined)
                                data.gravity = _data["gravity"];
                            if (_data["euler"] != undefined)
                                data.euler = this._parseToObjData("euler", _data["euler"]);
                            if (_data["eulerSpeed"] != undefined)
                                data.eulerSpeed = this._parseToObjData("eulerSpeed", _data["eulerSpeed"]);
                            if (_data["eulerNodes"] != undefined) {
                                data.eulerNodes = [];
                                if (data.euler != undefined) {
                                    data.eulerNodes.push(data.euler);
                                    data.euler.key = 0;
                                }
                                for (var i in _data["eulerNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["eulerNodes"][i]);
                                    data.eulerNodes.push(node);
                                }
                            }
                            if (_data["scale"] != undefined)
                                data.scale = this._parseToObjData("scale", _data["scale"]);
                            if (_data["scaleSpeed"] != undefined)
                                data.scaleSpeed = this._parseToObjData("scaleSpeed", _data["scaleSpeed"]);
                            if (_data["scaleNodes"] != undefined) {
                                data.scaleNodes = [];
                                if (data.scale != undefined) {
                                    data.scaleNodes.push(data.scale);
                                    data.scale.key = 0;
                                }
                                for (var i in _data["scaleNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["scaleNodes"][i]);
                                    data.scaleNodes.push(node);
                                }
                            }
                            if (_data["simulationSpeed"] != undefined) {
                                data.simulationSpeed = this._parseToObjData("simulationSpeed", _data["simulationSpeed"]);
                            }
                            if (_data["alpha"] != undefined)
                                data.alpha = this._parseToObjData("alpha", _data["alpha"]);
                            if (_data["alphaSpeed"] != undefined)
                                data.alphaSpeed = this._parseToObjData("alphaSpeed", _data["alphaSpeed"]);
                            if (_data["alphaNodes"] != undefined) {
                                data.alphaNodes = [];
                                if (data.alpha != undefined) {
                                    data.alphaNodes.push(data.alpha);
                                    data.alpha.key = 0;
                                }
                                for (var i in _data["alphaNodes"]) {
                                    var node = framework.EffectUtil.parseEffectNum(_data["alphaNodes"][i]);
                                    data.alphaNodes.push(node);
                                }
                            }
                            if (_data["color"] != undefined)
                                data.color = this._parseToObjData("color", _data["color"]);
                            if (_data["colorSpeed"] != undefined)
                                data.colorSpeed = this._parseToObjData("colorSpeed", _data["colorSpeed"]);
                            if (_data["colorNodes"] != undefined) {
                                data.colorNodes = [];
                                if (data.color != undefined) {
                                    data.colorNodes.push(data.color);
                                    data.color.key = 0;
                                }
                                for (var i in _data["colorNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["colorNodes"][i]);
                                    data.colorNodes.push(node);
                                }
                            }
                            if (_data["uv"] != undefined) {
                                data.uv = framework.EffectUtil.parseEffectVec2(_data["uv"]);
                            }
                            if (_data["uvtype"] != undefined) {
                                switch (_data["uvtype"]) {
                                    case "uvroll":
                                        data.uvType = framework.UVTypeEnum.UVRoll;
                                        if (_data["uvroll"] != undefined) {
                                            data.uvRoll = new framework.UVRollNew();
                                            data.uvRoll.uvSpeed = framework.EffectUtil.parseEffectUVSpeed(_data["uvroll"]);
                                        }
                                        break;
                                    case "uvsprite":
                                        var _val = _data["uvsprite"];
                                        data.uvType = framework.UVTypeEnum.UVSprite;
                                        data.uvSprite = new framework.UVSpriteNew();
                                        if (_val["row"] != undefined)
                                            data.uvSprite.row = _val["row"];
                                        if (_val["colum"] != undefined)
                                            data.uvSprite.column = _val["colum"];
                                        if (_val["count"] != undefined)
                                            data.uvSprite.totalCount = _val["count"];
                                        break;
                                    default:
                                        data.uvType = framework.UVTypeEnum.NONE;
                                        break;
                                }
                            }
                            else
                                data.uvType = framework.UVTypeEnum.NONE;
                            if (_data["billboard"] != undefined)
                                data.renderModel = this._parseToObjData("billboard", _data["billboard"]);
                            if (_data["life"] != undefined)
                                data.life = framework.EffectUtil.parseEffectValueData(_data["life"]);
                            if (_data["startpos"] != undefined) {
                                this._parseEmissionShape(_data["startpos"], element);
                            }
                        }
                    }
                }
            };
            EffectParser.prototype._parseEmissionShape = function (_startdata, element) {
                var startdata = element.emissionData.particleStartData;
                if (_startdata["center"] != undefined) {
                    var _startpos = _startdata["center"];
                    startdata.position.x = _startpos["0"];
                    startdata.position.y = _startpos["1"];
                    startdata.position.z = _startpos["2"];
                }
                switch (_startdata["type"]) {
                    case "normal":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.NORMAL;
                        break;
                    case "box":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.BOX;
                        break;
                    case "sphere":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.SPHERE;
                        break;
                    case "hemisphere":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.HEMISPHERE;
                        break;
                    case "cone":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.CONE;
                        break;
                    case "circle":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.CIRCLE;
                        break;
                    case "edge":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.EDGE;
                        break;
                    default:
                        break;
                }
                if (_startdata["bottomradius"] != undefined) {
                    startdata.bottomRadius = _startdata["bottomradius"];
                }
                if (_startdata["width"] != undefined) {
                    startdata.width = _startdata["width"];
                }
                if (_startdata["height"] != undefined) {
                    startdata.height = _startdata["height"];
                }
                if (_startdata["depth"] != undefined) {
                    startdata.depth = _startdata["depth"];
                }
                if (_startdata["angle"] != undefined) {
                    startdata.angle = _startdata["angle"];
                }
                if (_startdata["radius"] != undefined) {
                    startdata.radius = _startdata["radius"];
                }
                if (_startdata["direction"] != undefined) {
                    var _startdir = _startdata["direction"];
                    startdata.direction.x = _startdir["0"];
                    startdata.direction.y = _startdir["1"];
                    startdata.direction.z = _startdir["2"];
                }
            };
            EffectParser.prototype._parseToObjData = function (attrib, content) {
                switch (attrib) {
                    case "pos":
                    case "scale":
                    case "euler":
                    case "color":
                    case "moveSpeed":
                    case "eulerSpeed":
                    case "scaleSpeed":
                    case "colorSpeed":
                        return framework.EffectUtil.parseEffectVec3(content);
                    case "":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "alphaSpeed":
                    case "alpha":
                    case "simulationSpeed":
                        return framework.EffectUtil.parseEffectNum(content);
                    case "tilling":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "mat":
                        var mat = new framework.EffectMatData();
                        if (content != undefined) {
                            if (content["shader"] != undefined)
                                mat.shader = this.asMgr.getShader(content["shader"]);
                            else
                                mat.shader = this.asMgr.getShader("shader/def");
                            if (content["diffuseTexture"] != undefined)
                                mat.diffuseTexture = this.asMgr.getAssetByName(content["diffuseTexture"]);
                            if (content["alphaCut"] != undefined)
                                mat.alphaCut = content["alphaCut"];
                        }
                        return mat;
                    case "emmision":
                        var emission = new framework.EmissionData();
                        if (content["type"] != undefined)
                            emission.type = content["type"];
                        if (content["time"] != undefined)
                            emission.time = content["time"];
                        if (content["count"] != undefined)
                            emission.count = content["count"];
                        return emission;
                    case "billboard":
                        var billboardType = framework.RenderModel.Mesh;
                        if (content == "billboard") {
                            billboardType = framework.RenderModel.BillBoard;
                        }
                        else if (content == "horizontal") {
                            billboardType = framework.RenderModel.HorizontalBillBoard;
                        }
                        else if (content == "stretched") {
                            billboardType = framework.RenderModel.StretchedBillBoard;
                        }
                        else if (content == "vertical") {
                            billboardType = framework.RenderModel.VerticalBillBoard;
                        }
                        else if (content == "mesh") {
                            billboardType = framework.RenderModel.Mesh;
                        }
                        else {
                            billboardType = framework.RenderModel.None;
                        }
                        return billboardType;
                    case "mesh":
                        var str = content;
                        if (content.toString().indexOf(".mesh.bin") >= 0)
                            return this.asMgr.getAssetByName(content);
                        else
                            return this.asMgr.getDefaultMesh(content);
                    default:
                        return content;
                }
            };
            EffectParser.prototype._parseToParticleNode = function (content) {
                content = framework.StringUtil.replaceAll(content, " ", "");
                var charArray = content.match(framework.RegexpUtil.vector3FloatOrRangeRegexp);
                if (charArray != undefined) {
                    var node = new framework.ParticleNode();
                    for (var i = 1; i < charArray.length; i++) {
                        if (i == 1) {
                            node.x = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 2) {
                            node.y = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 3) {
                            node.z = this._parseToValueData(charArray[i]);
                        }
                    }
                    return node;
                }
                return null;
            };
            EffectParser.prototype._parseToValueData = function (content) {
                var data = new framework.ValueData();
                var array = this._parseToNumberArray(content);
                if (array != null) {
                    if (array.length > 1) {
                        data.valueLimitMin = array[0];
                        data.valueLimitMax = array[1];
                        data.isRandom = true;
                    }
                    else {
                        data.value = array[0];
                        data.isRandom = false;
                    }
                }
                return data;
            };
            EffectParser.prototype._parseToNumberArray = function (content) {
                content = framework.StringUtil.trimAll(content);
                content = framework.StringUtil.replaceAll(content, "\\[", "");
                content = framework.StringUtil.replaceAll(content, "\\]", "");
                var _array = content.split(",");
                var result = [];
                for (var i = 0; i < _array.length; i++) {
                    result.push(parseInt(_array[i]));
                }
                return result;
            };
            return EffectParser;
        }());
        framework.EffectParser = EffectParser;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectUtil = (function () {
            function EffectUtil() {
            }
            EffectUtil.RandomRange = function (min, max, isInteger) {
                if (isInteger === void 0) { isInteger = false; }
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            };
            EffectUtil.vecMuliNum = function (vec, num) {
                var v = new gd3d.math.vector3(vec.x * num, vec.y * num, vec.z * num);
                return v;
            };
            EffectUtil.parseEffectVec3 = function (value) {
                var node = new framework.ParticleNode();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectVec2 = function (value) {
                var node = new framework.ParticleNodeVec2();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectNum = function (value) {
                var node = new framework.ParticleNodeNumber();
                if (value instanceof Array) {
                    node.num.valueLimitMin = value[0];
                    node.num.valueLimitMax = value[1];
                    node.num.isRandom = true;
                }
                else {
                    node.num.value = value;
                    node.num.isRandom = false;
                }
                return node;
            };
            EffectUtil.parseEffectValueData = function (value) {
                var val = new framework.ValueData();
                if (value instanceof Array) {
                    val.valueLimitMin = value[0];
                    val.valueLimitMax = value[1];
                    val.isRandom = true;
                }
                else {
                    val.value = value;
                    val.isRandom = false;
                }
                return val;
            };
            EffectUtil.parseEffectUVSpeed = function (value) {
                var node = new framework.UVSpeedNode();
                for (var key in value) {
                    node[key].value = value[key];
                }
                return node;
            };
            EffectUtil.lookat = function (eye, targetpos, out, up) {
                if (up === void 0) { up = gd3d.math.pool.vector3_up; }
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var unitprojectedXZ = new gd3d.math.vector3(dir.x, 0, dir.z);
                gd3d.math.vec3Normalize(unitprojectedXZ, unitprojectedXZ);
                var yaw = Math.acos(unitprojectedXZ.z) / Math.PI * 180;
                if (unitprojectedXZ.x < 0) {
                    yaw = -yaw;
                }
                gd3d.math.quatFromAxisAngle(up, yaw, out);
                var right = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(up, dir, right);
                gd3d.math.vec3Normalize(right, right);
                var projectedXZ = new gd3d.math.vector3(dir.x, 0, dir.z);
                var length = gd3d.math.vec3Length(projectedXZ);
                var pitch = Math.acos(length) / Math.PI * 180;
                if (dir.y < 0) {
                    pitch = -pitch;
                }
                var quadRight = gd3d.math.pool.new_quaternion();
                gd3d.math.quatFromAxisAngle(right, pitch, quadRight);
            };
            EffectUtil.RotateVector3 = function (source, direction, out) {
                gd3d.math.vec3Normalize(source, source);
                gd3d.math.vec3Normalize(direction, direction);
                var forward = new gd3d.math.vector3(0, 0, 1);
                var axis = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(forward, direction, axis);
                gd3d.math.vec3Normalize(axis, axis);
                if (axis.x == 0 && axis.y == 0 && axis.z == 0) {
                    axis.x = 1;
                    axis.y = 0;
                    axis.z = 0;
                }
                var cos = gd3d.math.vec3Dot(forward, direction);
                var angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                var quatertion = gd3d.math.pool.new_quaternion();
                gd3d.math.quatFromAxisAngle(axis, angle, quatertion);
                gd3d.math.quatTransformVector(quatertion, source, out);
                gd3d.math.pool.delete_vector3(axis);
                gd3d.math.pool.delete_quaternion(quatertion);
            };
            EffectUtil.bindAxisBillboard = function (localAxis, out) {
                gd3d.math.vec3Normalize(localAxis, localAxis);
                var yAxis = gd3d.math.pool.vector3_up;
                var normal = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(yAxis, localAxis, normal);
                gd3d.math.vec3Normalize(normal, normal);
                if (normal.x == 0 && normal.y == 0 && normal.z == 0) {
                    normal.x = 1;
                    normal.y = 0;
                    normal.z = 0;
                }
                var cos = gd3d.math.vec3Dot(yAxis, localAxis);
                var angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                gd3d.math.quatFromAxisAngle(normal, angle, out);
            };
            EffectUtil.lookatVerticalBillboard = function (eye, targetpos, out, up) {
                if (up === void 0) { up = gd3d.math.pool.vector3_up; }
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var dirxz = new gd3d.math.vector3(dir.x, 0, dir.z);
                gd3d.math.vec3Normalize(dirxz, dirxz);
                var yaw = Math.acos(dirxz.z) / Math.PI * 180;
                if (dirxz.x < 0) {
                    yaw = -yaw;
                }
                gd3d.math.quatFromAxisAngle(up, yaw, out);
            };
            EffectUtil.quatLookatZ = function (eye, targetpos, out, forward) {
                if (forward === void 0) { forward = gd3d.math.pool.vector3_forward; }
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var dirxy = new gd3d.math.vector3(-dir.x, dir.y, 0);
                gd3d.math.vec3Normalize(dirxy, dirxy);
                var roll = Math.acos(dirxy.y) / Math.PI * 180;
                if (dirxy.x < 0) {
                    roll = -roll;
                }
                gd3d.math.quatFromAxisAngle(forward, roll, out);
            };
            EffectUtil.quatLookatX = function (eye, targetpos, out, right) {
                if (right === void 0) { right = gd3d.math.pool.vector3_right; }
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var diryz = new gd3d.math.vector3(0, -dir.y, dir.z);
                gd3d.math.vec3Normalize(diryz, diryz);
                var pitch = Math.acos(diryz.z) / Math.PI * 180;
                if (diryz.y < 0) {
                    pitch = -pitch;
                }
                gd3d.math.quatFromAxisAngle(right, pitch, out);
            };
            return EffectUtil;
        }());
        framework.EffectUtil = EffectUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var MeshBatcher = (function () {
            function MeshBatcher(mat, maxvercout, particle) {
                if (maxvercout === void 0) { maxvercout = 128; }
                this.bufferInit = false;
                this._maxvercount = 0;
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.bdispose = false;
                this._material = mat;
                this.particleSystem = particle;
                this.groupMesh = new gd3d.framework.mesh();
                this.groupMesh.data = new gd3d.render.meshData();
                this.groupMesh.glMesh = new gd3d.render.glMesh();
                this.parlist = new Array();
                this._vercount = 0;
                this._indexcount = 0;
                this.maxvercount = maxvercout;
                this.total = gd3d.render.meshData.calcByteSize(this.vf) / 4;
            }
            Object.defineProperty(MeshBatcher.prototype, "vercount", {
                get: function () {
                    return this._vercount;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshBatcher.prototype, "indexcount", {
                get: function () {
                    return this._indexcount;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MeshBatcher.prototype, "maxvercount", {
                get: function () {
                    return this._maxvercount;
                },
                set: function (value) {
                    if (this._maxvercount > value)
                        return;
                    this._maxvercount = value;
                    this.dataForVbo = new Float32Array(15 * this._maxvercount);
                    this.dataForEbo = new Uint16Array(3 * this._maxvercount);
                },
                enumerable: true,
                configurable: true
            });
            MeshBatcher.prototype.AddP = function (particle) {
                particle.vertexStartIndex = this._vercount;
                var shapeMesh = particle.mesh;
                var total = this.total;
                var vertexCount = particle.mesh.data.pos.length;
                for (var i_5 = 0; i_5 < vertexCount; i_5++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = particle.vertexArr[i_5 * 15 + 0];
                        vertex.y = particle.vertexArr[i_5 * 15 + 1];
                        vertex.z = particle.vertexArr[i_5 * 15 + 2];
                        gd3d.math.matrixTransformVector3(vertex, particle.localMatrix, vertex);
                        this.dataForVbo[(particle.vertexStartIndex + i_5) * 15 + 0] = vertex.x;
                        this.dataForVbo[(particle.vertexStartIndex + i_5) * 15 + 1] = vertex.y;
                        this.dataForVbo[(particle.vertexStartIndex + i_5) * 15 + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        this.dataForVbo[(this._vercount + i_5) * total + 3] = particle.vertexArr[i_5 * total + 3];
                        this.dataForVbo[(this._vercount + i_5) * total + 4] = particle.vertexArr[i_5 * total + 4];
                        this.dataForVbo[(this._vercount + i_5) * total + 5] = particle.vertexArr[i_5 * total + 5];
                    }
                    {
                        this.dataForVbo[(this._vercount + i_5) * total + 6] = particle.vertexArr[i_5 * total + 6];
                        this.dataForVbo[(this._vercount + i_5) * total + 7] = particle.vertexArr[i_5 * total + 7];
                        this.dataForVbo[(this._vercount + i_5) * total + 8] = particle.vertexArr[i_5 * total + 8];
                    }
                    {
                        particle.color.x = Math.min(particle.color.x, 1);
                        particle.color.y = Math.min(particle.color.y, 1);
                        particle.color.z = Math.min(particle.color.z, 1);
                        this.dataForVbo[(particle.vertexStartIndex + i_5) * 15 + 9] = particle.color.x;
                        this.dataForVbo[(particle.vertexStartIndex + i_5) * 15 + 10] = particle.color.y;
                        this.dataForVbo[(particle.vertexStartIndex + i_5) * 15 + 11] = particle.color.z;
                        this.dataForVbo[(particle.vertexStartIndex + i_5) * 15 + 12] = particle.color.w;
                    }
                    {
                        if (this.particleSystem.particleMethodType == framework.ParticleMethodType.UVSPRITE) {
                            var temptUV = gd3d.math.pool.new_vector2();
                            temptUV.x = particle.curTextureOffset.x * particle.vertexArr[i_5 * total + 13] * particle.materialData.tiling.x + particle.curTextureOffset.z + particle.materialData.offset.x;
                            temptUV.y = particle.curTextureOffset.y * particle.vertexArr[i_5 * total + 14] * particle.materialData.tiling.y + particle.curTextureOffset.w + particle.materialData.offset.y;
                            this.dataForVbo[(this._vercount + i_5) * total + 13] = temptUV.x;
                            this.dataForVbo[(this._vercount + i_5) * total + 14] = temptUV.y;
                            gd3d.math.pool.delete_vector2(temptUV);
                        }
                        else {
                            this.dataForVbo[(this._vercount + i_5) * total + 13] = particle.vertexArr[i_5 * total + 13] * particle.materialData.tiling.x + particle.materialData.offset.x;
                            this.dataForVbo[(this._vercount + i_5) * total + 14] = particle.vertexArr[i_5 * total + 14] * particle.materialData.tiling.y + particle.materialData.offset.y;
                        }
                    }
                }
                var ParticleIndexArr = shapeMesh.data.genIndexDataArray();
                for (var i = 0; i < ParticleIndexArr.length; i++) {
                    this.dataForEbo[this._indexcount + i] = ParticleIndexArr[i] + this._vercount;
                }
                this._vercount += vertexCount;
                this._indexcount += ParticleIndexArr.length;
                this.parlist.push(particle);
            };
            MeshBatcher.prototype.addParticle = function (particleMesh, particleData) {
                var particle = new Particle(particleMesh, particleData, this);
                if (particle != null) {
                    this.AddP(particle);
                }
                return particle;
            };
            MeshBatcher.prototype.update = function (delta) {
                if (this.bdispose)
                    return;
                for (var n = 0; n < this.parlist.length; n++) {
                    var particle = this.parlist[n];
                    if (!particle.isinit)
                        continue;
                    var vertexCount = particle.mesh.data.pos.length;
                    for (var i = 0; i < vertexCount; i++) {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = particle.vertexArr[i * 15 + 0];
                        vertex.y = particle.vertexArr[i * 15 + 1];
                        vertex.z = particle.vertexArr[i * 15 + 2];
                        if (this.particleSystem.isTrail) {
                            var temptMatrixToWorld = gd3d.math.pool.new_matrix();
                            gd3d.math.matrixMultiply(particle.trailMatrix, particle.localMatrix, temptMatrixToWorld);
                            gd3d.math.matrixTransformVector3(vertex, temptMatrixToWorld, vertex);
                            gd3d.math.pool.delete_matrix(temptMatrixToWorld);
                        }
                        else {
                            gd3d.math.matrixTransformVector3(vertex, particle.localMatrix, vertex);
                        }
                        this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 0] = vertex.x;
                        this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 1] = vertex.y;
                        this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 2] = vertex.z;
                        particle.color.x = Math.min(particle.color.x, 1);
                        particle.color.y = Math.min(particle.color.y, 1);
                        particle.color.z = Math.min(particle.color.z, 1);
                        this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 9] = particle.color.x;
                        this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 10] = particle.color.y;
                        this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 11] = particle.color.z;
                        this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 12] = particle.color.w;
                        if (this.particleSystem.particleMethodType == framework.ParticleMethodType.UVROLL || this.particleSystem.particleMethodType == framework.ParticleMethodType.UVSPRITE) {
                            var temptUV = gd3d.math.pool.new_vector2();
                            temptUV.x = particle.curTextureOffset.x * particle.vertexArr[i * this.total + 13] * particle.materialData.tiling.x + particle.curTextureOffset.z + particle.materialData.offset.x;
                            temptUV.y = particle.curTextureOffset.y * particle.vertexArr[i * this.total + 14] * particle.materialData.tiling.y + particle.curTextureOffset.w + particle.materialData.offset.y;
                            this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 13] = temptUV.x;
                            this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 14] = temptUV.y;
                            gd3d.math.pool.delete_vector2(temptUV);
                        }
                        else {
                            this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 13] = particle.vertexArr[i * 15 + 13] * particle.materialData.tiling.x + particle.materialData.offset.x;
                            this.dataForVbo[(particle.vertexStartIndex + i) * 15 + 14] = particle.vertexArr[i * 15 + 14] * particle.materialData.tiling.y + particle.materialData.offset.y;
                        }
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                }
            };
            MeshBatcher.prototype.render = function (context, assetmgr) {
                if (this.particleSystem.isTrail) {
                    context.updateModeTrail();
                }
                else {
                    context.updateModel(this.particleSystem.gameObject.transform);
                }
                if (!this.bufferInit) {
                    this.groupMesh.glMesh.initBuffer(context.webgl, this.vf, this.maxvercount);
                    this.bufferInit = true;
                }
                this.groupMesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                this.groupMesh.glMesh.addIndex(context.webgl, this.dataForEbo.length);
                this.groupMesh.glMesh.uploadIndexSubData(context.webgl, 0, this.dataForEbo);
                this.groupMesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.groupMesh.submesh.push(sm);
                }
                this._material.draw(context, this.groupMesh, sm, "base");
            };
            MeshBatcher.prototype.dispose = function () {
                if (this.groupMesh != null) {
                    if (!this.bdispose) {
                        this.bdispose = true;
                    }
                    this.groupMesh.dispose();
                }
                this.dataForEbo = null;
                this.dataForVbo = null;
                for (var k in this.parlist) {
                    this.parlist[k].dispose();
                }
                this.parlist.length = 0;
            };
            return MeshBatcher;
        }());
        framework.MeshBatcher = MeshBatcher;
        var Particle = (function () {
            function Particle(_shape, particleData, MeshBatcher) {
                this._color = new gd3d.math.vector4();
                this.infinite = false;
                this.speed = 0;
                this.speedDir = new gd3d.math.vector3(0, 0, 0);
                this.delayTime = 0;
                this.time = 0;
                this.velocity = new gd3d.math.vector3(0, 0, 0);
                this.acceleration = new gd3d.math.vector3(0, 0, 0);
                this.angularVelocity = new gd3d.math.vector3(0, 0, 0);
                this.gravitySpeed = 0;
                this.gravityModifier = 0;
                this.localAxisX = new gd3d.math.vector3(1, 0, 0);
                this.localAxisY = new gd3d.math.vector3(0, 1, 0);
                this.localAxisZ = new gd3d.math.vector3(0, 0, 1);
                this.startPosition = new gd3d.math.vector3(0, 0, 0);
                this.curPosition = new gd3d.math.vector3(0, 0, 0);
                this.startPitchYawRoll = new gd3d.math.vector3();
                this.rotation_start = new gd3d.math.quaternion();
                this.rotation_shape = new gd3d.math.quaternion();
                this.rotationToCamera = gd3d.math.pool.new_quaternion();
                this.rotation_overLifetime = new gd3d.math.quaternion();
                this.rotation_overLifetime_temp = new gd3d.math.quaternion();
                this.rotation = new gd3d.math.quaternion();
                this.localRotation = new gd3d.math.quaternion();
                this.worldRotation = new gd3d.math.quaternion();
                this.localMatrix = new gd3d.math.matrix();
                this.worldMatrix = new gd3d.math.matrix();
                this.interpType = framework.ParticleCurveType.CURVE;
                this.bindAxis = false;
                this.bindx = false;
                this.bindy = false;
                this.bindz = false;
                this.RotAngle = 0;
                this.displacement = new gd3d.math.vector3();
                this._tempVec3 = new gd3d.math.vector3();
                this.curTextureOffset = new gd3d.math.vector4();
                this.mesh = _shape;
                this.clear();
                this.meshBatcher = MeshBatcher;
                this.particleSyTrans = this.meshBatcher.particleSystem.gameObject.transform;
                this.camera = MeshBatcher.camera;
                this.cameraTransform = this.camera.gameObject.transform;
                this.particleDetailData = particleData.particleDetailData;
                this.materialData = particleData.materialData;
                this.localMatrix = new gd3d.math.matrix();
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.vertexArr = _shape.data.genVertexDataArray(vf);
                this.parseByData();
                if (this.meshBatcher.particleSystem.isTrail) {
                    this.recordTrailMatrix();
                }
            }
            Object.defineProperty(Particle.prototype, "localTranslate", {
                get: function () {
                    return this._localTranslate;
                },
                set: function (value) {
                    this._localTranslate = value;
                    this.curPosition = this._localTranslate;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Particle.prototype, "alpha", {
                get: function () {
                    return this._alpha;
                },
                set: function (value) {
                    this._alpha = value;
                    this._color.w = this._alpha;
                    this.startAlphaNode = new EffectAlphaNode(0, this._alpha);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Particle.prototype, "localScale", {
                get: function () {
                    return this._scale;
                },
                set: function (value) {
                    this._scale = value;
                    this._scale_temp = gd3d.math.pool.clone_vector3(this._scale);
                    this.startScaleNode = new EffectScaleNode(0, this._scale_temp);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Particle.prototype, "uvSpeed", {
                get: function () {
                    return this._uvSpeed;
                },
                set: function (value) {
                    this._uvSpeed = value;
                    this._uvSpeed_temp = gd3d.math.pool.clone_vector2(this._uvSpeed);
                    this.startUVSpeedNode = new EffectUVSpeedNode(0, this._uvSpeed_temp);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Particle.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._color = value;
                    this._color_temp = gd3d.math.pool.clone_vector4(this._color);
                    this.startColorNode = new EffectColorNode(0, this._color_temp);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Particle.prototype, "alive", {
                get: function () {
                    return this._alive;
                },
                set: function (value) {
                    this._alive = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Particle.prototype, "lifeLocation", {
                get: function () {
                    if (this.infinite) {
                        return (this.curlifeTime % this.lifeTime) / this.lifeTime;
                    }
                    else {
                        return this.curlifeTime / this.lifeTime;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Particle.prototype.recordTrailMatrix = function () {
                if (this.trailMatrix == undefined) {
                    this.trailMatrix = gd3d.math.pool.new_matrix();
                }
                gd3d.math.matrixClone(this.meshBatcherWorldMatrix, this.trailMatrix);
            };
            Particle.prototype.parseByData = function () {
                var p = this.particleDetailData;
                this.lookatcam = p.isLookAtCamera;
                this.isloop = p.isLoop;
                this.gravityModifier = p.gravity.getValue();
                this.gravitySpeed = p.gravitySpeed.getValue();
                this.lifeTime = p.life.getValue();
                this.speed = p.speed.getValue();
                this._color_temp = gd3d.math.pool.new_vector4();
                this._color_temp.x = p.color.x.getValue();
                this._color_temp.y = p.color.y.getValue();
                this._color_temp.z = p.color.z.getValue();
                this.color = this._color_temp;
                this.velocity = gd3d.math.pool.clone_vector3(p.velocity.getValue());
                this.acceleration = gd3d.math.pool.clone_vector3(p.acceleration.getValue());
                this.angularVelocity = gd3d.math.pool.clone_vector3(p.angularVelocity.getValue());
                this.angularVelocityForBillboard = p.angleSpeedForbillboard.getValue();
                this.centerPosition = gd3d.math.pool.clone_vector3(p.particleStartData.position);
                var randomDirection = gd3d.math.pool.clone_vector3(p.particleStartData.randomDirection);
                gd3d.math.vec3Clone(randomDirection, this.speedDir);
                gd3d.math.vec3Normalize(this.speedDir, this.speedDir);
                gd3d.math.vec3Clone(this.centerPosition, this.localTranslate);
                var randomPosition = gd3d.math.pool.clone_vector3(p.particleStartData.randomPosition);
                gd3d.math.vec3Add(this.localTranslate, randomPosition, this.localTranslate);
                gd3d.math.pool.delete_vector3(randomPosition);
                this.delayTime = p.delayTime.getValue();
                gd3d.math.vec3Clone(p.scale.getValue(), this.localScale);
                for (var i = 0; i < p.scaleNode.length; i++) {
                    var v = p.scaleNode[i];
                    var tscalenode = new EffectScaleNode(v.key, v.getValue());
                    this.addScaleNode(tscalenode);
                }
                for (var i = 0; i < p.colorNode.length; i++) {
                    var v = p.colorNode[i];
                    var tcolornode = new EffectColorNode(v.key, v.getValue());
                    this.addColorNode(tcolornode);
                }
                this.alpha = p.alpha.getValue();
                for (var i = 0; i < p.alphaNode.length; i++) {
                    var vv = p.alphaNode[i].alpha.getValue();
                    var talphanode = new EffectAlphaNode(p.alphaNode[i].key, vv);
                    this.addAlphaNode(talphanode);
                }
                this.interpType = p.interpolationType;
                if (this.interpType == framework.ParticleCurveType.LINEAR) {
                    this.curve = framework.Curve3.GetLerpBezier(p.positionNode);
                }
                else {
                    if (p.positionNode.length == 2) {
                        this.curve = gd3d.framework.Curve3.CreateQuadraticBezier(this.localTranslate, p.positionNode[0].getValue(), p.positionNode[1].getValue(), 20);
                    }
                    else if (p.positionNode.length == 3) {
                        this.curve = gd3d.framework.Curve3.CreateCubicBezier(this.localTranslate, p.positionNode[0].getValue(), p.positionNode[1].getValue(), p.positionNode[2].getValue(), 20);
                    }
                }
                this.bindAxis = p.bindAxis;
                this.bindx = p.bindx;
                this.bindy = p.bindy;
                this.bindz = p.bindz;
                this.infinite = p.infinite;
                this.renderModel = p.renderModel;
                this.isRotation = p.isRotation;
                this.meshBatcherWorldMatrix = this.particleSyTrans.getWorldMatrix();
                gd3d.math.vec3Clone(p.startPitchYawRoll.getValue(), this.startPitchYawRoll);
                gd3d.math.quatFromEulerAngles(this.startPitchYawRoll.x, this.startPitchYawRoll.y, this.startPitchYawRoll.z, this.rotation_start);
                gd3d.math.quatNormalize(this.rotation_start, this.rotation_start);
                gd3d.math.quatClone(this.rotation_start, this.localRotation);
                if (this.renderModel == framework.RenderModel.StretchedBillBoard) {
                    var targetPos = new gd3d.math.vector3();
                    var worldpos = new gd3d.math.vector3();
                    var quatWorld = new gd3d.math.quaternion();
                    var parentrot = new gd3d.math.quaternion();
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.meshBatcherWorldMatrix, worldpos);
                    if (gd3d.math.vec3Length(this.speedDir) > 0) {
                        gd3d.math.vec3Add(worldpos, this.speedDir, targetPos);
                        gd3d.math.quat2Lookat(worldpos, targetPos, quatWorld);
                        var pRot = this.particleSyTrans.getWorldRotate();
                        gd3d.math.quatClone(pRot, parentrot);
                        gd3d.math.quatInverse(parentrot, parentrot);
                        gd3d.math.quatMultiply(parentrot, quatWorld, this.localRotation);
                        var initRot = new gd3d.math.quaternion();
                        gd3d.math.quatFromEulerAngles(90, 0, 0, initRot);
                        gd3d.math.quatMultiply(this.localRotation, initRot, this.localRotation);
                    }
                }
                this.updaterot(0);
                gd3d.math.pool.delete_vector3(randomDirection);
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.particleDetailData.particleMethodType == framework.ParticleMethodType.UVROLL) {
                    this.uvSpeed = gd3d.math.pool.clone_vector2(this.particleDetailData.uvRoll.uvSpeed.getValue());
                    for (var i = 0; i < this.particleDetailData.uvRoll.uvSpeedNodes.length; i++) {
                        var uvspeed = this.particleDetailData.uvRoll.uvSpeedNodes[i];
                        var uvspednode = new EffectUVSpeedNode(uvspeed.key, uvspeed.getValue());
                        this.addUVSpeedNode(uvspednode);
                    }
                }
                if (this.particleDetailData.particleMethodType == framework.ParticleMethodType.UVSPRITE) {
                    this.updateUVSpriteAnimation(0);
                }
                this.isinit = true;
            };
            Particle.prototype.updaterot = function (delta) {
                var quatWorld = gd3d.math.pool.new_quaternion();
                var worldpos = gd3d.math.pool.new_vector3();
                var targetpos = gd3d.math.pool.new_vector3();
                var parentrot = gd3d.math.pool.new_quaternion();
                var lookRot = gd3d.math.pool.new_quaternion();
                var angleRot = gd3d.math.pool.new_quaternion();
                if (this.renderModel == framework.RenderModel.Mesh) {
                    if (this.lookatcam) {
                        gd3d.math.matrixTransformVector3(this.localTranslate, this.meshBatcherWorldMatrix, worldpos);
                        gd3d.math.vec3Clone(this.cameraTransform.getWorldTranslate(), targetpos);
                        gd3d.math.quatLookat(worldpos, targetpos, quatWorld);
                        var pRot = this.particleSyTrans.getWorldRotate();
                        gd3d.math.quatClone(pRot, parentrot);
                        gd3d.math.quatInverse(parentrot, parentrot);
                        gd3d.math.quatMultiply(parentrot, quatWorld, lookRot);
                        this.RotAngle += delta * this.angularVelocity.z;
                        gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.RotAngle, angleRot);
                        gd3d.math.quatMultiply(lookRot, angleRot, this.localRotation);
                    }
                    else {
                        var Anglex = delta * this.angularVelocity.x;
                        var Angley = delta * this.angularVelocity.y;
                        var Anglez = delta * this.angularVelocity.z;
                        if (this.bindAxis) {
                            if (this.bindx)
                                Anglex = 0;
                            if (this.bindy)
                                Angley = 0;
                            if (this.bindz)
                                Anglez = 0;
                        }
                        gd3d.math.quatFromEulerAngles(Anglex, Angley, Anglez, angleRot);
                        gd3d.math.quatMultiply(this.localRotation, angleRot, this.localRotation);
                    }
                }
                else {
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.meshBatcherWorldMatrix, worldpos);
                    if (this.renderModel == framework.RenderModel.BillBoard) {
                        gd3d.math.vec3Clone(this.cameraTransform.getWorldTranslate(), targetpos);
                        gd3d.math.quatLookat(worldpos, targetpos, quatWorld);
                    }
                    else if (this.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        quatWorld.x = -0.5;
                        quatWorld.y = 0.5;
                        quatWorld.z = 0.5;
                        quatWorld.w = 0.5;
                    }
                    else if (this.renderModel == framework.RenderModel.VerticalBillBoard) {
                        gd3d.math.vec3Clone(this.cameraTransform.getWorldTranslate(), targetpos);
                        targetpos.y = worldpos.y;
                        gd3d.math.quatLookat(worldpos, targetpos, quatWorld);
                    }
                    else if (this.renderModel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.quatLookat(worldpos, this.cameraTransform.getWorldTranslate(), quatWorld);
                        var pRot = this.particleSyTrans.getWorldRotate();
                        gd3d.math.quatClone(pRot, parentrot);
                        gd3d.math.quatInverse(parentrot, parentrot);
                        gd3d.math.quatMultiply(parentrot, quatWorld, lookRot);
                        var inverRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatInverse(this.localRotation, inverRot);
                        gd3d.math.quatMultiply(inverRot, lookRot, lookRot);
                        var angle = gd3d.math.pool.new_vector3();
                        gd3d.math.quatToEulerAngles(lookRot, angle);
                        gd3d.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        gd3d.math.quatMultiply(this.localRotation, lookRot, this.localRotation);
                        gd3d.math.pool.delete_vector3(worldpos);
                        gd3d.math.pool.delete_vector3(targetpos);
                        gd3d.math.pool.delete_quaternion(quatWorld);
                        gd3d.math.pool.delete_quaternion(parentrot);
                        gd3d.math.pool.delete_quaternion(angleRot);
                        gd3d.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    var pRot = this.particleSyTrans.getWorldRotate();
                    gd3d.math.quatClone(pRot, parentrot);
                    gd3d.math.quatInverse(parentrot, parentrot);
                    gd3d.math.quatMultiply(parentrot, quatWorld, lookRot);
                    this.RotAngle += delta * this.angularVelocityForBillboard;
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.RotAngle, angleRot);
                    gd3d.math.quatMultiply(lookRot, angleRot, this.localRotation);
                }
                gd3d.math.pool.delete_vector3(worldpos);
                gd3d.math.pool.delete_vector3(targetpos);
                gd3d.math.pool.delete_quaternion(quatWorld);
                gd3d.math.pool.delete_quaternion(parentrot);
                gd3d.math.pool.delete_quaternion(angleRot);
                gd3d.math.pool.delete_quaternion(lookRot);
            };
            Particle.prototype.updatematrix = function () {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
            };
            Particle.prototype.addUVSpeedNode = function (node) {
                this.listUvSpeedNode.push(node);
            };
            Particle.prototype.resetMatrix = function () {
                gd3d.math.matrixZero(this.localMatrix);
            };
            Particle.prototype.addAlphaNode = function (node) {
                this.listAlphaNode.push(node);
            };
            Particle.prototype.addColorNode = function (node) {
                this.listColorNode.push(node);
            };
            Particle.prototype.addScaleNode = function (node) {
                this.listScaleNode.push(node);
            };
            Particle.prototype.updategravity = function (deltaTime) {
                this.gravitySpeed = this.gravitySpeed + this.gravityModifier * -9.8 * deltaTime;
                this.localTranslate.y += this.gravitySpeed * deltaTime;
            };
            Particle.prototype.updateForce = function (delta) {
                this.velocity.x = this.velocity.x + this.acceleration.x * delta;
                this.velocity.y = this.velocity.y + this.acceleration.y * delta;
                this.velocity.z = this.velocity.z + this.acceleration.z * delta;
                this.displacement.x = this.velocity.x * delta;
                this.displacement.y = this.velocity.y * delta;
                this.displacement.z = this.velocity.z * delta;
                gd3d.math.vec3Add(this.localTranslate, this.displacement, this.localTranslate);
            };
            Particle.prototype.updateposition = function (deltaTime) {
                if (this.curve != null) {
                    if (this.curve.beizerPoints.length > 0) {
                        if (this.lifeLocation >= (this.curve.bezierPointNum - this.curve.beizerPoints.length) / (this.curve.bezierPointNum)) {
                            gd3d.math.vec3Clone(this.curPosition, this.startPosition);
                            this.curPosition = this.curve.beizerPoints.shift();
                        }
                    }
                    var subLife = this.lifeTime / this.curve.bezierPointNum;
                    var curPosLocation = (this.curlifeTime % subLife) / subLife;
                    gd3d.math.vec3SLerp(this.startPosition, this.curPosition, curPosLocation, this.localTranslate);
                }
                else {
                    this.updategravity(deltaTime);
                    this.updateForce(deltaTime);
                    gd3d.math.vec3ScaleByNum(this.speedDir, this.speed, this._tempVec3);
                    gd3d.math.vec3Add(this.localTranslate, this._tempVec3, this.localTranslate);
                }
            };
            Particle.prototype.updatescale = function (deltaTime) {
                var index = 0;
                for (var i = 0; i < this.listScaleNode.length; i++) {
                    if (this.listScaleNode[i].lifeLocation < this.lifeLocation) {
                        this.startScaleNode = this.listScaleNode[i];
                        index++;
                    }
                }
                this.listScaleNode.splice(0, index);
                if (this.listScaleNode.length == 0)
                    return;
                this.curScaleNode = this.listScaleNode[0];
                var duration = this.curScaleNode.lifeLocation - this.startScaleNode.lifeLocation;
                if (duration > 0) {
                    gd3d.math.vec3SLerp(this.startScaleNode.keyScale, this.curScaleNode.keyScale, (this.lifeLocation - this.startScaleNode.lifeLocation) / duration, this._scale);
                }
                if (this.localScale.x < 0 || this.localScale.y < 0 || this.localScale.z < 0) {
                    this.alive = false;
                }
            };
            Particle.prototype.updateUV = function (deltaTime) {
                var index = 0;
                if (this.listUvSpeedNode.length != 0) {
                    for (var i = 0; i < this.listUvSpeedNode.length; i++) {
                        if (this.listUvSpeedNode[i].lifelocation < this.lifeLocation) {
                            this.startUVSpeedNode = this.listUvSpeedNode[i];
                            index++;
                        }
                    }
                    this.listUvSpeedNode.splice(0, index);
                    if (this.listUvSpeedNode.length > 0) {
                        this.CurUVSpeedNode = this.listUvSpeedNode[0];
                        var duration = this.CurUVSpeedNode.lifelocation - this.startUVSpeedNode.lifelocation;
                        if (duration > 0) {
                            gd3d.math.vec2SLerp(this.startUVSpeedNode.keyUVSpeed, this.CurUVSpeedNode.keyUVSpeed, (this.lifeLocation - this.startUVSpeedNode.lifelocation) % duration, this._uvSpeed);
                        }
                    }
                }
                this.curTextureOffset.z -= deltaTime * this._uvSpeed.x;
                this.curTextureOffset.w -= deltaTime * this._uvSpeed.y;
            };
            Particle.prototype.updateUVSpriteAnimation = function (deltaTime) {
                var frameTime = 1.0 / (this.particleDetailData.uvSprite.frameOverLifeTime * this.particleDetailData.uvSprite.cycles);
                var frameIndex = Math.floor(this.lifeLocation / frameTime) + this.particleDetailData.uvSprite.startFrame;
                gd3d.math.spriteAnimation(this.particleDetailData.uvSprite.row, this.particleDetailData.uvSprite.column, frameIndex, this.curTextureOffset);
            };
            Particle.prototype.updatecolor = function (deltaTime) {
                var index = 0;
                for (var i = 0; i < this.listColorNode.length; i++) {
                    if (this.listColorNode[i].lifeLocation < this.lifeLocation) {
                        this.startColorNode = this.listColorNode[i];
                        index++;
                    }
                }
                this.listColorNode.splice(0, index);
                if (this.listColorNode.length != 0) {
                    this.curColorNode = this.listColorNode[0];
                    var tempt = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3SLerp(this.startColorNode.keyColor, this.curColorNode.keyColor, (this.lifeLocation - this.startColorNode.lifeLocation) / (this.curColorNode.lifeLocation - this.startColorNode.lifeLocation), tempt);
                    this._color.x = tempt.x;
                    this._color.y = tempt.y;
                    this._color.z = tempt.z;
                    gd3d.math.pool.delete_vector3(tempt);
                }
                index = 0;
                for (var i = 0; i < this.listAlphaNode.length; i++) {
                    if (this.listAlphaNode[i].lifeLocation < this.lifeLocation) {
                        this.startAlphaNode = this.listAlphaNode[i];
                        index++;
                    }
                }
                this.listAlphaNode.splice(0, index);
                if (this.listAlphaNode.length == 0) {
                    this._color.w = this._alpha;
                    return;
                }
                this.curAlphaNode = this.listAlphaNode[0];
                this._alpha = (this.curAlphaNode.keyAlpha - this.startAlphaNode.keyAlpha) * (this.lifeLocation - this.startAlphaNode.lifeLocation) / (this.curAlphaNode.lifeLocation - this.startAlphaNode.lifeLocation) + this.startAlphaNode.keyAlpha;
                this._color.w = this._alpha;
            };
            Particle.prototype.updatelifetime = function (deltaTime) {
                if (!this.alive) {
                    return this.alive;
                }
                this.curlifeTime += deltaTime;
                if (!this.infinite) {
                    if (this.curlifeTime > this.lifeTime) {
                        this.alive = false;
                    }
                }
                return this.alive;
            };
            Particle.prototype.update = function (delta) {
                this.time += delta;
                if (this.time < this.delayTime) {
                    return;
                }
                if (!this.alive)
                    return;
                if (!this.isinit) {
                    this.parseByData();
                }
                else {
                    if (!this.updatelifetime(delta)) {
                        if (this.isloop) {
                            this.clear();
                            this.parseByData();
                        }
                        else {
                            this.resetMatrix();
                        }
                    }
                    else {
                        this.updatescale(delta);
                        this.updatecolor(delta);
                        this.updateposition(delta);
                        this.updaterot(delta);
                        if (this.meshBatcher.particleSystem.particleMethodType == framework.ParticleMethodType.UVROLL) {
                            this.updateUV(delta);
                        }
                        else if (this.meshBatcher.particleSystem.particleMethodType == framework.ParticleMethodType.UVSPRITE) {
                            this.updateUVSpriteAnimation(delta);
                        }
                        this.updatematrix();
                    }
                }
            };
            Particle.prototype.clear = function () {
                this._alive = true;
                this.isinit = false;
                this.lookatcam = false;
                this.curlifeTime = 0;
                this.speed = 1;
                gd3d.math.pool.delete_vector2(this.uvSpeed);
                gd3d.math.pool.delete_vector2(this._uvSpeed_temp);
                gd3d.math.pool.delete_vector3(this._scale_temp);
                gd3d.math.pool.delete_vector4(this._color_temp);
                gd3d.math.pool.delete_vector3(this.velocity);
                gd3d.math.pool.delete_vector3(this.acceleration);
                gd3d.math.pool.delete_vector3(this.angularVelocity);
                this.speedDir.x = 0;
                this.speedDir.y = 0;
                this.speedDir.z = 0;
                this.localTranslate = new gd3d.math.vector3();
                this.centerPosition = new gd3d.math.vector3();
                this.curTextureOffset.x = 1.0;
                this.curTextureOffset.y = 1.0;
                this.curTextureOffset.z = 0.0;
                this.curTextureOffset.w = 0.0;
                this.color = new gd3d.math.vector4(1, 1, 1, 1);
                this.alpha = 1;
                this.listAlphaNode = new Array();
                this.listScaleNode = new Array();
                this.listColorNode = new Array();
                this.listUvSpeedNode = new Array();
                this.localScale = new gd3d.math.vector3();
                this.gravityModifier = 0;
                this.gravitySpeed = 0;
            };
            Particle.prototype.dispose = function () {
                this.vertexArr = null;
                gd3d.math.pool.delete_vector2(this.uvSpeed);
                gd3d.math.pool.delete_vector2(this._uvSpeed_temp);
                gd3d.math.pool.delete_vector3(this._scale_temp);
                gd3d.math.pool.delete_vector4(this._color_temp);
                gd3d.math.pool.delete_vector3(this.velocity);
                gd3d.math.pool.delete_vector3(this.acceleration);
                gd3d.math.pool.delete_vector3(this.angularVelocity);
                this.listAlphaNode.length = 0;
                this.listScaleNode.length = 0;
                this.listColorNode.length = 0;
                this.listUvSpeedNode.length = 0;
            };
            return Particle;
        }());
        framework.Particle = Particle;
        var EffectColorNode = (function () {
            function EffectColorNode(_location, _color) {
                this.lifeLocation = _location;
                this.keyColor = _color;
            }
            return EffectColorNode;
        }());
        framework.EffectColorNode = EffectColorNode;
        var EffectScaleNode = (function () {
            function EffectScaleNode(_location, _scale) {
                this.lifeLocation = _location;
                this.keyScale = _scale;
            }
            return EffectScaleNode;
        }());
        framework.EffectScaleNode = EffectScaleNode;
        var EffectAlphaNode = (function () {
            function EffectAlphaNode(_location, _keyAlpha) {
                this.lifeLocation = _location;
                this.keyAlpha = _keyAlpha;
            }
            return EffectAlphaNode;
        }());
        framework.EffectAlphaNode = EffectAlphaNode;
        var EffectUVSpeedNode = (function () {
            function EffectUVSpeedNode(_location, _uvSpeed) {
                this.lifelocation = _location;
                this.keyUVSpeed = _uvSpeed;
            }
            return EffectUVSpeedNode;
        }());
        framework.EffectUVSpeedNode = EffectUVSpeedNode;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ParticleLoader = (function () {
            function ParticleLoader() {
                this.emisssionMap = {};
                this.materialMap = {};
                this.particleMap = {};
            }
            ParticleLoader.prototype.load = function (indexurl, callback) {
                var _this = this;
                var effect = new framework.EffectData();
                var totalCount = 3;
                var i = indexurl.lastIndexOf("/");
                var baseurl = indexurl.substring(0, i);
                if (baseurl != "") {
                    baseurl += "/";
                }
                gd3d.io.loadText(indexurl, function (txt, _err) {
                    if (_err != null)
                        throw _err;
                    else {
                        var obj_1 = JSON.parse(txt);
                        {
                            var fileName = obj_1["files"];
                            var emssionUrl = fileName["emission"];
                            _this.loadEmission(baseurl + emssionUrl, function (emission, _err) {
                                totalCount--;
                                console.log("Emission has been loaded");
                            });
                            var particleUrl = fileName["particle"];
                            _this.loadParticle(baseurl + particleUrl, function (p, _err) {
                                totalCount--;
                                console.log("Particle has been loaded");
                            });
                            var materialUrl = fileName["material"];
                            _this.loadMatrial(baseurl + materialUrl, function (matrial, _err) {
                                totalCount--;
                                console.log("material has been loaded");
                            });
                            var depengImg = obj_1["dependImg"];
                            if (depengImg != undefined) {
                                for (var i = 0; i < depengImg.length; i++) {
                                    effect.dependImgList.push(depengImg[i]);
                                }
                            }
                            var dependShape = obj_1["dependShape"];
                            if (dependShape != undefined) {
                                for (var i = 0; i < dependShape.length; i++) {
                                    effect.dependShapeList.push(dependShape[i]);
                                }
                            }
                        }
                        var id_1 = setInterval(function () {
                            if (totalCount <= 0) {
                                loadfinish();
                                clearInterval(id_1);
                                totalCount = 3;
                            }
                        }, 20);
                        var loadfinish = function () {
                            var effectsystem = obj_1["effectsystem"];
                            effect.name = effectsystem["name"];
                            var list = effectsystem["particlelist"];
                            for (var e = 0; e < list.length; e++) {
                                var particleData = new framework.ParticleData();
                                var particleJsonData = list[e];
                                particleData.emissionData = _this.emisssionMap[particleJsonData["emission"]];
                                particleData.materialData = _this.materialMap[particleJsonData["material"]];
                                particleData.particleDetailData = _this.particleMap[particleJsonData["particle"]];
                                effect.particlelist.push(particleData);
                            }
                            callback(effect);
                        };
                    }
                });
            };
            ParticleLoader.prototype.loadEmission = function (baseUrl, callback) {
                var _this = this;
                gd3d.io.loadText(baseUrl, function (txt, _error) {
                    var array = JSON.parse(txt);
                    var emissionArray = new Array();
                    for (var i = 0; i < array.length; i++) {
                        var json = array[i];
                        var emissionData = new framework.EmissionData();
                        emissionArray[i] = emissionData;
                        emissionData.emissionName = json["name"];
                        switch (json["type"]) {
                            case "burst":
                                emissionData.type = framework.ParticleEmissionType.burst;
                                break;
                            case "continue":
                                emissionData.type = framework.ParticleEmissionType.continue;
                                break;
                        }
                        emissionData.time = json["time"];
                        emissionData.count = json["count"];
                        _this.emisssionMap[emissionData.emissionName] = emissionData;
                    }
                    callback(emissionArray, _error);
                });
            };
            ParticleLoader.prototype.loadMatrial = function (indexurl, callback) {
                var _this = this;
                gd3d.io.loadText(indexurl, function (txt, _err) {
                    var i = indexurl.lastIndexOf("/");
                    var url = indexurl.substring(0, i);
                    if (url != "") {
                        url += "/";
                    }
                    var array = JSON.parse(txt);
                    var _material = new Array();
                    for (var i = 0; i < array.length; i++) {
                        var json = array[i];
                        _material[i] = new framework.MaterialData();
                        _material[i].shaderName = json["shader"];
                        _material[i].name = json["name"];
                        _material[i].diffuseTexture = json["diffuseTexture"];
                        if (json["tilingx"] != undefined) {
                            _material[i].tiling.x = json["tilingx"];
                        }
                        if (json["tilingy"] != undefined) {
                            _material[i].tiling.y = json["tilingy"];
                        }
                        if (json["offsetx"] != undefined) {
                            _material[i].offset.x = json["offsetx"];
                        }
                        if (json["offsety"] != undefined) {
                            _material[i].offset.y = json["offsety"];
                        }
                        if (json["alphacut"] != undefined) {
                            _material[i].alphaCut = json["alphacut"];
                        }
                        _this.materialMap[_material[i].name] = _material[i];
                    }
                    callback(_material, _err);
                });
            };
            ParticleLoader.prototype.loadParticle = function (indexurl, callback) {
                var _this = this;
                gd3d.io.loadText(indexurl, function (txt, _err) {
                    var array = JSON.parse(txt);
                    var _particle = new Array();
                    for (var i = 0; i < array.length; i++) {
                        var json = array[i];
                        _particle[i] = new framework.ParticleDetailData();
                        _particle[i].name = json["name"];
                        if (json["rendermodel"] == undefined) {
                            console.log("url" + indexurl + "rendermodel" + "name:" + _particle[i].name);
                        }
                        else {
                            var rendermodel = json["rendermodel"];
                            var rendermodelType = rendermodel["type"];
                            var flag = true;
                            if (rendermodelType == "mesh") {
                                flag = false;
                                var rendermodelVal = rendermodel["value"];
                                _particle[i].renderModel = framework.RenderModel.Mesh;
                                var meshType = rendermodelVal["type"];
                                if (meshType == undefined) {
                                    _particle[i].type = "plane";
                                }
                                else {
                                    _particle[i].type = meshType;
                                }
                                if (rendermodelVal["lookatcam"] != undefined) {
                                    _particle[i].isLookAtCamera = rendermodel["lookatcam"];
                                }
                                if (rendermodelVal["angularvelocity"] != undefined) {
                                    var angularVelocity = rendermodelVal["angularvelocity"];
                                    var angularVelocity_X = angularVelocity["x"];
                                    if (angularVelocity_X != undefined) {
                                        if (angularVelocity_X["value"] != undefined) {
                                            _particle[i].angularVelocity.x.value = angularVelocity_X["value"];
                                        }
                                        else {
                                            _particle[i].angularVelocity.x.valueLimitMin = angularVelocity_X["valuerange"]["0"];
                                            _particle[i].angularVelocity.x.valueLimitMax = angularVelocity_X["valuerange"]["1"];
                                        }
                                    }
                                    var angularVelocity_Y = angularVelocity["y"];
                                    if (angularVelocity_Y != undefined) {
                                        if (angularVelocity_Y["value"] != undefined) {
                                            _particle[i].angularVelocity.y.value = angularVelocity_Y["value"];
                                        }
                                        else {
                                            _particle[i].angularVelocity.y.valueLimitMin = angularVelocity_Y["valuerange"]["0"];
                                            _particle[i].angularVelocity.y.valueLimitMax = angularVelocity_Y["valuerange"]["1"];
                                        }
                                    }
                                    var angularVelocity_Z = angularVelocity["z"];
                                    if (angularVelocity_Z != undefined) {
                                        if (angularVelocity_Z["value"] != undefined) {
                                            _particle[i].angularVelocity.z.value = angularVelocity_Z["value"];
                                        }
                                        else {
                                            _particle[i].angularVelocity.z.valueLimitMin = angularVelocity_Z["valuerange"]["0"];
                                            _particle[i].angularVelocity.z.valueLimitMax = angularVelocity_Z["valuerange"]["1"];
                                        }
                                    }
                                }
                                else {
                                    _particle[i].angularVelocity.x.value = 0;
                                    _particle[i].angularVelocity.y.value = 0;
                                    _particle[i].angularVelocity.z.value = 0;
                                }
                                if (rendermodelVal["bindaxis"] != undefined) {
                                    _particle[i].bindAxis = true;
                                    var bindAxis = rendermodelVal["bindaxis"];
                                    if (bindAxis["x"] != undefined) {
                                        _particle[i].bindx = bindAxis["x"];
                                    }
                                    if (bindAxis["y"] != undefined) {
                                        _particle[i].bindy = bindAxis["y"];
                                    }
                                    if (bindAxis["z"] != undefined) {
                                        _particle[i].bindz = bindAxis["z"];
                                    }
                                }
                            }
                            else if (rendermodelType == "billboard") {
                                _particle[i].renderModel = framework.RenderModel.BillBoard;
                            }
                            else if (rendermodelType == "stretched") {
                                _particle[i].renderModel = framework.RenderModel.StretchedBillBoard;
                            }
                            else if (rendermodelType == "horizontal") {
                                _particle[i].renderModel = framework.RenderModel.HorizontalBillBoard;
                            }
                            else if (rendermodelType == "vertical") {
                                _particle[i].renderModel = framework.RenderModel.VerticalBillBoard;
                            }
                            if (flag) {
                                if (rendermodel["value"] != undefined) {
                                    _particle[i].angleSpeedForbillboard.value = rendermodel["value"];
                                }
                                else if (rendermodel["valuerange"] != undefined) {
                                    _particle[i].angleSpeedForbillboard.valueLimitMin = rendermodel["valuerange"]["0"];
                                    _particle[i].angleSpeedForbillboard.valueLimitMax = rendermodel["valuerange"]["1"];
                                }
                            }
                        }
                        if (json["infinite"] != undefined) {
                            _particle[i].infinite = json["infinite"];
                        }
                        if (json["loop"] != undefined) {
                            _particle[i].isLoop = json["loop"];
                        }
                        if (json["uvsprite"] != undefined) {
                            _particle[i].particleMethodType = framework.ParticleMethodType.UVSPRITE;
                            var uvsprite = json["uvsprite"];
                            _particle[i].uvSprite = new framework.UVSprite();
                            _particle[i].uvSprite.row = uvsprite["row"];
                            _particle[i].uvSprite.column = uvsprite["column"];
                            _particle[i].uvSprite.cycles = uvsprite["cycles"];
                            _particle[i].uvSprite.startFrame = uvsprite["startFrame"];
                            _particle[i].uvSprite.frameOverLifeTime = uvsprite["freamOverLifeTime"];
                        }
                        if (json["uvroll"] != undefined) {
                            _particle[i].particleMethodType = framework.ParticleMethodType.UVROLL;
                            _particle[i].uvRoll = new framework.UVRoll();
                            var uvroll = json["uvroll"];
                            if (uvroll["speedU"] != undefined) {
                                _particle[i].uvRoll.uvSpeed.u.value = uvroll["speedU"];
                            }
                            if (uvroll["speedV"] != undefined) {
                                _particle[i].uvRoll.uvSpeed.v.value = uvroll["speedV"];
                            }
                            if (uvroll["uvSpeedNodes"] != undefined) {
                                var uvspedNodes = uvroll["uvSpeedNodes"];
                                for (var k = 0; k < uvspedNodes.length; k++) {
                                    var uvNode = uvspedNodes[k.toString()];
                                    _particle[i].uvRoll.uvSpeedNodes[k] = new framework.UVSpeedNode();
                                    if (uvNode["u"] != undefined) {
                                        _particle[i].uvRoll.uvSpeedNodes[k].u.value = uvNode["u"];
                                    }
                                    if (uvNode["v"] != undefined) {
                                        _particle[i].uvRoll.uvSpeedNodes[k].v.value = uvNode["v"];
                                    }
                                    if (uvNode["key"] != undefined) {
                                        _particle[i].uvRoll.uvSpeedNodes[k].key = uvNode["key"];
                                    }
                                }
                            }
                        }
                        if (json["gravity"] != undefined) {
                            var gravity = json["gravity"];
                            if (gravity["value"] != undefined) {
                                _particle[i].gravity.value = gravity["value"];
                            }
                            else {
                                _particle[i].gravity.valueLimitMin = gravity["valuerange"]["0"];
                                _particle[i].gravity.valueLimitMax = gravity["valuerange"]["1"];
                            }
                        }
                        if (json["gravityspeed"] != undefined) {
                            var gravitySpeed = json["gravityspeed"];
                            if (gravitySpeed["value"] != undefined) {
                                _particle[i].gravitySpeed.value = gravitySpeed["value"];
                            }
                            else {
                                _particle[i].gravitySpeed.valueLimitMin = gravitySpeed["valuerange"]["0"];
                                _particle[i].gravitySpeed.valueLimitMax = gravitySpeed["valuerange"]["1"];
                            }
                        }
                        if (json["speed"] != undefined) {
                            var _speed = json["speed"];
                            if (_speed["value"] != undefined) {
                                _particle[i].speed.value = _speed["value"];
                            }
                            else {
                                _particle[i].speed.valueLimitMin = _speed["valuerange"]["0"];
                                _particle[i].speed.valueLimitMax = _speed["valuerange"]["1"];
                            }
                        }
                        if (json["life"] != undefined) {
                            var life = json["life"];
                            if (life["value"] != undefined) {
                                _particle[i].life.value = life["value"];
                            }
                            else {
                                _particle[i].life.valueLimitMin = life["valuerange"]["0"];
                                _particle[i].life.valueLimitMax = life["valuerange"]["1"];
                            }
                        }
                        if (json["startrot"] != undefined) {
                            var startRotation = json["startrot"];
                            var startRotation_X = startRotation["x"];
                            if (startRotation_X != undefined) {
                                if (startRotation_X["value"] != undefined) {
                                    _particle[i].startPitchYawRoll.x.value = startRotation_X["value"];
                                }
                                else {
                                    _particle[i].startPitchYawRoll.x.valueLimitMin = startRotation_X["valuerange"]["0"];
                                    _particle[i].startPitchYawRoll.x.valueLimitMax = startRotation_X["valuerange"]["1"];
                                }
                            }
                            var startRotation_Y = startRotation["y"];
                            if (startRotation_Y != undefined) {
                                if (startRotation_Y["value"] != undefined) {
                                    _particle[i].startPitchYawRoll.y.value = startRotation_Y["value"];
                                }
                                else {
                                    _particle[i].startPitchYawRoll.y.valueLimitMin = startRotation_Y["valuerange"]["0"];
                                    _particle[i].startPitchYawRoll.y.valueLimitMax = startRotation_Y["valuerange"]["1"];
                                }
                            }
                            var startRotation_Z = startRotation["z"];
                            if (startRotation_Z != undefined) {
                                if (startRotation_Z["value"] != undefined) {
                                    _particle[i].startPitchYawRoll.z.value = startRotation_Z["value"];
                                }
                                else {
                                    _particle[i].startPitchYawRoll.z.valueLimitMin = startRotation_Z["valuerange"]["0"];
                                    _particle[i].startPitchYawRoll.z.valueLimitMax = startRotation_Z["valuerange"]["1"];
                                }
                            }
                        }
                        else {
                            _particle[i].startPitchYawRoll.x.value = 0;
                            _particle[i].startPitchYawRoll.y.value = 0;
                            _particle[i].startPitchYawRoll.z.value = 0;
                        }
                        if (json["interptype"] != undefined) {
                            switch (json["interptype"]) {
                                case "linear":
                                    _particle[i].interpolationType = framework.ParticleCurveType.LINEAR;
                                    break;
                                default:
                                    _particle[i].interpolationType = framework.ParticleCurveType.CURVE;
                                    break;
                            }
                        }
                        if (json["scale"] != undefined) {
                            var _scale = json["scale"];
                            if (_scale["x"] != undefined) {
                                _particle[i].scale.x.value = _scale["x"];
                            }
                            else {
                                _particle[i].scale.x.valueLimitMin = _scale["rangex"]["0"];
                                _particle[i].scale.x.valueLimitMax = _scale["rangex"]["1"];
                            }
                            if (_scale["y"] != undefined) {
                                _particle[i].scale.y.value = _scale["y"];
                            }
                            else {
                                _particle[i].scale.y.valueLimitMin = _scale["rangey"]["0"];
                                _particle[i].scale.y.valueLimitMax = _scale["rangey"]["1"];
                            }
                            if (_scale["z"] != undefined) {
                                _particle[i].scale.z.value = _scale["z"];
                            }
                            else {
                                _particle[i].scale.z.valueLimitMin = _scale["rangez"]["0"];
                                _particle[i].scale.z.valueLimitMax = _scale["rangez"]["1"];
                            }
                        }
                        else {
                            _particle[i].scale.x.value = 1;
                            _particle[i].scale.y.value = 1;
                            _particle[i].scale.z.value = 1;
                        }
                        if (json["scalenode"] != undefined) {
                            var scaleNodes = json["scalenode"];
                            for (var ii = 0; ii < scaleNodes.length; ii++) {
                                var scaleNode = scaleNodes[ii.toString()];
                                _particle[i].scaleNode[ii] = new framework.ParticleNode();
                                {
                                    if (scaleNode["x"] != undefined) {
                                        _particle[i].scaleNode[ii].x.value = scaleNode["x"];
                                    }
                                    else {
                                        _particle[i].scaleNode[ii].x.valueLimitMin = scaleNode["rangex"]["0"];
                                        _particle[i].scaleNode[ii].x.valueLimitMax = scaleNode["rangex"]["1"];
                                    }
                                }
                                {
                                    if (scaleNode["y"] != undefined) {
                                        _particle[i].scaleNode[ii].y.value = scaleNode["y"];
                                    }
                                    else {
                                        _particle[i].scaleNode[ii].y.valueLimitMin = scaleNode["rangey"]["0"];
                                        _particle[i].scaleNode[ii].y.valueLimitMax = scaleNode["rangey"]["1"];
                                    }
                                }
                                {
                                    if (scaleNode["z"] != undefined) {
                                        _particle[i].scaleNode[ii].z.value = scaleNode["z"];
                                    }
                                    else {
                                        _particle[i].scaleNode[ii].z.valueLimitMin = scaleNode["rangez"]["0"];
                                        _particle[i].scaleNode[ii].z.valueLimitMax = scaleNode["rangez"]["1"];
                                    }
                                }
                                _particle[i].scaleNode[ii].key = scaleNode["key"];
                            }
                        }
                        if (json["color"] != undefined) {
                            var _color = json["color"];
                            if (_color["x"] != undefined) {
                                _particle[i].color.x.value = _color["x"];
                            }
                            else {
                                _particle[i].color.x.valueLimitMin = _color["rangex"]["0"];
                                _particle[i].color.x.valueLimitMax = _color["rangex"]["1"];
                            }
                            if (_color["y"] != undefined) {
                                _particle[i].color.y.value = _color["y"];
                            }
                            else {
                                _particle[i].color.y.valueLimitMin = _color["rangey"]["0"];
                                _particle[i].color.y.valueLimitMax = _color["rangey"]["1"];
                            }
                            if (_color["z"] != undefined) {
                                _particle[i].color.z.value = _color["z"];
                            }
                            else {
                                _particle[i].color.z.valueLimitMin = _color["rangez"]["0"];
                                _particle[i].color.z.valueLimitMax = _color["rangez"]["1"];
                            }
                        }
                        else {
                            _particle[i].color.x.value = 1;
                            _particle[i].color.y.value = 1;
                            _particle[i].color.z.value = 1;
                        }
                        if (json["colornode"] != undefined) {
                            var colorNodes = json["colornode"];
                            for (var ii = 0; ii < colorNodes.length; ii++) {
                                var colorNode = colorNodes[ii.toString()];
                                _particle[i].colorNode[ii] = new framework.ParticleNode();
                                {
                                    if (colorNode["x"] != undefined) {
                                        _particle[i].colorNode[ii].x.value = colorNode["x"];
                                    }
                                    else {
                                        _particle[i].colorNode[ii].x.valueLimitMin = colorNode["rangex"]["0"];
                                        _particle[i].colorNode[ii].x.valueLimitMax = colorNode["rangex"]["1"];
                                    }
                                }
                                {
                                    if (colorNode["y"] != undefined) {
                                        _particle[i].colorNode[ii].y.value = colorNode["y"];
                                    }
                                    else {
                                        _particle[i].colorNode[ii].y.valueLimitMin = colorNode["rangey"]["0"];
                                        _particle[i].colorNode[ii].y.valueLimitMax = colorNode["rangey"]["1"];
                                    }
                                }
                                {
                                    if (colorNode["z"] != undefined) {
                                        _particle[i].colorNode[ii].z.value = colorNode["z"];
                                    }
                                    else {
                                        _particle[i].colorNode[ii].z.valueLimitMin = colorNode["rangez"]["0"];
                                        _particle[i].colorNode[ii].z.valueLimitMax = colorNode["rangez"]["1"];
                                    }
                                }
                                _particle[i].colorNode[ii].key = colorNode["key"];
                            }
                        }
                        if (json["alpha"] != undefined) {
                            var _alpha = json["alpha"];
                            if (_alpha["value"] != undefined) {
                                _particle[i].alpha.value = _alpha["value"];
                            }
                            else {
                                _particle[i].alpha.valueLimitMin = _alpha["valuerange"]["0"];
                                _particle[i].alpha.valueLimitMax = _alpha["valuerange"]["1"];
                            }
                        }
                        else {
                            _particle[i].alpha.value = 1;
                        }
                        if (json["alphanode"] != undefined) {
                            var alphaNodes = json["alphanode"];
                            for (var aa = 0; aa < alphaNodes.length; aa++) {
                                var alphaNode = alphaNodes[aa.toString()];
                                _particle[i].alphaNode[aa] = new framework.AlphaNode();
                                if (alphaNode["value"] != undefined) {
                                    _particle[i].alphaNode[aa].alpha.value = alphaNode["value"];
                                }
                                else {
                                    _particle[i].alphaNode[aa].alpha.valueLimitMin = alphaNode["valuerange"]["0"];
                                    _particle[i].alphaNode[aa].alpha.valueLimitMax = alphaNode["valuerange"]["1"];
                                }
                                _particle[i].alphaNode[aa].key = alphaNode["key"];
                            }
                        }
                        if (json["posnode"] != undefined) {
                            var positionNodes = json["posnode"];
                            for (var ii = 0; ii < positionNodes.length; ii++) {
                                var positionNode = positionNodes[ii.toString()];
                                _particle[i].positionNode[ii] = new framework.ParticleNode();
                                {
                                    if (positionNode["x"] != undefined) {
                                        _particle[i].positionNode[ii].x.value = positionNode["x"];
                                    }
                                    else {
                                        _particle[i].positionNode[ii].x.valueLimitMin = positionNode["rangex"]["0"];
                                        _particle[i].positionNode[ii].x.valueLimitMax = positionNode["rangex"]["1"];
                                    }
                                }
                                {
                                    if (positionNode["y"] != undefined) {
                                        _particle[i].positionNode[ii].y.value = positionNode["y"];
                                    }
                                    else {
                                        _particle[i].positionNode[ii].y.valueLimitMin = positionNode["rangey"]["0"];
                                        _particle[i].positionNode[ii].y.valueLimitMax = positionNode["rangey"]["1"];
                                    }
                                }
                                {
                                    if (positionNode["z"] != undefined) {
                                        _particle[i].positionNode[ii].z.value = positionNode["z"];
                                    }
                                    else {
                                        _particle[i].positionNode[ii].z.valueLimitMin = positionNode["rangez"]["0"];
                                        _particle[i].positionNode[ii].z.valueLimitMax = positionNode["rangez"]["1"];
                                    }
                                }
                                _particle[i].positionNode[ii].key = positionNode["key"];
                            }
                        }
                        if (json["isrotation"] != undefined) {
                            _particle[i].isRotation = json["isrotation"];
                        }
                        if (json["startpos"] != undefined) {
                            var _startdata = json["startpos"];
                            var startdata = _particle[i].particleStartData;
                            if (_startdata["center"] != undefined) {
                                var _startpos = _startdata["center"];
                                startdata.position.x = _startpos["0"];
                                startdata.position.y = _startpos["1"];
                                startdata.position.z = _startpos["2"];
                            }
                            switch (_startdata["type"]) {
                                case "normal":
                                    startdata.shapeType = gd3d.framework.ParticleSystemShape.NORMAL;
                                    break;
                                case "box":
                                    startdata.shapeType = gd3d.framework.ParticleSystemShape.BOX;
                                    break;
                                case "sphere":
                                    startdata.shapeType = gd3d.framework.ParticleSystemShape.SPHERE;
                                    break;
                                case "hemisphere":
                                    startdata.shapeType = gd3d.framework.ParticleSystemShape.HEMISPHERE;
                                    break;
                                case "cone":
                                    startdata.shapeType = gd3d.framework.ParticleSystemShape.CONE;
                                    break;
                                case "circle":
                                    startdata.shapeType = gd3d.framework.ParticleSystemShape.CIRCLE;
                                    break;
                                case "edge":
                                    startdata.shapeType = gd3d.framework.ParticleSystemShape.EDGE;
                                    break;
                                default:
                                    break;
                            }
                            if (_startdata["bottomradius"] != undefined) {
                                startdata.bottomRadius = _startdata["bottomradius"];
                            }
                            if (_startdata["width"] != undefined) {
                                startdata.width = _startdata["width"];
                            }
                            if (_startdata["height"] != undefined) {
                                startdata.height = _startdata["height"];
                            }
                            if (_startdata["depth"] != undefined) {
                                startdata.depth = _startdata["depth"];
                            }
                            if (_startdata["angle"] != undefined) {
                                startdata.angle = _startdata["angle"];
                            }
                            if (_startdata["radius"] != undefined) {
                                startdata.radius = _startdata["radius"];
                            }
                            if (_startdata["direction"] != undefined) {
                                var _startdir = _startdata["direction"];
                                var startdir = startdata.direction;
                                startdir.x = _startdir["0"];
                                startdir.y = _startdir["1"];
                                startdir.z = _startdir["2"];
                            }
                        }
                        if (json["istrail"] != undefined) {
                            _particle[i].istrail = json["istrail"];
                        }
                        _this.particleMap[_particle[i].name] = _particle[i];
                    }
                    callback(_particle, _err);
                });
            };
            return ParticleLoader;
        }());
        framework.ParticleLoader = ParticleLoader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Particles = (function () {
            function Particles(sys) {
                this.emissionElements = [];
                this.loopFrame = Number.MAX_VALUE;
                this.effectSys = sys;
                this.vf = sys.vf;
            }
            Particles.prototype.addEmission = function (_emissionNew) {
                var _emissionElement = new EmissionElement(_emissionNew, this.effectSys);
                this.emissionElements.push(_emissionElement);
            };
            Particles.prototype.update = function (delta) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].update(delta);
                }
            };
            Particles.prototype.render = function (context, assetmgr, camera) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].render(context, assetmgr, camera);
                }
            };
            Particles.prototype.dispose = function () {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].dispose();
                }
            };
            return Particles;
        }());
        framework.Particles = Particles;
        var EmissionElement = (function () {
            function EmissionElement(_emissionNew, sys) {
                this.active = true;
                this.isover = false;
                this.effectSys = sys;
                this.vf = sys.vf;
                this.gameObject = sys.gameObject;
                this.emissionNew = _emissionNew;
                switch (this.emissionNew.emissionType) {
                    case framework.ParticleEmissionType.burst:
                        break;
                    case framework.ParticleEmissionType.continue:
                        this._continueSpaceTime = this.emissionNew.time / (this.emissionNew.emissionCount - 1);
                        break;
                }
                this.curTime = 0;
                this.numcount = 0;
                this.emissionBatchers = [];
                this.emissionBatchers[0] = new EmissionBatcher(this.emissionNew, this.effectSys);
            }
            EmissionElement.prototype.update = function (delta) {
                this.curTime += delta;
                this.updateEmission(delta);
                this.updateBatcher(delta);
            };
            EmissionElement.prototype.updateBatcher = function (delta) {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].update(delta);
                }
            };
            EmissionElement.prototype.updateEmission = function (delta) {
                if (this.isover)
                    return;
                if (this.emissionNew.emissionType == framework.ParticleEmissionType.continue) {
                    if (this.numcount == 0) {
                        this.addParticle();
                        this.numcount++;
                    }
                    if (this.curTime > this._continueSpaceTime) {
                        if (this.numcount < this.emissionNew.emissionCount) {
                            this.addParticle();
                            this.curTime = 0;
                            this.numcount++;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
                else if (this.emissionNew.emissionType == framework.ParticleEmissionType.burst) {
                    if (this.curTime > this.emissionNew.time) {
                        this.addParticle(this.emissionNew.emissionCount);
                        this.isover = true;
                    }
                }
            };
            EmissionElement.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                for (var i = 0; i < count; i++) {
                    this.emissionBatchers[0].addParticle();
                }
            };
            EmissionElement.prototype.render = function (context, assetmgr, camera) {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].render(context, assetmgr, camera);
                }
            };
            EmissionElement.prototype.dispose = function () {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].dispose();
                }
            };
            EmissionElement.prototype.isOver = function () {
                return this.isover;
            };
            return EmissionElement;
        }());
        framework.EmissionElement = EmissionElement;
        var EmissionBatcher = (function () {
            function EmissionBatcher(_data, effectSys) {
                this.beBufferInited = false;
                this.beAddParticle = false;
                this.particles = [];
                this.vertexSize = 0;
                this.formate = 0;
                this.curVerCount = 0;
                this.curIndexCount = 0;
                this._totalVertexCount = 0;
                this._indexStartIndex = 0;
                this._vbosize = 0;
                this.effectSys = effectSys;
                this.data = _data;
                this.formate = effectSys.vf;
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.formate) / 4;
                this.curTotalVertexCount = 256;
                this.indexStartIndex = 256;
                this.mesh = new framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = 0;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                this.mat = new framework.material();
                if (this.data.mat.shader == null) {
                    this.mat.setShader(framework.sceneMgr.app.getAssetMgr().getShader("diffuse.shader.json"));
                }
                else {
                    this.mat.setShader(this.data.mat.shader);
                }
                if (this.data.mat.alphaCut != undefined)
                    this.mat.setFloat("_AlphaCut", this.data.mat.alphaCut);
                if (this.data.mat.diffuseTexture != null)
                    this.mat.setTexture("_MainTex", this.data.mat.diffuseTexture);
            }
            EmissionBatcher.prototype.addParticle = function () {
                var p = new ParticleNew1(this);
                p.uploadData(this.dataForVbo);
                for (var i = 0; i < p.dataForEbo.length; i++) {
                    this.dataForEbo[this.curIndexCount + i] = p.dataForEbo[i] + this.curVerCount;
                }
                this.curVerCount += this.data.mesh.data.pos.length;
                this.curIndexCount += p.dataForEbo.length;
                this.particles.push(p);
                this.beAddParticle = true;
            };
            Object.defineProperty(EmissionBatcher.prototype, "curTotalVertexCount", {
                get: function () {
                    return this._totalVertexCount;
                },
                set: function (val) {
                    this._totalVertexCount = val;
                    this.resizeVboSize(this._totalVertexCount * this.vertexSize);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EmissionBatcher.prototype, "indexStartIndex", {
                get: function () {
                    return this._indexStartIndex;
                },
                set: function (value) {
                    this._indexStartIndex = value;
                    if (this.dataForEbo != null) {
                        var ebo = new Uint16Array(this._indexStartIndex);
                        ebo.set(this.dataForEbo, 0);
                        this.dataForEbo = ebo;
                    }
                    else {
                        this.dataForEbo = new Uint16Array(this._indexStartIndex);
                    }
                },
                enumerable: true,
                configurable: true
            });
            EmissionBatcher.prototype.update = function (delta) {
                for (var key in this.particles) {
                    this.particles[key].update(delta);
                    this.particles[key].uploadData(this.dataForVbo);
                }
            };
            EmissionBatcher.prototype.resizeVboSize = function (value) {
                if (this._vbosize > value)
                    return;
                this._vbosize = value;
                if (this.dataForVbo != null) {
                    var vbo = new Float32Array(this._vbosize);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                else {
                    this.dataForVbo = new Float32Array(this._vbosize);
                }
            };
            EmissionBatcher.prototype.render = function (context, assetmgr, camera) {
                var mesh = this.mesh;
                if (!this.beBufferInited) {
                    mesh.glMesh.initBuffer(context.webgl, this.formate, this.curTotalVertexCount);
                    mesh.glMesh.addIndex(context.webgl, this.dataForEbo.length);
                    this.beBufferInited = true;
                }
                if (this.beAddParticle) {
                    this.beAddParticle = false;
                    mesh.submesh[0].size = this.dataForEbo.length;
                    mesh.glMesh.resetEboSize(context.webgl, 0, this.dataForEbo.length);
                    mesh.glMesh.uploadIndexSubData(context.webgl, 0, this.dataForEbo);
                }
                mesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                this.mat.draw(context, mesh, mesh.submesh[0], "base");
            };
            EmissionBatcher.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.mesh.dispose();
                this.mat.dispose();
                for (var key in this.particles) {
                    this.particles[key].dispose();
                }
            };
            return EmissionBatcher;
        }());
        framework.EmissionBatcher = EmissionBatcher;
        var ParticleNew1 = (function () {
            function ParticleNew1(batcher) {
                this.renderModel = framework.RenderModel.None;
                this.matrix = new gd3d.math.matrix();
                this.tilling = new gd3d.math.vector2(1, 1);
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localRotation = new gd3d.math.quaternion();
                this.rotationByShape = new gd3d.math.quaternion();
                this.startPitchYawRoll = new gd3d.math.vector3();
                this.rotation_start = new gd3d.math.quaternion();
                this.speedDir = new gd3d.math.vector3(0, 0, 0);
                this.batcher = batcher;
                this.format = batcher.formate;
                this.data = batcher.data.clone();
                this.data.life.getValueRandom();
                this.startFrameId = this.batcher.effectSys.frameId;
                if (this.data.uvType == framework.UVTypeEnum.UVSprite) {
                    this.uvSpriteFrameInternal = (this.data.life.getValue() * framework.effectSystem.fps) / this.data.uvSprite.totalCount;
                }
                this.gameObject = batcher.effectSys.gameObject;
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.format) / 4;
                this.vertexStartIndex = batcher.curVerCount;
                this.dataForVbo = new Float32Array(this.data.mesh.data.pos.length * this.vertexSize);
                this.dataForEbo = this.data.mesh.data.genIndexDataArray();
                this.sourceVbo = this.data.getVboData(this.format);
                this.vertexCount = this.data.mesh.data.pos.length;
                this.curLife = 0;
                this.initByData();
                this.dataForVbo.set(this.data.mesh.data.genVertexDataArray(this.format), 0);
            }
            ParticleNew1.prototype.uploadData = function (array) {
                array.set(this.dataForVbo, this.vertexStartIndex * this.vertexSize);
            };
            ParticleNew1.prototype.initByData = function () {
                var localRandomDirection = gd3d.math.pool.clone_vector3(this.data.particleStartData.randomDirection);
                this.speedDir = gd3d.math.pool.clone_vector3(localRandomDirection);
                var localCenterTranslate = gd3d.math.pool.clone_vector3(this.data.particleStartData.position);
                var localRandomTranslate = gd3d.math.pool.clone_vector3(this.data.particleStartData.randomPosition);
                this.localTranslate = gd3d.math.pool.clone_vector3(localCenterTranslate);
                gd3d.math.vec3Add(this.localTranslate, localRandomTranslate, this.localTranslate);
                this.simulationSpeed = this.data.simulationSpeed != undefined ? this.data.simulationSpeed.getValue() : 0;
                if (this.data.euler == undefined)
                    this.euler = new gd3d.math.vector3(0, 0, 0);
                else
                    this.euler = this.data.euler.getValueRandom();
                if (this.data.scale == undefined)
                    this.scale = new gd3d.math.vector3(1, 1, 1);
                else
                    this.scale = this.data.scale.getValueRandom();
                if (this.data.color == undefined)
                    this.color = new gd3d.math.vector3(0, 0, 0);
                else
                    this.color = this.data.color.getValueRandom();
                if (this.data.alpha == undefined)
                    this.alpha = 1;
                else
                    this.alpha = this.data.alpha.getValueRandom();
                if (this.renderModel == framework.RenderModel.None || this.renderModel == framework.RenderModel.StretchedBillBoard) {
                    gd3d.math.quatFromEulerAngles(this.startPitchYawRoll.x, this.startPitchYawRoll.y, this.startPitchYawRoll.z, this.rotation_start);
                    if (this.data.particleStartData.shapeType != framework.ParticleSystemShape.NORMAL) {
                        var localOrgin = gd3d.math.pool.vector3_zero;
                        gd3d.math.quatLookat(localOrgin, localRandomDirection, this.rotationByShape);
                        var initRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatFromEulerAngles(90, 0, 0, initRot);
                        gd3d.math.quatMultiply(this.rotationByShape, initRot, this.rotationByShape);
                        gd3d.math.pool.delete_quaternion(initRot);
                    }
                }
            };
            ParticleNew1.prototype.update = function (delta) {
                this.curLife += delta;
                if (this.curLife >= this.data.life.getValue()) {
                    gd3d.math.matrixZero(this.matrix);
                    this._updateVBO();
                    return;
                }
                this._updatePos(delta);
                this._updateEuler(delta);
                this._updateScale(delta);
                this._updateRotation(delta);
                this._updateLocalMatrix(delta);
                this._updateColor(delta);
                this._updateAlpha(delta);
                this._updateUV(delta);
                this._updateVBO();
            };
            ParticleNew1.prototype._updateLocalMatrix = function (delta) {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.scale, this.localRotation, this.matrix);
            };
            ParticleNew1.prototype._updateRotation = function (delta) {
                gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                this._updateElementRotation();
            };
            ParticleNew1.prototype._updateElementRotation = function () {
                var cam = gd3d.framework.sceneMgr.app.getScene().mainCamera;
                var cameraTransform = cam.gameObject.transform;
                var translation = gd3d.math.pool.new_vector3();
                var worldRotation = gd3d.math.pool.new_quaternion();
                var worldTranslation = gd3d.math.pool.new_vector3();
                var invTransformRotation = gd3d.math.pool.new_quaternion();
                gd3d.math.vec3Clone(this.localTranslate, translation);
                gd3d.math.matrixTransformVector3(translation, this.gameObject.transform.getWorldMatrix(), worldTranslation);
                this.renderModel = this.data.renderModel;
                if (this.renderModel != framework.RenderModel.None) {
                    if (this.renderModel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    else if (this.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.renderModel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(cameraTransform.getWorldTranslate(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.renderModel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.quatClone(this.rotationByShape, this.localRotation);
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                        var lookRot = new gd3d.math.quaternion();
                        gd3d.math.quatClone(this.gameObject.transform.getWorldRotate(), invTransformRotation);
                        gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                        gd3d.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        var inverRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatInverse(this.localRotation, inverRot);
                        gd3d.math.quatMultiply(inverRot, lookRot, lookRot);
                        var angle = gd3d.math.pool.new_vector3();
                        gd3d.math.quatToEulerAngles(lookRot, angle);
                        gd3d.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        gd3d.math.quatMultiply(this.localRotation, lookRot, this.localRotation);
                        gd3d.math.pool.delete_quaternion(inverRot);
                        gd3d.math.pool.delete_vector3(angle);
                        gd3d.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.renderModel == framework.RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    gd3d.math.quatMultiply(worldRotation, this.rotationByEuler, worldRotation);
                    gd3d.math.quatClone(this.gameObject.transform.getWorldRotate(), invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.localRotation);
                }
                else {
                    gd3d.math.quatMultiply(worldRotation, this.rotationByEuler, this.localRotation);
                    gd3d.math.quatMultiply(this.rotationByShape, this.localRotation, this.localRotation);
                }
                gd3d.math.pool.delete_vector3(translation);
                gd3d.math.pool.delete_quaternion(worldRotation);
                gd3d.math.pool.delete_vector3(worldTranslation);
                gd3d.math.pool.delete_quaternion(invTransformRotation);
            };
            ParticleNew1.prototype._updatePos = function (delta) {
                if (this.data.moveSpeed != undefined) {
                    if (this.data.moveSpeed.x != undefined)
                        this.localTranslate.x += this.data.moveSpeed.x.getValue() * delta;
                    if (this.data.moveSpeed.y != undefined)
                        this.localTranslate.y += this.data.moveSpeed.y.getValue() * delta;
                    if (this.data.moveSpeed.z != undefined)
                        this.localTranslate.z += this.data.moveSpeed.z.getValue() * delta;
                }
                var currentTranslate = framework.EffectUtil.vecMuliNum(this.speedDir, this.simulationSpeed);
                gd3d.math.vec3Add(this.localTranslate, currentTranslate, this.localTranslate);
            };
            ParticleNew1.prototype._updateEuler = function (delta) {
                var index = 0;
                if (this.data.eulerNodes != undefined && this.data.eulerSpeed != undefined) {
                    console.error("scalespeed");
                    return;
                }
                if (this.data.eulerNodes != undefined) {
                    this._updateNode(this.data.eulerNodes, this.data.life.getValue(), this.euler);
                }
                else if (this.data.eulerSpeed != undefined) {
                    if (this.data.eulerSpeed.x != undefined)
                        this.euler.x += this.data.eulerSpeed.x.getValue() * delta;
                    if (this.data.eulerSpeed.y != undefined)
                        this.euler.y += this.data.eulerSpeed.y.getValue() * delta;
                    if (this.data.eulerSpeed.z != undefined)
                        this.euler.z += this.data.eulerSpeed.z.getValue() * delta;
                }
            };
            ParticleNew1.prototype._updateScale = function (delta) {
                var index = 0;
                if (this.data.scaleNodes != undefined && this.data.scaleSpeed != undefined) {
                    console.error("scalespeed");
                    return;
                }
                if (this.data.scaleNodes != undefined) {
                    this._updateNode(this.data.scaleNodes, this.data.life.getValue(), this.scale);
                }
                else if (this.data.scaleSpeed != undefined) {
                    if (this.data.scaleSpeed.x != undefined)
                        this.scale.x += this.data.scaleSpeed.x.getValue() * delta;
                    if (this.data.scaleSpeed.y != undefined)
                        this.scale.y += this.data.scaleSpeed.y.getValue() * delta;
                    if (this.data.scaleSpeed.z != undefined)
                        this.scale.z += this.data.scaleSpeed.z.getValue() * delta;
                }
            };
            ParticleNew1.prototype._updateColor = function (delta) {
                var index = 0;
                if (this.data.colorNodes != undefined && this.data.colorSpeed != undefined) {
                    console.error("colorspeed");
                    return;
                }
                if (this.data.colorNodes != undefined) {
                    this._updateNode(this.data.colorNodes, this.data.life.getValue(), this.color);
                }
                else if (this.data.colorSpeed != undefined) {
                    if (this.data.colorSpeed.x != undefined)
                        this.color.x += this.data.colorSpeed.x.getValue() * delta;
                    if (this.data.colorSpeed.y != undefined)
                        this.color.y += this.data.colorSpeed.y.getValue() * delta;
                    if (this.data.colorSpeed.z != undefined)
                        this.color.z += this.data.colorSpeed.z.getValue() * delta;
                }
            };
            ParticleNew1.prototype._updateNode = function (nodes, life, out) {
                var index = 0;
                if (nodes != undefined) {
                    for (var i = 0; i < nodes.length; i++) {
                        if (i + 1 < nodes.length) {
                            if (nodes[i].key * life <= this.curLife && nodes[i + 1].key * life >= this.curLife) {
                                this.tempStartNode = nodes[i];
                                this.tempEndNode = nodes[i + 1];
                                index++;
                                break;
                            }
                        }
                        else {
                            if (this.curLife < nodes[i].key * life) {
                                this.tempStartNode = nodes[i - 1];
                                this.tempEndNode = nodes[i];
                            }
                        }
                    }
                    var duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                    if (this.tempStartNode instanceof framework.ParticleNode) {
                        if (duration > 0) {
                            gd3d.math.vec3SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                    else if (this.tempStartNode instanceof framework.ParticleNodeNumber) {
                        if (duration > 0) {
                            out = gd3d.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                        }
                    }
                    else if (this.tempStartNode instanceof framework.UVSpeedNode) {
                        if (duration > 0) {
                            gd3d.math.vec2SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                }
            };
            ParticleNew1.prototype._updateAlpha = function (delta) {
                var index = 0;
                if (this.data.alphaNodes != undefined && this.data.alphaSpeed != undefined) {
                    console.error("colorspeed");
                    return;
                }
                if (this.data.alphaNodes != undefined) {
                    this._updateNode(this.data.alphaNodes, this.data.life.getValue(), this.alpha);
                }
                else if (this.data.alphaSpeed != undefined) {
                    this.alpha += this.data.alphaSpeed.getValue() * delta;
                }
            };
            ParticleNew1.prototype._updateUV = function (delta) {
                if (this.uv == undefined)
                    this.uv = new gd3d.math.vector2();
                if (this.data.uvType == framework.UVTypeEnum.NONE) {
                    this.uv = this.data.uv.getValue();
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVRoll) {
                    if (this.data.uvRoll != undefined) {
                        if (this.data.uvRoll.uvSpeedNodes != undefined && this.data.uvRoll.uvSpeed != undefined) {
                            console.error("uvspeed");
                            return;
                        }
                        var index = 0;
                        if (this.data.uvRoll.uvSpeedNodes != undefined) {
                            this._updateNode(this.data.uvRoll.uvSpeedNodes, this.data.life.getValue(), this.uv);
                        }
                        else if (this.data.uvRoll.uvSpeed != undefined) {
                            if (this.data.uvRoll.uvSpeed.u != undefined)
                                this.uv.x += this.data.uvRoll.uvSpeed.u.getValue() * delta;
                            if (this.data.uvRoll.uvSpeed.v != undefined)
                                this.uv.y += this.data.uvRoll.uvSpeed.v.getValue() * delta;
                        }
                    }
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVSprite) {
                    if (this.data.uvSprite != undefined) {
                        this.spriteIndex = Math.floor((this.batcher.effectSys.frameId - this.startFrameId) / this.uvSpriteFrameInternal);
                        this.spriteIndex %= this.data.uvSprite.totalCount;
                        this.uv.x = (this.spriteIndex % this.data.uvSprite.column) / this.data.uvSprite.column;
                        this.uv.y = Math.floor((this.spriteIndex / this.data.uvSprite.column)) / this.data.uvSprite.row;
                        this.tilling.x = this.data.uvSprite.column;
                        this.tilling.y = this.data.uvSprite.row;
                    }
                }
            };
            ParticleNew1.prototype._updateVBO = function () {
                var vertexSize = this.vertexSize;
                for (var i = 0; i < this.vertexCount; i++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = this.sourceVbo[i * vertexSize + 0];
                        vertex.y = this.sourceVbo[i * vertexSize + 1];
                        vertex.z = this.sourceVbo[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, this.matrix, vertex);
                        this.dataForVbo[i * vertexSize + 0] = vertex.x;
                        this.dataForVbo[i * vertexSize + 1] = vertex.y;
                        this.dataForVbo[i * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        var r = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 9], 0, 1);
                        var g = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 10], 0, 1);
                        var b = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 11], 0, 1);
                        var a = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 12], 0, 1);
                        if (this.color != undefined) {
                            r = gd3d.math.floatClamp(this.color.x, 0, 1);
                            g = gd3d.math.floatClamp(this.color.y, 0, 1);
                            b = gd3d.math.floatClamp(this.color.z, 0, 1);
                        }
                        if (this.alpha != undefined)
                            a = gd3d.math.floatClamp(this.alpha, 0, 1);
                        this.dataForVbo[i * 15 + 9] = r;
                        this.dataForVbo[i * 15 + 10] = g;
                        this.dataForVbo[i * 15 + 11] = b;
                        this.dataForVbo[i * 15 + 12] = a;
                    }
                    {
                        this.dataForVbo[i * vertexSize + 13] = this.sourceVbo[i * vertexSize + 13] / this.tilling.x + this.uv.x;
                        this.dataForVbo[i * vertexSize + 14] = this.sourceVbo[i * vertexSize + 14] / this.tilling.y + this.uv.y;
                    }
                }
            };
            ParticleNew1.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.rotation_start = null;
                this.localRotation = null;
                this.startPitchYawRoll = null;
                this.rotationByEuler = null;
                this.rotationByShape = null;
                this.tilling = null;
                this.matrix = null;
                this.localTranslate = null;
                this.euler = null;
                this.scale = null;
                this.color = null;
                this.uv = null;
            };
            return ParticleNew1;
        }());
        framework.ParticleNew1 = ParticleNew1;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var TrailSection = (function () {
            function TrailSection(p, t) {
                if (p === void 0) { p = new gd3d.math.vector3(); }
                if (t === void 0) { t = 0; }
                this.point = p;
                this.time = t;
            }
            return TrailSection;
        }());
        framework.TrailSection = TrailSection;
        var Color = (function () {
            function Color(r, g, b, a) {
                this.a = a;
                this.r = r;
                this.g = g;
                this.b = b;
            }
            Color.white = function () {
                return new Color(1, 1, 1, 1);
            };
            Color.black = function () {
                return new Color(0, 0, 0, 1);
            };
            Color.red = function () {
                return new Color(1, 0, 0, 1);
            };
            Color.green = function () {
                return new Color(0, 1, 0, 1);
            };
            Color.blue = function () {
                return new Color(0, 0, 1, 1);
            };
            return Color;
        }());
        framework.Color = Color;
        var Trail = (function () {
            function Trail(_obj, _mesh) {
                this.height = 200.0;
                this.time = 2.0;
                this.minDistance = 0.1;
                this.timeTransitionSpeed = 1;
                this.desiredTime = 2.0;
                this.startColor = Color.white();
                this.endColor = new Color(1, 1, 1, 0);
                this.alwaysUp = false;
                this.now = 0;
                this.sections = new Array();
                this._defaultcount = 256;
                this._maxvercount = 0;
                this._vercount = 0;
                this._indexcount = 0;
            }
            Object.defineProperty(Trail.prototype, "maxvercount", {
                get: function () {
                    return this._maxvercount;
                },
                set: function (value) {
                },
                enumerable: true,
                configurable: true
            });
            Trail.prototype.caclMaxVercount = function (_curcount) {
                if (this.maxvercount < _curcount) {
                    this.maxvercount = this.maxvercount * 2;
                    this.caclMaxVercount(_curcount);
                }
            };
            Trail.prototype.startTrail = function (timeToTweenTo, fadeInTime) {
                this.desiredTime = timeToTweenTo;
                if (this.time != this.desiredTime) {
                    this.timeTransitionSpeed = Math.abs(this.desiredTime - this.time) / fadeInTime;
                }
                if (this.time <= 0) {
                    this.time = 0.01;
                }
            };
            Trail.prototype.setTime = function (trailTime, timeToTweenTo, tweenSpeed) {
                this.time = trailTime;
                this.desiredTime = timeToTweenTo;
                this.timeTransitionSpeed = tweenSpeed;
                if (this.time <= 0) {
                }
            };
            Trail.prototype.fadeOut = function (fadeTime) {
                this.desiredTime = 0;
                if (this.time > 0) {
                    this.timeTransitionSpeed = this.time / fadeTime;
                }
            };
            Trail.prototype.Itterate = function (itterateTime) {
            };
            Trail.prototype.updateTrail = function (currentTime, deltaTime) {
                if (this.time > this.desiredTime) {
                    this.time -= deltaTime * this.timeTransitionSpeed;
                    if (this.time <= this.desiredTime)
                        this.time = this.desiredTime;
                }
                else if (this.time < this.desiredTime) {
                    this.time += deltaTime * this.timeTransitionSpeed;
                    if (this.time >= this.desiredTime)
                        this.time = this.desiredTime;
                }
                console.log(this.time);
                this._vercount = 0;
                this._indexcount = 0;
                while (this.sections.length > 0 && currentTime > this.sections[this.sections.length - 1].time + this.time) {
                    this.sections.splice(this.sections.length - 1);
                }
                this.caclMaxVercount(this.sections.length * 2);
                if (this.sections.length < 2)
                    return;
                for (var i = 0; i < this.sections.length; i++) {
                    this.currentSection = this.sections[i];
                    var u = 0.0;
                    if (i != 0)
                        u = gd3d.math.floatClamp((currentTime - this.currentSection.time) / this.time, 0, 1);
                }
                var triangles = new Array((this.sections.length - 1) * 2 * 3);
                for (var i = 0; i < triangles.length / 6; i++) {
                    triangles[i * 6 + 0] = i * 2;
                    triangles[i * 6 + 1] = i * 2 + 1;
                    triangles[i * 6 + 2] = i * 2 + 2;
                    triangles[i * 6 + 3] = i * 2 + 2;
                    triangles[i * 6 + 4] = i * 2 + 1;
                    triangles[i * 6 + 5] = i * 2 + 3;
                }
                this._indexcount = triangles.length;
            };
            return Trail;
        }());
        framework.Trail = Trail;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var HideFlags;
        (function (HideFlags) {
            HideFlags[HideFlags["None"] = 0] = "None";
            HideFlags[HideFlags["HideInHierarchy"] = 1] = "HideInHierarchy";
            HideFlags[HideFlags["HideInInspector"] = 2] = "HideInInspector";
            HideFlags[HideFlags["DontSaveInEditor"] = 4] = "DontSaveInEditor";
            HideFlags[HideFlags["NotEditable"] = 8] = "NotEditable";
            HideFlags[HideFlags["DontSaveInBuild"] = 16] = "DontSaveInBuild";
            HideFlags[HideFlags["DontUnloadUnusedAsset"] = 32] = "DontUnloadUnusedAsset";
            HideFlags[HideFlags["DontSave"] = 52] = "DontSave";
            HideFlags[HideFlags["HideAndDontSave"] = 61] = "HideAndDontSave";
        })(HideFlags = framework.HideFlags || (framework.HideFlags = {}));
        var nodeComponent = (function () {
            function nodeComponent(comp, init) {
                if (init === void 0) { init = false; }
                this.comp = comp;
                this.init = init;
            }
            return nodeComponent;
        }());
        __decorate([
            gd3d.reflect.Field("INodeComponent"),
            __metadata("design:type", Object)
        ], nodeComponent.prototype, "comp", void 0);
        nodeComponent = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Object, Boolean])
        ], nodeComponent);
        framework.nodeComponent = nodeComponent;
        var gameObject = (function () {
            function gameObject() {
                this.layer = 0;
                this.hideFlags = HideFlags.None;
                this.components = [];
                this._visible = true;
            }
            gameObject.prototype.getScene = function () {
                return this.transform.scene;
            };
            Object.defineProperty(gameObject.prototype, "visibleInScene", {
                get: function () {
                    var obj = this;
                    while (obj.visible && obj.transform.parent) {
                        obj = obj.transform.parent.gameObject;
                    }
                    return obj.visible;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(gameObject.prototype, "visible", {
                get: function () {
                    return this._visible;
                },
                set: function (val) {
                    if (val != this._visible) {
                        this._visible = val;
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.ChangeVisible);
                    }
                },
                enumerable: true,
                configurable: true
            });
            ;
            gameObject.prototype.getName = function () {
                return this.transform.name;
            };
            gameObject.prototype.update = function (delta) {
                if (this.components == null)
                    return;
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].init == false) {
                        this.components[i].comp.start();
                        this.components[i].init = true;
                    }
                    if (this.getScene().app.bePlay && !this.getScene().app.bePause) {
                        this.components[i].comp.update(delta);
                    }
                    else if (this.components[i].comp == this.renderer || this.components[i].comp == this.camera) {
                        this.components[i].comp.update(delta);
                    }
                }
            };
            gameObject.prototype.addComponentDirect = function (comp) {
                if (comp.gameObject != null) {
                    throw new Error("this components has added to a  gameObject");
                }
                comp.gameObject = this;
                if (this.components == null)
                    this.components = [];
                var nodeObj = new nodeComponent(comp, false);
                var add = true;
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "effectbatcher") == "1") {
                    if (this.renderer == null) {
                        this.renderer = comp;
                    }
                    else {
                        add = false;
                        console.warn("");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    if (this.camera == null) {
                        this.camera = comp;
                    }
                    else {
                        add = false;
                        console.warn("");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "light") == "1") {
                    if (this.light == null) {
                        this.light = comp;
                        console.warn("add light:" + this.transform.name);
                    }
                    else {
                        add = false;
                        console.warn("");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1") {
                    if (this.collider == null) {
                        this.collider = comp;
                    }
                    else {
                        add = false;
                        console.warn("");
                    }
                }
                if (add) {
                    this.components.push(nodeObj);
                    if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1")
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.AddCamera);
                    if (gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1")
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.AddCanvasRender);
                }
                return comp;
            };
            gameObject.prototype.getComponent = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return this.components[i].comp;
                    }
                }
                return null;
            };
            gameObject.prototype.getComponents = function () {
                var components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            };
            gameObject.prototype.getComponentsInChildren = function (type) {
                var components = [];
                this._getComponentsInChildren(type, this, components);
                return components;
            };
            gameObject.prototype._getComponentsInChildren = function (type, obj, array) {
                for (var i = 0; i < obj.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(obj.components[i].comp["__proto__"]);
                    if (cname == type) {
                        array.push(obj.components[i].comp);
                    }
                }
                for (var i_6 = 0; obj.transform.children != undefined && i_6 < obj.transform.children.length; i_6++) {
                    var _obj = obj.transform.children[i_6].gameObject;
                    this._getComponentsInChildren(type, _obj, array);
                }
            };
            gameObject.prototype.getComponentInParent = function (type) {
                var result = null;
                var _parent = this.transform.parent;
                while (result == null && _parent != null) {
                    result = _parent.gameObject.getComponent(type);
                    _parent = _parent.parent;
                }
                return result;
            };
            gameObject.prototype.addComponent = function (type) {
                if (this.components == null)
                    this.components = [];
                for (var key in this.components) {
                    var st = this.components[key]["comp"]["constructor"]["name"];
                    if (st == type) {
                        throw new Error("" + type + "");
                    }
                }
                var pp = gd3d.reflect.getPrototype(type);
                var comp = gd3d.reflect.createInstance(pp, { "nodecomp": "1" });
                return this.addComponentDirect(comp);
            };
            gameObject.prototype.removeComponent = function (comp) {
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        if (this.components[i].init) {
                            this.components[i].comp.remove();
                        }
                        this.remove(this.components[i].comp);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            };
            gameObject.prototype.remove = function (comp) {
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1") {
                    this.renderer = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    this.camera = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "light") == "1") {
                    this.light = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1") {
                    this.collider = null;
                }
            };
            gameObject.prototype.removeComponentByTypeName = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    if (gd3d.reflect.getClassName(this.components[i].comp) == type) {
                        if (this.components[i].init) {
                            this.components[i].comp.remove();
                        }
                        this.remove(this.components[i].comp);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            };
            gameObject.prototype.removeAllComponents = function () {
                for (var i = 0; i < this.components.length; i++) {
                    {
                        this.components[i].comp.remove();
                    }
                    this.remove(this.components[i].comp);
                }
                this.components.length = 0;
            };
            gameObject.prototype.dispose = function () {
                this.removeAllComponents();
            };
            return gameObject;
        }());
        __decorate([
            gd3d.reflect.Field("number"),
            gd3d.reflect.UIStyle("enum"),
            __metadata("design:type", Number)
        ], gameObject.prototype, "layer", void 0);
        __decorate([
            gd3d.reflect.Field("nodeComponent[]"),
            __metadata("design:type", Array)
        ], gameObject.prototype, "components", void 0);
        gameObject = __decorate([
            gd3d.reflect.SerializeType
        ], gameObject);
        framework.gameObject = gameObject;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var renderContext = (function () {
            function renderContext(webgl) {
                this.viewPortPixel = new gd3d.math.rect(0, 0, 0, 0);
                this.eyePos = new gd3d.math.vector4();
                this.matrixView = new gd3d.math.matrix();
                this.matrixProject = new gd3d.math.matrix();
                this.matrixModel = new gd3d.math.matrix();
                this.matrixModelViewProject = new gd3d.math.matrix;
                this.matrixModelView = new gd3d.math.matrix;
                this.matrixViewProject = new gd3d.math.matrix;
                this.floatTimer = 0;
                this.intLightCount = 0;
                this.vec4LightPos = new Float32Array(32);
                this.vec4LightDir = new Float32Array(32);
                this.floatLightSpotAngleCos = new Float32Array(8);
                this.lightmap = null;
                this.lightmapUV = 1;
                this.lightmapOffset = new gd3d.math.vector4(1, 1, 0, 0);
                this.webgl = webgl;
            }
            renderContext.prototype.updateCamera = function (app, camera) {
                camera.calcViewPortPixel(app, this.viewPortPixel);
                var asp = this.viewPortPixel.w / this.viewPortPixel.h;
                camera.calcViewMatrix(this.matrixView);
                camera.calcProjectMatrix(asp, this.matrixProject);
                gd3d.math.matrixMultiply(this.matrixProject, this.matrixView, this.matrixViewProject);
                this.floatTimer = app.getTotalTime();
                var pso = camera.gameObject.transform.getWorldTranslate();
                this.eyePos.x = pso.x;
                this.eyePos.y = pso.y;
                this.eyePos.z = pso.z;
            };
            renderContext.prototype.updateLights = function (lights) {
                this.intLightCount = lights.length;
                var dirt = gd3d.math.pool.new_vector3();
                for (var i = 0; i < lights.length; i++) {
                    {
                        var pos = lights[i].gameObject.transform.getWorldTranslate();
                        this.vec4LightPos[i * 4 + 0] = pos.x;
                        this.vec4LightPos[i * 4 + 1] = pos.y;
                        this.vec4LightPos[i * 4 + 2] = pos.z;
                        this.vec4LightPos[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Direction ? 0 : 1;
                        lights[i].gameObject.transform.getForwardInWorld(dirt);
                        this.vec4LightDir[i * 4 + 0] = dirt.x;
                        this.vec4LightDir[i * 4 + 1] = dirt.y;
                        this.vec4LightDir[i * 4 + 2] = dirt.z;
                        this.vec4LightDir[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Point ? 0 : 1;
                        this.floatLightSpotAngleCos[i] = lights[i].spotAngelCos;
                    }
                }
                gd3d.math.pool.delete_vector3(dirt);
            };
            renderContext.prototype.updateOverlay = function () {
                gd3d.math.matrixMakeIdentity(this.matrixModelViewProject);
            };
            renderContext.prototype.updateModel = function (model) {
                gd3d.math.matrixClone(model.getWorldMatrix(), this.matrixModel);
                gd3d.math.matrixMultiply(this.matrixView, this.matrixModel, this.matrixModelView);
                gd3d.math.matrixMultiply(this.matrixViewProject, this.matrixModel, this.matrixModelViewProject);
            };
            renderContext.prototype.updateModeTrail = function () {
                gd3d.math.matrixClone(this.matrixView, this.matrixModelView);
                gd3d.math.matrixClone(this.matrixViewProject, this.matrixModelViewProject);
            };
            return renderContext;
        }());
        framework.renderContext = renderContext;
        var RenderLayerEnum;
        (function (RenderLayerEnum) {
            RenderLayerEnum[RenderLayerEnum["Common"] = 0] = "Common";
            RenderLayerEnum[RenderLayerEnum["Transparent"] = 1] = "Transparent";
            RenderLayerEnum[RenderLayerEnum["Overlay"] = 2] = "Overlay";
        })(RenderLayerEnum = framework.RenderLayerEnum || (framework.RenderLayerEnum = {}));
        var renderList = (function () {
            function renderList() {
                this.renderLayers = [];
                var common = new renderLayer();
                var transparent = new renderLayer(true);
                var overlay = new renderLayer(true);
                this.renderLayers.push(common);
                this.renderLayers.push(transparent);
                this.renderLayers.push(overlay);
            }
            renderList.prototype.clear = function () {
                for (var i = 0; i < this.renderLayers.length; i++) {
                    this.renderLayers[i].list.length = 0;
                }
            };
            renderList.prototype.addRenderer = function (renderer) {
                if (renderer.layer == RenderLayerEnum.Common) {
                    this.renderLayers[0].list.push(renderer);
                }
                else if (renderer.layer == RenderLayerEnum.Transparent) {
                    this.renderLayers[1].list.push(renderer);
                }
                else if (renderer.layer == RenderLayerEnum.Overlay) {
                    this.renderLayers[2].list.push(renderer);
                }
            };
            return renderList;
        }());
        framework.renderList = renderList;
        var renderLayer = (function () {
            function renderLayer(_sort) {
                if (_sort === void 0) { _sort = false; }
                this.needSort = false;
                this.list = [];
                this.needSort = _sort;
            }
            return renderLayer;
        }());
        framework.renderLayer = renderLayer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var scene = (function () {
            function scene(app) {
                this.renderCameras = [];
                this._mainCamera = null;
                this.renderContext = [];
                this.renderLights = [];
                this.lightmaps = [];
                this.RealCameraNumber = 0;
                this.app = app;
                this.webgl = app.webgl;
                this.assetmgr = app.getAssetMgr();
                this.rootNode = new framework.transform();
                this.rootNode.scene = this;
                this.renderList = new framework.renderList();
            }
            Object.defineProperty(scene.prototype, "mainCamera", {
                get: function () {
                    if (this._mainCamera == null) {
                        this._mainCamera = this.renderCameras[0];
                    }
                    return this._mainCamera;
                },
                set: function (_camera) {
                    for (var i in this.renderCameras) {
                        if (this.renderCameras[i] == _camera) {
                            this._mainCamera = _camera;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            scene.prototype.update = function (delta) {
                this.rootNode.updateTran(false);
                this.rootNode.updateAABBChild();
                this.renderCameras.length = 0;
                this.renderLights.length = 0;
                this.renderList.clear();
                this.updateScene(this.rootNode, delta);
                document["log"] = {};
                document["log"].lights = this.renderLights.length;
                document["log"].cameras = [];
                if (this.renderCameras.length > 1) {
                    this.renderCameras.sort(function (a, b) {
                        return a.order - b.order;
                    });
                }
                for (var i = 0; i < this.renderCameras.length; i++) {
                    this.renderCameras[i].index = i;
                    document["log"].cameras.push({});
                    document["log"].cameras[i].name = this.renderCameras[i].gameObject.getName();
                    document["log"].cameras[i].objs = [];
                }
                this.RealCameraNumber = 0;
                for (var i = 0; i < this.renderCameras.length; i++) {
                    this._renderCamera(i);
                }
                if (this.RealCameraNumber == 0) {
                    this.webgl.clearColor(0, 0, 0, 1);
                    this.webgl.clearDepth(1.0);
                    this.webgl.clear(this.webgl.COLOR_BUFFER_BIT | this.webgl.DEPTH_BUFFER_BIT);
                }
            };
            scene.prototype._renderCamera = function (camindex) {
                var cam = this.renderCameras[camindex];
                var context = this.renderContext[camindex];
                if (!this.app.bePlay && cam.gameObject.transform.name.toLowerCase().indexOf("editor") >= 0) {
                    context.updateCamera(this.app, cam);
                    context.updateLights(this.renderLights);
                    cam.fillRenderer(this);
                    cam.renderScene(this, context);
                    this.RealCameraNumber++;
                    if (this.app.be2dstate) {
                        var overLays = cam.getOverLays();
                        for (var i = 0; i < overLays.length; i++) {
                            if (cam.CullingMask & framework.CullingMask.ui) {
                                overLays[i].render(context, this.assetmgr, cam);
                            }
                        }
                    }
                }
                else if (this.app.bePlay && cam.gameObject.transform.name.toLowerCase().indexOf("editor") < 0) {
                    context.updateCamera(this.app, cam);
                    context.updateLights(this.renderLights);
                    cam.fillRenderer(this);
                    cam.renderScene(this, context);
                    this.RealCameraNumber++;
                    var overLays = cam.getOverLays();
                    for (var i = 0; i < overLays.length; i++) {
                        if (cam.CullingMask & framework.CullingMask.ui) {
                            overLays[i].render(context, this.assetmgr, cam);
                        }
                    }
                }
                if (!this.app.bePlay && this.app.be2dstate) {
                    if (camindex == this.app.curcameraindex) {
                        var overLays = cam.getOverLays();
                        for (var i = 0; i < overLays.length; i++) {
                            if (cam.CullingMask & framework.CullingMask.ui) {
                                overLays[i].render(context, this.assetmgr, cam);
                            }
                        }
                    }
                }
            };
            scene.prototype.updateScene = function (node, delta) {
                if (node.gameObject != null) {
                    node.gameObject.update(delta);
                    var c = node.gameObject.camera;
                    if (c != null) {
                        this.renderCameras.push(c);
                    }
                    while (this.renderContext.length < this.renderCameras.length) {
                        this.renderContext.push(new framework.renderContext(this.webgl));
                    }
                    var l = node.gameObject.light;
                    if (l != null) {
                        this.renderLights.push(l);
                    }
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.updateScene(node.children[i], delta);
                    }
                }
            };
            scene.prototype.addChild = function (node) {
                this.rootNode.addChild(node);
            };
            scene.prototype.removeChild = function (node) {
                this.rootNode.removeChild(node);
            };
            scene.prototype.getChildren = function () {
                return this.rootNode.children;
            };
            scene.prototype.getChildCount = function () {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            };
            scene.prototype.getChild = function (index) {
                return this.rootNode.children[index];
            };
            scene.prototype.getChildByName = function (name) {
                var res = this.rootNode.find(name);
                return res;
            };
            scene.prototype.getRoot = function () {
                return this.rootNode;
            };
            scene.prototype.pickAll = function (ray, isPickMesh) {
                if (isPickMesh === void 0) { isPickMesh = false; }
                var picked = this.doPick(ray, true, isPickMesh);
                if (picked == null)
                    return null;
                return picked;
            };
            scene.prototype.pick = function (ray, isPickMesh) {
                if (isPickMesh === void 0) { isPickMesh = false; }
                var pickinfo = this.doPick(ray, false, isPickMesh);
                if (pickinfo == null)
                    return null;
                return pickinfo;
            };
            scene.prototype.doPick = function (ray, pickall, isPickMesh) {
                if (pickall === void 0) { pickall = false; }
                if (isPickMesh === void 0) { isPickMesh = false; }
                var pickedList = new Array();
                if (isPickMesh) {
                    this.pickMesh(ray, this.getRoot(), pickedList);
                }
                else {
                    this.pickCollider(ray, this.getRoot(), pickedList);
                }
                if (pickedList.length == 0)
                    return null;
                if (pickall) {
                    return pickedList;
                }
                else {
                    var index = 0;
                    for (var i = 1; i < pickedList.length; i++) {
                        if (pickedList[i].distance < pickedList[index].distance)
                            index = i;
                    }
                    return pickedList[index];
                }
            };
            scene.prototype.pickMesh = function (ray, tran, pickedList) {
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return;
                    var meshFilter = tran.gameObject.getComponent("meshFilter");
                    if (meshFilter != null) {
                        var mesh = meshFilter.getMeshOutput();
                        var pickinfo = mesh.intersects(ray, tran.getWorldMatrix());
                        if (pickinfo) {
                            pickedList.push(pickinfo);
                            pickinfo.pickedtran = tran;
                        }
                    }
                    else {
                        var skinmesh = tran.gameObject.getComponent("skinnedMeshRenderer");
                        if (skinmesh != null) {
                            var pickinfo = skinmesh.intersects(ray);
                            if (pickinfo) {
                                pickedList.push(pickinfo);
                                pickinfo.pickedtran = tran;
                            }
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        this.pickMesh(ray, tran.children[i], pickedList);
                    }
                }
            };
            scene.prototype.pickCollider = function (ray, tran, pickedList) {
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return;
                    if (tran.gameObject.collider != null) {
                        var pickinfo = ray.intersectCollider(tran);
                        if (pickinfo) {
                            pickedList.push(pickinfo);
                            pickinfo.pickedtran = tran;
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        this.pickCollider(ray, tran.children[i], pickedList);
                    }
                }
            };
            return scene;
        }());
        framework.scene = scene;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var taskstate = (function () {
            function taskstate() {
                this.finish = false;
                this.error = false;
                this.message = null;
                this.cancel = false;
                this.taskCall = null;
                this.taskInterface = null;
            }
            return taskstate;
        }());
        framework.taskstate = taskstate;
        var taskMgr = (function () {
            function taskMgr() {
                this.tasks = [];
                this.laststate = null;
            }
            taskMgr.prototype.addTaskCall = function (task) {
                var st = new taskstate();
                st.taskCall = task;
                this.tasks.push(st);
            };
            taskMgr.prototype.addTask = function (task) {
                var st = new taskstate();
                st.taskInterface = task;
                this.tasks.push(st);
            };
            taskMgr.prototype.move = function (delta) {
                if (this.laststate != null && this.laststate.cancel) {
                    return;
                }
                if (this.laststate != null && this.laststate.finish == false) {
                    return;
                }
                var task = this.tasks.shift();
                if (task == null) {
                    return;
                }
                var state = new taskstate();
                var laststate = this.laststate;
                this.laststate = state;
                if (task.taskInterface == null) {
                    task.taskCall(laststate, state);
                }
                else {
                    task.taskInterface.move(delta, laststate, state);
                }
            };
            taskMgr.prototype.cancel = function () {
                if (this.laststate != null) {
                    this.laststate.cancel = true;
                }
            };
            return taskMgr;
        }());
        framework.taskMgr = taskMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var aabb = (function () {
            function aabb(_minimum, _maximum) {
                this.opmin = new gd3d.math.vector3();
                this.opmax = new gd3d.math.vector3();
                this._center = new gd3d.math.vector3();
                this.srcmin = gd3d.math.pool.clone_vector3(_minimum);
                this.srcmax = gd3d.math.pool.clone_vector3(_maximum);
                this.minimum = gd3d.math.pool.clone_vector3(_minimum);
                this.maximum = gd3d.math.pool.clone_vector3(_maximum);
            }
            aabb.prototype.update = function (worldmatrix) {
                gd3d.math.matrixGetTranslation(worldmatrix, this.opmin);
                gd3d.math.matrixGetTranslation(worldmatrix, this.opmax);
                if (worldmatrix.rawData[0] > 0) {
                    this.opmin.x += worldmatrix.rawData[0] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[0] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[0] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[0] * this.srcmin.x;
                }
                if (worldmatrix.rawData[1] > 0) {
                    this.opmin.y += worldmatrix.rawData[1] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[1] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[1] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[1] * this.srcmin.y;
                }
                if (worldmatrix.rawData[2] > 0) {
                    this.opmin.z += worldmatrix.rawData[2] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[2] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[2] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[2] * this.srcmin.z;
                }
                if (worldmatrix.rawData[4] > 0) {
                    this.opmin.x += worldmatrix.rawData[4] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[4] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[4] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[4] * this.srcmin.x;
                }
                if (worldmatrix.rawData[5] > 0) {
                    this.opmin.y += worldmatrix.rawData[5] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[5] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[5] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[5] * this.srcmin.y;
                }
                if (worldmatrix.rawData[6] > 0) {
                    this.opmin.z += worldmatrix.rawData[6] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[6] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[6] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[6] * this.srcmin.z;
                }
                if (worldmatrix.rawData[8] > 0) {
                    this.opmin.x += worldmatrix.rawData[8] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[8] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[8] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[8] * this.srcmin.x;
                }
                if (worldmatrix.rawData[9] > 0) {
                    this.opmin.y += worldmatrix.rawData[9] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[9] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[9] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[9] * this.srcmin.y;
                }
                if (worldmatrix.rawData[10] > 0) {
                    this.opmin.z += worldmatrix.rawData[10] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[10] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[10] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[10] * this.srcmin.z;
                }
                this.minimum = gd3d.math.pool.clone_vector3(this.opmin);
                this.maximum = gd3d.math.pool.clone_vector3(this.opmax);
            };
            aabb.prototype.addVector3 = function (vec) {
                gd3d.math.vec3Max(this.maximum, vec, this.maximum);
                gd3d.math.vec3Max(this.minimum, vec, this.minimum);
            };
            aabb.prototype.containsVector3 = function (vec) {
                return (vec.x > this.minimum.x) && (vec.x < this.maximum.x) &&
                    (vec.y > this.minimum.y) && (vec.x < this.maximum.y) &&
                    (vec.z > this.minimum.z) && (vec.z < this.maximum.z);
            };
            aabb.prototype.intersectAABB = function (aabb) {
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                return true;
            };
            aabb.prototype.addAABB = function (aabb) {
                if (aabb != null) {
                    gd3d.math.vec3Max(this.maximum, aabb.maximum, this.maximum);
                    gd3d.math.vec3Min(this.minimum, aabb.minimum, this.minimum);
                }
            };
            Object.defineProperty(aabb.prototype, "center", {
                get: function () {
                    gd3d.math.vec3Add(this.maximum, this.minimum, this._center);
                    gd3d.math.vec3ScaleByNum(this._center, 0.5, this._center);
                    return this._center;
                },
                enumerable: true,
                configurable: true
            });
            aabb.prototype.clear = function () {
                gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimum);
                gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximum);
            };
            aabb.prototype.clone = function () {
                var _min = gd3d.math.pool.clone_vector3(this.minimum);
                var _max = gd3d.math.pool.clone_vector3(this.maximum);
                var aabb = new gd3d.framework.aabb(_min, _max);
                return aabb;
            };
            aabb.prototype.getVec3 = function (vecs) {
                vecs[0] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[1] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[1].z = this.maximum.z;
                vecs[2] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[2].x = this.maximum.x;
                vecs[3] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[3].y = this.minimum.y;
                vecs[4] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[4].y = this.maximum.y;
                vecs[5] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[5].x = this.minimum.x;
                vecs[6] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[6].z = this.minimum.z;
                vecs[7] = gd3d.math.pool.clone_vector3(this.maximum);
            };
            return aabb;
        }());
        framework.aabb = aabb;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var obb = (function () {
            function obb() {
                this.vectors = new Array();
            }
            obb.prototype.buildByMaxMin = function (minimum, maximum) {
                this.vectors[0] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[1] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[1].z = maximum.z;
                this.vectors[2] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[2].x = maximum.x;
                this.vectors[3] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[3].y = minimum.y;
                this.vectors[4] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[4].y = maximum.y;
                this.vectors[5] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[5].x = minimum.x;
                this.vectors[6] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[6].z = minimum.z;
                this.vectors[7] = gd3d.math.pool.clone_vector3(maximum);
                this.center = new gd3d.math.vector3();
                gd3d.math.vec3Add(maximum, minimum, this.center);
                gd3d.math.vec3ScaleByNum(this.center, 0.5, this.center);
                this.halfsize = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(maximum, minimum, this.halfsize);
                gd3d.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                this.directions = [new gd3d.math.vector3(), new gd3d.math.vector3(), new gd3d.math.vector3()];
            };
            obb.prototype.buildByCenterSize = function (center, size) {
                this.center = gd3d.math.pool.clone_vector3(center);
                this.halfsize = gd3d.math.pool.clone_vector3(size);
                gd3d.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                var hsx = this.halfsize.x;
                var hsy = this.halfsize.y;
                var hsz = this.halfsize.z;
                var cenx = this.center.x;
                var ceny = this.center.y;
                var cenz = this.center.z;
                this.vectors[0] = new gd3d.math.vector3(cenx - hsx, ceny - hsy, cenz - hsz);
                this.vectors[1] = new gd3d.math.vector3(cenx - hsx, ceny - hsy, cenz + hsz);
                this.vectors[2] = new gd3d.math.vector3(cenx + hsx, ceny - hsy, cenz - hsz);
                this.vectors[3] = new gd3d.math.vector3(cenx + hsx, ceny - hsy, cenz + hsz);
                this.vectors[4] = new gd3d.math.vector3(cenx - hsx, ceny + hsy, cenz - hsz);
                this.vectors[5] = new gd3d.math.vector3(cenx - hsx, ceny + hsy, cenz + hsz);
                this.vectors[6] = new gd3d.math.vector3(cenx + hsx, ceny + hsy, cenz - hsz);
                this.vectors[7] = new gd3d.math.vector3(cenx + hsx, ceny + hsy, cenz + hsz);
                this.directions = [new gd3d.math.vector3(), new gd3d.math.vector3(), new gd3d.math.vector3()];
            };
            obb.prototype.update = function (worldmatrix) {
                gd3d.math.matrixGetTranslation(worldmatrix, this.center);
                gd3d.math.matrixGetVector3ByOffset(worldmatrix, 0, this.directions[0]);
                gd3d.math.matrixGetVector3ByOffset(worldmatrix, 4, this.directions[1]);
                gd3d.math.matrixGetVector3ByOffset(worldmatrix, 8, this.directions[2]);
            };
            obb.prototype.caclWorldVecs = function (vecs, worldmatrix) {
                for (var index = 0; index < this.vectors.length; index++) {
                    vecs[index] = new gd3d.math.vector3();
                    gd3d.math.matrixTransformVector3(this.vectors[index], worldmatrix, vecs[index]);
                }
            };
            obb.prototype.intersects = function (_obb) {
                if (_obb == null)
                    return false;
                var box0 = this;
                var box1 = _obb;
                if (!this.axisOverlap(box0.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[2], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[2], box0, box1))
                    return false;
                var crossresult = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(box0.directions[0], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[0], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[0], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[1], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[1], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[1], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[2], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[2], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[2], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                return true;
            };
            obb.prototype.computeBoxExtents = function (axis, box) {
                var p = gd3d.math.vec3Dot(box.center, axis);
                var r0 = Math.abs(gd3d.math.vec3Dot(box.directions[0], axis)) * box.halfsize.x;
                var r1 = Math.abs(gd3d.math.vec3Dot(box.directions[1], axis)) * box.halfsize.y;
                var r2 = Math.abs(gd3d.math.vec3Dot(box.directions[2], axis)) * box.halfsize.z;
                var r = r0 + r1 + r2;
                var result = gd3d.math.pool.new_vector3();
                result.x = p - r;
                result.y = p + r;
                return result;
            };
            obb.prototype.axisOverlap = function (axis, box0, box1) {
                var result0 = this.computeBoxExtents(axis, box0);
                var result1 = this.computeBoxExtents(axis, box1);
                return this.extentsOverlap(result0.x, result0.y, result1.x, result1.y);
            };
            obb.prototype.extentsOverlap = function (min0, max0, min1, max1) {
                return !(min0 > max1 || min1 > max0);
            };
            obb.prototype.clone = function () {
                var _obb = new obb();
                _obb.center = gd3d.math.pool.clone_vector3(this.center);
                _obb.halfsize = this.halfsize;
                for (var key in this.directions) {
                    _obb.directions[key] = gd3d.math.pool.clone_vector3(this.directions[key]);
                }
                return _obb;
            };
            obb.prototype.dispose = function () {
                this.vectors.length = 0;
                this.directions.length = 0;
            };
            return obb;
        }());
        framework.obb = obb;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var pickinfo = (function () {
            function pickinfo(_bu, _bv, _distance) {
                this.hitposition = new gd3d.math.vector3();
                this.bu = 0;
                this.bv = 0;
                this.faceId = -1;
                this.subMeshId = 0;
                this.distance = _distance;
                this.bu = _bu;
                this.bv = _bv;
            }
            return pickinfo;
        }());
        framework.pickinfo = pickinfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ray = (function () {
            function ray(_origin, _dir) {
                this.origin = gd3d.math.pool.clone_vector3(_origin);
                this.direction = gd3d.math.pool.clone_vector3(_dir);
            }
            ray.prototype.intersectAABB = function (_aabb) {
                return this.intersectBoxMinMax(_aabb.minimum, _aabb.maximum);
            };
            ray.prototype.intersectPlaneTransform = function (tran) {
                var pickinfo = null;
                var panelpoint = tran.getWorldTranslate();
                var forward = gd3d.math.pool.new_vector3();
                tran.getForwardInWorld(forward);
                var hitposition = this.intersectPlane(panelpoint, forward);
                if (hitposition) {
                    pickinfo = new gd3d.framework.pickinfo(0, 0, 0);
                    pickinfo.hitposition = hitposition;
                    pickinfo.distance = gd3d.math.vec3Distance(pickinfo.hitposition, this.origin);
                }
                gd3d.math.pool.delete_vector3(forward);
                return pickinfo;
            };
            ray.prototype.intersectPlane = function (planePoint, planeNormal) {
                var vp1 = planeNormal.x;
                var vp2 = planeNormal.y;
                var vp3 = planeNormal.z;
                var n1 = planePoint.x;
                var n2 = planePoint.y;
                var n3 = planePoint.z;
                var v1 = this.direction.x;
                var v2 = this.direction.y;
                var v3 = this.direction.z;
                var m1 = this.origin.x;
                var m2 = this.origin.y;
                var m3 = this.origin.z;
                var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
                if (vpt === 0) {
                    return null;
                }
                else {
                    var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                    return new gd3d.math.vector3(m1 + v1 * t, m2 + v2 * t, m3 + v3 * t);
                }
            };
            ray.prototype.intersectCollider = function (tran) {
                var _collider = tran.gameObject.collider;
                var pickinfo = null;
                if (_collider instanceof framework.boxcollider) {
                    var obb = _collider.getBound();
                    var vecs = [];
                    obb.caclWorldVecs(vecs, _collider.gameObject.transform.getWorldMatrix());
                    var data = gd3d.render.meshData.genBoxByArray(vecs);
                    for (var index = 0; index < data.pos.length; index += 3) {
                        var p0 = data.pos[data.trisindex[index]];
                        var p1 = data.pos[data.trisindex[index + 1]];
                        var p2 = data.pos[data.trisindex[index + 2]];
                        var result = this.intersectsTriangle(p0, p1, p2);
                        if (result) {
                            if (result.distance < 0)
                                continue;
                            if (!pickinfo || pickinfo.distance > result.distance) {
                                pickinfo = result;
                                var tdir = gd3d.math.pool.new_vector3();
                                gd3d.math.vec3ScaleByNum(this.direction, result.distance, tdir);
                                gd3d.math.vec3Add(this.origin, tdir, pickinfo.hitposition);
                                gd3d.math.pool.delete_vector3(tdir);
                            }
                        }
                    }
                }
                else if (_collider instanceof framework.meshcollider) {
                    var mesh = _collider.getBound();
                    if (mesh != null) {
                        pickinfo = mesh.intersects(this, tran.getWorldMatrix());
                    }
                }
                else if (_collider instanceof framework.canvasRenderer) {
                    pickinfo = this.intersectPlaneTransform(tran);
                }
                return pickinfo;
            };
            ray.prototype.intersectBoxMinMax = function (minimum, maximum) {
                var d = 0.0;
                var maxValue = Number.MAX_VALUE;
                var inv;
                var min;
                var max;
                var temp;
                if (Math.abs(this.direction.x) < 0.0000001) {
                    if (this.origin.x < minimum.x || this.origin.x > maximum.x) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.x;
                    min = (minimum.x - this.origin.x) * inv;
                    max = (maximum.x - this.origin.x) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.y) < 0.0000001) {
                    if (this.origin.y < minimum.y || this.origin.y > maximum.y) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.y;
                    min = (minimum.y - this.origin.y) * inv;
                    max = (maximum.y - this.origin.y) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.z) < 0.0000001) {
                    if (this.origin.z < minimum.z || this.origin.z > maximum.z) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.z;
                    min = (minimum.z - this.origin.z) * inv;
                    max = (maximum.z - this.origin.z) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                return true;
            };
            ray.prototype.intersectsSphere = function (center, radius) {
                var center_ori = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(center, this.origin, center_ori);
                var raydist = gd3d.math.vec3Dot(this.direction, center_ori);
                if (orilen2 < rad2)
                    return true;
                if (raydist < 0)
                    return false;
                var orilen2 = gd3d.math.vec3SqrLength(center_ori);
                gd3d.math.pool.delete_vector3(center_ori);
                var rad2 = radius * radius;
                var d = rad2 - (orilen2 - raydist * raydist);
                if (d < 0)
                    return false;
                return true;
            };
            ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {
                var _edge1 = gd3d.math.pool.new_vector3();
                var _edge2 = gd3d.math.pool.new_vector3();
                var _pvec = gd3d.math.pool.new_vector3();
                var _tvec = gd3d.math.pool.new_vector3();
                var _qvec = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(vertex1, vertex0, _edge1);
                gd3d.math.vec3Subtract(vertex2, vertex0, _edge2);
                gd3d.math.vec3Cross(this.direction, _edge2, _pvec);
                var det = gd3d.math.vec3Dot(_edge1, _pvec);
                if (det === 0) {
                    return null;
                }
                var invdet = 1 / det;
                gd3d.math.vec3Subtract(this.origin, vertex0, _tvec);
                var bu = gd3d.math.vec3Dot(_tvec, _pvec) * invdet;
                if (bu < 0 || bu > 1.0) {
                    return null;
                }
                gd3d.math.vec3Cross(_tvec, _edge1, _qvec);
                var bv = gd3d.math.vec3Dot(this.direction, _qvec) * invdet;
                if (bv < 0 || bu + bv > 1.0) {
                    return null;
                }
                var distance = gd3d.math.vec3Dot(_edge2, _qvec) * invdet;
                gd3d.math.pool.delete_vector3(_edge1);
                gd3d.math.pool.delete_vector3(_edge2);
                gd3d.math.pool.delete_vector3(_pvec);
                gd3d.math.pool.delete_vector3(_tvec);
                gd3d.math.pool.delete_vector3(_qvec);
                return new framework.pickinfo(bu, bv, distance);
            };
            return ray;
        }());
        framework.ray = ray;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var transform = (function () {
            function transform() {
                this.name = "noname";
                this.insId = new insID();
                this.prefab = null;
                this.aabbdirty = true;
                this.aabbchilddirty = true;
                this.dirty = true;
                this.dirtyChild = true;
                this.dirtyWorldDecompose = false;
                this.localRotate = new gd3d.math.quaternion();
                this.localTranslate = new gd3d.math.vector3(0, 0, 0);
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.localMatrix = new gd3d.math.matrix();
                this._localEulerAngles = new gd3d.math.vector3(0, 0, 0);
                this.worldMatrix = new gd3d.math.matrix();
                this.worldRotate = new gd3d.math.quaternion();
                this.worldTranslate = new gd3d.math.vector3(0, 0, 0);
                this.worldScale = new gd3d.math.vector3(1, 1, 1);
            }
            Object.defineProperty(transform.prototype, "scene", {
                get: function () {
                    if (this._scene == null) {
                        if (this.parent == null)
                            return null;
                        return this.parent.scene;
                    }
                    return this._scene;
                },
                set: function (value) {
                    this._scene = value;
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.markAABBDirty = function () {
                this.aabbdirty = true;
                this.markAABBChildDirty();
                var p = this.parent;
                while (p != null) {
                    p.markAABBChildDirty();
                    p = p.parent;
                }
            };
            transform.prototype.markAABBChildDirty = function () {
                this.aabbchilddirty = true;
            };
            transform.prototype.caclAABB = function () {
                if (this.gameObject.components == null)
                    return;
                if (this.aabb == null) {
                    this.aabb = this.buildAABB();
                    this.aabbchild = this.aabb.clone();
                }
                this.aabb.update(this.worldMatrix);
            };
            transform.prototype.caclAABBChild = function () {
                if (this.aabb == null)
                    return;
                this.aabbchild = this.aabb.clone();
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.aabbchild.addAABB(this.children[i].aabbchild);
                    }
                }
            };
            transform.prototype.buildAABB = function () {
                var minimum = new gd3d.math.vector3();
                var maximum = new gd3d.math.vector3();
                var filter = this.gameObject.getComponent("meshFilter");
                if (filter != null && filter.mesh != null) {
                    var meshdata = filter.mesh.data;
                    gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                    gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                    for (var i = 0; i < meshdata.pos.length; i++) {
                        gd3d.math.vec3Max(meshdata.pos[i], maximum, maximum);
                        gd3d.math.vec3Min(meshdata.pos[i], minimum, minimum);
                    }
                }
                else {
                    var skinmesh = this.gameObject.getComponent("skinnedMeshRenderer");
                    if (skinmesh != null) {
                        var skinmeshdata = skinmesh.mesh.data;
                        gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                        gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                        for (var i = 0; i < skinmeshdata.pos.length; i++) {
                            gd3d.math.vec3Max(skinmeshdata.pos[i], maximum, maximum);
                            gd3d.math.vec3Min(skinmeshdata.pos[i], minimum, minimum);
                        }
                    }
                    else {
                        minimum.x = -1;
                        minimum.y = -1;
                        minimum.z = -1;
                        maximum.x = 1;
                        maximum.y = 1;
                        maximum.z = 1;
                    }
                }
                var _aabb = new framework.aabb(minimum, maximum);
                return _aabb;
            };
            transform.prototype.addChild = function (node) {
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.push(node);
                node.scene = this.scene;
                node.parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
            };
            transform.prototype.addChildAt = function (node, index) {
                if (index < 0)
                    return;
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.splice(index, 0, node);
                node.scene = this.scene;
                node.parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
            };
            transform.prototype.removeAllChild = function () {
                if (this.children == undefined)
                    return;
                while (this.children.length > 0) {
                    this.removeChild(this.children[0]);
                }
            };
            transform.prototype.removeChild = function (node) {
                if (node.parent != this || this.children == null) {
                    throw new Error("not my child.");
                }
                var i = this.children.indexOf(node);
                if (i >= 0) {
                    this.children.splice(i, 1);
                    framework.sceneMgr.app.markNotify(node, framework.NotifyType.RemoveChild);
                    node.parent = null;
                }
            };
            transform.prototype.find = function (name) {
                if (this.name == name)
                    return this;
                else {
                    if (this.children != undefined) {
                        for (var i in this.children) {
                            var res = this.children[i].find(name);
                            if (res != null)
                                return res;
                            else {
                                continue;
                            }
                        }
                    }
                }
                return null;
            };
            transform.prototype.checkImpactTran = function (tran) {
                if (this.gameObject.collider == null)
                    return false;
                return this.gameObject.collider.intersectsTransform(tran);
            };
            transform.prototype.checkImpact = function () {
                var trans = new Array();
                this.doImpact(this.scene.getRoot(), trans);
                return trans;
            };
            transform.prototype.doImpact = function (tran, impacted) {
                if (tran == this)
                    return;
                if (tran.gameObject != null && tran.gameObject.collider != null) {
                    if (this.checkImpactTran(tran)) {
                        impacted.push(tran);
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        this.doImpact(tran.children[i], impacted);
                    }
                }
            };
            transform.prototype.markDirty = function () {
                this.dirty = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p = p.parent;
                }
            };
            transform.prototype.updateTran = function (parentChange) {
                if (this.dirtyChild == false && this.dirty == false && parentChange == false)
                    return;
                if (this.dirty) {
                    gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                if (this.dirty || parentChange) {
                    if (this.parent == null) {
                        gd3d.math.matrixClone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        gd3d.math.matrixMultiply(this.parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    this.dirtyWorldDecompose = true;
                    this.markAABBDirty();
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].updateTran(parentChange || this.dirty);
                    }
                }
                this.dirty = false;
                this.dirtyChild = false;
                if (this.aabbdirty) {
                    this.caclAABB();
                    this.aabbdirty = false;
                }
            };
            transform.prototype.updateWorldTran = function () {
                var p = this.parent;
                var dirtylist = [];
                dirtylist.push(this);
                while (p != null) {
                    if (p.dirty)
                        dirtylist.push(p);
                    p = p.parent;
                }
                var top = dirtylist.pop();
                top.updateTran(false);
            };
            transform.prototype.updateAABBChild = function () {
                if (this.aabbchilddirty) {
                    if (this.children != null) {
                        for (var i = 0; i < this.children.length; i++) {
                            this.children[i].updateAABBChild();
                        }
                    }
                    this.caclAABBChild();
                    this.aabbchilddirty = false;
                }
            };
            Object.defineProperty(transform.prototype, "localEulerAngles", {
                get: function () {
                    gd3d.math.quatToEulerAngles(this.localRotate, this._localEulerAngles);
                    return this._localEulerAngles;
                },
                set: function (angle) {
                    gd3d.math.quatFromEulerAngles(angle.x, angle.y, angle.z, this.localRotate);
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.getWorldTranslate = function () {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrixDecompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldTranslate;
            };
            transform.prototype.getWorldScale = function () {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrixDecompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldScale;
            };
            transform.prototype.getWorldRotate = function () {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrixDecompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldRotate;
            };
            transform.prototype.getLocalMatrix = function () {
                return this.localMatrix;
            };
            transform.prototype.getWorldMatrix = function () {
                return this.worldMatrix;
            };
            transform.prototype.getForwardInWorld = function (out) {
                var forward = gd3d.math.pool.new_vector3();
                forward.x = 0;
                forward.y = 0;
                forward.z = 1;
                gd3d.math.matrixTransformNormal(forward, this.worldMatrix, out);
                gd3d.math.vec3Normalize(out, out);
                gd3d.math.pool.delete_vector3(forward);
            };
            transform.prototype.getRightInWorld = function (out) {
                var right = gd3d.math.pool.new_vector3();
                right.x = 1;
                right.y = 0;
                right.z = 0;
                gd3d.math.matrixTransformNormal(right, this.worldMatrix, out);
                gd3d.math.vec3Normalize(out, out);
                gd3d.math.pool.delete_vector3(right);
            };
            transform.prototype.getUpInWorld = function (out) {
                var up = gd3d.math.pool.new_vector3();
                up.x = 0;
                up.y = 1;
                up.z = 0;
                gd3d.math.matrixTransformNormal(up, this.worldMatrix, out);
                gd3d.math.vec3Normalize(out, out);
                gd3d.math.pool.delete_vector3(up);
            };
            transform.prototype.setWorldMatrix = function (mat) {
                this.dirty = true;
                this.updateWorldTran();
                var pworld = gd3d.math.pool.new_matrix();
                if (this.parent != null) {
                    gd3d.math.matrixClone(this.parent.worldMatrix, pworld);
                }
                else {
                    gd3d.math.matrixMakeIdentity(pworld);
                }
                var invparentworld = gd3d.math.pool.new_matrix();
                gd3d.math.matrixInverse(pworld, invparentworld);
                gd3d.math.matrixClone(mat, this.worldMatrix);
                this.dirtyWorldDecompose = true;
                gd3d.math.matrixMultiply(invparentworld, this.worldMatrix, this.localMatrix);
                gd3d.math.matrixDecompose(this.localMatrix, this.localScale, this.localRotate, this.localTranslate);
                this.markDirty();
                gd3d.math.pool.delete_matrix(pworld);
                gd3d.math.pool.delete_matrix(invparentworld);
            };
            transform.prototype.setWorldPosition = function (pos) {
                this.dirty = true;
                this.updateWorldTran();
                var pworld = gd3d.math.pool.new_matrix();
                if (this.parent != null) {
                    gd3d.math.matrixClone(this.parent.worldMatrix, pworld);
                }
                else {
                    gd3d.math.matrixMakeIdentity(pworld);
                }
                var invparentworld = gd3d.math.pool.new_matrix();
                gd3d.math.matrixInverse(pworld, invparentworld);
                this.worldMatrix.rawData[12] = pos.x;
                this.worldMatrix.rawData[13] = pos.y;
                this.worldMatrix.rawData[14] = pos.z;
                gd3d.math.matrixMultiply(invparentworld, this.worldMatrix, this.localMatrix);
                gd3d.math.matrixDecompose(this.localMatrix, this.localScale, this.localRotate, this.localTranslate);
                this.markDirty();
                gd3d.math.pool.delete_matrix(pworld);
                gd3d.math.pool.delete_matrix(invparentworld);
            };
            transform.prototype.lookat = function (trans) {
                this.dirty = true;
                trans.updateWorldTran();
                this.updateWorldTran();
                var p0 = this.getWorldTranslate();
                var p1 = trans.getWorldTranslate();
                var d = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(p1, p0, d);
                var quatworld = gd3d.math.pool.new_quaternion();
                var quat = gd3d.math.pool.new_quaternion();
                gd3d.math.quatLookat(p0, p1, quatworld);
                var quatworldCur = this.parent.getWorldRotate();
                gd3d.math.quatInverse(quatworldCur, quat);
                gd3d.math.quatMultiply(quat, quatworld, this.localRotate);
                gd3d.math.pool.delete_vector3(d);
                gd3d.math.pool.delete_quaternion(quatworld);
                gd3d.math.pool.delete_quaternion(quat);
            };
            transform.prototype.lookatPoint = function (point) {
                this.dirty = true;
                this.updateWorldTran();
                var p0 = this.getWorldTranslate();
                var p1 = point;
                var d = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(p1, p0, d);
                var quatworld = gd3d.math.pool.new_quaternion();
                var quat = gd3d.math.pool.new_quaternion();
                gd3d.math.quatLookat(p0, p1, quatworld);
                var quatworldCur = this.parent.getWorldRotate();
                gd3d.math.quatInverse(quatworldCur, quat);
                gd3d.math.quatMultiply(quat, quatworld, this.localRotate);
                this.markDirty();
                gd3d.math.pool.delete_vector3(d);
                gd3d.math.pool.delete_quaternion(quatworld);
                gd3d.math.pool.delete_quaternion(quat);
            };
            Object.defineProperty(transform.prototype, "gameObject", {
                get: function () {
                    if (this._gameObject == null) {
                        this._gameObject = new framework.gameObject();
                        this._gameObject.transform = this;
                    }
                    return this._gameObject;
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.clone = function () {
                return gd3d.io.cloneObj(this);
            };
            transform.prototype.dispose = function () {
                if (this.children) {
                    for (var k in this.children) {
                        this.children[k].dispose();
                    }
                    this.removeAllChild();
                }
                this._gameObject.dispose();
            };
            return transform;
        }());
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], transform.prototype, "name", void 0);
        __decorate([
            gd3d.reflect.Field("transform[]"),
            __metadata("design:type", Array)
        ], transform.prototype, "children", void 0);
        __decorate([
            gd3d.reflect.Field("quaternion"),
            __metadata("design:type", gd3d.math.quaternion)
        ], transform.prototype, "localRotate", void 0);
        __decorate([
            gd3d.reflect.Field("vector3", new gd3d.math.vector3(0, 0, 0)),
            __metadata("design:type", gd3d.math.vector3)
        ], transform.prototype, "localTranslate", void 0);
        __decorate([
            gd3d.reflect.Field("vector3", new gd3d.math.vector3(1, 1, 1)),
            __metadata("design:type", gd3d.math.vector3)
        ], transform.prototype, "localScale", void 0);
        __decorate([
            gd3d.reflect.Field("gameObject"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], transform.prototype, "gameObject", null);
        transform = __decorate([
            gd3d.reflect.SerializeType
        ], transform);
        framework.transform = transform;
        var insID = (function () {
            function insID() {
                this.id = insID.next();
            }
            insID.next = function () {
                var next = insID.idAll;
                insID.idAll++;
                return next;
            };
            insID.prototype.getInsID = function () {
                return this.id;
            };
            return insID;
        }());
        insID.idAll = 1;
        framework.insID = insID;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EnumUtil = (function () {
            function EnumUtil() {
            }
            EnumUtil.getEnumObjByType = function (enumType) {
                var index = enumType.indexOf("gd3d.framework.");
                if (index == 0)
                    enumType = enumType.substr(15);
                return eval("{result:" + enumType + "}");
            };
            return EnumUtil;
        }());
        framework.EnumUtil = EnumUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var PrimitiveType;
        (function (PrimitiveType) {
            PrimitiveType[PrimitiveType["Sphere"] = 0] = "Sphere";
            PrimitiveType[PrimitiveType["Capsule"] = 1] = "Capsule";
            PrimitiveType[PrimitiveType["Cylinder"] = 2] = "Cylinder";
            PrimitiveType[PrimitiveType["Cube"] = 3] = "Cube";
            PrimitiveType[PrimitiveType["Plane"] = 4] = "Plane";
            PrimitiveType[PrimitiveType["Quad"] = 5] = "Quad";
            PrimitiveType[PrimitiveType["Pyramid"] = 6] = "Pyramid";
        })(PrimitiveType = framework.PrimitiveType || (framework.PrimitiveType = {}));
        var Primitive2DType;
        (function (Primitive2DType) {
            Primitive2DType[Primitive2DType["RawImage2D"] = 0] = "RawImage2D";
            Primitive2DType[Primitive2DType["Image2D"] = 1] = "Image2D";
            Primitive2DType[Primitive2DType["Label"] = 2] = "Label";
            Primitive2DType[Primitive2DType["Button"] = 3] = "Button";
        })(Primitive2DType = framework.Primitive2DType || (framework.Primitive2DType = {}));
        var GameObjectUtil = (function () {
            function GameObjectUtil() {
            }
            GameObjectUtil.CreatePrimitive = function (type, app) {
                var objName = PrimitiveType[type];
                var trans = new framework.transform();
                trans.name = objName;
                var mesh = trans.gameObject.addComponent("meshFilter");
                var smesh = app.getAssetMgr().getDefaultMesh(objName.toLowerCase());
                mesh.mesh = smesh;
                var renderer = trans.gameObject.addComponent("meshRenderer");
                renderer.materials = [];
                renderer.materials.push(new framework.material());
                renderer.materials[0].setShader(app.getAssetMgr().getShader("shader/def"));
                return trans.gameObject;
            };
            GameObjectUtil.Create2DPrimitive = function (type, app) {
                var objName = Primitive2DType[type];
                var componentName = framework.StringUtil.firstCharToLowerCase(objName);
                var t2d = new framework.transform2D();
                t2d.name = objName;
                var i2dComp = t2d.addComponent(componentName);
                t2d.pivot.x = 0;
                t2d.pivot.y = 0;
                switch (type) {
                    case Primitive2DType.RawImage2D:
                        GameObjectUtil.create2D_rawImage(i2dComp, app);
                        break;
                    case Primitive2DType.Image2D:
                        GameObjectUtil.create2D_image2D(i2dComp, app);
                        break;
                    case Primitive2DType.Label:
                        GameObjectUtil.create2D_label(i2dComp, app);
                        break;
                    case Primitive2DType.Button:
                        GameObjectUtil.create2D_button(i2dComp, app);
                        break;
                }
                return t2d;
            };
            GameObjectUtil.create2D_rawImage = function (img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.image = app.getAssetMgr().getDefaultTexture("white");
            };
            GameObjectUtil.create2D_image2D = function (img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.setTexture(app.getAssetMgr().getDefaultTexture("white"));
            };
            GameObjectUtil.create2D_label = function (label, app) {
                label.transform.width = 150;
                label.transform.height = 50;
                label.text = "label";
                label.fontsize = 25;
                label.color = new gd3d.math.color(1, 0, 0, 1);
                var _font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                if (_font == null) {
                    app.getAssetMgr().load("res/STXINGKA.TTF.png", gd3d.framework.AssetTypeEnum.Auto, function (s) {
                        if (s.isfinish) {
                            app.getAssetMgr().load("res/resources/STXINGKA.font.json", gd3d.framework.AssetTypeEnum.Auto, function (s1) {
                                label.font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                                label.transform.markDirty();
                            });
                        }
                    });
                }
                else {
                    label.font = _font;
                    ;
                    label.transform.markDirty();
                }
            };
            GameObjectUtil.create2D_button = function (btn, app) {
                btn.transform.width = 150;
                btn.transform.height = 50;
                var img = btn.transform.addComponent("image2D");
                img.setTexture(app.getAssetMgr().getDefaultTexture("white"));
                img.imageType = gd3d.framework.ImageType.Sliced;
                btn.targetImage = img;
                btn.transition = gd3d.framework.TransitionType.ColorTint;
                var lab = new gd3d.framework.transform2D();
                lab.name = "label";
                lab.width = 150;
                lab.height = 50;
                lab.pivot.x = 0;
                lab.pivot.y = 0;
                lab.localTranslate.y = -10;
                var label = lab.addComponent("label");
                label.text = "button";
                label.fontsize = 25;
                label.color = new gd3d.math.color(1, 0, 0, 1);
                btn.transform.addChild(lab);
                var _font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                if (_font == null) {
                    app.getAssetMgr().load("res/STXINGKA.TTF.png", gd3d.framework.AssetTypeEnum.Auto, function (s) {
                        if (s.isfinish) {
                            app.getAssetMgr().load("res/resources/STXINGKA.font.json", gd3d.framework.AssetTypeEnum.Auto, function (s1) {
                                label.font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                                btn.transform.markDirty();
                            });
                        }
                    });
                }
                else {
                    label.font = _font;
                    ;
                    btn.transform.markDirty();
                }
            };
            return GameObjectUtil;
        }());
        framework.GameObjectUtil = GameObjectUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var NumberUtil = (function () {
            function NumberUtil() {
            }
            return NumberUtil;
        }());
        NumberUtil.KEY_A = 65;
        NumberUtil.KEY_D = 68;
        NumberUtil.KEY_E = 69;
        NumberUtil.KEY_Q = 81;
        NumberUtil.KEY_R = 82;
        NumberUtil.KEY_S = 83;
        NumberUtil.KEY_W = 87;
        NumberUtil.KEY_a = 97;
        NumberUtil.KEY_d = 100;
        NumberUtil.KEY_e = 101;
        NumberUtil.KEY_q = 113;
        NumberUtil.KEY_r = 114;
        NumberUtil.KEY_s = 115;
        NumberUtil.KEY_w = 119;
        framework.NumberUtil = NumberUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var RegexpUtil = (function () {
            function RegexpUtil() {
            }
            return RegexpUtil;
        }());
        RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
        RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
        framework.RegexpUtil = RegexpUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var StringUtil = (function () {
            function StringUtil() {
            }
            StringUtil.replaceAll = function (srcStr, fromStr, toStr) {
                return srcStr.replace(new RegExp(fromStr, 'gm'), toStr);
            };
            StringUtil.trimAll = function (str) {
                str += "";
                var result = str.replace(/(^\s+)|(\s+$)/g, "");
                result = result.replace(/\s/g, "");
                return result;
            };
            StringUtil.firstCharToLowerCase = function (str) {
                var firstChar = str.substr(0, 1).toLowerCase();
                var other = str.substr(1);
                return firstChar + other;
            };
            return StringUtil;
        }());
        StringUtil.COMPONENT_CAMERA = "camera";
        StringUtil.COMPONENT_BOXCOLLIDER = "boxcollider";
        StringUtil.COMPONENT_LIGHT = "light";
        StringUtil.COMPONENT_MESHFILTER = "meshFilter";
        StringUtil.COMPONENT_MESHRENDER = "meshRenderer";
        StringUtil.COMPONENT_EFFECTSYSTEM = "effectSystem";
        StringUtil.COMPONENT_LABEL = "label";
        StringUtil.COMPONENT_IMAGE = "image2D";
        StringUtil.COMPONENT_RAWIMAGE = "rawImage2D";
        StringUtil.COMPONENT_BUTTON = "button";
        StringUtil.COMPONENT_SKINMESHRENDER = "skinnedMeshRenderer";
        StringUtil.COMPONENT_CAMERACONTROLLER = "cameraController";
        StringUtil.COMPONENT_CANVASRENDER = "canvasRenderer";
        StringUtil.UIStyle_RangeFloat = "rangeFloat";
        StringUtil.UIStyle_Enum = "enum";
        StringUtil.RESOURCES_MESH_CUBE = "cube";
        framework.StringUtil = StringUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        function loadText(url, fun) {
            var req = new XMLHttpRequest();
            req.open("GET", url);
            req.responseType = "text";
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 404) {
                        fun(null, new Error("got a 404:" + url));
                        return;
                    }
                    fun(req.responseText, null);
                }
            };
            req.onerror = function () {
                fun(null, new Error("onerr in req:"));
            };
            req.send();
        }
        io.loadText = loadText;
        function loadArrayBuffer(url, fun) {
            var req = new XMLHttpRequest();
            req.open("GET", url);
            req.responseType = "arraybuffer";
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 404) {
                        fun(null, new Error("got a 404:" + url));
                        return;
                    }
                    fun(req.response, null);
                }
            };
            req.onerror = function () {
                fun(null, new Error("onerr in req:"));
            };
            req.send();
        }
        io.loadArrayBuffer = loadArrayBuffer;
        function loadBlob(url, fun) {
            var req = new XMLHttpRequest();
            req.open("GET", url);
            req.responseType = "blob";
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 404) {
                        fun(null, new Error("got a 404:" + url));
                        return;
                    }
                    fun(req.response, null);
                }
            };
            req.onerror = function () {
                fun(null, new Error("onerr in req:"));
            };
            req.send();
        }
        io.loadBlob = loadBlob;
        function loadImg(url, fun, progress) {
            var img = new Image();
            img.src = url;
            img.onerror = function (error) {
                if (error != null) {
                    fun(null, new Error(error.message));
                }
            };
            img.onprogress = function (e) {
                if (progress) {
                    var val = e.loaded / e.total * 100;
                    progress(val);
                }
            };
            img.onload = function () {
                fun(img, null);
            };
        }
        io.loadImg = loadImg;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        var pool = (function () {
            function pool() {
            }
            pool.collect_all = function () {
                pool.collect_vector4();
                pool.collect_vector3();
                pool.collect_vector2();
                pool.collect_matrix();
                pool.collect_quaternion();
                pool.collect_color();
            };
            Object.defineProperty(pool, "vector4_one", {
                get: function () {
                    if (pool._vector4_one == null) {
                        pool._vector4_one = new math.vector4(1, 1, 1, 1);
                    }
                    return pool._vector4_one;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_vector4 = function () {
                if (pool.unused_vector4.length > 0)
                    return pool.unused_vector4.pop();
                else
                    return new math.vector4();
            };
            pool.clone_vector4 = function (src) {
                if (pool.unused_vector4.length > 0) {
                    var v = pool.unused_vector4.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    v.w = src.w;
                    return v;
                }
                else
                    return new math.vector4(src.x, src.y, src.z);
            };
            pool.delete_vector4 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector4) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    pool.unused_vector4.push(v);
                }
                else
                    console.error("kindding me?vector4");
            };
            pool.collect_vector4 = function () {
                pool.unused_vector4.length = 0;
            };
            Object.defineProperty(pool, "color_one", {
                get: function () {
                    if (pool._color_one == null) {
                        pool._color_one = new math.color(1, 1, 1, 1);
                    }
                    return pool._color_one;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_color = function () {
                if (pool.unused_color.length > 0)
                    return pool.unused_color.pop();
                else
                    return new math.color();
            };
            pool.delete_color = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.color) {
                    v.r = v.g = v.b = 0;
                    v.a = 1;
                    pool.unused_color.push(v);
                }
                else
                    console.error("kindding me?color");
            };
            pool.collect_color = function () {
                pool.unused_color.length = 0;
            };
            Object.defineProperty(pool, "vector3_up", {
                get: function () {
                    if (pool._vector3_up == null) {
                        pool._vector3_up = new math.vector3(0, 1, 0);
                    }
                    return pool._vector3_up;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_right", {
                get: function () {
                    if (pool._vector3_right == null) {
                        pool._vector3_right = new math.vector3(1, 0, 0);
                    }
                    return pool._vector3_right;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_forward", {
                get: function () {
                    if (pool._vector3_forward == null) {
                        pool._vector3_forward = new math.vector3(0, 0, 1);
                    }
                    return pool._vector3_forward;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_zero", {
                get: function () {
                    if (pool._vector3_zero == null) {
                        pool._vector3_zero = new math.vector3(0, 0, 0);
                    }
                    return pool._vector3_zero;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_one", {
                get: function () {
                    if (pool._vector3_one == null) {
                        pool._vector3_one = new math.vector3(1, 1, 1);
                    }
                    return pool._vector3_one;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_vector3 = function () {
                if (pool.unused_vector3.length > 0) {
                    var v = pool.unused_vector3.pop();
                    v.x = v.y = v.z = 0;
                    return v;
                }
                else
                    return new math.vector3();
            };
            pool.clone_vector3 = function (src) {
                if (pool.unused_vector3.length > 0) {
                    var v = pool.unused_vector3.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    return v;
                }
                else
                    return new math.vector3(src.x, src.y, src.z);
            };
            pool.delete_vector3 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector3) {
                    v.x = v.y = v.z = 0;
                    pool.unused_vector3.push(v);
                }
                else
                    console.error("kindding me?vector3");
            };
            pool.collect_vector3 = function () {
                pool.unused_vector3.length = 0;
            };
            Object.defineProperty(pool, "vector2_up", {
                get: function () {
                    if (pool._vector2_up == null) {
                        pool._vector2_up = new math.vector2(0, 1);
                    }
                    return pool._vector2_up;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector2_right", {
                get: function () {
                    if (pool._vector2_right == null) {
                        pool._vector2_right = new math.vector2(1, 0);
                    }
                    return pool._vector2_right;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_vector2 = function () {
                if (pool.unused_vector2.length > 0)
                    return pool.unused_vector2.pop();
                else
                    return new math.vector2();
            };
            pool.clone_vector2 = function (src) {
                if (pool.unused_vector2.length > 0) {
                    var v = pool.unused_vector2.pop();
                    v.x = src.x;
                    v.y = src.y;
                    return v;
                }
                else
                    return new math.vector2(src.x, src.y);
            };
            pool.delete_vector2 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector2) {
                    v.x = v.y = 0;
                    pool.unused_vector2.push(v);
                }
                else
                    console.error("kindding me?vector2");
            };
            pool.delete_vector2Array = function (vs) {
                for (var i = 0; i < vs.length; i++) {
                    if (vs[i] != undefined) {
                        vs[i].x = vs[i].y = 0;
                        pool.unused_vector2.push(vs[i]);
                    }
                }
                vs.length = 0;
            };
            pool.collect_vector2 = function () {
                pool.unused_vector2.length = 0;
            };
            pool.new_matrix3x2 = function () {
                if (pool.unused_matrix3x2.length > 0)
                    return pool.unused_matrix3x2.pop();
                else
                    return new math.matrix3x2();
            };
            pool.clone_matrix3x2 = function (src) {
                var v = pool.new_matrix();
                for (var i = 0; i < 6; i++)
                    v.rawData[i] = src.rawData[i];
                return v;
            };
            pool.delete_matrix3x2 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.matrix3x2) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 0;
                    v.rawData[4] = 1;
                    v.rawData[5] = 0;
                    pool.unused_matrix3x2.push(v);
                }
                else {
                    console.error("kindding me?matrix3x2");
                }
            };
            pool.collect_matrix3x2 = function () {
                pool.unused_matrix3x2.length = 0;
            };
            pool.new_matrix = function () {
                if (pool.unused_matrix.length > 0)
                    return pool.unused_matrix.pop();
                else
                    return new math.matrix();
            };
            pool.clone_matrix = function (src) {
                var v = pool.new_matrix();
                for (var i = 0; i < 16; i++)
                    v.rawData[i] = src.rawData[i];
                return v;
            };
            pool.delete_matrix = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.matrix) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 0;
                    v.rawData[4] = 0;
                    v.rawData[5] = 1;
                    v.rawData[6] = 0;
                    v.rawData[7] = 0;
                    v.rawData[8] = 0;
                    v.rawData[9] = 0;
                    v.rawData[10] = 1;
                    v.rawData[11] = 0;
                    v.rawData[12] = 0;
                    v.rawData[13] = 0;
                    v.rawData[14] = 0;
                    v.rawData[15] = 1;
                    pool.unused_matrix.push(v);
                }
                else
                    console.error("kindding me?matrix");
            };
            pool.collect_matrix = function () {
                pool.unused_matrix.length = 0;
            };
            pool.new_quaternion = function () {
                if (pool.unused_quaternion.length > 0)
                    return pool.unused_quaternion.pop();
                else
                    return new math.quaternion();
            };
            pool.clone_quaternion = function (src) {
                if (pool.unused_quaternion.length > 0) {
                    var v = pool.unused_quaternion.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    v.w = src.w;
                    return v;
                }
                else
                    return new math.quaternion(src.x, src.y, src.z, src.w);
            };
            pool.delete_quaternion = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.quaternion) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    pool.unused_quaternion.push(v);
                }
                else
                    console.error("kindding me?quaternion");
            };
            pool.collect_quaternion = function () {
                pool.unused_quaternion.length = 0;
            };
            return pool;
        }());
        pool.unused_vector4 = [];
        pool.unused_color = [];
        pool.unused_vector3 = [];
        pool.unused_vector2 = [];
        pool.unused_matrix3x2 = [];
        pool.unused_matrix = [];
        pool.unused_quaternion = [];
        math.pool = pool;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var caps = (function () {
            function caps() {
            }
            return caps;
        }());
        render.caps = caps;
        var webglkit = (function () {
            function webglkit() {
            }
            webglkit.SetMaxVertexAttribArray = function (webgl, count) {
                for (var i = count; i < webglkit._maxVertexAttribArray; i++) {
                    webgl.disableVertexAttribArray(i);
                }
                webglkit._maxVertexAttribArray = count;
            };
            webglkit.GetTextureNumber = function (webgl, index) {
                webglkit.initConst(webgl);
                return webglkit._texNumber[index];
            };
            webglkit.initConst = function (webgl) {
                if (webglkit._texNumber == null) {
                    webglkit._texNumber = [];
                    webglkit._texNumber.push(webgl.TEXTURE0);
                    webglkit._texNumber.push(webgl.TEXTURE1);
                    webglkit._texNumber.push(webgl.TEXTURE2);
                    webglkit._texNumber.push(webgl.TEXTURE3);
                    webglkit._texNumber.push(webgl.TEXTURE4);
                    webglkit._texNumber.push(webgl.TEXTURE5);
                    webglkit._texNumber.push(webgl.TEXTURE6);
                    webglkit._texNumber.push(webgl.TEXTURE7);
                    webglkit._texNumber.push(webgl.TEXTURE8);
                    webglkit._texNumber.push(webgl.TEXTURE9);
                    webglkit.LEQUAL = webgl.LEQUAL;
                    webglkit.NEVER = webgl.NEVER;
                    webglkit.EQUAL = webgl.EQUAL;
                    webglkit.GEQUAL = webgl.GEQUAL;
                    webglkit.NOTEQUAL = webgl.NOTEQUAL;
                    webglkit.LESS = webgl.LESS;
                    webglkit.GREATER = webgl.GREATER;
                    webglkit.ALWAYS = webgl.ALWAYS;
                    webglkit.FUNC_ADD = webgl.FUNC_ADD;
                    webglkit.FUNC_SUBTRACT = webgl.FUNC_SUBTRACT;
                    webglkit.FUNC_REVERSE_SUBTRACT = webgl.FUNC_REVERSE_SUBTRACT;
                    webglkit.ONE = webgl.ONE;
                    webglkit.ZERO = webgl.ZERO;
                    webglkit.SRC_ALPHA = webgl.SRC_ALPHA;
                    webglkit.SRC_COLOR = webgl.SRC_COLOR;
                    webglkit.ONE_MINUS_SRC_ALPHA = webgl.ONE_MINUS_SRC_ALPHA;
                    webglkit.ONE_MINUS_SRC_COLOR = webgl.ONE_MINUS_SRC_COLOR;
                    webglkit.ONE_MINUS_DST_ALPHA = webgl.ONE_MINUS_DST_ALPHA;
                    webglkit.ONE_MINUS_DST_COLOR = webgl.ONE_MINUS_DST_COLOR;
                    webglkit.caps.standardDerivatives = (webgl.getExtension('OES_standard_derivatives') !== null);
                }
            };
            return webglkit;
        }());
        webglkit._maxVertexAttribArray = 0;
        webglkit._texNumber = null;
        webglkit.caps = new caps();
        render.webglkit = webglkit;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var ShowFaceStateEnum;
        (function (ShowFaceStateEnum) {
            ShowFaceStateEnum[ShowFaceStateEnum["ALL"] = 0] = "ALL";
            ShowFaceStateEnum[ShowFaceStateEnum["CCW"] = 1] = "CCW";
            ShowFaceStateEnum[ShowFaceStateEnum["CW"] = 2] = "CW";
        })(ShowFaceStateEnum = render.ShowFaceStateEnum || (render.ShowFaceStateEnum = {}));
        var DrawModeEnum;
        (function (DrawModeEnum) {
            DrawModeEnum[DrawModeEnum["VboTri"] = 0] = "VboTri";
            DrawModeEnum[DrawModeEnum["VboLine"] = 1] = "VboLine";
            DrawModeEnum[DrawModeEnum["EboTri"] = 2] = "EboTri";
            DrawModeEnum[DrawModeEnum["EboLine"] = 3] = "EboLine";
        })(DrawModeEnum = render.DrawModeEnum || (render.DrawModeEnum = {}));
        var BlendModeEnum;
        (function (BlendModeEnum) {
            BlendModeEnum[BlendModeEnum["Close"] = 0] = "Close";
            BlendModeEnum[BlendModeEnum["Blend"] = 1] = "Blend";
            BlendModeEnum[BlendModeEnum["Blend_PreMultiply"] = 2] = "Blend_PreMultiply";
            BlendModeEnum[BlendModeEnum["Add"] = 3] = "Add";
            BlendModeEnum[BlendModeEnum["Add_PreMultiply"] = 4] = "Add_PreMultiply";
        })(BlendModeEnum = render.BlendModeEnum || (render.BlendModeEnum = {}));
        var glDrawPass = (function () {
            function glDrawPass() {
                this.state_showface = ShowFaceStateEnum.CCW;
                this.state_zwrite = false;
                this.state_ztest = false;
                this.state_ztest_method = render.webglkit.LEQUAL;
                this.state_blend = false;
                this.state_blendEquation = 0;
                this.state_blendSrcRGB = 0;
                this.state_blendDestRGB = 0;
                this.state_blendSrcAlpha = 0;
                this.state_blendDestALpha = 0;
                this.uniforms = {};
                this.uniformallchange = false;
            }
            glDrawPass.prototype.setProgram = function (program, uniformDefault) {
                if (uniformDefault === void 0) { uniformDefault = false; }
                this.program = program;
                this.uniforms = {};
                for (var key in this.program.mapUniform) {
                    var loc = this.program.mapUniform[key].location;
                    if (this.program.mapUniform[key].type == render.UniformTypeEnum.Texture) {
                        this.uniforms[key] = { change: false, location: loc, type: render.UniformTypeEnum.Texture, value: null };
                    }
                    else if (this.program.mapUniform[key].type == render.UniformTypeEnum.Float4x4v) {
                        this.uniforms[key] = { change: false, location: loc, type: render.UniformTypeEnum.Float4x4v, value: uniformDefault ? new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) : null };
                    }
                    else if (this.program.mapUniform[key].type == render.UniformTypeEnum.Float4x4) {
                        this.uniforms[key] = { change: false, location: loc, type: render.UniformTypeEnum.Float4x4, value: uniformDefault ? new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) : null };
                    }
                    else if (this.program.mapUniform[key].type == render.UniformTypeEnum.Float4v) {
                        this.uniforms[key] = { change: false, location: loc, type: render.UniformTypeEnum.Float4v, value: uniformDefault ? new Float32Array([0, 0, 0, 0]) : null };
                    }
                    else if (this.program.mapUniform[key].type == render.UniformTypeEnum.Float4) {
                        this.uniforms[key] = { change: false, location: loc, type: render.UniformTypeEnum.Float4, value: uniformDefault ? new Float32Array([0, 0, 0, 0]) : null };
                    }
                    else if (this.program.mapUniform[key].type == render.UniformTypeEnum.Float) {
                        this.uniforms[key] = { change: false, location: loc, type: render.UniformTypeEnum.Float, value: uniformDefault ? 0 : null };
                    }
                    else if (this.program.mapUniform[key].type == render.UniformTypeEnum.Floatv) {
                        this.uniforms[key] = { change: false, location: loc, type: render.UniformTypeEnum.Floatv, value: uniformDefault ? new Float32Array([0]) : null };
                    }
                }
                this.uniformallchange = true;
            };
            glDrawPass.prototype.setAlphaBlend = function (mode) {
                if (mode == BlendModeEnum.Add) {
                    this.state_blend = true;
                    this.state_zwrite = false;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.webglkit.ONE;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Add_PreMultiply) {
                    this.state_blend = true;
                    this.state_zwrite = false;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.ONE;
                    this.state_blendDestRGB = render.webglkit.ONE;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend) {
                    this.state_blend = true;
                    this.state_zwrite = false;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend_PreMultiply) {
                    this.state_blend = true;
                    this.state_zwrite = false;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.ONE;
                    this.state_blendDestRGB = render.webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Close) {
                    this.state_blend = false;
                }
            };
            glDrawPass.prototype.uniformFloat = function (name, number) {
                var v = this.uniforms[name];
                if (v == null)
                    throw new Error("do not have this uniform");
                if (v.type != render.UniformTypeEnum.Float)
                    throw new Error("wrong uniform type:" + v.type);
                this.uniforms[name].value = number;
                this.uniforms[name].change = true;
            };
            glDrawPass.prototype.uniformFloatv = function (name, numbers) {
                var v = this.uniforms[name];
                if (v == null)
                    throw new Error("do not have this uniform");
                if (v.type != render.UniformTypeEnum.Floatv)
                    throw new Error("wrong uniform type:" + v.type);
                this.uniforms[name].value = numbers;
                this.uniforms[name].change = true;
            };
            glDrawPass.prototype.uniformVec4 = function (name, vec) {
                var v = this.uniforms[name];
                if (v == null)
                    throw new Error("do not have this uniform");
                if (v.type != render.UniformTypeEnum.Float4)
                    throw new Error("wrong uniform type:" + v.type);
                var varray = this.uniforms[name].value;
                if (varray == null) {
                    this.uniforms[name].value = [0, 0, 0, 0];
                    varray = this.uniforms[name].value;
                }
                varray[0] = vec.x;
                varray[1] = vec.y;
                varray[2] = vec.z;
                varray[3] = vec.w;
                this.uniforms[name].change = true;
            };
            glDrawPass.prototype.uniformVec4v = function (name, vecdata) {
                var v = this.uniforms[name];
                if (v == null)
                    throw new Error("do not have this uniform");
                if (v.type != render.UniformTypeEnum.Float4v)
                    throw new Error("wrong uniform type:" + v.type);
                this.uniforms[name].value = vecdata;
                this.uniforms[name].change = true;
            };
            glDrawPass.prototype.uniformMatrix = function (name, mat) {
                var v = this.uniforms[name];
                if (v == null)
                    throw new Error("do not have this uniform");
                if (v.type != render.UniformTypeEnum.Float4x4)
                    throw new Error("wrong uniform type:" + v.type);
                this.uniforms[name].value = mat.rawData;
                this.uniforms[name].change = true;
            };
            glDrawPass.prototype.uniformMatrixV = function (name, matdata) {
                var v = this.uniforms[name];
                if (v == null)
                    throw new Error("do not have this uniform");
                if (v.type != render.UniformTypeEnum.Float4x4v)
                    throw new Error("wrong uniform type:" + v.type);
                this.uniforms[name].value = matdata;
                this.uniforms[name].change = true;
            };
            glDrawPass.prototype.uniformTexture = function (name, tex) {
                var v = this.uniforms[name];
                if (v == null)
                    throw new Error("do not have this uniform");
                if (v.type != render.UniformTypeEnum.Texture)
                    throw new Error("wrong uniform type:" + v.type);
                this.uniforms[name].value = tex;
                this.uniforms[name].change = true;
            };
            glDrawPass.prototype.use = function (webgl, applyUniForm) {
                if (applyUniForm === void 0) { applyUniForm = true; }
                if (this.state_showface == ShowFaceStateEnum.ALL) {
                    webgl.disable(webgl.CULL_FACE);
                }
                else {
                    if (this.state_showface == ShowFaceStateEnum.CCW) {
                        webgl.frontFace(webgl.CCW);
                    }
                    else {
                        webgl.frontFace(webgl.CW);
                    }
                    webgl.cullFace(webgl.BACK);
                    webgl.enable(webgl.CULL_FACE);
                }
                if (this.state_zwrite) {
                    webgl.depthMask(true);
                }
                else {
                    webgl.depthMask(false);
                }
                if (this.state_ztest) {
                    webgl.enable(webgl.DEPTH_TEST);
                    webgl.depthFunc(this.state_ztest_method);
                }
                else {
                    webgl.disable(webgl.DEPTH_TEST);
                }
                if (this.state_blend) {
                    webgl.enable(webgl.BLEND);
                    webgl.blendEquation(this.state_blendEquation);
                    webgl.blendFuncSeparate(this.state_blendSrcRGB, this.state_blendDestRGB, this.state_blendSrcAlpha, this.state_blendDestALpha);
                }
                else {
                    webgl.disable(webgl.BLEND);
                }
                this.program.use(webgl);
                if (applyUniForm) {
                    this.applyUniformSaved(webgl);
                }
            };
            glDrawPass.prototype.applyUniformSaved = function (webgl) {
                var texindex = 0;
                for (var key in this.uniforms) {
                    var u = this.uniforms[key];
                    if (u.type == render.UniformTypeEnum.Texture) {
                        if (this.uniformallchange || u.change) {
                            var tex = u.value != null ? u.value.texture : null;
                            webgl.activeTexture(render.webglkit.GetTextureNumber(webgl, texindex));
                            webgl.bindTexture(webgl.TEXTURE_2D, tex);
                            webgl.uniform1i(u.location, texindex);
                        }
                        texindex++;
                    }
                    else if (this.uniformallchange || u.change) {
                        if (u.type == render.UniformTypeEnum.Float) {
                            webgl.uniform1f(u.location, u.value);
                        }
                        else if (u.type == render.UniformTypeEnum.Floatv) {
                            webgl.uniform1fv(u.location, u.value);
                        }
                        else if (u.type == render.UniformTypeEnum.Float4 || u.type == render.UniformTypeEnum.Float4v) {
                            webgl.uniform4fv(u.location, u.value);
                        }
                        else if (u.type == render.UniformTypeEnum.Float4x4 || u.type == render.UniformTypeEnum.Float4x4v) {
                            webgl.uniformMatrix4fv(u.location, false, u.value);
                        }
                    }
                    u.change = false;
                }
                this.uniformallchange = false;
            };
            glDrawPass.prototype.applyUniform_Float = function (webgl, key, value) {
                var u = this.uniforms[key];
                webgl.uniform1f(u.location, value);
            };
            glDrawPass.prototype.applyUniform_Floatv = function (webgl, key, value) {
                var u = this.uniforms[key];
                webgl.uniform1fv(u.location, value);
            };
            glDrawPass.prototype.applyUniform_Float4 = function (webgl, key, value) {
                var u = this.uniforms[key];
                webgl.uniform4f(u.location, value.x, value.y, value.z, value.w);
            };
            glDrawPass.prototype.applyUniform_Float4v = function (webgl, key, values) {
                var u = this.uniforms[key];
                webgl.uniform4fv(u.location, values);
            };
            glDrawPass.prototype.applyUniform_Float4x4 = function (webgl, key, value) {
                var u = this.uniforms[key];
                webgl.uniformMatrix4fv(u.location, false, value.rawData);
            };
            glDrawPass.prototype.applyUniform_Float4x4v = function (webgl, key, values) {
                var u = this.uniforms[key];
                webgl.uniformMatrix4fv(u.location, false, values);
            };
            glDrawPass.prototype.applyUniform_FloatTexture = function (webgl, texindex, key, value) {
                var u = this.uniforms[key];
                var tex = value != null ? value.texture : null;
                webgl.activeTexture(render.webglkit.GetTextureNumber(webgl, texindex));
                webgl.bindTexture(webgl.TEXTURE_2D, tex);
                webgl.uniform1i(u.location, texindex);
            };
            glDrawPass.prototype.draw = function (webgl, mesh, drawmode, drawindexindex, drawbegin, drawcount) {
                if (drawmode === void 0) { drawmode = DrawModeEnum.EboTri; }
                if (drawindexindex === void 0) { drawindexindex = 0; }
                if (drawbegin === void 0) { drawbegin = 0; }
                if (drawcount === void 0) { drawcount = -1; }
                this.use(webgl);
                mesh.bind(webgl, this.program, drawindexindex);
                if (drawmode == DrawModeEnum.VboTri) {
                    mesh.drawArrayTris(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.VboLine) {
                    mesh.drawArrayLines(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.EboTri) {
                    mesh.drawElementTris(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.EboLine) {
                    mesh.drawElementLines(webgl, drawbegin, drawcount);
                }
            };
            return glDrawPass;
        }());
        glDrawPass.textureID = null;
        render.glDrawPass = glDrawPass;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var VertexFormatMask;
        (function (VertexFormatMask) {
            VertexFormatMask[VertexFormatMask["Position"] = 1] = "Position";
            VertexFormatMask[VertexFormatMask["Normal"] = 2] = "Normal";
            VertexFormatMask[VertexFormatMask["Tangent"] = 4] = "Tangent";
            VertexFormatMask[VertexFormatMask["Color"] = 8] = "Color";
            VertexFormatMask[VertexFormatMask["UV0"] = 16] = "UV0";
            VertexFormatMask[VertexFormatMask["UV1"] = 32] = "UV1";
            VertexFormatMask[VertexFormatMask["BlendIndex4"] = 64] = "BlendIndex4";
            VertexFormatMask[VertexFormatMask["BlendWeight4"] = 128] = "BlendWeight4";
            VertexFormatMask[VertexFormatMask["ColorEX"] = 256] = "ColorEX";
        })(VertexFormatMask = render.VertexFormatMask || (render.VertexFormatMask = {}));
        var number4 = (function () {
            function number4() {
            }
            return number4;
        }());
        render.number4 = number4;
        var MeshTypeEnum;
        (function (MeshTypeEnum) {
            MeshTypeEnum[MeshTypeEnum["Static"] = 0] = "Static";
            MeshTypeEnum[MeshTypeEnum["Dynamic"] = 1] = "Dynamic";
            MeshTypeEnum[MeshTypeEnum["Stream"] = 2] = "Stream";
        })(MeshTypeEnum = render.MeshTypeEnum || (render.MeshTypeEnum = {}));
        var drawInfo = (function () {
            function drawInfo() {
            }
            Object.defineProperty(drawInfo, "ins", {
                get: function () {
                    if (drawInfo._ins == null)
                        drawInfo._ins = new drawInfo();
                    return drawInfo._ins;
                },
                enumerable: true,
                configurable: true
            });
            return drawInfo;
        }());
        render.drawInfo = drawInfo;
        var glMesh = (function () {
            function glMesh() {
                this.bindIndex = -1;
                this.vertexFormat = VertexFormatMask.Position;
            }
            glMesh.prototype.initBuffer = function (webgl, vf, vertexCount, mode) {
                if (mode === void 0) { mode = MeshTypeEnum.Static; }
                if (this.vbo != null)
                    throw new Error("you can only initbuffer once.");
                if (mode == MeshTypeEnum.Static)
                    this.mode = webgl.STATIC_DRAW;
                else if (mode == MeshTypeEnum.Dynamic)
                    this.mode = webgl.DYNAMIC_DRAW;
                else if (mode == MeshTypeEnum.Stream)
                    this.mode = webgl.STREAM_DRAW;
                this.vertexFormat = vf;
                this.vertexCount = vertexCount;
                if (vertexCount > 0) {
                    this.vertexByteSize = render.meshData.calcByteSize(vf);
                    this.vbo = webgl.createBuffer();
                    webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                    webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
                }
                this.indexCounts = [];
                this.ebos = [];
            };
            glMesh.prototype.addIndex = function (webgl, indexcount) {
                var index = this.ebos.length;
                var _ebo = webgl.createBuffer();
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, _ebo);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
                this.ebos.push(_ebo);
                this.indexCounts.push(indexcount);
                return index;
            };
            glMesh.prototype.resetVboSize = function (webgl, vertexCount) {
                this.vertexCount = vertexCount;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
            };
            glMesh.prototype.resetEboSize = function (webgl, eboindex, indexcount) {
                this.indexCounts[eboindex] = indexcount;
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
            };
            glMesh.prototype.dispose = function (webgl) {
                webgl.deleteBuffer(this.vbo);
                this.vbo = null;
                if (this.ebos) {
                    for (var i = 0; i < this.ebos.length; i++)
                        webgl.deleteBuffer(this.ebos[i]);
                    this.ebos.length = 0;
                }
            };
            glMesh.prototype.caclByteLength = function () {
                var total = 0;
                total += this.vertexByteSize * this.vertexCount;
                for (var k in this.indexCounts) {
                    total += this.indexCounts[k] * 2;
                }
                return total;
            };
            glMesh.prototype.bind = function (webgl, shadercode, bindEbo) {
                if (bindEbo === void 0) { bindEbo = 0; }
                this.bindIndex = bindEbo;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                if (bindEbo >= 0) {
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[bindEbo]);
                }
                var total = this.vertexByteSize;
                var seek = 0;
                var channel = 0;
                {
                    if (shadercode.posPos >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posPos);
                        webgl.vertexAttribPointer(shadercode.posPos, 3, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                if (this.vertexFormat & VertexFormatMask.Normal) {
                    if (shadercode.posNormal >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posNormal);
                        webgl.vertexAttribPointer(shadercode.posNormal, 3, webgl.FLOAT, true, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                else if (shadercode.posNormal >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posNormal);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.Tangent) {
                    if (shadercode.posTangent >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posTangent);
                        webgl.vertexAttribPointer(shadercode.posTangent, 3, webgl.FLOAT, true, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                else if (shadercode.posTangent >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posTangent);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.Color) {
                    if (shadercode.posColor >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posColor);
                        webgl.vertexAttribPointer(shadercode.posColor, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posColor >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posColor);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.UV0) {
                    if (shadercode.posUV0 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posUV0);
                        webgl.vertexAttribPointer(shadercode.posUV0, 2, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 8;
                }
                else if (shadercode.posUV0 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posUV0);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.UV1) {
                    if (shadercode.posUV2 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posUV2);
                        webgl.vertexAttribPointer(shadercode.posUV2, 2, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 8;
                }
                else if (shadercode.posUV2 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posUV2);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.BlendIndex4) {
                    if (shadercode.posBlendIndex4 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posBlendIndex4);
                        webgl.vertexAttribPointer(shadercode.posBlendIndex4, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posBlendIndex4 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posBlendIndex4);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.BlendWeight4) {
                    if (shadercode.posBlendWeight4 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posBlendWeight4);
                        webgl.vertexAttribPointer(shadercode.posBlendWeight4, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posBlendWeight4 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posBlendWeight4);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.ColorEX) {
                    if (shadercode.posColorEx >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posColorEx);
                        webgl.vertexAttribPointer(shadercode.posColorEx, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posColorEx >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posColorEx);
                    channel++;
                }
                render.webglkit.SetMaxVertexAttribArray(webgl, channel);
            };
            glMesh.prototype.uploadVertexSubData = function (webgl, varray, offset) {
                if (offset === void 0) { offset = 0; }
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferSubData(webgl.ARRAY_BUFFER, offset, varray);
            };
            glMesh.prototype.uploadIndexSubData = function (webgl, eboindex, data, offset) {
                if (offset === void 0) { offset = 0; }
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, offset, data);
            };
            glMesh.prototype.drawArrayTris = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.vertexCount / 3) | 0) * 3;
                drawInfo.ins.triCount += count / 3;
                drawInfo.ins.renderCount++;
                webgl.drawArrays(webgl.TRIANGLES, start, count);
            };
            glMesh.prototype.drawArrayLines = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.vertexCount / 2) | 0) * 2;
                drawInfo.ins.renderCount++;
                webgl.drawArrays(webgl.LINES, start, count);
            };
            glMesh.prototype.drawElementTris = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.indexCounts[this.bindIndex] / 3) | 0) * 3;
                drawInfo.ins.triCount += count / 3;
                drawInfo.ins.renderCount++;
                webgl.drawElements(webgl.TRIANGLES, count, webgl.UNSIGNED_SHORT, start * 2);
            };
            glMesh.prototype.drawElementLines = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.indexCounts[this.bindIndex] / 2) | 0) * 2;
                drawInfo.ins.renderCount++;
                webgl.drawElements(webgl.LINES, count, webgl.UNSIGNED_SHORT, start * 2);
            };
            return glMesh;
        }());
        render.glMesh = glMesh;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var meshData = (function () {
            function meshData() {
            }
            meshData.addQuadPos = function (data, quad) {
                var istart = data.pos.length;
                meshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
            };
            meshData.addQuadPos_Quad = function (data, quad) {
                var istart = data.pos.length;
                meshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
                data.trisindex.push(istart + 2);
            };
            meshData.addQuadVec3ByValue = function (array, value) {
                for (var i = 0; i < 4; i++) {
                    var v = gd3d.math.pool.clone_vector3(value);
                    array.push(v);
                }
            };
            meshData.addQuadVec3 = function (array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            };
            meshData.addQuadVec2 = function (array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            };
            meshData.genQuad = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, 0),
                    new gd3d.math.vector3(-half, -half, 0),
                    new gd3d.math.vector3(half, half, 0),
                    new gd3d.math.vector3(half, -half, 0)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genPlaneCCW = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, 0, half),
                    new gd3d.math.vector3(-half, 0, -half),
                    new gd3d.math.vector3(half, 0, half),
                    new gd3d.math.vector3(half, 0, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genCylinderCCW = function (height, radius, segment) {
                if (segment === void 0) { segment = 20; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var normal = new gd3d.math.vector3(0, 1, 0);
                for (var s = 0; s < 4; s++) {
                    var y = (s < 2 ? 0.5 : -0.5) * height;
                    if (s == 0)
                        normal = new gd3d.math.vector3(0, 1, 0);
                    else if (s == 3)
                        normal = new gd3d.math.vector3(0, -1, 0);
                    for (var i = 0; i < segment; i++) {
                        var r = i / segment * Math.PI * 2;
                        var x = Math.sin(r);
                        var z = Math.cos(r);
                        if (s == 1 || s == 2)
                            normal = new gd3d.math.vector3(x, 0, z);
                        data.pos.push(new gd3d.math.vector3(x * radius, y, z * radius));
                        var vn = gd3d.math.pool.clone_vector3(normal);
                        data.normal.push(vn);
                        if (s == 0 || s == 3) {
                            data.uv.push(new gd3d.math.vector2(x / 2 + 0.5, z / 2 + 0.5));
                        }
                        else {
                            data.uv.push(new gd3d.math.vector2(i / segment, y < 0 ? 0 : 1));
                        }
                    }
                }
                var itop = data.pos.length;
                data.pos.push(new gd3d.math.vector3(0, 0.5 * height, 0));
                data.normal.push(new gd3d.math.vector3(0, 1, 0));
                data.uv.push(new gd3d.math.vector2(0.5, 0.5));
                var ibottom = data.pos.length;
                data.pos.push(new gd3d.math.vector3(0, -0.5 * height, 0));
                data.normal.push(new gd3d.math.vector3(0, -1, 0));
                data.uv.push(new gd3d.math.vector2(0.5, 0.5));
                for (var i = 0; i < segment; i++) {
                    data.trisindex.push(itop);
                    data.trisindex.push(i == segment - 1 ? segment * 0 + 0 : segment * 0 + i + 1);
                    data.trisindex.push(segment * 0 + i + 0);
                    data.trisindex.push(ibottom);
                    data.trisindex.push(segment * 3 + i + 0);
                    data.trisindex.push(i == segment - 1 ? segment * 3 + 0 : segment * 3 + i + 1);
                    var t = segment * 1 + i;
                    var t2 = i == segment - 1 ? segment * 1 + 0 : segment * 1 + i + 1;
                    var b = segment * 2 + i;
                    var b2 = i == segment - 1 ? segment * 2 + 0 : segment * 2 + i + 1;
                    data.trisindex.push(t);
                    data.trisindex.push(t2);
                    data.trisindex.push(b);
                    data.trisindex.push(t2);
                    data.trisindex.push(b2);
                    data.trisindex.push(b);
                }
                return data;
            };
            meshData.genPyramid = function (height, halfsize) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var vec1 = new gd3d.math.vector3();
                var vec2 = new gd3d.math.vector3();
                var vec3 = new gd3d.math.vector3();
                var vec4 = new gd3d.math.vector3();
                var vec5 = new gd3d.math.vector3(0, -1, 0);
                var uvxx = new gd3d.math.vector2(0.5, 0.5);
                var uv00 = new gd3d.math.vector2(0, 0);
                var uv01 = new gd3d.math.vector2(0, 1);
                var uv10 = new gd3d.math.vector2(1, 0);
                var uv11 = new gd3d.math.vector2(1, 1);
                var ipos = 0;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.uv.push(uv00);
                data.uv.push(uvxx);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.uv.push(uv01);
                data.uv.push(uvxx);
                data.uv.push(uv11);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.uv.push(uv11);
                data.uv.push(uvxx);
                data.uv.push(uv10);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.uv.push(uv10);
                data.uv.push(uvxx);
                data.uv.push(uv00);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.uv.push(uv00);
                data.uv.push(uv10);
                data.uv.push(uv11);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                data.trisindex.push(ipos + 3);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos);
                ipos += 4;
                return data;
            };
            meshData.genSphereCCW = function (radius, widthSegments, heightSegments) {
                if (radius === void 0) { radius = 1; }
                if (widthSegments === void 0) { widthSegments = 24; }
                if (heightSegments === void 0) { heightSegments = 12; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                widthSegments = Math.max(3, Math.floor(widthSegments));
                heightSegments = Math.max(2, Math.floor(heightSegments));
                var ix, iy;
                var index = 0;
                var grid = [];
                var vertex = new gd3d.math.vector3();
                var normal = new gd3d.math.vector3();
                for (iy = 0; iy <= heightSegments; iy++) {
                    var verticesRow = [];
                    var v = iy / heightSegments;
                    for (ix = 0; ix <= widthSegments; ix++) {
                        var u = ix / widthSegments;
                        vertex.x = -radius * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        vertex.y = radius * Math.cos(v * Math.PI);
                        vertex.z = radius * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        data.pos.push(gd3d.math.pool.clone_vector3(vertex));
                        normal = gd3d.math.pool.clone_vector3(vertex);
                        var num = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                        if (num > Number.MIN_VALUE) {
                            normal.x = normal.x / num;
                            normal.y = normal.y / num;
                            normal.z = normal.z / num;
                        }
                        else {
                            normal.x = 0;
                            normal.y = 0;
                            normal.z = 0;
                        }
                        data.normal.push(normal);
                        var uv = new gd3d.math.vector2(1 - u, v);
                        data.uv.push(uv);
                        verticesRow.push(index++);
                    }
                    grid.push(verticesRow);
                }
                for (iy = 0; iy < heightSegments; iy++) {
                    for (ix = 0; ix < widthSegments; ix++) {
                        var a = grid[iy][ix + 1];
                        var b = grid[iy][ix];
                        var c = grid[iy + 1][ix];
                        var d = grid[iy + 1][ix + 1];
                        if (iy !== 0)
                            data.trisindex.push(a, d, b);
                        if (iy !== heightSegments - 1)
                            data.trisindex.push(b, d, c);
                    }
                }
                return data;
            };
            meshData.genBoxCCW = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(half, -half, -half),
                    new gd3d.math.vector3(half, -half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(-half, half, -half),
                    new gd3d.math.vector3(half, half, half),
                    new gd3d.math.vector3(half, half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(half, -half, half),
                    new gd3d.math.vector3(half, half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(0, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, -half),
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(half, half, -half),
                    new gd3d.math.vector3(half, -half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(half, -half, -half),
                    new gd3d.math.vector3(half, -half, half),
                    new gd3d.math.vector3(half, half, -half),
                    new gd3d.math.vector3(half, half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(-half, half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                return data;
            };
            meshData.genBoxByArray = function (array) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos(data, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos(data, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos(data, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos(data, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                return data;
            };
            meshData.genBoxByArray_Quad = function (array) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos_Quad(data, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos_Quad(data, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos_Quad(data, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                return data;
            };
            meshData.genCircleLineCCW = function (radius, segment, wide) {
                if (segment === void 0) { segment = 64; }
                if (wide === void 0) { wide = 0.05; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                for (var i = 0; i < segment; i++) {
                    var r1 = Math.PI * 2 * i / segment;
                    var x1 = Math.sin(r1) * radius;
                    var z1 = Math.cos(r1) * radius;
                    var r2 = Math.PI * 2 * (i + 1) / segment;
                    var x2 = Math.sin(r2) * radius;
                    var z2 = Math.cos(r2) * radius;
                    meshData.addQuadPos(data, [
                        new gd3d.math.vector3(x2, wide, z2),
                        new gd3d.math.vector3(x1, wide, z1),
                        new gd3d.math.vector3(x2, -wide, z2),
                        new gd3d.math.vector3(x1, -wide, z1)
                    ]);
                }
                return data;
            };
            meshData.prototype.caclByteLength = function () {
                var len = 0;
                if (this.pos != undefined)
                    len += 12;
                if (this.color != undefined)
                    len += 16;
                if (this.normal != undefined)
                    len += 12;
                if (this.tangent != undefined)
                    len += 12;
                if (this.uv != undefined)
                    len += 8;
                if (this.uv2 != undefined)
                    len += 8;
                if (this.blendIndex != undefined)
                    len += 16;
                if (this.blendWeight != undefined)
                    len += 16;
                if (this.colorex != undefined)
                    len += 16;
                if (this.trisindex != undefined)
                    len += 12;
                len *= this.pos.length;
                return len;
            };
            meshData.calcByteSize = function (vf) {
                var total = 0;
                if (vf & render.VertexFormatMask.Position)
                    total += 12;
                if (vf & render.VertexFormatMask.Normal)
                    total += 12;
                if (vf & render.VertexFormatMask.Tangent)
                    total += 12;
                if (vf & render.VertexFormatMask.Color)
                    total += 16;
                if (vf & render.VertexFormatMask.UV0)
                    total += 8;
                if (vf & render.VertexFormatMask.UV1)
                    total += 8;
                if (vf & render.VertexFormatMask.BlendIndex4)
                    total += 16;
                if (vf & render.VertexFormatMask.BlendWeight4)
                    total += 16;
                if (vf & render.VertexFormatMask.ColorEX)
                    total += 16;
                return total;
            };
            meshData.prototype.genVertexDataArray = function (vf) {
                var vertexCount = this.pos.length;
                var total = meshData.calcByteSize(vf) / 4;
                var varray = new Float32Array(total * vertexCount);
                for (var i = 0; i < vertexCount; i++) {
                    var nseek = 0;
                    varray[i * total + nseek] = this.pos[i].x;
                    nseek++;
                    varray[i * total + nseek] = this.pos[i].y;
                    nseek++;
                    varray[i * total + nseek] = this.pos[i].z;
                    nseek++;
                    if (vf & render.VertexFormatMask.Normal) {
                        if (this.normal == undefined || this.normal.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.normal[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.normal[i].y;
                            nseek++;
                            varray[i * total + nseek] = this.normal[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Tangent) {
                        if (this.tangent == undefined || this.tangent.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.tangent[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.tangent[i].y;
                            nseek++;
                            varray[i * total + nseek] = this.tangent[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Color) {
                        if (this.color == undefined || this.color.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.color[i].r;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].g;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].b;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].a;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV0) {
                        if (this.uv == undefined || this.uv.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.uv[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.uv[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV1) {
                        if (this.uv2 == undefined || this.uv2.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.uv2[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.uv2[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendIndex4) {
                        if (this.blendIndex == undefined || this.blendIndex.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.blendIndex[i].v0;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v1;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v2;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendWeight4) {
                        if (this.blendWeight == undefined || this.blendWeight.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.blendWeight[i].v0;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v1;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v2;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.ColorEX) {
                        if (this.colorex == undefined || this.colorex.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.colorex[i].r;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].g;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].b;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].a;
                            nseek++;
                        }
                    }
                }
                return varray;
            };
            meshData.prototype.genIndexDataArray = function () {
                return new Uint16Array(this.trisindex);
            };
            meshData.prototype.genIndexDataArrayTri2Line = function () {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 3) | 0); i++) {
                    line.push(this.trisindex[i * 3 + 0]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 0]);
                }
                return new Uint16Array(line);
            };
            meshData.prototype.genIndexDataArrayQuad2Line = function () {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 4) | 0); i++) {
                    line.push(this.trisindex[i * 4 + 0]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 3]);
                }
                return new Uint16Array(line);
            };
            return meshData;
        }());
        render.meshData = meshData;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var staticMeshRenderer = (function () {
            function staticMeshRenderer() {
                this.eboIndex = 0;
                this.drawMode = render.DrawModeEnum.EboTri;
                this.drawbegin = 0;
                this.drawcount = -1;
            }
            staticMeshRenderer.prototype.draw = function (webgl) {
                this.material.use(webgl);
                this.mesh.bind(webgl, this.material.program, this.eboIndex);
                if (this.drawMode == render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, this.drawbegin, this.drawcount);
                }
            };
            return staticMeshRenderer;
        }());
        render.staticMeshRenderer = staticMeshRenderer;
        var batchRenderer = (function () {
            function batchRenderer() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            batchRenderer.prototype.initBuffer = function (webgl, vf, drawMode) {
                this.mesh = new render.glMesh();
                this.mesh.initBuffer(webgl, vf, 128, render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == render.DrawModeEnum.EboLine || drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
            };
            batchRenderer.prototype.begin = function (webgl, mat) {
                if (this.vboCount > 0)
                    this.end(webgl);
                this.curmaterial = mat;
            };
            batchRenderer.prototype.push = function (webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > 2048
                    ||
                        (ebodata != null && this.eboCount + ebodata.length > 2048)) {
                    this.end(webgl);
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    var narr = new Float32Array(this.dataForVbo.length * 2);
                    for (var i = 0; i < this.dataForVbo.length; i++) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (var i = 0; i < vbodata.length; i++) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == render.DrawModeEnum.VboLine || this.drawMode == render.DrawModeEnum.VboTri)
                    return;
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        var narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (var i = 0; i < this.dataForEbo.length; i++) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (var i = 0; i < ebodata.length; i++) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            };
            batchRenderer.prototype.end = function (webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexSubData(webgl, this.dataForVbo.slice(0, this.vboCount), 0);
                if (this.eboCount > 0)
                    this.mesh.uploadIndexSubData(webgl, 0, this.dataForEbo.slice(0, this.eboCount), 0);
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                this.curmaterial.use(webgl);
                this.mesh.bind(webgl, this.curmaterial.program, (this.drawMode == render.DrawModeEnum.EboLine || this.drawMode == render.DrawModeEnum.EboTri) ? 0 : -1);
                if (this.drawMode == render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
            };
            return batchRenderer;
        }());
        render.batchRenderer = batchRenderer;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var glWindow = (function () {
            function glWindow() {
                this.clearop_Color = false;
                this.backColor = new gd3d.math.color(1, 0, 1, 1);
                this.clearop_Depth = false;
                this.clearop_Stencil = false;
                this.viewport = new gd3d.math.rect(0, 0, 1, 1);
            }
            glWindow.prototype.use = function (webgl) {
                if (this.renderTarget != null) {
                    this.renderTarget.use(webgl);
                }
                else {
                    gd3d.render.glRenderTarget.useNull(webgl);
                }
                if (this.backColor != null)
                    webgl.clearColor(this.backColor.r, this.backColor.g, this.backColor.b, this.backColor.a);
                var n = 0;
                if (this.clearop_Color)
                    n |= webgl.COLOR_BUFFER_BIT;
                if (this.clearop_Depth)
                    n |= webgl.DEPTH_BUFFER_BIT;
                if (this.clearop_Stencil)
                    n |= webgl.STENCIL_BUFFER_BIT;
                webgl.clear(n);
                if (this.renderTarget != null) {
                    webgl.viewport(this.renderTarget.width * this.viewport.x, this.renderTarget.height * this.viewport.y, this.renderTarget.width * this.viewport.w, this.renderTarget.height * this.viewport.h);
                }
                else {
                    webgl.viewport(webgl.canvas.width * this.viewport.x, webgl.canvas.height * this.viewport.y, webgl.canvas.width * this.viewport.w, webgl.canvas.height * this.viewport.h);
                }
            };
            return glWindow;
        }());
        render.glWindow = glWindow;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var UniformTypeEnum;
        (function (UniformTypeEnum) {
            UniformTypeEnum[UniformTypeEnum["Texture"] = 0] = "Texture";
            UniformTypeEnum[UniformTypeEnum["Float"] = 1] = "Float";
            UniformTypeEnum[UniformTypeEnum["Floatv"] = 2] = "Floatv";
            UniformTypeEnum[UniformTypeEnum["Float4"] = 3] = "Float4";
            UniformTypeEnum[UniformTypeEnum["Float4v"] = 4] = "Float4v";
            UniformTypeEnum[UniformTypeEnum["Float4x4"] = 5] = "Float4x4";
            UniformTypeEnum[UniformTypeEnum["Float4x4v"] = 6] = "Float4x4v";
        })(UniformTypeEnum = render.UniformTypeEnum || (render.UniformTypeEnum = {}));
        var uniform = (function () {
            function uniform() {
            }
            return uniform;
        }());
        render.uniform = uniform;
        var ShaderTypeEnum;
        (function (ShaderTypeEnum) {
            ShaderTypeEnum[ShaderTypeEnum["VS"] = 0] = "VS";
            ShaderTypeEnum[ShaderTypeEnum["FS"] = 1] = "FS";
        })(ShaderTypeEnum = render.ShaderTypeEnum || (render.ShaderTypeEnum = {}));
        var glShader = (function () {
            function glShader(name, type, shader, code) {
                this.mapUniform = {};
                this.name = name;
                this.type = type;
                this.shader = shader;
                this._scanUniform(code);
            }
            glShader.prototype._scanUniform = function (txt) {
                var lines1 = txt.split(";");
                for (var ii in lines1) {
                    var lines = lines1[ii].split("\n");
                    for (var i in lines) {
                        var line = lines[i];
                        var words = line.match(new RegExp("([_a-zA-Z0-9]+)|([/=;]+)", "g"));
                        if (words != null && words.length >= 3 && words[0] == "uniform") {
                            var t = words[1];
                            var n = words[2];
                            if (t == "highp" || t == "lowp" || t == "mediump") {
                                t = words[2];
                                n = words[3];
                            }
                            var info = { name: n, type: UniformTypeEnum.Float };
                            this.mapUniform[n] = info;
                            if (t == "sampler2D") {
                                info.type = UniformTypeEnum.Texture;
                            }
                            else if (t == "float" && line.indexOf("[") >= 0 && line.indexOf("]") >= 0) {
                                info.type = UniformTypeEnum.Floatv;
                            }
                            else if (t == "float") {
                                info.type = UniformTypeEnum.Float;
                            }
                            else if (t == "vec4" && line.indexOf("[") >= 0 && line.indexOf("]") >= 0) {
                                info.type = UniformTypeEnum.Float4v;
                            }
                            else if (t == "vec4") {
                                info.type = UniformTypeEnum.Float4;
                            }
                            else if (t == "mat4" && line.indexOf("[") >= 0 && line.indexOf("]") >= 0) {
                                info.type = UniformTypeEnum.Float4x4v;
                            }
                            else if (t == "mat4") {
                                info.type = UniformTypeEnum.Float4x4;
                            }
                            else {
                                throw new Error("uniform type:" + t + " not defined.");
                            }
                        }
                    }
                }
            };
            return glShader;
        }());
        render.glShader = glShader;
        var glProgram = (function () {
            function glProgram(vs, fs, program) {
                this.posPos = -1;
                this.posNormal = -1;
                this.posTangent = -1;
                this.posColor = -1;
                this.posUV0 = -1;
                this.posUV2 = -1;
                this.posBlendIndex4 = -1;
                this.posBlendWeight4 = -1;
                this.posColorEx = -1;
                this.mapUniform = {};
                this.vs = vs;
                this.fs = fs;
                this.program = program;
            }
            glProgram.prototype.initAttribute = function (webgl) {
                this.posPos = webgl.getAttribLocation(this.program, "_glesVertex");
                this.posColor = webgl.getAttribLocation(this.program, "_glesColor");
                this.posUV0 = webgl.getAttribLocation(this.program, "_glesMultiTexCoord0");
                this.posUV2 = webgl.getAttribLocation(this.program, "_glesMultiTexCoord1");
                this.posNormal = webgl.getAttribLocation(this.program, "_glesNormal");
                this.posTangent = webgl.getAttribLocation(this.program, "_glesTangent");
                this.posBlendIndex4 = webgl.getAttribLocation(this.program, "_glesBlendIndex4");
                this.posBlendWeight4 = webgl.getAttribLocation(this.program, "_glesBlendWeight4");
                this.posColorEx = webgl.getAttribLocation(this.program, "_glesColorEx");
            };
            glProgram.prototype.use = function (webgl) {
                webgl.useProgram(this.program);
            };
            return glProgram;
        }());
        render.glProgram = glProgram;
        var shaderPool = (function () {
            function shaderPool() {
                this.mapVS = {};
                this.mapFS = {};
                this.mapProgram = {};
            }
            shaderPool.prototype.disposeVS = function (webgl, id) {
                webgl.deleteShader(this.mapVS[id].shader);
            };
            shaderPool.prototype.disposeFS = function (webgl, id) {
                webgl.deleteShader(this.mapFS[id].shader);
            };
            shaderPool.prototype.disposeProgram = function (webgl, id) {
                webgl.deleteProgram(this.mapProgram[id].program);
            };
            shaderPool.prototype.disposeAll = function (webgl) {
                for (var key in this.mapVS) {
                    this.disposeVS(webgl, key);
                }
                for (var key in this.mapFS) {
                    this.disposeFS(webgl, key);
                }
                for (var key in this.mapProgram) {
                    this.disposeProgram(webgl, key);
                }
                this.mapVS = {};
                this.mapFS = {};
                this.mapProgram = {};
            };
            shaderPool.prototype.compileVS = function (webgl, name, code) {
                var vs = webgl.createShader(webgl.VERTEX_SHADER);
                webgl.shaderSource(vs, code);
                webgl.compileShader(vs);
                var r1 = webgl.getShaderParameter(vs, webgl.COMPILE_STATUS);
                if (r1 == false) {
                    if (confirm("a vs:" + name + " error!!!" + webgl.getShaderInfoLog(vs) + "\n" + "did you want see the code?")) {
                        webgl.deleteShader(vs);
                        alert(code);
                    }
                    return null;
                }
                var s = new glShader(name, ShaderTypeEnum.VS, vs, code);
                this.mapVS[name] = s;
                return s;
            };
            shaderPool.prototype.compileFS = function (webgl, name, code) {
                var fs = webgl.createShader(webgl.FRAGMENT_SHADER);
                webgl.shaderSource(fs, code);
                webgl.compileShader(fs);
                var r1 = webgl.getShaderParameter(fs, webgl.COMPILE_STATUS);
                if (r1 == false) {
                    if (confirm("a fs:" + name + " error!!!" + webgl.getShaderInfoLog(fs) + "\n" + "did you want see the code?")) {
                        webgl.deleteShader(fs);
                        alert(code);
                    }
                    return null;
                }
                var s = new glShader(name, ShaderTypeEnum.FS, fs, code);
                this.mapFS[name] = s;
                return s;
            };
            shaderPool.prototype.linkProgram = function (webgl, nameVS, nameFS) {
                var program = webgl.createProgram();
                webgl.attachShader(program, this.mapVS[nameVS].shader);
                webgl.attachShader(program, this.mapFS[nameFS].shader);
                webgl.linkProgram(program);
                var r3 = webgl.getProgramParameter(program, webgl.LINK_STATUS);
                if (r3 == false) {
                    alert("vs:" + nameVS + "   fs:" + nameFS + "a webgl program error:" + webgl.getProgramInfoLog(program));
                    webgl.deleteProgram(program);
                    return null;
                }
                var name = nameVS + "_" + nameFS;
                var glp = new glProgram(this.mapVS[nameVS], this.mapFS[nameFS], program);
                for (var key in this.mapVS[nameVS].mapUniform) {
                    var u = this.mapVS[nameVS].mapUniform[key];
                    glp.mapUniform[key] = { name: u.name, type: u.type, location: null };
                }
                for (var key in this.mapFS[nameFS].mapUniform) {
                    var u = this.mapFS[nameFS].mapUniform[key];
                    glp.mapUniform[key] = { name: u.name, type: u.type, location: null };
                }
                for (var key in glp.mapUniform) {
                    glp.mapUniform[key].location = webgl.getUniformLocation(program, key);
                }
                glp.initAttribute(webgl);
                this.mapProgram[name] = glp;
                return glp;
            };
            return shaderPool;
        }());
        render.shaderPool = shaderPool;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var TextureFormatEnum;
        (function (TextureFormatEnum) {
            TextureFormatEnum[TextureFormatEnum["RGBA"] = 1] = "RGBA";
            TextureFormatEnum[TextureFormatEnum["RGB"] = 2] = "RGB";
            TextureFormatEnum[TextureFormatEnum["Gray"] = 3] = "Gray";
        })(TextureFormatEnum = render.TextureFormatEnum || (render.TextureFormatEnum = {}));
        var textureReader = (function () {
            function textureReader(webgl, texRGBA, width, height, gray) {
                if (gray === void 0) { gray = true; }
                this.gray = gray;
                this.width = width;
                this.height = height;
                var fbo = webgl.createFramebuffer();
                var fbold = webgl.getParameter(webgl.FRAMEBUFFER_BINDING);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbo);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, texRGBA, 0);
                var readData = new Uint8Array(this.width * this.height * 4);
                readData[0] = 2;
                webgl.readPixels(0, 0, this.width, this.height, webgl.RGBA, webgl.UNSIGNED_BYTE, readData);
                webgl.deleteFramebuffer(fbo);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbold);
                if (gray) {
                    this.data = new Uint8Array(this.width * this.height);
                    for (var i = 0; i < width * height; i++) {
                        this.data[i] = readData[i * 4];
                    }
                }
                else {
                    this.data = readData;
                }
            }
            textureReader.prototype.getPixel = function (u, v) {
                var x = (u * this.width) | 0;
                var y = (v * this.height) | 0;
                if (x < 0 || x >= this.width || y < 0 || y >= this.height)
                    return 0;
                if (this.gray) {
                    return this.data[y * this.width + x];
                }
                else {
                    var i = (y * this.width + x) * 4;
                    return new gd3d.math.color(this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]);
                }
            };
            return textureReader;
        }());
        render.textureReader = textureReader;
        var glRenderTarget = (function () {
            function glRenderTarget(webgl, width, height, depth, stencil) {
                if (depth === void 0) { depth = false; }
                if (stencil === void 0) { stencil = false; }
                this.width = width;
                this.height = height;
                this.fbo = webgl.createFramebuffer();
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                if (depth || stencil) {
                    this.renderbuffer = webgl.createRenderbuffer();
                    webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                    if (depth && stencil) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else if (depth) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                }
                this.texture = webgl.createTexture();
                this.fbo["width"] = width;
                this.fbo["height"] = height;
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
            }
            glRenderTarget.prototype.use = function (webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            };
            glRenderTarget.useNull = function (webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            };
            glRenderTarget.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteFramebuffer(this.renderbuffer);
                    this.renderbuffer = null;
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glRenderTarget.prototype.caclByteLength = function () {
                return this.width * this.height * 4;
            };
            glRenderTarget.prototype.isFrameBuffer = function () {
                return true;
            };
            return glRenderTarget;
        }());
        render.glRenderTarget = glRenderTarget;
        var glTexture2D = (function () {
            function glTexture2D(webgl, format, mipmap, linear) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (mipmap === void 0) { mipmap = false; }
                if (linear === void 0) { linear = true; }
                this.loaded = false;
                this.width = 0;
                this.height = 0;
                this.mipmap = false;
                this.webgl = webgl;
                this.format = format;
                this.texture = webgl.createTexture();
            }
            glTexture2D.prototype.uploadImage = function (img, mipmap, linear, premultiply, repeat, mirroredU, mirroredV) {
                if (premultiply === void 0) { premultiply = true; }
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.width = img.width;
                this.height = img.height;
                this.mipmap = mipmap;
                this.loaded = true;
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, formatGL, this.webgl.UNSIGNED_BYTE, img);
                if (mipmap) {
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            };
            glTexture2D.prototype.uploadByteArray = function (mipmap, linear, width, height, data, repeat, mirroredU, mirroredV) {
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.width = width;
                this.height = height;
                this.mipmap = mipmap;
                this.loaded = true;
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, this.webgl.UNSIGNED_BYTE, data);
                if (mipmap) {
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            };
            glTexture2D.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen;
                if (this.mipmap) {
                    len = len * (1 - Math.pow(0.25, 10)) / 0.75;
                }
                return len;
            };
            glTexture2D.prototype.getReader = function (redOnly) {
                if (redOnly === void 0) { redOnly = false; }
                if (this.reader != null) {
                    if (this.reader.gray != redOnly)
                        throw new Error("get param diff with this.reader");
                    return this.reader;
                }
                if (this.format != TextureFormatEnum.RGBA)
                    throw new Error("only rgba texture can read");
                if (this.texture == null)
                    return null;
                if (this.reader == null)
                    this.reader = new textureReader(this.webgl, this.texture, this.width, this.height, redOnly);
                return this.reader;
            };
            glTexture2D.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glTexture2D.prototype.isFrameBuffer = function () {
                return false;
            };
            glTexture2D.formGrayArray = function (webgl, array, width, height) {
                var mipmap = false;
                var linear = true;
                var t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(array.length * 4);
                for (var y = 0; y < width; y++) {
                    for (var x = 0; x < width; x++) {
                        var fi = y * 512 + x;
                        var i = y * width + x;
                        data[fi * 4] = array[i] * 255;
                        data[fi * 4 + 1] = array[i] * 255;
                        data[fi * 4 + 2] = array[i] * 255;
                        data[fi * 4 + 3] = 255;
                    }
                }
                t.uploadByteArray(mipmap, linear, 512, 512, data);
                return t;
            };
            glTexture2D.staticTexture = function (webgl, name) {
                var t = glTexture2D.mapTexture[name];
                if (t != undefined)
                    return t;
                var mipmap = false;
                var linear = true;
                t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(4);
                var width = 1;
                var height = 1;
                data[0] = 128;
                data[1] = 0;
                data[2] = 128;
                data[3] = 255;
                if (name == "gray") {
                    data[0] = 128;
                    data[1] = 128;
                    data[2] = 128;
                    data[3] = 255;
                }
                else if (name == "white") {
                    data[0] = 255;
                    data[1] = 255;
                    data[2] = 255;
                    data[3] = 255;
                }
                else if (name == "black") {
                    data[0] = 0;
                    data[1] = 0;
                    data[2] = 0;
                    data[3] = 255;
                }
                else if (name == "grid") {
                    width = 256;
                    height = 256;
                    data = new Uint8Array(width * width * 4);
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            var seek = (y * width + x) * 4;
                            if (((x - width * 0.5) * (y - height * 0.5)) > 0) {
                                data[seek] = 0;
                                data[seek + 1] = 0;
                                data[seek + 2] = 0;
                                data[seek + 3] = 255;
                            }
                            else {
                                data[seek] = 255;
                                data[seek + 1] = 255;
                                data[seek + 2] = 255;
                                data[seek + 3] = 255;
                            }
                        }
                    }
                }
                t.uploadByteArray(mipmap, linear, width, height, data);
                glTexture2D.mapTexture[name] = t;
                return t;
            };
            return glTexture2D;
        }());
        glTexture2D.mapTexture = {};
        render.glTexture2D = glTexture2D;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
//# sourceMappingURL=gd3d.js.map