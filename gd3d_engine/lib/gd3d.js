var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var NotifyType;
        (function (NotifyType) {
            NotifyType[NotifyType["AddChild"] = 0] = "AddChild";
            NotifyType[NotifyType["RemoveChild"] = 1] = "RemoveChild";
            NotifyType[NotifyType["ChangeVisible"] = 2] = "ChangeVisible";
            NotifyType[NotifyType["AddCamera"] = 3] = "AddCamera";
            NotifyType[NotifyType["AddCanvasRender"] = 4] = "AddCanvasRender";
        })(NotifyType = framework.NotifyType || (framework.NotifyType = {}));
        var CanvasFixedType;
        (function (CanvasFixedType) {
            CanvasFixedType[CanvasFixedType["FixedWidthType"] = 0] = "FixedWidthType";
            CanvasFixedType[CanvasFixedType["FixedHeightType"] = 1] = "FixedHeightType";
        })(CanvasFixedType = framework.CanvasFixedType || (framework.CanvasFixedType = {}));
        var application = (function () {
            function application() {
                this.limitFrame = true;
                this.version = "v0.0.1";
                this.build = "b000056";
                this._tar = -1;
                this._standDeltaTime = -1;
                this.beWidthSetted = false;
                this.beHeightSetted = false;
                this.scale = 0;
                this.beStepNumber = 0;
                this.pretimer = 0;
                this.isFrustumCulling = true;
                this._userCode = [];
                this._userCodeNew = [];
                this._editorCode = [];
                this._editorCodeNew = [];
                this._bePlay = false;
                this.be2dstate = false;
                this.curcameraindex = -1;
                this._bePause = false;
                this._beStepForward = false;
                this.orientation = framework.OrientationMode.AUTO;
                this.shouldRotate = false;
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.OffOrientationUpdate = false;
            }
            Object.defineProperty(application.prototype, "timeScale", {
                get: function () {
                    return this._timeScale;
                },
                set: function (val) {
                    this._timeScale = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "targetFrame", {
                get: function () {
                    return this._tar;
                },
                set: function (val) {
                    if (val == 0)
                        val = -1;
                    this._tar = val;
                    this._standDeltaTime = 1 / this._tar;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasFixHeight", {
                set: function (val) {
                    this.beHeightSetted = true;
                    this.beWidthSetted = false;
                    this._fixHeight = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasFixWidth", {
                set: function (val) {
                    this.beWidthSetted = true;
                    this.beHeightSetted = false;
                    this._fixWidth = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasClientWidth", {
                get: function () {
                    return this._canvasClientWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasClientHeight", {
                get: function () {
                    return this._canvasClientHeight;
                },
                enumerable: true,
                configurable: true
            });
            application.prototype.start = function (div, type, val, webglDebug) {
                if (type === void 0) { type = CanvasFixedType.FixedHeightType; }
                if (val === void 0) { val = 1200; }
                if (webglDebug === void 0) { webglDebug = false; }
                console.log("version: " + this.version + "  build: " + this.build);
                if (div == null) {
                    console.error("root div does Null at application start ");
                    return;
                }
                div.style.overflow = "hidden";
                div.style.position = "absolute";
                div.style.width = "100%";
                div.style.height = "100%";
                framework.sceneMgr.app = this;
                this._timeScale = 1;
                this.outcontainer = div;
                var rotateDiv = document.createElement("div");
                rotateDiv.className = "full";
                rotateDiv.style.overflow = "hidden";
                rotateDiv.style.position = "absolute";
                rotateDiv.style.width = "100%";
                rotateDiv.style.height = "100%";
                this.container = rotateDiv;
                div.appendChild(rotateDiv);
                var sc1 = document.createElement("script");
                var sc2 = document.createElement("script");
                sc1.type = "text/javascript";
                sc2.type = "text/javascript";
                sc1.innerHTML = framework.textureutil.webgl_util;
                sc2.innerHTML = framework.textureutil.webgl_texture_util;
                document.body.appendChild(sc1);
                document.body.appendChild(sc2);
                var canvas = document.createElement("canvas");
                if (canvas == null) {
                    alert("Failed to create canvas at the application.start()");
                    throw Error("Failed to create canvas at the application.start()");
                }
                canvas.className = "full";
                canvas.style.position = "absolute";
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                canvas.style.backgroundColor = "#1e1e1e";
                canvas.setAttribute("tabindex", "1");
                rotateDiv.appendChild(canvas);
                var tempWebGlUtil = new framework.WebGLUtils();
                this.webgl = tempWebGlUtil.setupWebGL(canvas);
                if (this.webgl == null) {
                    alert("Failed to get webgl at the application.start()");
                    throw Error("Failed to get webgl at the application.start()");
                }
                switch (type) {
                    case CanvasFixedType.FixedWidthType:
                        this.canvasFixWidth = val;
                        break;
                    case CanvasFixedType.FixedHeightType:
                        this.canvasFixHeight = val;
                        break;
                }
                if (this.beWidthSetted) {
                    this.webgl.canvas.width = this._fixWidth;
                    this.webgl.canvas.height = this._fixWidth * this.webgl.canvas.clientHeight / this.webgl.canvas.clientWidth;
                    this.scale = this.webgl.canvas.clientHeight / this.webgl.canvas.height;
                }
                else if (this.beHeightSetted) {
                    this.webgl.canvas.height = this._fixHeight;
                    this.webgl.canvas.width = this.webgl.canvas.clientWidth * this._fixHeight / this.webgl.canvas.clientHeight;
                    this.scale = this.webgl.canvas.clientHeight / this.webgl.canvas.height;
                }
                this._canvasClientWidth = this.webgl.canvas.clientWidth;
                this._canvasClientHeight = this.webgl.canvas.clientHeight;
                gd3d.render.webglkit.initConst(this.webgl);
                this.initRender();
                this.initAssetMgr();
                this.initInputMgr();
                this.initScene();
                this.beginTimer = this.lastTimer = this.pretimer = Date.now() / 1000;
                this.loop();
                gd3d.io.referenceInfo.regDefaultType();
                var initovercallback = window["initovercallback"];
                if (initovercallback != null) {
                    initovercallback(this);
                }
                if (webglDebug) {
                    var tempWebGLDebugUtils = new framework.WebGLDebugUtils();
                    this.webgl = tempWebGLDebugUtils.makeDebugContext(this.webgl);
                    console.error(" i am ---webglDebug-");
                }
            };
            application.prototype.markNotify = function (trans, type) {
                this.doNotify(trans, type);
            };
            application.prototype.doNotify = function (trans, type) {
                if (trans == null)
                    return;
                if (!this.checkFilter(trans))
                    return;
                if (this.notify)
                    this.notify.notify(trans, type);
                if (trans.children != null) {
                    for (var index in trans.children) {
                        this.doNotify(trans.children[index], type);
                    }
                }
            };
            application.prototype.checkFilter = function (trans) {
                if (trans instanceof gd3d.framework.transform) {
                    if (trans.gameObject.hideFlags & gd3d.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                if (trans instanceof gd3d.framework.transform2D) {
                    if (trans.hideFlags & gd3d.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                return true;
            };
            application.prototype.showFps = function () {
                if (this.stats == null) {
                    this.stats = new Stats.Stats(this);
                    this.stats.container.style.position = 'absolute';
                    this.stats.container.style.left = '0px';
                    this.stats.container.style.top = '0px';
                    this.container.appendChild(this.stats.container);
                }
                else {
                    this.container.appendChild(this.stats.container);
                }
            };
            application.prototype.closeFps = function () {
                if (this.stats != null) {
                    this.container.removeChild(this.stats.container);
                }
            };
            application.prototype.update = function (delta) {
                {
                    this.updateOrientationMode();
                }
                if (this.webgl.canvas.clientWidth != this._canvasClientWidth || this.webgl.canvas.clientHeight != this._canvasClientHeight) {
                    this._canvasClientWidth = this.webgl.canvas.clientWidth;
                    this._canvasClientHeight = this.webgl.canvas.clientHeight;
                    if (this.beWidthSetted) {
                        this.webgl.canvas.width = this._fixWidth;
                        this.webgl.canvas.height = this._fixWidth * this.webgl.canvas.clientHeight / this.webgl.canvas.clientWidth;
                        this.scale = this.webgl.canvas.clientHeight / this.webgl.canvas.height;
                    }
                    else if (this.beHeightSetted) {
                        this.webgl.canvas.height = this._fixHeight;
                        this.webgl.canvas.width = this.webgl.canvas.clientWidth * this._fixHeight / this.webgl.canvas.clientHeight;
                        this.scale = this.webgl.canvas.clientHeight / this.webgl.canvas.height;
                    }
                    console.log("_fixWidth:" + this._fixWidth + "   _fixHeight:" + this._fixHeight);
                    console.log("canvas resize.   width:" + this.webgl.canvas.width + "   height:" + this.webgl.canvas.height);
                    console.log("canvas resize.   clientWidth:" + this.webgl.canvas.clientWidth + "   clientHeight:" + this.webgl.canvas.clientHeight);
                }
                this.width = this.webgl.canvas.width;
                this.height = this.webgl.canvas.height;
                if (this.bePlay) {
                    if (this.bePause) {
                        if (this.beStepForward && this.beStepNumber > 0) {
                            this.beStepNumber--;
                            this.updateUserCode(delta);
                        }
                    }
                    else {
                        this.updateUserCode(delta);
                    }
                }
                this.updateEditorCode(delta);
                if (this._scene != null) {
                    this._scene.update(delta);
                }
            };
            application.prototype.getUserUpdateTimer = function () {
                return this.usercodetime;
            };
            application.prototype.getTotalTime = function () {
                return this.totalTime;
            };
            Object.defineProperty(application.prototype, "deltaTime", {
                get: function () {
                    return this._deltaTime * this._timeScale;
                },
                enumerable: true,
                configurable: true
            });
            application.prototype.getUpdateTimer = function () {
                return this.updateTimer;
            };
            application.prototype.loop = function () {
                var now = Date.now() / 1000;
                this._deltaTime = now - this.lastTimer;
                this.totalTime = now - this.beginTimer;
                this.updateTimer = now - this.pretimer;
                if (this._deltaTime < this._standDeltaTime) {
                    var _this_1 = this;
                    var del = this._standDeltaTime - this._deltaTime;
                    setTimeout(function () {
                        var _now = Date.now() / 1000;
                        _this_1.lastTimer = _now;
                        _this_1.pretimer = _now;
                        _this_1.update(_this_1._standDeltaTime);
                        if (_this_1.stats != null)
                            _this_1.stats.update();
                        _this_1.loop();
                    }, del * 1000);
                }
                else {
                    this.update(this.deltaTime);
                    if (this.stats != null)
                        this.stats.update();
                    this.lastTimer = now;
                    this.pretimer = now;
                    if (this.limitFrame) {
                        requestAnimationFrame(this.loop.bind(this));
                    }
                    else {
                        setTimeout(this.loop.bind(this), 1);
                    }
                }
            };
            application.prototype.initScene = function () {
                if (this._scene == null) {
                    this._scene = new framework.scene(this);
                    framework.sceneMgr.scene = this._scene;
                }
            };
            application.prototype.initRender = function () {
                framework.uniformSetter.initAutouniform();
                gd3d.render.shaderUniform.webgl = this.webgl;
                gd3d.render.shaderUniform.initApplyUnifmFunc();
            };
            application.prototype.getScene = function () {
                return this._scene;
            };
            application.prototype.initAssetMgr = function () {
                if (this._assetmgr == null) {
                    this._assetmgr = new framework.assetMgr(this);
                    this._assetmgr.initDefAsset();
                }
            };
            application.prototype.getAssetMgr = function () {
                return this._assetmgr;
            };
            application.prototype.initInputMgr = function () {
                if (this._inputmgr == null) {
                    this._inputmgr = new framework.inputMgr(this);
                }
            };
            application.prototype.getInputMgr = function () {
                return this._inputmgr;
            };
            Object.defineProperty(application.prototype, "bePlay", {
                get: function () {
                    return this._bePlay;
                },
                set: function (value) {
                    this._bePlay = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "bePause", {
                get: function () {
                    return this._bePause;
                },
                set: function (value) {
                    this._bePause = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(application.prototype, "beStepForward", {
                get: function () {
                    return this._beStepForward;
                },
                set: function (value) {
                    this._beStepForward = value;
                },
                enumerable: true,
                configurable: true
            });
            application.prototype.updateUserCode = function (delta) {
                for (var i = this._userCodeNew.length - 1; i >= 0; i--) {
                    var c = this._userCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._userCode.push(c);
                        this._userCodeNew.splice(i, 1);
                    }
                }
                var closeindex = -1;
                for (var i = 0; i < this._userCode.length; i++) {
                    var c = this._userCode[i];
                    if (c.isClosed() == false) {
                        c.onUpdate(delta);
                    }
                    else if (closeindex < 0) {
                        closeindex = i;
                    }
                }
                if (closeindex >= 0) {
                    this._userCode.splice(closeindex, 1);
                }
            };
            application.prototype.updateEditorCode = function (delta) {
                for (var i = this._editorCodeNew.length - 1; i >= 0; i--) {
                    var c = this._editorCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._editorCode.push(c);
                        this._editorCodeNew.splice(i, 1);
                    }
                }
                var closeindex = -1;
                for (var i = this._editorCode.length - 1; i >= 0; i--) {
                    var c = this._editorCode[i];
                    if (c.isClosed()) {
                        this._editorCode.splice(i, 1);
                    }
                    else {
                        c.onUpdate(delta);
                    }
                }
            };
            application.prototype.addUserCodeDirect = function (program) {
                this._userCodeNew.push(program);
            };
            application.prototype.addUserCode = function (classname) {
                var prototype = gd3d.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = gd3d.reflect.createInstance(prototype, { "usercode": "1" });
                    this.addUserCodeDirect(code);
                }
            };
            application.prototype.addEditorCode = function (classname) {
                var prototype = gd3d.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = gd3d.reflect.createInstance(prototype, { "editorcode": "1" });
                    this.addEditorCodeDirect(code);
                }
            };
            application.prototype.addEditorCodeDirect = function (program) {
                this._editorCodeNew.push(program);
            };
            application.prototype.updateOrientationMode = function () {
                if (this.OffOrientationUpdate)
                    return;
                var screenRect = this.outcontainer.getBoundingClientRect();
                this.shouldRotate = false;
                if (this.orientation != framework.OrientationMode.AUTO) {
                    this.shouldRotate =
                        (this.orientation == framework.OrientationMode.LANDSCAPE || this.orientation == framework.OrientationMode.LANDSCAPE_FLIPPED) && screenRect.height > screenRect.width ||
                            this.orientation == framework.OrientationMode.PORTRAIT && screenRect.width > screenRect.height;
                }
                var screenWidth = this.shouldRotate ? screenRect.height : screenRect.width;
                var screenHeight = this.shouldRotate ? screenRect.width : screenRect.height;
                if (this.lastWidth == screenWidth && this.lastHeight == screenHeight)
                    return;
                this.lastWidth = screenWidth;
                this.lastHeight = screenHeight;
                this.container.style[getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
                this.container.style.width = screenWidth + "px";
                this.container.style.height = screenHeight + "px";
                var rotation = 0;
                if (this.shouldRotate) {
                    if (this.orientation == framework.OrientationMode.LANDSCAPE) {
                        rotation = 90;
                        this.container.style.top = (screenRect.height - screenWidth) / 2 + "px";
                        this.container.style.left = (screenRect.width + screenHeight) / 2 + "px";
                    }
                    else {
                        rotation = -90;
                        this.container.style.top = (screenRect.height + screenWidth) / 2 + "px";
                        this.container.style.left = (screenRect.width - screenHeight) / 2 + "px";
                    }
                }
                else {
                    this.container.style.top = (screenRect.height - screenHeight) / 2 + "px";
                    this.container.style.left = (screenRect.width - screenWidth) / 2 + "px";
                }
                var transform = "rotate(" + rotation + "deg)";
                this.container.style[getPrefixStyleName("transform")] = transform;
            };
            return application;
        }());
        framework.application = application;
        framework.OrientationMode = {
            AUTO: "auto",
            PORTRAIT: "portrait",
            LANDSCAPE: "landscape",
            LANDSCAPE_FLIPPED: "landscapeFlipped"
        };
        var currentPrefix = null;
        function getPrefixStyleName(name, element) {
            var header = "";
            if (element != null) {
                header = getPrefix(name, element);
            }
            else {
                if (currentPrefix == null) {
                    var tempStyle = document.createElement('div').style;
                    currentPrefix = getPrefix("transform", tempStyle);
                }
                header = currentPrefix;
            }
            if (header == "") {
                return name;
            }
            return header + name.charAt(0).toUpperCase() + name.substring(1, name.length);
        }
        framework.getPrefixStyleName = getPrefixStyleName;
        function getPrefix(name, element) {
            if (name in element) {
                return "";
            }
            name = name.charAt(0).toUpperCase() + name.substring(1, name.length);
            var transArr = ["webkit", "ms", "Moz", "O"];
            for (var i = 0; i < transArr.length; i++) {
                var tempStyle = transArr[i] + name;
                if (tempStyle in element) {
                    return transArr[i];
                }
            }
            return "";
        }
        framework.getPrefix = getPrefix;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var sceneMgr = (function () {
            function sceneMgr() {
            }
            Object.defineProperty(sceneMgr, "ins", {
                get: function () {
                    if (sceneMgr._ins == null)
                        sceneMgr._ins = new sceneMgr();
                    return sceneMgr._ins;
                },
                enumerable: true,
                configurable: true
            });
            return sceneMgr;
        }());
        framework.sceneMgr = sceneMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var Stats;
(function (Stats_1) {
    var Stats = (function () {
        function Stats(app) {
            var _this = this;
            this.mode = 0;
            this.app = app;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', function (event) {
                event.preventDefault();
                _this.showPanel(++_this.mode % _this.container.children.length);
            }, false);
            this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.frames = 0;
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            this.ratePanel = this.addPanel(new Panel('%', '#0f0', '#020'));
            this.userratePanel = this.addPanel(new Panel('%', '#0f0', '#020'));
            if (self.performance && self.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        Stats.prototype.update = function () {
            this.beginTime = this.end();
        };
        Stats.prototype.showPanel = function (id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        };
        Stats.prototype.addPanel = function (panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        };
        Stats.prototype.begin = function () {
            this.beginTime = (performance || Date).now();
        };
        Stats.prototype.end = function () {
            this.frames++;
            var time = (performance || Date).now();
            this.msPanel.update(time - this.beginTime, 200);
            if (time > this.prevTime + 1000) {
                var fps = (this.frames * 1000) / (time - this.prevTime);
                this.fpsPanel.update(fps, 100);
                this.ratePanel.update(this.app.getUpdateTimer() * this.frames / 10, 100);
                this.userratePanel.update(this.app.getUserUpdateTimer() * this.frames / 10, 100);
                this.prevTime = time;
                this.frames = 0;
                if (this.memPanel) {
                    var memory = performance["memory"];
                    this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
                }
            }
            return time;
        };
        return Stats;
    }());
    Stats_1.Stats = Stats;
    var Panel = (function () {
        function Panel(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        Panel.prototype.update = function (value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        };
        return Panel;
    }());
})(Stats || (Stats = {}));
var gd3d;
(function (gd3d) {
    var reflect;
    (function (reflect) {
        function regType(target, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"]["class"] == undefined)
                target["__gdmeta__"]["class"] = {};
            var name = target["constructor"]["name"];
            if (name == null) {
                var fs = target["constructor"].toString();
                var i = fs.indexOf("(");
                name = fs.substring(9, i);
            }
            target["__gdmeta__"]["class"]["typename"] = name;
            if (document["__gdmeta__"] == null)
                document["__gdmeta__"] = {};
            document["__gdmeta__"][name] = target;
            if (target["__gdmeta__"]["class"]["custom"] == null)
                target["__gdmeta__"]["class"]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"]["class"]["custom"][key] = customInfo[key];
                }
            }
        }
        function regFunc(target, funcname, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"][funcname] == null)
                target["__gdmeta__"][funcname] = {};
            target["__gdmeta__"][funcname]["type"] = "function";
            var tp = Reflect.getMetadata("design:paramtypes", target, funcname);
            var tr = Reflect.getMetadata("design:returntype", target, funcname);
            target["__gdmeta__"][funcname]["paramtypes"] = [];
            for (var i in tp) {
                target["__gdmeta__"][funcname]["paramtypes"][i] = tp[i]["name"];
            }
            target["__gdmeta__"][funcname]["returntype"] = tr == null ? null : tr["name"];
            if (target["__gdmeta__"][funcname]["custom"] == null)
                target["__gdmeta__"][funcname]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][funcname]["custom"][key] = customInfo[key];
                }
            }
        }
        function regField(target, fieldName, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"][fieldName] == null)
                target["__gdmeta__"][fieldName] = {};
            target["__gdmeta__"][fieldName]["type"] = "field";
            if (target["__gdmeta__"][fieldName]["custom"] == null)
                target["__gdmeta__"][fieldName]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][fieldName]["custom"][key] = customInfo[key];
                }
            }
        }
        function getPrototypes() {
            return document["__gdmeta__"];
        }
        reflect.getPrototypes = getPrototypes;
        function getPrototype(name) {
            return document["__gdmeta__"][name];
        }
        reflect.getPrototype = getPrototype;
        function createInstance(prototype, matchTag) {
            if (matchTag == null) {
                var ctor = prototype.constructor;
                return new ctor();
            }
            else {
                var info = prototype["__gdmeta__"]["class"]["custom"];
                for (var key in matchTag) {
                    if (info[key] != matchTag[key]) {
                        console.warn("createInstance:" + name + ". tag do not match.");
                        return null;
                    }
                }
                var ctor = prototype.constructor;
                return new ctor();
            }
        }
        reflect.createInstance = createInstance;
        function getClassName(prototype) {
            var info = prototype["__gdmeta__"]["class"]["typename"];
            return info;
        }
        reflect.getClassName = getClassName;
        function getClassTag(prototype, tag) {
            var info = prototype["__gdmeta__"]["class"]["custom"];
            return info[tag];
        }
        reflect.getClassTag = getClassTag;
        function getMeta(prototype) {
            var meta = prototype.__gdmeta__;
            return meta;
        }
        reflect.getMeta = getMeta;
        function attr_Class(constructorObj) {
            regType(constructorObj.prototype, null);
        }
        reflect.attr_Class = attr_Class;
        function attr_Func(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey, value) {
                regFunc(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Func = attr_Func;
        function attr_Field(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey) {
                regField(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Field = attr_Field;
        function userCode(constructorObj) {
            regType(constructorObj.prototype, { "usercode": "1" });
        }
        reflect.userCode = userCode;
        function editorCode(constructorObj) {
            regType(constructorObj.prototype, { "editorcode": "1" });
        }
        reflect.editorCode = editorCode;
        function selfClone(constructorObj) {
            regType(constructorObj.prototype, { "selfclone": "1" });
        }
        reflect.selfClone = selfClone;
        function nodeComponent(constructorObj) {
            regType(constructorObj.prototype, { "nodecomp": "1" });
        }
        reflect.nodeComponent = nodeComponent;
        function nodeComponentInspector(constructorObj) {
            regType(constructorObj.prototype, { "nodecomp_inspector": "1" });
        }
        reflect.nodeComponentInspector = nodeComponentInspector;
        function nodeRender(constructorObj) {
            regType(constructorObj.prototype, { "renderer": "1" });
        }
        reflect.nodeRender = nodeRender;
        function nodeCamera(constructorObj) {
            regType(constructorObj.prototype, { "camera": "1" });
        }
        reflect.nodeCamera = nodeCamera;
        function nodeLight(constructorObj) {
            regType(constructorObj.prototype, { "light": "1" });
        }
        reflect.nodeLight = nodeLight;
        function nodeBoxCollider(constructorObj) {
            regType(constructorObj.prototype, { "boxcollider": "1" });
        }
        reflect.nodeBoxCollider = nodeBoxCollider;
        function nodeSphereCollider(constructorObj) {
            regType(constructorObj.prototype, { "spherecollider": "1" });
        }
        reflect.nodeSphereCollider = nodeSphereCollider;
        function nodeEffectBatcher(constructorObj) {
            regType(constructorObj.prototype, { "effectbatcher": "1" });
        }
        reflect.nodeEffectBatcher = nodeEffectBatcher;
        function nodeMeshCollider(constructorObj) {
            regType(constructorObj.prototype, { "meshcollider": "1" });
        }
        reflect.nodeMeshCollider = nodeMeshCollider;
        function nodeCanvasRendererCollider(constructorObj) {
            regType(constructorObj.prototype, { "canvasRenderer": "1" });
        }
        reflect.nodeCanvasRendererCollider = nodeCanvasRendererCollider;
        function node2DComponent(constructorObj) {
            regType(constructorObj.prototype, { "2dcomp": "1" });
        }
        reflect.node2DComponent = node2DComponent;
        function pluginMenuItem(constructorObj) {
            regType(constructorObj.prototype, { "plugin_menuitem": "1" });
        }
        reflect.pluginMenuItem = pluginMenuItem;
        function pluginWindow(constructorObj) {
            regType(constructorObj.prototype, { "plugin_window": "1" });
        }
        reflect.pluginWindow = pluginWindow;
        function pluginExt(constructorObj) {
            regType(constructorObj.prototype, { "plugin_ext": "1" });
        }
        reflect.pluginExt = pluginExt;
        function compValue(integer, defvalue, min, max) {
            if (integer === void 0) { integer = false; }
            if (defvalue === void 0) { defvalue = 0; }
            if (min === void 0) { min = Number.MIN_VALUE; }
            if (max === void 0) { max = Number.MAX_VALUE; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "compValue": "1",
                    "integer": integer ? "1" : "0",
                    "defvalue": defvalue.toString(),
                    "min": min.toString(),
                    "max": max.toString(),
                });
            };
        }
        reflect.compValue = compValue;
        function compCall(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey, value) {
                regFunc(target, propertyKey, { "compcall": "1" });
                regFunc(target, propertyKey, customInfo);
            };
        }
        reflect.compCall = compCall;
        function SerializeType(constructorObj) {
            regType(constructorObj.prototype, { "SerializeType": "1" });
        }
        reflect.SerializeType = SerializeType;
        function Field(valueType, defaultValue, enumRealType) {
            if (defaultValue === void 0) { defaultValue = undefined; }
            if (enumRealType === void 0) { enumRealType = undefined; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "SerializeField": true,
                    "valueType": valueType
                });
                if (defaultValue == undefined) {
                }
                else {
                    regField(target, propertyKey, {
                        "defaultValue": defaultValue
                    });
                }
            };
        }
        reflect.Field = Field;
        function UIComment(comment) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "UIComment": comment
                });
            };
        }
        reflect.UIComment = UIComment;
        var FieldUIStyle;
        (function (FieldUIStyle) {
            FieldUIStyle[FieldUIStyle["None"] = 0] = "None";
            FieldUIStyle[FieldUIStyle["RangeFloat"] = 1] = "RangeFloat";
            FieldUIStyle[FieldUIStyle["MultiLineString"] = 2] = "MultiLineString";
            FieldUIStyle[FieldUIStyle["Enum"] = 3] = "Enum";
        })(FieldUIStyle = reflect.FieldUIStyle || (reflect.FieldUIStyle = {}));
        function UIStyle(style, min, max, defvalue) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "FieldUIStyle": style,
                    "min": min ? min : null,
                    "max": max ? max : null,
                    "defvalue": defvalue ? defvalue : null
                });
            };
        }
        reflect.UIStyle = UIStyle;
    })(reflect = gd3d.reflect || (gd3d.reflect = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var canvas = (function () {
            function canvas() {
                this.is2dUI = true;
                this.pointDown = false;
                this.pointSelect = null;
                this.pointEvent = new framework.PointEvent();
                this.pointX = 0;
                this.pointY = 0;
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.lastMaskSta = -1;
                this.pixelWidth = 640;
                this.pixelHeight = 480;
                this.rootNode = new framework.transform2D();
                this.rootNode.canvas = this;
            }
            canvas.prototype.addChild = function (node) {
                this.rootNode.addChild(node);
            };
            canvas.prototype.removeChild = function (node) {
                this.rootNode.removeChild(node);
            };
            canvas.prototype.getChildren = function () {
                return this.rootNode.children;
            };
            canvas.prototype.getChildCount = function () {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            };
            canvas.prototype.getChild = function (index) {
                return this.rootNode.children[index];
            };
            canvas.prototype.update = function (delta, touch, XOnScreenSpace, YOnScreenSpace) {
                var asp = this.pixelWidth / this.pixelHeight;
                this.rootNode.localScale.x = 2 / this.pixelWidth;
                this.rootNode.localScale.y = -2 / this.pixelHeight;
                this.rootNode.localTranslate.y = 1;
                this.rootNode.localTranslate.x = -1;
                if (this.pixelWidth != this.lastWidth || this.pixelHeight != this.lastHeight) {
                    this.lastWidth = this.rootNode.width = this.pixelWidth;
                    this.lastHeight = this.rootNode.height = this.pixelHeight;
                    this.rootNode.markDirty();
                }
                this.rootNode.pivot.x = 0;
                this.rootNode.pivot.y = 0;
                this.rootNode.updateTran(false);
                {
                    this.pointEvent.eated = false;
                    this.pointEvent.x = XOnScreenSpace;
                    this.pointEvent.y = YOnScreenSpace;
                    this.pointEvent.selected = this.pointSelect;
                    var skip = false;
                    if (this.pointDown == false && touch == false) {
                        skip = true;
                    }
                    else if (this.pointDown == false && touch == true) {
                        this.pointEvent.type = framework.PointEventEnum.PointDown;
                    }
                    else if (this.pointDown == true && touch == true) {
                        this.pointEvent.type = framework.PointEventEnum.PointHold;
                        if (this.pointX == this.pointEvent.x && this.pointY == this.pointEvent.y) {
                            skip = true;
                        }
                    }
                    else if (this.pointDown == true && touch == false) {
                        this.pointEvent.type = framework.PointEventEnum.PointUp;
                    }
                    if (!skip) {
                        if (this.scene.app.bePlay) {
                            this.rootNode.onCapturePointEvent(this, this.pointEvent);
                            this.rootNode.onPointEvent(this, this.pointEvent);
                        }
                        this.pointSelect = this.pointEvent.selected;
                        this.pointDown = touch;
                        this.pointX = this.pointEvent.x;
                        this.pointY = this.pointEvent.y;
                    }
                }
                this.rootNode.update(delta);
            };
            canvas.prototype.render = function (context, assetmgr) {
                this.context = context;
                this.assetmgr = assetmgr;
                this.lastMat = null;
                if (this.batcher == null) {
                    this.webgl = context.webgl;
                    this.batcher = new framework.batcher2D();
                    var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0 | gd3d.render.VertexFormatMask.ColorEX;
                    this.batcher.initBuffer(context.webgl, vf, gd3d.render.DrawModeEnum.VboTri);
                }
                this.drawScene(this.rootNode, context, assetmgr);
                this.batcher.end(context.webgl);
                if (this.afterRender != null)
                    this.afterRender();
            };
            canvas.prototype.pushRawData = function (mat, data) {
                if (mat != this.lastMat) {
                    this.lastMat = mat;
                    this.batcher.end(this.webgl);
                    var pass = this.lastMat.getShader().passes["base"][0];
                    pass.use(this.webgl);
                    mat.uploadUnifoms(pass, this.context);
                    this.batcher.begin(this.webgl, pass);
                }
                else {
                    var msta = mat.statedMapUniforms["MaskState"];
                    var mr = mat.statedMapUniforms["_maskRect"];
                    if (msta != null && msta.value != null && mr != null && mr.value != null) {
                        var rect = mr.value;
                        if (this.lastMaskV4 == null)
                            this.lastMaskV4 = new gd3d.math.vector4();
                        if (msta.value != this.lastMaskSta || this.lastMaskV4.x != rect.x || this.lastMaskV4.y != rect.y || this.lastMaskV4.z != rect.z || this.lastMaskV4.w != rect.w) {
                            this.lastMaskSta = msta.value;
                            gd3d.math.vec4Clone(rect, this.lastMaskV4);
                            this.batcher.end(this.webgl);
                            var pass = this.lastMat.getShader().passes["base"][0];
                            mat.uploadUnifoms(pass, this.context);
                        }
                    }
                }
                this.batcher.push(this.webgl, data, null);
            };
            canvas.prototype.drawScene = function (node, context, assetmgr) {
                if (!node.visible)
                    return;
                if (node.renderer != null) {
                    node.renderer.render(this);
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.drawScene(node.children[i], context, assetmgr);
                    }
                }
            };
            canvas.prototype.getRoot = function () {
                if (this.rootNode == null) {
                    this.rootNode = new framework.transform2D();
                    this.rootNode.canvas = this;
                    this.scene.app.markNotify(this.rootNode, framework.NotifyType.AddChild);
                }
                return this.rootNode;
            };
            canvas.prototype.screenToCanvasPoint = function (fromP, outP) {
                if (fromP == null || outP == null)
                    return;
                var scalx = 1 - (fromP.x - 1) / -2;
                var scaly = (fromP.y - 1) / -2;
                outP.x = scalx * this.pixelWidth;
                outP.y = scaly * this.pixelHeight;
            };
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], canvas.prototype, "pixelWidth", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], canvas.prototype, "pixelHeight", void 0);
            __decorate([
                gd3d.reflect.Field("transform2D"),
                __metadata("design:type", framework.transform2D)
            ], canvas.prototype, "rootNode", void 0);
            canvas = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], canvas);
            return canvas;
        }());
        framework.canvas = canvas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var batcher2D = (function () {
            function batcher2D() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            batcher2D.prototype.initBuffer = function (webgl, vf, drawMode) {
                this.mesh = new gd3d.render.glMesh();
                this.mesh.initBuffer(webgl, vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == gd3d.render.DrawModeEnum.EboLine || drawMode == gd3d.render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
            };
            batcher2D.prototype.begin = function (webgl, pass) {
                if (this.vboCount > 0)
                    this.end(webgl);
                this.curPass = pass;
            };
            batcher2D.prototype.push = function (webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > 2048
                    ||
                        (ebodata != null && this.eboCount + ebodata.length > 2048)) {
                    this.end(webgl);
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    var narr = new Float32Array(this.dataForVbo.length * 2);
                    for (var i = 0; i < this.dataForVbo.length; i++) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (var i = 0; i < vbodata.length; i++) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == gd3d.render.DrawModeEnum.VboLine || this.drawMode == gd3d.render.DrawModeEnum.VboTri)
                    return;
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        var narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (var i = 0; i < this.dataForEbo.length; i++) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (var i = 0; i < ebodata.length; i++) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            };
            batcher2D.prototype.end = function (webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexData(webgl, this.dataForVbo);
                if (this.eboCount > 0) {
                    this.mesh.uploadIndexData(webgl, 0, this.dataForEbo);
                }
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                this.curPass.use(webgl);
                this.mesh.bind(webgl, this.curPass.program, (this.drawMode == gd3d.render.DrawModeEnum.EboLine || this.drawMode == gd3d.render.DrawModeEnum.EboTri) ? 0 : -1);
                if (this.drawMode == gd3d.render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
            };
            return batcher2D;
        }());
        framework.batcher2D = batcher2D;
        var canvasRenderer = (function () {
            function canvasRenderer() {
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                this.renderLayer = framework.CullingMask.default;
                this.canvas = new framework.canvas();
                this.canvas.is2dUI = false;
            }
            canvasRenderer.prototype.getBound = function () {
                return null;
            };
            canvasRenderer.prototype.intersectsTransform = function (tran) {
                return false;
            };
            canvasRenderer.prototype.start = function () {
                this.canvas.scene = this.gameObject.getScene();
                this.canvas.parentTrans = this.gameObject.transform;
                this.inputmgr = this.gameObject.getScene().app.getInputMgr();
            };
            canvasRenderer.prototype.addChild = function (node) {
                this.canvas.addChild(node);
            };
            canvasRenderer.prototype.removeChild = function (node) {
                this.canvas.removeChild(node);
            };
            canvasRenderer.prototype.getChildren = function () {
                return this.canvas.getChildren();
            };
            canvasRenderer.prototype.getChildCount = function () {
                return this.canvas.getChildCount();
            };
            canvasRenderer.prototype.getChild = function (index) {
                return this.canvas.getChild(index);
            };
            canvasRenderer.prototype.update = function (delta) {
                var asp = this.canvas.pixelWidth / this.canvas.pixelHeight;
                this.gameObject.transform.localScale.x = this.gameObject.transform.localScale.y * asp;
                if (this.cameraTouch != null) {
                    var scene = this.gameObject.getScene();
                    var ray = this.cameraTouch.creatRayByScreen(new gd3d.math.vector2(this.inputmgr.point.x, this.inputmgr.point.y), scene.app);
                    var pinfo = scene.pick(ray);
                    if (pinfo != null && pinfo.pickedtran == this.gameObject.transform) {
                        var mat = this.gameObject.transform.getWorldMatrix();
                        var matinv = new gd3d.math.matrix();
                        gd3d.math.matrixInverse(mat, matinv);
                        var outv = new gd3d.math.vector3();
                        gd3d.math.matrixTransformVector3(pinfo.hitposition, matinv, outv);
                        this.canvas.update(delta, this.inputmgr.point.touch, outv.x, outv.y);
                    }
                    else {
                        this.canvas.update(delta, false, 0, 0);
                    }
                }
                else {
                    this.canvas.update(delta, false, 0, 0);
                }
            };
            canvasRenderer.prototype.pick2d = function (ray) {
                var pinfo = ray.intersectPlaneTransform(this.gameObject.transform);
                if (pinfo != null) {
                    var mat = this.gameObject.transform.getWorldMatrix();
                    var matinv = gd3d.math.pool.new_matrix();
                    gd3d.math.matrixInverse(mat, matinv);
                    var outv = gd3d.math.pool.new_vector3();
                    gd3d.math.matrixTransformVector3(pinfo.hitposition, matinv, outv);
                    var outv2 = gd3d.math.pool.new_vector2();
                    outv2.x = outv.x;
                    outv2.y = outv.y;
                    var root = this.canvas.getRoot();
                    return this.dopick2d(outv2, root);
                }
                return null;
            };
            canvasRenderer.prototype.dopick2d = function (outv, tran) {
                if (tran.components != null) {
                    for (var i = tran.components.length - 1; i >= 0; i--) {
                        var comp = tran.components[i];
                        if (comp != null)
                            if (comp.init && comp.comp.transform.ContainsCanvasPoint(outv)) {
                                return comp.comp.transform;
                            }
                    }
                }
                if (tran.children != null) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        var tran2 = this.dopick2d(outv, tran.children[i]);
                        if (tran2 != null)
                            return tran2;
                    }
                }
                return null;
            };
            canvasRenderer.prototype.render = function (context, assetmgr, camera) {
                context.updateModel(this.gameObject.transform);
                this.canvas.render(context, assetmgr);
            };
            canvasRenderer.prototype.jsonToAttribute = function (json, assetmgr) {
            };
            canvasRenderer.prototype.remove = function () {
            };
            canvasRenderer.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.Field("canvas"),
                __metadata("design:type", framework.canvas)
            ], canvasRenderer.prototype, "canvas", void 0);
            canvasRenderer = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeCanvasRendererCollider,
                __metadata("design:paramtypes", [])
            ], canvasRenderer);
            return canvasRenderer;
        }());
        framework.canvasRenderer = canvasRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var PointEventEnum;
        (function (PointEventEnum) {
            PointEventEnum[PointEventEnum["PointNothing"] = 0] = "PointNothing";
            PointEventEnum[PointEventEnum["PointDown"] = 1] = "PointDown";
            PointEventEnum[PointEventEnum["PointHold"] = 2] = "PointHold";
            PointEventEnum[PointEventEnum["PointUp"] = 3] = "PointUp";
        })(PointEventEnum = framework.PointEventEnum || (framework.PointEventEnum = {}));
        var PointEvent = (function () {
            function PointEvent() {
            }
            return PointEvent;
        }());
        framework.PointEvent = PointEvent;
        var UIEvent = (function () {
            function UIEvent() {
                this.funcs = [];
            }
            UIEvent.prototype.addListener = function (func) {
                this.funcs.push(func);
            };
            UIEvent.prototype.excute = function () {
                for (var key in this.funcs) {
                    this.funcs[key]();
                }
            };
            UIEvent.prototype.clear = function () {
                this.funcs.length = 0;
            };
            return UIEvent;
        }());
        framework.UIEvent = UIEvent;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var overlay2D = (function () {
            function overlay2D() {
                this.init = false;
                this.autoAsp = true;
                this.sortOrder = 0;
                this.canvas = new framework.canvas();
                framework.sceneMgr.app.markNotify(this.canvas.getRoot(), framework.NotifyType.AddChild);
            }
            overlay2D.prototype.start = function (camera) {
                if (camera == this.camera)
                    return;
                this.camera = camera;
                this.app = camera.gameObject.getScene().app;
                this.canvas.scene = camera.gameObject.getScene();
                this.inputmgr = camera.gameObject.getScene().app.getInputMgr();
            };
            overlay2D.prototype.addChild = function (node) {
                this.canvas.addChild(node);
            };
            overlay2D.prototype.removeChild = function (node) {
                this.canvas.removeChild(node);
            };
            overlay2D.prototype.getChildren = function () {
                return this.canvas.getChildren();
            };
            overlay2D.prototype.getChildCount = function () {
                return this.canvas.getChildCount();
            };
            overlay2D.prototype.getChild = function (index) {
                return this.canvas.getChild(index);
            };
            overlay2D.prototype.render = function (context, assetmgr, camera) {
                if (!this.canvas.getRoot().visible)
                    return;
                if (this.camera == null || this.camera == undefined)
                    return;
                if (this.autoAsp) {
                    var vp = new gd3d.math.rect();
                    this.camera.calcViewPortPixel(assetmgr.app, vp);
                    var aspcam = vp.w / vp.h;
                    var aspc = this.canvas.pixelWidth / this.canvas.pixelHeight;
                    if (aspc != aspcam) {
                        this.canvas.pixelWidth = this.canvas.pixelHeight * aspcam;
                        this.canvas.getRoot().markDirty();
                    }
                }
                context.updateOverlay();
                this.canvas.render(context, assetmgr);
            };
            overlay2D.prototype.update = function (delta) {
                var vp = new gd3d.math.rect();
                var app = this.camera.calcViewPortPixel(this.app, vp);
                var sx = (this.inputmgr.point.x / vp.w) * 2 - 1;
                var sy = (this.inputmgr.point.y / vp.h) * -2 + 1;
                this.canvas.update(delta, this.inputmgr.point.touch, sx, sy);
            };
            overlay2D.prototype.pick2d = function (mx, my, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                if (this.camera == null)
                    return null;
                var vp = new gd3d.math.rect();
                var app = this.camera.calcViewPortPixel(this.app, vp);
                var sx = (mx / vp.w) * 2 - 1;
                var sy = (my / vp.h) * -2 + 1;
                var outv2 = gd3d.math.pool.new_vector2();
                outv2.x = sx;
                outv2.y = sy;
                var root = this.canvas.getRoot();
                var trans = this.dopick2d(outv2, root, tolerance);
                gd3d.math.pool.delete_vector2(outv2);
                return trans;
            };
            overlay2D.prototype.dopick2d = function (outv, tran, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                if (tran.components != null) {
                    for (var i = tran.components.length - 1; i >= 0; i--) {
                        var comp = tran.components[i];
                        if (comp != null)
                            if (comp.init && comp.comp.transform.ContainsCanvasPoint(outv, tolerance)) {
                                return comp.comp.transform;
                            }
                    }
                }
                if (tran.children != null) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        var tran2 = this.dopick2d(outv, tran.children[i], tolerance);
                        if (tran2 != null)
                            return tran2;
                    }
                }
                return null;
            };
            overlay2D.prototype.pick2d_new = function (mx, my, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                if (this.camera == null)
                    return null;
                var vp = new gd3d.math.rect();
                var app = this.camera.calcViewPortPixel(this.app, vp);
                var sx = (mx / vp.w) * 2 - 1;
                var sy = (my / vp.h) * -2 + 1;
                var outv2 = gd3d.math.pool.new_vector2();
                outv2.x = sx;
                outv2.y = sy;
                var root = this.canvas.getRoot();
                return this.dopick2d_new(outv2, root, tolerance);
            };
            overlay2D.prototype.dopick2d_new = function (outv, tran, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                if (tran.children != null) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        var tran2 = this.dopick2d_new(outv, tran.children[i]);
                        if (tran2 != null)
                            return tran2;
                    }
                }
                var uirect = tran.getComponent("uirect");
                if (uirect != null) {
                    if (uirect.canbeClick && uirect.transform.ContainsCanvasPoint(outv, tolerance)) {
                        return uirect.transform;
                    }
                }
                return null;
            };
            overlay2D.prototype.calScreenPosToCanvasPos = function (mousePos, canvasPos) {
                var vp = new gd3d.math.rect();
                this.camera.calcViewPortPixel(this.app, vp);
                var temt = gd3d.math.pool.new_vector2();
                temt.x = (mousePos.x / vp.w) * 2 - 1;
                temt.y = (mousePos.y / vp.h) * -2 + 1;
                var mat = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Clone(this.canvas.getRoot().getWorldMatrix(), mat);
                gd3d.math.matrix3x2Inverse(mat, mat);
                gd3d.math.matrix3x2TransformVector2(mat, temt, canvasPos);
                gd3d.math.pool.delete_vector2(temt);
            };
            __decorate([
                gd3d.reflect.Field("canvas"),
                __metadata("design:type", framework.canvas)
            ], overlay2D.prototype, "canvas", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], overlay2D.prototype, "autoAsp", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], overlay2D.prototype, "sortOrder", void 0);
            overlay2D = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], overlay2D);
            return overlay2D;
        }());
        framework.overlay2D = overlay2D;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        var vector2 = (function () {
            function vector2(x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                this.x = x;
                this.y = y;
            }
            vector2.prototype.toString = function () {
                return this.x + "," + this.y;
            };
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector2.prototype, "x", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector2.prototype, "y", void 0);
            vector2 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number])
            ], vector2);
            return vector2;
        }());
        math.vector2 = vector2;
        var rect = (function () {
            function rect(x, y, w, h) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (w === void 0) { w = 0; }
                if (h === void 0) { h = 0; }
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }
            rect.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.w + "," + this.h;
            };
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], rect.prototype, "x", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], rect.prototype, "y", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], rect.prototype, "w", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], rect.prototype, "h", void 0);
            rect = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], rect);
            return rect;
        }());
        math.rect = rect;
        var border = (function () {
            function border(l, t, r, b) {
                if (l === void 0) { l = 0; }
                if (t === void 0) { t = 0; }
                if (r === void 0) { r = 0; }
                if (b === void 0) { b = 0; }
                this.l = l;
                this.t = t;
                this.r = r;
                this.b = b;
            }
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], border.prototype, "l", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], border.prototype, "t", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], border.prototype, "r", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], border.prototype, "b", void 0);
            border = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], border);
            return border;
        }());
        math.border = border;
        var color = (function () {
            function color(r, g, b, a) {
                if (r === void 0) { r = 1; }
                if (g === void 0) { g = 1; }
                if (b === void 0) { b = 1; }
                if (a === void 0) { a = 1; }
                this.r = r;
                this.g = g;
                this.b = b;
                this.a = a;
            }
            color.prototype.toString = function () {
                return this.r + "," + this.g + "," + this.b + "," + this.a;
            };
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], color.prototype, "r", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], color.prototype, "g", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], color.prototype, "b", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], color.prototype, "a", void 0);
            color = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], color);
            return color;
        }());
        math.color = color;
        var vector3 = (function () {
            function vector3(x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                this.x = x;
                this.y = y;
                this.z = z;
            }
            vector3.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z;
            };
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector3.prototype, "x", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector3.prototype, "y", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector3.prototype, "z", void 0);
            vector3 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number])
            ], vector3);
            return vector3;
        }());
        math.vector3 = vector3;
        var vector4 = (function () {
            function vector4(x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 0; }
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            vector4.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z + "," + this.w;
            };
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector4.prototype, "x", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector4.prototype, "y", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector4.prototype, "z", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector4.prototype, "w", void 0);
            vector4 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], vector4);
            return vector4;
        }());
        math.vector4 = vector4;
        var quaternion = (function () {
            function quaternion(x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 1; }
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            quaternion.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z + "," + this.w;
            };
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], quaternion.prototype, "x", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], quaternion.prototype, "y", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], quaternion.prototype, "z", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], quaternion.prototype, "w", void 0);
            quaternion = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], quaternion);
            return quaternion;
        }());
        math.quaternion = quaternion;
        var matrix = (function () {
            function matrix(datas) {
                if (datas === void 0) { datas = null; }
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            }
            matrix.prototype.toString = function () {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "," + this.rawData[3] + "],"
                    + "[" + this.rawData[4] + "," + this.rawData[5] + "," + this.rawData[6] + "," + this.rawData[7] + "],"
                    + "[" + this.rawData[8] + "," + this.rawData[9] + "," + this.rawData[10] + "," + this.rawData[11] + "],"
                    + "[" + this.rawData[12] + "," + this.rawData[13] + "," + this.rawData[14] + "," + this.rawData[15] + "]";
            };
            return matrix;
        }());
        math.matrix = matrix;
        var matrix3x2 = (function () {
            function matrix3x2(datas) {
                if (datas === void 0) { datas = null; }
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = new Float32Array([1, 0, 0, 1, 0, 0]);
            }
            matrix3x2.prototype.toString = function () {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "],"
                    + "[" + this.rawData[3] + "," + this.rawData[4] + "," + this.rawData[5] + "]";
            };
            return matrix3x2;
        }());
        math.matrix3x2 = matrix3x2;
        function vec4FormJson(json, vec4) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            vec4.x = Number(arr[0]);
            vec4.y = Number(arr[1]);
            vec4.z = Number(arr[2]);
            vec4.w = Number(arr[3]);
        }
        math.vec4FormJson = vec4FormJson;
        function vec3FormJson(json, vec3) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            vec3.x = Number(arr[0]);
            vec3.y = Number(arr[1]);
            vec3.z = Number(arr[2]);
        }
        math.vec3FormJson = vec3FormJson;
        function vec2FormJson(json, vec2) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            vec2.x = Number(arr[0]);
            vec2.y = Number(arr[1]);
        }
        math.vec2FormJson = vec2FormJson;
        function colorFormJson(json, _color) {
            json = json.replace("RGBA(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            _color.r = Number(arr[0]);
            _color.g = Number(arr[1]);
            _color.b = Number(arr[2]);
            _color.a = Number(arr[3]);
        }
        math.colorFormJson = colorFormJson;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var layoutOption;
        (function (layoutOption) {
            layoutOption[layoutOption["LEFT"] = 1] = "LEFT";
            layoutOption[layoutOption["TOP"] = 2] = "TOP";
            layoutOption[layoutOption["RIGHT"] = 4] = "RIGHT";
            layoutOption[layoutOption["BOTTOM"] = 8] = "BOTTOM";
            layoutOption[layoutOption["H_CENTER"] = 16] = "H_CENTER";
            layoutOption[layoutOption["V_CENTER"] = 32] = "V_CENTER";
        })(layoutOption = framework.layoutOption || (framework.layoutOption = {}));
        var C2DComponent = (function () {
            function C2DComponent(comp, init) {
                if (init === void 0) { init = false; }
                this.comp = comp;
                this.init = init;
            }
            __decorate([
                gd3d.reflect.Field("I2DComponent"),
                __metadata("design:type", Object)
            ], C2DComponent.prototype, "comp", void 0);
            C2DComponent = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Object, Boolean])
            ], C2DComponent);
            return C2DComponent;
        }());
        framework.C2DComponent = C2DComponent;
        var transform2D = (function () {
            function transform2D() {
                this.name = "noname";
                this.pivot = new gd3d.math.vector2(0, 0);
                this.hideFlags = framework.HideFlags.None;
                this._visible = true;
                this.insId = new framework.insID();
                this.dirty = true;
                this.dirtyChild = true;
                this.dirtyWorldDecompose = false;
                this.localTranslate = new gd3d.math.vector2(0, 0);
                this.localScale = new gd3d.math.vector2(1, 1);
                this.localRotate = 0;
                this._isMask = false;
                this._parentIsMask = false;
                this.localMatrix = new gd3d.math.matrix3x2;
                this.worldMatrix = new gd3d.math.matrix3x2();
                this.worldRotate = new gd3d.math.angelref();
                this.worldTranslate = new gd3d.math.vector2(0, 0);
                this.worldScale = new gd3d.math.vector2(1, 1);
                this.components = [];
                this.optionArr = [layoutOption.LEFT, layoutOption.TOP, layoutOption.RIGHT, layoutOption.BOTTOM, layoutOption.H_CENTER, layoutOption.V_CENTER];
                this._layoutState = 0;
                this.layoutValueMap = {};
                this._layoutPercentState = 0;
                this.layoutDirty = false;
                this.lastParentWidth = 0;
                this.lastParentHeight = 0;
                this.lastParentPivot = new gd3d.math.vector2(0, 0);
                this.lastPivot = new gd3d.math.vector2(0, 0);
            }
            Object.defineProperty(transform2D.prototype, "canvas", {
                get: function () {
                    if (this._canvas == null) {
                        if (this.parent == null)
                            return null;
                        return this.parent.canvas;
                    }
                    return this._canvas;
                },
                set: function (val) {
                    this._canvas = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "visibleInScene", {
                get: function () {
                    var obj = this;
                    while (obj.visible) {
                        obj = obj.parent;
                    }
                    return obj.visible;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "visible", {
                get: function () {
                    return this._visible;
                },
                set: function (val) {
                    if (val != this._visible) {
                        this._visible = val;
                        framework.sceneMgr.app.markNotify(this, framework.NotifyType.ChangeVisible);
                    }
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(transform2D.prototype, "transform", {
                get: function () {
                    return this;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "maskRect", {
                get: function () {
                    if (this._temp_maskRect == null)
                        this._temp_maskRect = new gd3d.math.rect();
                    if (this._maskRect != null) {
                        this._temp_maskRect.x = this._maskRect.x;
                        this._temp_maskRect.y = this._maskRect.y;
                        this._temp_maskRect.w = this._maskRect.w;
                        this._temp_maskRect.h = this._maskRect.h;
                    }
                    return this._temp_maskRect;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "isMask", {
                get: function () {
                    return this._isMask;
                },
                set: function (b) {
                    this._isMask = b;
                    this.markDirty();
                    if (this.parent != null)
                        this.updateTran(true);
                },
                enumerable: true,
                configurable: true
            });
            transform2D.prototype.updateMaskRect = function () {
                var rect_x;
                var rect_y;
                var rect_w;
                var rect_h;
                var ParentRect;
                if (this.parent != null) {
                    this._parentIsMask = this.parent.isMask || this.parent.parentIsMask;
                    ParentRect = this.parent.maskRect;
                }
                else
                    this._parentIsMask = false;
                if (this.isMask || this.parentIsMask) {
                    if (this.isMask) {
                        var wPos = this.getWorldTranslate();
                        var wW = this.canvas.pixelWidth;
                        var wH = this.canvas.pixelHeight;
                        rect_x = wPos.x / wW;
                        rect_y = wPos.y / wH;
                        rect_w = this.width / wW;
                        rect_h = this.height / wH;
                        if (this.parentIsMask && ParentRect != null) {
                            var min_x = Math.max(rect_x, ParentRect.x);
                            var min_y = Math.max(rect_y, ParentRect.y);
                            var max_x = Math.min(rect_x + rect_w, ParentRect.x + ParentRect.w);
                            var max_y = Math.min(rect_y + rect_h, ParentRect.y + ParentRect.h);
                            rect_x = min_x;
                            rect_y = min_y;
                            rect_w = max_x - min_x;
                            rect_h = max_y - min_y;
                        }
                    }
                    else if (ParentRect != null) {
                        rect_x = ParentRect.x;
                        rect_y = ParentRect.y;
                        rect_w = ParentRect.w;
                        rect_h = ParentRect.h;
                    }
                    if (this._maskRect == null)
                        this._maskRect = new gd3d.math.rect();
                    if (this._maskRect.x != rect_x || this._maskRect.x != rect_y || this._maskRect.x != rect_w || this._maskRect.x != rect_h) {
                        this._maskRect.x = rect_x;
                        this._maskRect.y = rect_y;
                        this._maskRect.w = rect_w;
                        this._maskRect.h = rect_h;
                    }
                }
            };
            Object.defineProperty(transform2D.prototype, "parentIsMask", {
                get: function () {
                    return this._parentIsMask;
                },
                enumerable: true,
                configurable: true
            });
            transform2D.prototype.addChild = function (node) {
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.push(node);
                node.parent = this;
                node.canvas = this.canvas;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                this.markDirty();
            };
            transform2D.prototype.addChildAt = function (node, index) {
                if (index < 0)
                    return;
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.splice(index, 0, node);
                node.canvas = this.canvas;
                node.parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                this.markDirty();
            };
            transform2D.prototype.removeChild = function (node) {
                if (node.parent != this || this.children == null) {
                    throw new Error("not my child.");
                }
                var i = this.children.indexOf(node);
                if (i >= 0) {
                    this.children.splice(i, 1);
                    node.parent = null;
                    framework.sceneMgr.app.markNotify(node, framework.NotifyType.RemoveChild);
                }
            };
            transform2D.prototype.removeAllChild = function () {
                while (this.children.length > 0) {
                    this.removeChild(this.children[0]);
                }
            };
            transform2D.prototype.markDirty = function () {
                this.dirty = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p = p.parent;
                }
            };
            transform2D.prototype.updateTran = function (parentChange) {
                if (this.dirtyChild == false && this.dirty == false && parentChange == false)
                    return;
                if (this.dirty) {
                    gd3d.math.matrix3x2MakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                if (this.dirty || parentChange) {
                    this.refreshLayout();
                    if (this.parent == null) {
                        gd3d.math.matrix3x2Clone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        gd3d.math.matrix3x2Multiply(this.parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    this.updateMaskRect();
                    if (this.renderer != null) {
                        this.renderer.updateTran();
                    }
                    this.dirtyWorldDecompose = true;
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].updateTran(parentChange || this.dirty);
                    }
                }
                this.dirty = false;
                this.dirtyChild = false;
            };
            transform2D.prototype.updateWorldTran = function () {
                var p = this.parent;
                var dirtylist = [];
                dirtylist.push(this);
                while (p != null) {
                    if (p.dirty)
                        dirtylist.push(p);
                    p = p.parent;
                }
                var top = dirtylist.pop();
                top.updateTran(false);
            };
            transform2D.prototype.CalcReCanvasMtx = function (out) {
                if (!out)
                    return;
                var tsca = gd3d.math.pool.new_vector2();
                var ttran = gd3d.math.pool.new_vector2();
                tsca.x = this.canvas.pixelWidth / 2;
                tsca.y = -this.canvas.pixelHeight / 2;
                ttran.x = this.canvas.pixelWidth / 2;
                ttran.y = this.canvas.pixelHeight / 2;
                gd3d.math.matrix3x2MakeTransformRTS(ttran, tsca, 0, out);
            };
            transform2D.prototype.decomposeWorldMatrix = function () {
                if (this.dirtyWorldDecompose) {
                    var reCanvasMtx = gd3d.math.pool.new_matrix3x2();
                    this.CalcReCanvasMtx(reCanvasMtx);
                    var outMatrix = gd3d.math.pool.new_matrix3x2();
                    gd3d.math.matrix3x2Multiply(reCanvasMtx, this.worldMatrix, outMatrix);
                    gd3d.math.matrix3x2Decompose(outMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    gd3d.math.pool.delete_matrix3x2(reCanvasMtx);
                    gd3d.math.pool.delete_matrix3x2(outMatrix);
                    this.dirtyWorldDecompose = false;
                }
            };
            transform2D.prototype.getWorldTranslate = function () {
                this.decomposeWorldMatrix();
                return this.worldTranslate;
            };
            transform2D.prototype.getWorldScale = function () {
                this.decomposeWorldMatrix();
                return this.worldScale;
            };
            transform2D.prototype.getWorldRotate = function () {
                this.decomposeWorldMatrix();
                return this.worldRotate;
            };
            transform2D.prototype.getLocalMatrix = function () {
                return this.localMatrix;
            };
            transform2D.prototype.getWorldMatrix = function () {
                return this.worldMatrix;
            };
            transform2D.getTransInfoInCanvas = function (trans, out) {
                var mat = trans.getWorldMatrix();
                var rotmat = trans.canvas.getRoot().getWorldMatrix();
                var inversemat = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Inverse(rotmat, inversemat);
                var mattoRoot = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Multiply(inversemat, mat, mattoRoot);
                var rotscale = gd3d.math.pool.new_vector2();
                var rotRot = new gd3d.math.angelref();
                var rotPos = gd3d.math.pool.new_vector2();
                gd3d.math.matrix3x2Decompose(mattoRoot, rotscale, rotRot, rotPos);
                gd3d.math.vec2Clone(trans.pivot, out.pivot);
                gd3d.math.vec2Clone(rotPos, out.pivotPos);
                out.rot = rotRot.v;
                out.width = trans.width * rotscale.x;
                out.height = trans.height * rotscale.y;
                gd3d.math.pool.delete_matrix3x2(inversemat);
                gd3d.math.pool.delete_matrix3x2(mattoRoot);
                gd3d.math.pool.delete_vector2(rotscale);
                gd3d.math.pool.delete_vector2(rotPos);
            };
            transform2D.prototype.setWorldPosition = function (pos) {
                this.dirty = true;
                this.updateWorldTran();
                var thispos = this.getWorldTranslate();
                var dir = gd3d.math.pool.new_vector2();
                dir.x = pos.x - thispos.x;
                dir.y = pos.y - thispos.y;
                var pworld = gd3d.math.pool.new_matrix3x2();
                if (this.parent != null) {
                    gd3d.math.matrix3x2Clone(this.parent.worldMatrix, pworld);
                }
                else {
                    gd3d.math.matrix3x2MakeIdentity(pworld);
                }
                var matinv = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Inverse(pworld, matinv);
                var dirinv = gd3d.math.pool.new_vector2();
                gd3d.math.matrix3x2TransformNormal(matinv, dir, dirinv);
                this.localTranslate.x += dirinv.x;
                this.localTranslate.y += dirinv.y;
                gd3d.math.pool.delete_matrix3x2(matinv);
                gd3d.math.pool.delete_vector2(dir);
                gd3d.math.pool.delete_vector2(dirinv);
            };
            transform2D.prototype.dispose = function () {
                if (this.children) {
                    for (var k in this.children) {
                        this.children[k].dispose();
                    }
                    this.removeAllChild();
                }
                this.removeAllComponents();
            };
            transform2D.prototype.update = function (delta) {
                if (this.components != null) {
                    for (var i = 0; i < this.components.length; i++) {
                        if (this.components[i].init == false) {
                            this.components[i].comp.start();
                            this.components[i].init = true;
                        }
                        if (framework.sceneMgr.app.bePlay && !framework.sceneMgr.app.bePause)
                            this.components[i].comp.update(delta);
                    }
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].update(delta);
                    }
                }
            };
            transform2D.prototype.addComponent = function (type) {
                if (this.components == null)
                    this.components = [];
                for (var key in this.components) {
                    var st = this.components[key]["comp"]["constructor"]["name"];
                    if (st == type) {
                        throw new Error("已经有一个" + type + "的组件了，不能俩");
                    }
                }
                var pp = gd3d.reflect.getPrototype(type);
                var comp = gd3d.reflect.createInstance(pp, { "2dcomp": "1" });
                return this.addComponentDirect(comp);
            };
            transform2D.prototype.addComponentDirect = function (comp) {
                if (comp.transform != null) {
                    throw new Error("this components has added to a  gameObject");
                }
                comp.transform = this;
                if (this.components == null)
                    this.components = [];
                var _comp = new C2DComponent(comp, false);
                this.components.push(_comp);
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1") {
                    if (this.renderer == null) {
                        this.renderer = comp;
                    }
                    else {
                        throw new Error("已经有一个渲染器的组件了，不能俩");
                    }
                }
                return comp;
            };
            transform2D.prototype.removeComponent = function (comp) {
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        if (this.components[i].init) {
                        }
                        this.components.splice(i, 1);
                    }
                }
            };
            transform2D.prototype.removeComponentByTypeName = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    if (gd3d.reflect.getClassName(this.components[i].comp) == type) {
                        var p = this.components.splice(i, 1);
                        if (p[0].comp == this.renderer)
                            this.renderer = null;
                        return p[0];
                    }
                }
            };
            transform2D.prototype.removeAllComponents = function () {
                for (var i = 0; i < this.components.length; i++) {
                    this.components[i].comp.remove();
                    if (this.components[i].comp == this.renderer)
                        this.renderer = null;
                }
                this.components.length = 0;
            };
            transform2D.prototype.getComponent = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return this.components[i].comp;
                    }
                }
                return null;
            };
            transform2D.prototype.getComponents = function () {
                var components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            };
            transform2D.prototype.getComponentsInChildren = function (type) {
                var components = [];
                this.getNodeCompoents(this, type, components);
                return components;
            };
            transform2D.prototype.getNodeCompoents = function (node, _type, comps) {
                for (var i in node.components) {
                    var cname = gd3d.reflect.getClassName(node.components[i].comp["__proto__"]);
                    if (cname == _type) {
                        comps.push(this.components[i].comp);
                    }
                }
                if (node.children != null) {
                    for (var i in node.children) {
                        this.getNodeCompoents(node.children[i], _type, comps);
                    }
                }
            };
            transform2D.prototype.onCapturePointEvent = function (canvas, ev) {
                if (this.components != null) {
                    for (var i = 0; i <= this.components.length; i++) {
                        if (ev.eated == false) {
                            var comp = this.components[i];
                            if (comp != null)
                                if (comp.init) {
                                    comp.comp.onPointEvent(canvas, ev, true);
                                }
                        }
                    }
                }
                if (ev.eated == false) {
                    if (this.children != null) {
                        for (var i = 0; i <= this.children.length; i++) {
                            var c = this.children[i];
                            if (c != null && c.visible)
                                c.onCapturePointEvent(canvas, ev);
                        }
                    }
                }
            };
            transform2D.prototype.ContainsCanvasPoint = function (pworld, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                var mworld = this.getWorldMatrix();
                var mout = new gd3d.math.matrix3x2();
                gd3d.math.matrix3x2Inverse(mworld, mout);
                var p2 = new gd3d.math.vector2();
                gd3d.math.matrix3x2TransformVector2(mout, pworld, p2);
                p2.x += this.pivot.x * this.width;
                p2.y += this.pivot.y * this.height;
                return p2.x + tolerance >= 0 && p2.y + tolerance >= 0 && p2.x < this.width + tolerance && p2.y < this.height + tolerance;
            };
            transform2D.prototype.onPointEvent = function (canvas, ev) {
                if (this.children != null) {
                    for (var i = this.children.length - 1; i >= 0; i--) {
                        if (ev.eated == false) {
                            var c = this.children[i];
                            if (c != null && c.visible)
                                c.onPointEvent(canvas, ev);
                        }
                    }
                }
                if (ev.eated == false && this.components != null) {
                    for (var i = this.components.length - 1; i >= 0; i--) {
                        var comp = this.components[i];
                        if (comp != null)
                            if (comp.init) {
                                comp.comp.onPointEvent(canvas, ev, false);
                            }
                    }
                }
            };
            Object.defineProperty(transform2D.prototype, "layoutState", {
                get: function () {
                    return this._layoutState;
                },
                set: function (state) {
                    if (isNaN(state) || state == undefined)
                        return;
                    if (state != this._layoutState) {
                        this.layoutDirty = true;
                        this.markDirty();
                        this._layoutState = state;
                    }
                },
                enumerable: true,
                configurable: true
            });
            transform2D.prototype.setLayoutValue = function (option, value) {
                if (isNaN(option) || isNaN(value) || option == undefined || value == undefined)
                    return;
                if (this.layoutValueMap[option] == undefined || value != this.layoutValueMap[option]) {
                    this.layoutDirty = true;
                    this.markDirty();
                    this.layoutValueMap[option] = value;
                }
            };
            transform2D.prototype.getLayoutValue = function (option) {
                return this.layoutValueMap[option];
            };
            Object.defineProperty(transform2D.prototype, "layoutPercentState", {
                get: function () {
                    return this._layoutPercentState;
                },
                set: function (state) {
                    if (isNaN(state) || state == undefined)
                        return;
                    if (state != this._layoutPercentState) {
                        this.layoutDirty = true;
                        this.markDirty();
                        this._layoutPercentState = state;
                    }
                },
                enumerable: true,
                configurable: true
            });
            transform2D.prototype.refreshLayout = function () {
                var parent = this.parent;
                if (!parent)
                    return;
                if (parent.width != this.lastParentWidth || parent.height != this.lastParentHeight || parent.pivot.x != this.lastParentPivot.x
                    || parent.pivot.y != this.lastParentPivot.y || this.pivot.x != this.lastPivot.x || this.pivot.y != this.lastPivot.y)
                    this.layoutDirty = true;
                if (!this.layoutDirty)
                    return;
                var state = this._layoutState;
                if (state != 0) {
                    if (state & layoutOption.LEFT) {
                        if (state & layoutOption.RIGHT) {
                            this.width = parent.width - this.getLayValue(layoutOption.LEFT) - this.getLayValue(layoutOption.RIGHT);
                        }
                        this.localTranslate.x = this.getLayValue(layoutOption.LEFT) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    else if (state & layoutOption.RIGHT) {
                        this.localTranslate.x = parent.width - this.width - this.getLayValue(layoutOption.RIGHT) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    if (state & layoutOption.H_CENTER) {
                        this.localTranslate.x = (parent.width - this.width) / 2 + this.getLayValue(layoutOption.H_CENTER) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    if (state & layoutOption.TOP) {
                        if (state & layoutOption.BOTTOM) {
                            this.height = parent.height - this.getLayValue(layoutOption.TOP) - this.getLayValue(layoutOption.BOTTOM);
                        }
                        this.localTranslate.y = this.getLayValue(layoutOption.TOP) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    else if (state & layoutOption.BOTTOM) {
                        this.localTranslate.y = parent.height - this.height - this.getLayValue(layoutOption.BOTTOM) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    if (state & layoutOption.V_CENTER) {
                        this.localTranslate.y = (parent.height - this.height) / 2 + this.getLayValue(layoutOption.V_CENTER) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    gd3d.math.matrix3x2MakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                this.layoutDirty = false;
                this.lastParentWidth = parent.width;
                this.lastParentHeight = parent.height;
                this.lastParentPivot.x = parent.pivot.x;
                this.lastParentPivot.y = parent.pivot.y;
                this.lastPivot.x = this.pivot.x;
                this.lastPivot.y = this.pivot.y;
            };
            transform2D.prototype.getLayValue = function (opation) {
                if (this.layoutValueMap[opation] == undefined)
                    this.layoutValueMap[opation] = 0;
                var value = 0;
                if (this._layoutPercentState & opation) {
                    if (this.parent) {
                        switch (opation) {
                            case layoutOption.LEFT:
                            case layoutOption.H_CENTER:
                            case layoutOption.RIGHT:
                                value = this.parent.width * this.layoutValueMap[opation] / 100;
                                break;
                            case layoutOption.TOP:
                            case layoutOption.V_CENTER:
                            case layoutOption.BOTTOM:
                                value = this.parent.height * this.layoutValueMap[opation] / 100;
                                break;
                        }
                    }
                }
                else {
                    value = this.layoutValueMap[opation];
                }
                return value;
            };
            transform2D.prototype.clone = function () {
                return gd3d.io.cloneObj(this);
            };
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform2D.prototype, "name", void 0);
            __decorate([
                gd3d.reflect.Field("transform2D[]"),
                __metadata("design:type", Array)
            ], transform2D.prototype, "children", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "width", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "height", void 0);
            __decorate([
                gd3d.reflect.Field("vector2"),
                __metadata("design:type", gd3d.math.vector2)
            ], transform2D.prototype, "pivot", void 0);
            __decorate([
                gd3d.reflect.Field("vector2"),
                __metadata("design:type", gd3d.math.vector2)
            ], transform2D.prototype, "localTranslate", void 0);
            __decorate([
                gd3d.reflect.Field("vector2"),
                __metadata("design:type", gd3d.math.vector2)
            ], transform2D.prototype, "localScale", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "localRotate", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Boolean])
            ], transform2D.prototype, "isMask", null);
            __decorate([
                gd3d.reflect.Field("C2DComponent[]"),
                __metadata("design:type", Array)
            ], transform2D.prototype, "components", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], transform2D.prototype, "layoutState", null);
            __decorate([
                gd3d.reflect.Field("numberdic"),
                __metadata("design:type", Object)
            ], transform2D.prototype, "layoutValueMap", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], transform2D.prototype, "layoutPercentState", null);
            transform2D = __decorate([
                gd3d.reflect.SerializeType
            ], transform2D);
            return transform2D;
        }());
        framework.transform2D = transform2D;
        var t2dInfo = (function () {
            function t2dInfo() {
                this.pivot = new gd3d.math.vector2();
                this.pivotPos = new gd3d.math.vector2();
            }
            t2dInfo.getCenter = function (info, outCenter) {
                outCenter.x = info.pivotPos.x + info.width * (0.5 - info.pivot.x) * Math.cos(info.rot) - info.height * (0.5 - info.pivot.y) * Math.sin(info.rot);
                outCenter.y = info.pivotPos.y - info.width * (0.5 - info.pivot.x) * Math.sin(info.rot) + info.height * (0.5 - info.pivot.y) * Math.cos(info.rot);
            };
            return t2dInfo;
        }());
        framework.t2dInfo = t2dInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var behaviour2d = (function () {
            function behaviour2d() {
            }
            behaviour2d.prototype.start = function () {
            };
            behaviour2d.prototype.update = function (delta) {
            };
            behaviour2d.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            behaviour2d.prototype.remove = function () {
            };
            behaviour2d = __decorate([
                gd3d.reflect.node2DComponent
            ], behaviour2d);
            return behaviour2d;
        }());
        framework.behaviour2d = behaviour2d;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var TransitionType;
        (function (TransitionType) {
            TransitionType[TransitionType["None"] = 0] = "None";
            TransitionType[TransitionType["ColorTint"] = 1] = "ColorTint";
            TransitionType[TransitionType["SpriteSwap"] = 2] = "SpriteSwap";
        })(TransitionType = framework.TransitionType || (framework.TransitionType = {}));
        var button = (function () {
            function button() {
                this._transition = TransitionType.ColorTint;
                this._origianlSpriteName = "";
                this._pressedSpriteName = "";
                this._normalColor = new gd3d.math.color(1, 1, 1, 1);
                this._pressedColor = new gd3d.math.color(0.5, 0.5, 0.5, 1);
                this._fadeDuration = 0.1;
                this.onClick = new framework.UIEvent();
                this._downInThis = false;
                this._dragOut = false;
            }
            Object.defineProperty(button.prototype, "transition", {
                get: function () {
                    return this._transition;
                },
                set: function (transition) {
                    this._transition = transition;
                    if (this._targetImage != null) {
                        if (transition == TransitionType.ColorTint) {
                            this._targetImage.color = this.normalColor;
                        }
                        else {
                            this._targetImage.color = this._originalColor;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "targetImage", {
                get: function () {
                    return this._targetImage;
                },
                set: function (graphic) {
                    if (this._targetImage != null) {
                        this._targetImage.color = this._originalColor;
                    }
                    if (graphic != null) {
                        this._originalColor = graphic.color;
                        this._originalSprite = graphic.sprite;
                        if (graphic.sprite)
                            this._origianlSpriteName = graphic.sprite.getName();
                        if (this._transition == TransitionType.ColorTint) {
                            graphic.color = this.normalColor;
                        }
                    }
                    else {
                        this._originalColor = null;
                        this._originalSprite = null;
                    }
                    this._targetImage = graphic;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "pressedGraphic", {
                get: function () {
                    return this._pressedSprite;
                },
                set: function (sprite) {
                    this._pressedSprite = sprite;
                    if (sprite != null) {
                        this._pressedSpriteName = sprite.getName();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "normalColor", {
                get: function () {
                    return this._normalColor;
                },
                set: function (color) {
                    this._normalColor = color;
                    if (this._targetImage != null && this.transition == TransitionType.ColorTint) {
                        this._targetImage.color = color;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "pressedColor", {
                get: function () {
                    return this._pressedColor;
                },
                set: function (color) {
                    this._pressedColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(button.prototype, "fadeDuration", {
                get: function () {
                    return this._fadeDuration;
                },
                set: function (duration) {
                    this._fadeDuration = duration;
                },
                enumerable: true,
                configurable: true
            });
            button.prototype.render = function (canvas) {
            };
            button.prototype.updateTran = function () {
            };
            button.prototype.start = function () {
            };
            button.prototype.update = function (delta) {
            };
            button.prototype.remove = function () {
                this._targetImage = null;
                this.transform = null;
                this._normalColor = null;
                this._originalColor = null;
                this._pressedColor = null;
                if (this.pressedGraphic)
                    this.pressedGraphic.unuse(true);
            };
            button.prototype.onPointEvent = function (canvas, ev, oncap) {
                if (oncap == false) {
                    var b = this.transform.ContainsCanvasPoint(new gd3d.math.vector2(ev.x, ev.y));
                    if (b) {
                        ev.eated = true;
                        if (ev.type == framework.PointEventEnum.PointDown) {
                            this._downInThis = true;
                            this.showPress();
                        }
                        else if (ev.type == framework.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == true) {
                                this._dragOut = false;
                                this.showPress();
                            }
                        }
                        else if (ev.type == framework.PointEventEnum.PointUp && this._downInThis) {
                            this._downInThis = false;
                            this.showNormal();
                            this.onClick.excute();
                        }
                    }
                    else {
                        if (ev.type == framework.PointEventEnum.PointUp) {
                            this._downInThis = false;
                        }
                        else if (ev.type == framework.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == false) {
                                this._dragOut = true;
                                this.showNormal();
                            }
                        }
                    }
                }
            };
            button.prototype.showNormal = function () {
                if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._normalColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    if (!this._originalSprite) {
                        this._originalSprite = this.tryGetSprite(this._origianlSpriteName);
                    }
                    this.changeSprite(this._originalSprite);
                }
            };
            button.prototype.showPress = function () {
                if (this.transition == TransitionType.None) {
                    return;
                }
                else if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._pressedColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    if (this._targetImage != null && this._targetImage.sprite != null && this._originalSprite == null) {
                        this._originalSprite = this._targetImage.sprite;
                    }
                    if (!this._pressedSprite) {
                        this._pressedSprite = this.tryGetSprite(this._pressedSpriteName);
                    }
                    this.changeSprite(this._pressedSprite);
                }
            };
            button.prototype.tryGetSprite = function (spriteName) {
                var temp = this.transform.canvas.assetmgr.mapNamed[spriteName];
                if (temp != null) {
                    var tsprite = this.transform.canvas.assetmgr.getAssetByName(spriteName);
                    if (tsprite)
                        return tsprite;
                }
            };
            button.prototype.changeColor = function (targetColor) {
                if (this._targetImage != null) {
                    this._targetImage.color = targetColor;
                    this._targetImage.transform.markDirty();
                }
            };
            button.prototype.changeSprite = function (sprite) {
                if (sprite == null)
                    return;
                if (this._targetImage != null) {
                    this._targetImage.sprite = sprite;
                    this._targetImage.transform.markDirty();
                }
            };
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], button.prototype, "transition", null);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], button.prototype, "_origianlSpriteName", void 0);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], button.prototype, "_pressedSpriteName", void 0);
            __decorate([
                gd3d.reflect.Field("reference"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [framework.image2D])
            ], button.prototype, "targetImage", null);
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("color"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [gd3d.math.color])
            ], button.prototype, "normalColor", null);
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("color"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [gd3d.math.color])
            ], button.prototype, "pressedColor", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], button.prototype, "fadeDuration", null);
            button = __decorate([
                gd3d.reflect.node2DComponent
            ], button);
            return button;
        }());
        framework.button = button;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var image2D = (function () {
            function image2D() {
                this._unitLen = 13;
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.needRefreshImg = false;
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
                this._imageType = ImageType.Simple;
                this._fillMethod = FillMethod.Horizontal;
                this._fillAmmount = 1;
                this._spriteName = "";
                this._imageBorder = new gd3d.math.border();
                gd3d.io.enumMgr.enumMap["ImageType"] = ImageType;
                gd3d.io.enumMgr.enumMap["FillMethod"] = FillMethod;
            }
            Object.defineProperty(image2D.prototype, "uimat", {
                get: function () {
                    if (this._sprite && this._sprite.texture) {
                        var rectPostfix = this.transform.parentIsMask ? "_(" + this.transform.insId + ")" : "";
                        var matName = this._sprite.texture.getName() + "_uimask" + rectPostfix;
                        var canvas_1 = this.transform.canvas;
                        if (!canvas_1.assetmgr)
                            return;
                        var mat = this._uimat;
                        if (!mat || mat.getName() != matName) {
                            if (mat)
                                mat.unuse();
                            mat = canvas_1.assetmgr.getAssetByName(matName);
                            if (mat)
                                mat.use();
                        }
                        if (mat == null) {
                            mat = new framework.material(matName);
                            mat.setShader(canvas_1.assetmgr.getShader("shader/defmaskui"));
                            mat.use();
                        }
                        mat.setFloat("MaskState", this.transform.parentIsMask ? 1 : 0);
                        this._uimat = mat;
                    }
                    return this._uimat;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "imageType", {
                get: function () {
                    return this._imageType;
                },
                set: function (type) {
                    this._imageType = type;
                    this.prepareData();
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "fillMethod", {
                get: function () {
                    return this._fillMethod;
                },
                set: function (method) {
                    this._fillMethod = method;
                    this.prepareData();
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "fillAmmount", {
                get: function () {
                    return this._fillAmmount;
                },
                set: function (ammount) {
                    this._fillAmmount = ammount;
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "sprite", {
                get: function () {
                    return this._sprite;
                },
                set: function (sprite) {
                    if (sprite == this._sprite)
                        return;
                    this.needRefreshImg = true;
                    if (this._sprite) {
                        this._sprite.unuse();
                    }
                    this._sprite = sprite;
                    if (sprite) {
                        this._sprite.use();
                        this._spriteName = this._sprite.getName();
                        this.prepareData();
                        if (this.transform != null) {
                            this.transform.markDirty();
                            this.updateTran();
                        }
                    }
                    else {
                        this._spriteName = "";
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "imageBorder", {
                get: function () {
                    return this._imageBorder;
                },
                enumerable: true,
                configurable: true
            });
            image2D.prototype.render = function (canvas) {
                if (this._sprite == null) {
                    var temp = canvas.assetmgr.mapNamed[this._spriteName];
                    var tspr = void 0;
                    if (temp != null) {
                        tspr = canvas.assetmgr.getAssetByName(this._spriteName);
                    }
                    else {
                        if (canvas.assetmgr.mapDefaultSprite[this._spriteName])
                            tspr = canvas.assetmgr.getDefaultSprite(this._spriteName);
                    }
                    if (tspr) {
                        this.sprite = tspr;
                        this.needRefreshImg = true;
                    }
                }
                var mat = this.uimat;
                if (!mat)
                    return;
                var img = null;
                if (this._sprite != null && this._sprite.texture != null) {
                    img = this._sprite.texture;
                }
                if (img != null) {
                    if (this.needRefreshImg) {
                        mat.setTexture("_MainTex", img);
                        this.needRefreshImg = false;
                    }
                    if (this.transform.parentIsMask) {
                        if (this._cacheMaskV4 == null)
                            this._cacheMaskV4 = new gd3d.math.vector4();
                        var rect = this.transform.maskRect;
                        if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h) {
                            this._cacheMaskV4.x = rect.x;
                            this._cacheMaskV4.y = rect.y;
                            this._cacheMaskV4.z = rect.w;
                            this._cacheMaskV4.w = rect.h;
                            mat.setVector4("_maskRect", this._cacheMaskV4);
                        }
                    }
                    canvas.pushRawData(mat, this.datar);
                }
            };
            image2D.prototype.start = function () {
            };
            image2D.prototype.update = function (delta) {
            };
            image2D.prototype.remove = function () {
                if (this._sprite)
                    this._sprite.unuse(true);
                if (this._uimat)
                    this._uimat.unuse(true);
                this.datar.length = 0;
                this.transform = null;
                this._imageBorder = null;
            };
            image2D.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            image2D.prototype.prepareData = function () {
                if (this._sprite == null)
                    return;
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        break;
                    case ImageType.Sliced:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                        ];
                        break;
                    case ImageType.Tiled:
                        this.datar = [];
                        break;
                    case ImageType.Filled:
                        var halfu = urange.x + 0.5 * ulen;
                        var halfv = vrange.x + 0.5 * vlen;
                        switch (this._fillMethod) {
                            case FillMethod.Horizontal:
                            case FillMethod.Vertical:
                            case FillMethod.Radial_90:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_180:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_360:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                ];
                                break;
                        }
                        break;
                }
            };
            image2D.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                if (this._sprite == null)
                    return;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.updateSimpleData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Sliced:
                        this.updateSlicedData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Tiled:
                        this.updateTiledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Filled:
                        this.updateFilledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                }
                var vertexCount = this.datar.length / this._unitLen;
                for (var i = 0; i < vertexCount; i++) {
                    this.datar[i * this._unitLen + 3] = this.color.r;
                    this.datar[i * this._unitLen + 4] = this.color.g;
                    this.datar[i * this._unitLen + 5] = this.color.b;
                    this.datar[i * this._unitLen + 6] = this.color.a;
                }
            };
            image2D.prototype.updateQuadData = function (x0, y0, x1, y1, x2, y2, x3, y3, quadIndex, mirror) {
                if (quadIndex === void 0) { quadIndex = 0; }
                if (mirror === void 0) { mirror = false; }
                var _index = quadIndex * 6;
                if (!mirror) {
                    this.datar[(_index + 0) * this._unitLen] = x0;
                    this.datar[(_index + 0) * this._unitLen + 1] = y0;
                    this.datar[(_index + 1) * this._unitLen] = x1;
                    this.datar[(_index + 1) * this._unitLen + 1] = y1;
                    this.datar[(_index + 2) * this._unitLen] = x2;
                    this.datar[(_index + 2) * this._unitLen + 1] = y2;
                    this.datar[(_index + 3) * this._unitLen] = x2;
                    this.datar[(_index + 3) * this._unitLen + 1] = y2;
                    this.datar[(_index + 4) * this._unitLen] = x1;
                    this.datar[(_index + 4) * this._unitLen + 1] = y1;
                    this.datar[(_index + 5) * this._unitLen] = x3;
                    this.datar[(_index + 5) * this._unitLen + 1] = y3;
                }
                else {
                    this.datar[(_index + 0) * this._unitLen] = x0;
                    this.datar[(_index + 0) * this._unitLen + 1] = y0;
                    this.datar[(_index + 1) * this._unitLen] = x1;
                    this.datar[(_index + 1) * this._unitLen + 1] = y1;
                    this.datar[(_index + 2) * this._unitLen] = x3;
                    this.datar[(_index + 2) * this._unitLen + 1] = y3;
                    this.datar[(_index + 3) * this._unitLen] = x0;
                    this.datar[(_index + 3) * this._unitLen + 1] = y0;
                    this.datar[(_index + 4) * this._unitLen] = x3;
                    this.datar[(_index + 4) * this._unitLen + 1] = y3;
                    this.datar[(_index + 5) * this._unitLen] = x2;
                    this.datar[(_index + 5) * this._unitLen + 1] = y2;
                }
            };
            image2D.prototype.updateSimpleData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
            };
            image2D.prototype.updateSlicedData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var border = this._imageBorder;
                var rect = this._sprite.rect;
                var r1c1 = gd3d.math.pool.new_vector2();
                var r1c4 = gd3d.math.pool.new_vector2();
                var r4c1 = gd3d.math.pool.new_vector2();
                var r4c4 = gd3d.math.pool.new_vector2();
                var r1c2 = gd3d.math.pool.new_vector2();
                var r1c3 = gd3d.math.pool.new_vector2();
                var r2c1 = gd3d.math.pool.new_vector2();
                var r3c1 = gd3d.math.pool.new_vector2();
                var r2c2 = gd3d.math.pool.new_vector2();
                var r2c3 = gd3d.math.pool.new_vector2();
                var r2c4 = gd3d.math.pool.new_vector2();
                var r3c2 = gd3d.math.pool.new_vector2();
                var r3c3 = gd3d.math.pool.new_vector2();
                var r3c4 = gd3d.math.pool.new_vector2();
                var r4c2 = gd3d.math.pool.new_vector2();
                var r4c3 = gd3d.math.pool.new_vector2();
                var r1c1_uv = gd3d.math.pool.new_vector2();
                var r1c4_uv = gd3d.math.pool.new_vector2();
                var r4c1_uv = gd3d.math.pool.new_vector2();
                var r4c4_uv = gd3d.math.pool.new_vector2();
                var r1c2_uv = gd3d.math.pool.new_vector2();
                var r1c3_uv = gd3d.math.pool.new_vector2();
                var r2c1_uv = gd3d.math.pool.new_vector2();
                var r3c1_uv = gd3d.math.pool.new_vector2();
                var r2c2_uv = gd3d.math.pool.new_vector2();
                var r2c3_uv = gd3d.math.pool.new_vector2();
                var r2c4_uv = gd3d.math.pool.new_vector2();
                var r3c2_uv = gd3d.math.pool.new_vector2();
                var r3c3_uv = gd3d.math.pool.new_vector2();
                var r3c4_uv = gd3d.math.pool.new_vector2();
                var r4c2_uv = gd3d.math.pool.new_vector2();
                var r4c3_uv = gd3d.math.pool.new_vector2();
                var help1 = gd3d.math.pool.new_vector2();
                var help2 = gd3d.math.pool.new_vector2();
                var help3 = gd3d.math.pool.new_vector2();
                r1c1.x = x0;
                r1c1.y = y0;
                r1c4.x = x1;
                r1c4.y = y1;
                r4c1.x = x2;
                r4c1.y = y2;
                r4c4.x = x3;
                r4c4.y = y3;
                var width = gd3d.math.vec2Distance(r1c1, r1c4);
                var height = gd3d.math.vec2Distance(r1c1, r4c1);
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var l_vertex = (border.l) / this.transform.width;
                var r_vertex = (border.r) / this.transform.width;
                var t_vertex = (border.t) / this.transform.height;
                var b_vertex = (border.b) / this.transform.height;
                var l = (border.l) / rect.w * (urange.y - urange.x);
                var r = (border.r) / rect.w * (urange.y - urange.x);
                var t = (border.t) / rect.h * (vrange.y - vrange.x);
                var b = (border.b) / rect.h * (vrange.y - vrange.x);
                gd3d.math.vec2Subtract(r1c4, r1c1, r1c2);
                gd3d.math.vec2ScaleByNum(r1c2, l_vertex, r1c2);
                gd3d.math.vec2Add(r1c2, r1c1, r1c2);
                gd3d.math.vec2Subtract(r1c1, r1c4, r1c3);
                gd3d.math.vec2ScaleByNum(r1c3, r_vertex, r1c3);
                gd3d.math.vec2Add(r1c3, r1c4, r1c3);
                gd3d.math.vec2Subtract(r4c1, r1c1, r2c1);
                gd3d.math.vec2ScaleByNum(r2c1, t_vertex, r2c1);
                gd3d.math.vec2Add(r2c1, r1c1, r2c1);
                gd3d.math.vec2Subtract(r1c1, r4c1, r3c1);
                gd3d.math.vec2ScaleByNum(r3c1, b_vertex, r3c1);
                gd3d.math.vec2Add(r3c1, r4c1, r3c1);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c3);
                gd3d.math.vec2Subtract(r1c4, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c4);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c3);
                gd3d.math.vec2Subtract(r1c4, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c4);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r4c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r4c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r4c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r4c3);
                r1c1_uv.x = urange.x;
                r1c1_uv.y = vrange.x;
                r1c2_uv.x = l + urange.x;
                r1c2_uv.y = vrange.x;
                r1c3_uv.x = urange.y - r;
                r1c3_uv.y = vrange.x;
                r1c4_uv.x = urange.y;
                r1c4_uv.y = vrange.x;
                r2c1_uv.x = urange.x;
                r2c1_uv.y = t + vrange.x;
                r2c2_uv.x = l + urange.x;
                r2c2_uv.y = t + vrange.x;
                r2c3_uv.x = urange.y - r;
                r2c3_uv.y = t + vrange.x;
                r2c4_uv.x = urange.y;
                r2c4_uv.y = t + vrange.x;
                r3c1_uv.x = urange.x;
                r3c1_uv.y = vrange.y - b;
                r3c2_uv.x = l + urange.x;
                r3c2_uv.y = vrange.y - b;
                r3c3_uv.x = urange.y - r;
                r3c3_uv.y = vrange.y - b;
                r3c4_uv.x = urange.y;
                r3c4_uv.y = vrange.y - b;
                r4c1_uv.x = urange.x;
                r4c1_uv.y = vrange.y;
                r4c2_uv.x = l + urange.x;
                r4c2_uv.y = vrange.y;
                r4c3_uv.x = urange.y - r;
                r4c3_uv.y = vrange.y;
                r4c4_uv.x = urange.y;
                r4c4_uv.y = vrange.y;
                var vertexs = [r1c1, r1c2, r1c3, r1c4, r2c1, r2c2, r2c3, r2c4, r3c1, r3c2, r3c3, r3c4, r4c1, r4c2, r4c3, r4c4];
                var uvs = [r1c1_uv, r1c2_uv, r1c3_uv, r1c4_uv, r2c1_uv, r2c2_uv, r2c3_uv, r2c4_uv, r3c1_uv, r3c2_uv, r3c3_uv, r3c4_uv, r4c1_uv, r4c2_uv, r4c3_uv, r4c4_uv];
                var partVertexs;
                var partUVs;
                for (var i = 0; i < 9; i++) {
                    var r_1 = Math.floor(i / 3);
                    var c = i % 3;
                    partVertexs = [vertexs[0 + c + r_1 * 4], vertexs[1 + c + r_1 * 4], vertexs[4 + c + r_1 * 4], vertexs[5 + c + r_1 * 4]];
                    partUVs = [uvs[0 + c + r_1 * 4], uvs[1 + c + r_1 * 4], uvs[4 + c + r_1 * 4], uvs[5 + c + r_1 * 4]];
                    this.updateQuadData(partVertexs[0].x, partVertexs[0].y, partVertexs[1].x, partVertexs[1].y, partVertexs[2].x, partVertexs[2].y, partVertexs[3].x, partVertexs[3].y, i);
                    this.datar[(0 + i * 6) * this._unitLen + 7] = partUVs[0].x;
                    this.datar[(0 + i * 6) * this._unitLen + 8] = partUVs[0].y;
                    this.datar[(1 + i * 6) * this._unitLen + 7] = partUVs[1].x;
                    this.datar[(1 + i * 6) * this._unitLen + 8] = partUVs[1].y;
                    this.datar[(2 + i * 6) * this._unitLen + 7] = partUVs[2].x;
                    this.datar[(2 + i * 6) * this._unitLen + 8] = partUVs[2].y;
                    this.datar[(3 + i * 6) * this._unitLen + 7] = partUVs[2].x;
                    this.datar[(3 + i * 6) * this._unitLen + 8] = partUVs[2].y;
                    this.datar[(4 + i * 6) * this._unitLen + 7] = partUVs[1].x;
                    this.datar[(4 + i * 6) * this._unitLen + 8] = partUVs[1].y;
                    this.datar[(5 + i * 6) * this._unitLen + 7] = partUVs[3].x;
                    this.datar[(5 + i * 6) * this._unitLen + 8] = partUVs[3].y;
                    partVertexs.length = 0;
                    partUVs.length = 0;
                }
                gd3d.math.pool.delete_vector2Array(vertexs);
                gd3d.math.pool.delete_vector2Array(uvs);
                gd3d.math.pool.delete_vector2Array([help1, help2, help3]);
            };
            image2D.prototype.updateFilledData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                var halfu = urange.x + 0.5 * ulen;
                var halfv = vrange.x + 0.5 * vlen;
                switch (this._fillMethod) {
                    case FillMethod.Horizontal:
                    case FillMethod.Vertical:
                    case FillMethod.Radial_90:
                        if (this._fillMethod == FillMethod.Horizontal) {
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x0);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y0);
                            x3 = x3 - (1 - this.fillAmmount) * (x3 - x2);
                            y3 = y3 - (1 - this.fillAmmount) * (y3 - y2);
                            this.datar[1 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[4 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[5 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                        }
                        else if (this._fillMethod == FillMethod.Vertical) {
                            x0 = x0 - (1 - this.fillAmmount) * (x0 - x2);
                            y0 = y0 - (1 - this.fillAmmount) * (y0 - y2);
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x3);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y3);
                            this.datar[0 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[1 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[4 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                        }
                        else if (this._fillMethod == FillMethod.Radial_90) {
                            if (this.fillAmmount >= 0.5) {
                                var _fillRate = 2 * (1 - this.fillAmmount);
                                x0 = x0 - _fillRate * (x0 - x1);
                                y0 = y0 - _fillRate * (y0 - y1);
                                this.datar[0 * this._unitLen + 7] = urange.x + _fillRate * ulen;
                                this.datar[1 * this._unitLen + 8] = vrange.x;
                                this.datar[4 * this._unitLen + 8] = vrange.x;
                            }
                            else {
                                var _fillRate = 2 * (0.5 - this.fillAmmount);
                                x1 = x1 - _fillRate * (x1 - x3);
                                y1 = y1 - _fillRate * (y1 - y3);
                                x0 = x1;
                                y0 = y1;
                                this.datar[0 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                                this.datar[1 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                                this.datar[4 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                            }
                        }
                        this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case FillMethod.Radial_180:
                        var tx = (x0 + x1) / 2;
                        var ty = (y0 + y1) / 2;
                        var bx = (x2 + x3) / 2;
                        var by = (y2 + y3) / 2;
                        if (this.fillAmmount >= 0.75) {
                            var _fillRate = 4 * (1 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - x0);
                            y2 = y2 - _fillRate * (y2 - y0);
                            this.datar[5 * this._unitLen + 8] = vrange.y - _fillRate * vlen;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            var _fillRate = 4 * (0.75 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - tx);
                            y0 = y0 - _fillRate * (y0 - ty);
                            x2 = x0;
                            y2 = y0;
                            this.datar[0 * this._unitLen + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[3 * this._unitLen + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            var _fillRate = 4 * (0.5 - this.fillAmmount);
                            tx = tx - _fillRate * (tx - x1);
                            ty = ty - _fillRate * (ty - y1);
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[6 * this._unitLen + 7] = halfu + 0.5 * ulen * _fillRate;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else {
                            var _fillRate = 4 * (0.25 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - x3);
                            y1 = y1 - _fillRate * (y1 - y3);
                            tx = x1;
                            ty = y1;
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[7 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                            this.datar[10 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                        }
                        this.updateQuadData(x0, y0, tx, ty, x2, y2, bx, by, 0, true);
                        this.updateQuadData(tx, ty, x1, y1, bx, by, x3, y3, 1);
                        break;
                    case FillMethod.Radial_360:
                        var t_x = (x0 + x1) / 2;
                        var t_y = (y0 + y1) / 2;
                        var l_x = (x0 + x2) / 2;
                        var l_y = (y0 + y2) / 2;
                        var b_x = (x2 + x3) / 2;
                        var b_y = (y2 + y3) / 2;
                        var r_x = (x1 + x3) / 2;
                        var r_y = (y1 + y3) / 2;
                        var c_x = (l_x + r_x) / 2;
                        var c_y = (l_y + r_y) / 2;
                        var b_x1 = b_x;
                        var b_y1 = b_y;
                        if (this.fillAmmount >= 0.875) {
                            var _fillRate = 8 * (1 - this.fillAmmount);
                            b_x = b_x - _fillRate * (b_x - x2);
                            b_y = b_y - _fillRate * (b_y - y2);
                            this.datar[17 * this._unitLen + 7] = halfu - 0.5 * _fillRate * ulen;
                            this.datar[14 * this._unitLen + 8] = vrange.y;
                            this.datar[15 * this._unitLen + 8] = vrange.y;
                            this.datar[5 * this._unitLen + 8] = halfv;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.75) {
                            var _fillRate = 8 * (0.875 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - l_x);
                            y2 = y2 - _fillRate * (y2 - l_y);
                            b_x = x2;
                            b_y = y2;
                            this.datar[14 * this._unitLen + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[15 * this._unitLen + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[5 * this._unitLen + 8] = halfv;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.625) {
                            var _fillRate = 8 * (0.75 - this.fillAmmount);
                            l_x = l_x - _fillRate * (l_x - x0);
                            l_y = l_y - _fillRate * (l_y - y0);
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[5 * this._unitLen + 8] = halfv - 0.5 * _fillRate * vlen;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            var _fillRate = 8 * (0.625 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - t_x);
                            y0 = y0 - _fillRate * (y0 - t_y);
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[0 * this._unitLen + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[3 * this._unitLen + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.375) {
                            var _fillRate = 8 * (0.5 - this.fillAmmount);
                            t_x = t_x - _fillRate * (t_x - x1);
                            t_y = t_y - _fillRate * (t_y - y1);
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[6 * this._unitLen + 7] = halfu + 0.5 * _fillRate * ulen;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            var _fillRate = 8 * (0.375 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - r_x);
                            y1 = y1 - _fillRate * (y1 - r_y);
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[7 * this._unitLen + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[10 * this._unitLen + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.125) {
                            var _fillRate = 8 * (0.25 - this.fillAmmount);
                            r_x = r_x - _fillRate * (r_x - x3);
                            r_y = r_y - _fillRate * (r_y - y3);
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[19 * this._unitLen + 8] = halfv + 0.5 * _fillRate * vlen;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else {
                            var _fillRate = 8 * (0.125 - this.fillAmmount);
                            x3 = x3 - _fillRate * (x3 - b_x);
                            y3 = y3 - _fillRate * (y3 - b_y);
                            r_x = x3;
                            r_y = y3;
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[20 * this._unitLen + 7] = urange.y - 0.5 * _fillRate * ulen;
                            this.datar[22 * this._unitLen + 7] = urange.y - 0.5 * _fillRate * ulen;
                        }
                        this.updateQuadData(x0, y0, t_x, t_y, l_x, l_y, c_x, c_y, 0, true);
                        this.updateQuadData(t_x, t_y, x1, y1, c_x, c_y, r_x, r_y, 1);
                        this.updateQuadData(l_x, l_y, c_x, c_y, x2, y2, b_x, b_y, 2);
                        this.updateQuadData(c_x, c_y, r_x, r_y, b_x1, b_y1, x3, y3, 3, true);
                        break;
                }
            };
            image2D.prototype.updateTiledData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var rect = this._sprite.rect;
                var border = this._imageBorder;
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                var xlen = x1 - x0;
                var ylen = y2 - y0;
                var _ul = this.transform.width / rect.w;
                var _vl = this.transform.height / rect.h;
                var inv_ul = 1 / _ul;
                var inv_vl = 1 / _vl;
                var dindex = 0;
                for (var i = 0; i < _vl - 1; i++) {
                    for (var j = 0; j < _ul - 1; j++) {
                        var tdata = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        this.datar = this.datar.concat(tdata);
                        var tx0 = x0 + inv_ul * xlen * j;
                        var ty0 = y0 + inv_vl * ylen * i;
                        var tx1 = x0 + inv_ul * xlen * (j + 1);
                        var ty1 = y0 + inv_vl * ylen * i;
                        var tx2 = x0 + inv_ul * xlen * j;
                        var ty2 = y0 + inv_vl * ylen * (i + 1);
                        var tx3 = x0 + inv_ul * xlen * (j + 1);
                        var ty3 = y0 + inv_vl * ylen * (i + 1);
                        this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                        dindex++;
                    }
                }
                var intvl = Math.ceil(_vl) - 1;
                var tvl = _vl - Math.ceil(_vl) + 1;
                for (var j = 0; j < _ul - 1; j++) {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * j;
                    var ty0 = y0 + inv_vl * ylen * intvl;
                    var tx1 = x0 + inv_ul * xlen * (j + 1);
                    var ty1 = y0 + inv_vl * ylen * intvl;
                    var tx2 = x0 + inv_ul * xlen * j;
                    var ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                    var tx3 = x0 + inv_ul * xlen * (j + 1);
                    var ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
                var intul = Math.ceil(_ul) - 1;
                var tul = _ul - Math.ceil(_ul) + 1;
                for (var i = 0; i < _vl - 1; i++) {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.y, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * intul;
                    var ty0 = y0 + inv_vl * ylen * i;
                    var tx1 = x0 + inv_ul * xlen * (intul + tul);
                    var ty1 = y0 + inv_vl * ylen * i;
                    var tx2 = x0 + inv_ul * xlen * intul;
                    var ty2 = y0 + inv_vl * ylen * (i + 1);
                    var tx3 = x0 + inv_ul * xlen * (intul + tul);
                    var ty3 = y0 + inv_vl * ylen * (i + 1);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
                {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * intul;
                    var ty0 = y0 + inv_vl * ylen * intvl;
                    var tx1 = x0 + inv_ul * xlen * (intul + tul);
                    var ty1 = y0 + inv_vl * ylen * intvl;
                    var tx2 = x0 + inv_ul * xlen * intul;
                    var ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                    var tx3 = x0 + inv_ul * xlen * (intul + tul);
                    var ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
            };
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("color"),
                __metadata("design:type", gd3d.math.color)
            ], image2D.prototype, "color", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                gd3d.reflect.UIStyle("enum"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], image2D.prototype, "imageType", null);
            __decorate([
                gd3d.reflect.Field("number"),
                gd3d.reflect.UIStyle("enum"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], image2D.prototype, "fillMethod", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], image2D.prototype, "fillAmmount", null);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], image2D.prototype, "_spriteName", void 0);
            __decorate([
                gd3d.reflect.Field("border"),
                __metadata("design:type", Object)
            ], image2D.prototype, "_imageBorder", void 0);
            image2D = __decorate([
                gd3d.reflect.node2DComponent,
                gd3d.reflect.nodeRender,
                __metadata("design:paramtypes", [])
            ], image2D);
            return image2D;
        }());
        framework.image2D = image2D;
        var ImageType;
        (function (ImageType) {
            ImageType[ImageType["Simple"] = 0] = "Simple";
            ImageType[ImageType["Sliced"] = 1] = "Sliced";
            ImageType[ImageType["Tiled"] = 2] = "Tiled";
            ImageType[ImageType["Filled"] = 3] = "Filled";
        })(ImageType = framework.ImageType || (framework.ImageType = {}));
        var FillMethod;
        (function (FillMethod) {
            FillMethod[FillMethod["Horizontal"] = 0] = "Horizontal";
            FillMethod[FillMethod["Vertical"] = 1] = "Vertical";
            FillMethod[FillMethod["Radial_90"] = 2] = "Radial_90";
            FillMethod[FillMethod["Radial_180"] = 3] = "Radial_180";
            FillMethod[FillMethod["Radial_360"] = 4] = "Radial_360";
        })(FillMethod = framework.FillMethod || (framework.FillMethod = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var inputField = (function () {
            function inputField() {
                this.customRegexStr = "";
                this.beFocus = false;
                this._text = "";
                this._charlimit = 0;
                this._lineType = lineType.SingleLine;
                this._contentType = contentType.None;
            }
            Object.defineProperty(inputField.prototype, "frameImage", {
                get: function () {
                    return this._frameImage;
                },
                set: function (frameImg) {
                    this._frameImage = frameImg;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "text", {
                get: function () {
                    return this._text;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "characterLimit", {
                get: function () { return this._charlimit; },
                set: function (charlimit) {
                    this._charlimit = parseInt("" + charlimit);
                    this._charlimit = isNaN(this._charlimit) || this._charlimit < 0 ? 0 : this._charlimit;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "LineType", {
                get: function () { return this._lineType; },
                set: function (lineType) {
                    this._lineType = lineType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "ContentType", {
                get: function () { return this._contentType; },
                set: function (contentType) {
                    this._contentType = contentType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "TextLabel", {
                get: function () {
                    return this._textLable;
                },
                set: function (textLabel) {
                    textLabel.text = this._text;
                    this._textLable = textLabel;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "PlaceholderLabel", {
                get: function () {
                    return this._placeholderLabel;
                },
                set: function (placeholderLabel) {
                    if (placeholderLabel.text == null || placeholderLabel.text == "")
                        placeholderLabel.text = "Enter Text...";
                    this._placeholderLabel = placeholderLabel;
                },
                enumerable: true,
                configurable: true
            });
            inputField.prototype.updateData = function (_font) {
            };
            inputField.prototype.render = function (canvas) {
            };
            inputField.prototype.updateTran = function () {
                this.inputElmLayout();
                if (this._placeholderLabel) {
                    if (this._placeholderLabel.transform.width != this.transform.width)
                        this._placeholderLabel.transform.width = this.transform.width;
                    if (this._placeholderLabel.transform.height != this.transform.height)
                        this._placeholderLabel.transform.height = this.transform.height;
                }
                if (this._textLable) {
                    if (this._textLable.transform.width != this.transform.width)
                        this._textLable.transform.width = this.transform.width;
                    if (this._textLable.transform.height != this.transform.height)
                        this._textLable.transform.height = this.transform.height;
                }
            };
            inputField.prototype.start = function () {
                var _this = this;
                this.inputElement = document.createElement("Input");
                this.inputElement.style.opacity = "0";
                this.inputElement.style.visibility = "hidden";
                if (this.transform.canvas.scene) {
                    var htmlCanv = this.transform.canvas.scene.webgl.canvas;
                    if (htmlCanv)
                        htmlCanv.parentElement.appendChild(this.inputElement);
                }
                this.inputElement.onblur = function (e) {
                    _this.beFocus = false;
                };
                this.inputElement.onfocus = function (e) {
                    _this.beFocus = true;
                };
                this.inputElmLayout();
            };
            inputField.prototype.inputElmLayout = function () {
                if (this.inputElement == null)
                    return;
                var pos = this.transform.getWorldTranslate();
                this.transform.localTranslate;
                var cssStyle = this.inputElement.style;
                if (pos.x + "px" == cssStyle.left && pos.y + "px" == cssStyle.top && this.transform.width + "px" == cssStyle.width && this.transform.height + "px" == cssStyle.height)
                    return;
                var scale = this.transform.canvas.scene.app.canvasClientHeight / this.transform.canvas.pixelHeight;
                cssStyle.position = "absolute";
                cssStyle.left = pos.x * scale + "px";
                cssStyle.top = pos.y * scale + "px";
                cssStyle.width = this.transform.width * scale + "px";
                cssStyle.height = this.transform.height * scale + "px";
            };
            inputField.prototype.textRefresh = function () {
                if (!this.beFocus || !this._textLable || !this._placeholderLabel || !this.inputElement || this._text == this.inputElement.value)
                    return;
                if (this._charlimit > 0 && this.inputElement.value.length >= this._charlimit) {
                    if (this.inputElement.value != this._text)
                        if (this.inputElement.value.length > this._text.length) {
                            this.inputElement.value = this._text;
                        }
                        else {
                            this._text = this.inputElement.value;
                        }
                    return;
                }
                this._text = this.inputElement.value;
                if (this._contentType == contentType.Custom) {
                    if (this.customRegexStr != null && this.customRegexStr != "")
                        this._text = this._text.replace(this.customRegexStr, '');
                }
                else {
                    if (this._contentType == contentType.None) {
                    }
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word) && (this._contentType & contentType.ChineseCharacter) && (this._contentType & contentType.Underline)) {
                        this._text = this._text.replace(/^[\u4E00-\u9FA5a-zA-Z0-9_]{3,20}$/ig, '');
                    }
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word) && (this._contentType & contentType.Underline)) {
                        this._text = this._text.replace(/[^\w\.\/]/ig, '');
                    }
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word)) {
                        this._text = this._text.replace(/[^(A-Za-z0-9)]/ig, '');
                    }
                    else if ((this._contentType & contentType.ChineseCharacter) && (this._contentType & contentType.Word)) {
                        this._text = this._text.replace(/[^(A-Za-z\u4E00-\u9FA5)]/ig, '');
                    }
                    else if (this._contentType == contentType.Number) {
                        this._text = this._text.replace(/\D+/g, '');
                    }
                    else if (this._contentType == contentType.ChineseCharacter) {
                        this._text = this._text.replace(/[^\u4E00-\u9FA5]/g, '');
                    }
                }
                this.inputElement.value = this._text;
                if (this._textLable) {
                    this._textLable.text = this._text;
                    this.filterContentText();
                }
                if (this._text == "") {
                    this._placeholderLabel.transform.visible = true;
                    this._textLable.transform.visible = false;
                }
                else {
                    this._placeholderLabel.transform.visible = false;
                    this._textLable.transform.visible = true;
                }
            };
            inputField.prototype.filterContentText = function () {
                if (!this._textLable || this._text == null)
                    return;
                var lab = this._textLable;
                var rate = lab.fontsize / lab.font.lineHeight;
                var font = lab.font;
                var addw = 0;
                var addh = 0;
                var str = "";
                switch (this._lineType) {
                    case lineType.SingleLine:
                        for (var i = lab.text.length - 1; i >= 0; i--) {
                            var c = lab.text.charAt(i);
                            var cinfo = font.cmap[c];
                            if (!cinfo) {
                                console.warn("can't find character \"" + c + "\" in " + font.getName() + " Font");
                                continue;
                            }
                            addw += cinfo.xAddvance * rate;
                            if (addw > lab.transform.width) {
                                lab.text = str;
                                break;
                            }
                            str = lab.text[i] + str;
                        }
                        break;
                    case lineType.MultiLine:
                        var fristline = true;
                        addh += lab.fontsize * lab.linespace;
                        for (var i = lab.text.length - 1; i >= 0; i--) {
                            var c = lab.text.charAt(i);
                            var cinfo = font.cmap[c];
                            if (!cinfo) {
                                console.warn("can't find character \"" + c + "\" in " + font.getName() + " Font");
                                continue;
                            }
                            addw += cinfo.xAddvance * rate;
                            if (addw > lab.transform.width) {
                                addw = 0;
                                fristline = false;
                                addh += lab.fontsize * lab.linespace;
                            }
                            if (!fristline && addh > lab.transform.height) {
                                lab.text = str;
                                break;
                            }
                            str = lab.text[i] + str;
                        }
                        break;
                }
            };
            inputField.prototype.update = function (delta) {
                this.textRefresh();
            };
            inputField.prototype.remove = function () {
                this._placeholderLabel = null;
                this._textLable = null;
                this.transform = null;
                this._frameImage = null;
                if (this.inputElement) {
                    this.inputElement.disabled = false;
                    this.inputElement.value = "";
                    this.inputElement.style.visibility = "hidden";
                    if (this.inputElement.parentElement)
                        this.inputElement.parentElement.removeChild(this.inputElement);
                    this.inputElement = null;
                }
            };
            inputField.prototype.onPointEvent = function (canvas, ev, oncap) {
                if (oncap == false) {
                    if (ev.type != framework.PointEventEnum.PointDown)
                        return;
                    var b = this.transform.ContainsCanvasPoint(new gd3d.math.vector2(ev.x, ev.y));
                    if (b) {
                        this.inputElement.style.visibility = "visible";
                        this.inputElement.focus();
                    }
                    else {
                        if (this.beFocus)
                            this.inputElement.blur();
                        if (this.inputElement.style.visibility != "hidden")
                            this.inputElement.style.visibility = "hidden";
                    }
                }
            };
            __decorate([
                gd3d.reflect.Field("reference"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [framework.image2D])
            ], inputField.prototype, "frameImage", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], inputField.prototype, "characterLimit", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], inputField.prototype, "LineType", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], inputField.prototype, "ContentType", null);
            __decorate([
                gd3d.reflect.Field("reference"),
                __metadata("design:type", framework.label),
                __metadata("design:paramtypes", [framework.label])
            ], inputField.prototype, "TextLabel", null);
            __decorate([
                gd3d.reflect.Field("reference"),
                __metadata("design:type", framework.label),
                __metadata("design:paramtypes", [framework.label])
            ], inputField.prototype, "PlaceholderLabel", null);
            inputField = __decorate([
                gd3d.reflect.node2DComponent,
                gd3d.reflect.nodeRender
            ], inputField);
            return inputField;
        }());
        framework.inputField = inputField;
        var lineType;
        (function (lineType) {
            lineType[lineType["SingleLine"] = 0] = "SingleLine";
            lineType[lineType["MultiLine"] = 1] = "MultiLine";
        })(lineType = framework.lineType || (framework.lineType = {}));
        var contentType;
        (function (contentType) {
            contentType[contentType["None"] = 0] = "None";
            contentType[contentType["Number"] = 1] = "Number";
            contentType[contentType["Word"] = 2] = "Word";
            contentType[contentType["Underline"] = 4] = "Underline";
            contentType[contentType["ChineseCharacter"] = 8] = "ChineseCharacter";
            contentType[contentType["NoneChineseCharacter"] = 16] = "NoneChineseCharacter";
            contentType[contentType["Email"] = 32] = "Email";
            contentType[contentType["PassWord"] = 64] = "PassWord";
            contentType[contentType["Custom"] = 128] = "Custom";
        })(contentType = framework.contentType || (framework.contentType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var label = (function () {
            function label() {
                this.needRefreshFont = false;
                this._fontName = "defFont";
                this._fontsize = 14;
                this.linespace = 1;
                this.horizontalType = HorizontalType.Left;
                this.verticalType = VerticalType.Center;
                this.horizontalOverflow = false;
                this.verticalOverflow = false;
                this.indexarr = [];
                this.remainarrx = [];
                this.data_begin = new gd3d.math.vector2(0, 0);
                this.datar = [];
                this.color = new gd3d.math.color(1, 1, 1, 1);
                this.color2 = new gd3d.math.color(0, 0, 0.5, 0.5);
                this.dirtyData = true;
            }
            Object.defineProperty(label.prototype, "text", {
                get: function () {
                    return this._text;
                },
                set: function (text) {
                    text = text == null ? "" : text;
                    this._text = text;
                    this.initdater();
                    this.dirtyData = true;
                },
                enumerable: true,
                configurable: true
            });
            label.prototype.initdater = function () {
                var cachelen = 6 * 13 * this._text.length;
                this.datar.splice(0, this.datar.length);
                while (this.datar.length < cachelen) {
                    this.datar.push(0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
                }
                while (this.datar.length < cachelen) {
                    this.datar.pop();
                }
            };
            Object.defineProperty(label.prototype, "font", {
                get: function () {
                    return this._font;
                },
                set: function (font) {
                    if (font == this._font)
                        return;
                    this.needRefreshFont = true;
                    if (this._font) {
                        this._font.unuse();
                    }
                    this._font = font;
                    if (font) {
                        this._font.use();
                        this._fontName = this._font.getName();
                    }
                    else {
                        this._fontName = "";
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(label.prototype, "fontsize", {
                get: function () {
                    return this._fontsize;
                },
                set: function (size) {
                    this._fontsize = size;
                },
                enumerable: true,
                configurable: true
            });
            label.prototype.updateData = function (_font) {
                this.dirtyData = false;
                var rate = this._fontsize / _font.lineHeight;
                var m = this.transform.getWorldMatrix();
                var m11 = m.rawData[0];
                var m12 = m.rawData[2];
                var m21 = m.rawData[1];
                var m22 = m.rawData[3];
                var bx = this.data_begin.x;
                var by = this.data_begin.y;
                var txadd = 0;
                var tyadd = 0;
                this.indexarr = [];
                this.remainarrx = [];
                var remainy = 0;
                tyadd += this._fontsize * this.linespace;
                var contrast_w = this.horizontalOverflow ? Number.MAX_VALUE : this.transform.width;
                var contrast_h = this.verticalOverflow ? Number.MAX_VALUE : this.transform.height;
                for (var i = 0; i < this._text.length; i++) {
                    var c = this._text.charAt(i);
                    var cinfo = _font.cmap[c];
                    if (cinfo == undefined) {
                        continue;
                    }
                    if (txadd + cinfo.xAddvance * rate > contrast_w) {
                        if (tyadd + this._fontsize * this.linespace > contrast_h) {
                            break;
                        }
                        else {
                            this.indexarr.push(i);
                            this.remainarrx.push(this.transform.width - txadd);
                            txadd = 0;
                            tyadd += this._fontsize * this.linespace;
                        }
                    }
                    txadd += cinfo.xAddvance * rate;
                }
                this.indexarr.push(i);
                this.remainarrx.push(this.transform.width - txadd);
                remainy = this.transform.height - tyadd;
                var i = 0;
                var xadd = 0;
                var yadd = 0;
                if (this.verticalType == VerticalType.Center) {
                    yadd += remainy / 2;
                }
                else if (this.verticalType == VerticalType.Boom) {
                    yadd += remainy;
                }
                this.initdater();
                for (var arri = 0; arri < this.indexarr.length; arri++) {
                    xadd = 0;
                    if (this.horizontalType == HorizontalType.Center) {
                        xadd += this.remainarrx[arri] / 2;
                    }
                    else if (this.horizontalType == HorizontalType.Right) {
                        xadd += this.remainarrx[arri];
                    }
                    for (; i < this.indexarr[arri]; i++) {
                        var c = this._text.charAt(i);
                        var cinfo = _font.cmap[c];
                        if (cinfo == undefined) {
                            continue;
                        }
                        var cx = xadd + cinfo.xOffset * rate;
                        var cy = yadd - cinfo.yOffset * rate + _font.baseline * rate;
                        var ch = rate * cinfo.ySize;
                        var cw = rate * cinfo.xSize;
                        xadd += cinfo.xAddvance * rate;
                        var x1 = cx + cw;
                        var y1 = cy;
                        var x2 = cx;
                        var y2 = cy + ch;
                        var x3 = cx + cw;
                        var y3 = cy + ch;
                        this.datar[i * 6 * 13 + 0] = bx + cx * m11 + cy * m12;
                        this.datar[i * 6 * 13 + 1] = by + cx * m21 + cy * m22;
                        this.datar[i * 6 * 13 + 13 * 1 + 0] = bx + x1 * m11 + y1 * m12;
                        this.datar[i * 6 * 13 + 13 * 1 + 1] = by + x1 * m21 + y1 * m22;
                        this.datar[i * 6 * 13 + 13 * 2 + 0] = bx + x2 * m11 + y2 * m12;
                        this.datar[i * 6 * 13 + 13 * 2 + 1] = by + x2 * m21 + y2 * m22;
                        this.datar[i * 6 * 13 + 13 * 3 + 0] = bx + x2 * m11 + y2 * m12;
                        this.datar[i * 6 * 13 + 13 * 3 + 1] = by + x2 * m21 + y2 * m22;
                        this.datar[i * 6 * 13 + 13 * 4 + 0] = bx + x1 * m11 + y1 * m12;
                        this.datar[i * 6 * 13 + 13 * 4 + 1] = by + x1 * m21 + y1 * m22;
                        this.datar[i * 6 * 13 + 13 * 5 + 0] = bx + x3 * m11 + y3 * m12;
                        this.datar[i * 6 * 13 + 13 * 5 + 1] = by + x3 * m21 + y3 * m22;
                        var u0 = cinfo.x;
                        var v0 = cinfo.y;
                        var u1 = cinfo.x + cinfo.w;
                        var v1 = cinfo.y;
                        var u2 = cinfo.x;
                        var v2 = cinfo.y + cinfo.h;
                        var u3 = cinfo.x + cinfo.w;
                        var v3 = cinfo.y + cinfo.h;
                        this.datar[i * 6 * 13 + 7] = u0;
                        this.datar[i * 6 * 13 + 8] = v0;
                        this.datar[i * 6 * 13 + 13 * 1 + 7] = u1;
                        this.datar[i * 6 * 13 + 13 * 1 + 8] = v1;
                        this.datar[i * 6 * 13 + 13 * 2 + 7] = u2;
                        this.datar[i * 6 * 13 + 13 * 2 + 8] = v2;
                        this.datar[i * 6 * 13 + 13 * 3 + 7] = u2;
                        this.datar[i * 6 * 13 + 13 * 3 + 8] = v2;
                        this.datar[i * 6 * 13 + 13 * 4 + 7] = u1;
                        this.datar[i * 6 * 13 + 13 * 4 + 8] = v1;
                        this.datar[i * 6 * 13 + 13 * 5 + 7] = u3;
                        this.datar[i * 6 * 13 + 13 * 5 + 8] = v3;
                        for (var j = 0; j < 6; j++) {
                            this.datar[i * 6 * 13 + 13 * j + 3] = this.color.r;
                            this.datar[i * 6 * 13 + 13 * j + 4] = this.color.g;
                            this.datar[i * 6 * 13 + 13 * j + 5] = this.color.b;
                            this.datar[i * 6 * 13 + 13 * j + 6] = this.color.a;
                            this.datar[i * 6 * 13 + 13 * j + 9] = this.color2.r;
                            this.datar[i * 6 * 13 + 13 * j + 10] = this.color2.g;
                            this.datar[i * 6 * 13 + 13 * j + 11] = this.color2.b;
                            this.datar[i * 6 * 13 + 13 * j + 12] = this.color2.a;
                        }
                    }
                    yadd += this._fontsize * this.linespace;
                }
            };
            Object.defineProperty(label.prototype, "uimat", {
                get: function () {
                    if (this.font && this.font.texture) {
                        var rectPostfix = this.transform.parentIsMask ? "_(" + this.transform.insId + ")" : "";
                        var matName = this.font.texture.getName() + "_fontmask" + rectPostfix;
                        var canvas_2 = this.transform.canvas;
                        if (!canvas_2.assetmgr)
                            return;
                        var mat = this._uimat;
                        if (!mat || mat.getName() != matName) {
                            if (mat)
                                mat.unuse();
                            mat = canvas_2.assetmgr.getAssetByName(matName);
                            if (mat)
                                mat.use();
                        }
                        if (mat == null) {
                            mat = new framework.material(matName);
                            mat.setShader(canvas_2.assetmgr.getShader("shader/defmaskfont"));
                            mat.use();
                        }
                        mat.setFloat("MaskState", this.transform.parentIsMask ? 1 : 0);
                        this._uimat = mat;
                    }
                    return this._uimat;
                },
                enumerable: true,
                configurable: true
            });
            label.prototype.render = function (canvas) {
                if (this._font == null) {
                    var temp = canvas.assetmgr.mapNamed[this._fontName];
                    if (temp != null) {
                        var tfont = canvas.assetmgr.getAssetByName(this._fontName);
                        if (tfont) {
                            this.font = tfont;
                            this.needRefreshFont = true;
                        }
                    }
                }
                if (this._font != null) {
                    if (this.dirtyData == true) {
                        this.updateData(this._font);
                        this.dirtyData = false;
                    }
                    var mat = this.uimat;
                    if (!mat)
                        return;
                    var img;
                    if (this._font != null) {
                        img = this._font.texture;
                    }
                    if (img != null) {
                        if (this.needRefreshFont) {
                            mat.setTexture("_MainTex", img);
                            this.needRefreshFont = false;
                        }
                        if (this.transform.parentIsMask) {
                            if (this._cacheMaskV4 == null)
                                this._cacheMaskV4 = new gd3d.math.vector4();
                            var rect = this.transform.maskRect;
                            if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h) {
                                this._cacheMaskV4.x = rect.x;
                                this._cacheMaskV4.y = rect.y;
                                this._cacheMaskV4.z = rect.w;
                                this._cacheMaskV4.w = rect.h;
                                mat.setVector4("_maskRect", this._cacheMaskV4);
                            }
                        }
                        if (this.datar.length != 0)
                            canvas.pushRawData(mat, this.datar);
                    }
                }
            };
            label.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var t = -this.transform.pivot.y * this.transform.height;
                this.data_begin.x = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                this.data_begin.y = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                this.dirtyData = true;
            };
            label.prototype.start = function () {
            };
            label.prototype.update = function (delta) {
            };
            label.prototype.remove = function () {
                if (this._font)
                    this._font.unuse(true);
                if (this._uimat)
                    this._uimat.unuse(true);
                this.indexarr.length = 0;
                this.remainarrx.length = 0;
                this.datar.length = 0;
                this.transform = null;
                this._cacheMaskV4 = null;
            };
            label.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String),
                __metadata("design:paramtypes", [String])
            ], label.prototype, "text", null);
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", Object)
            ], label.prototype, "_fontName", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], label.prototype, "fontsize", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], label.prototype, "linespace", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], label.prototype, "horizontalType", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], label.prototype, "verticalType", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], label.prototype, "horizontalOverflow", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], label.prototype, "verticalOverflow", void 0);
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("color"),
                __metadata("design:type", gd3d.math.color)
            ], label.prototype, "color", void 0);
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("color"),
                __metadata("design:type", gd3d.math.color)
            ], label.prototype, "color2", void 0);
            label = __decorate([
                gd3d.reflect.node2DComponent,
                gd3d.reflect.nodeRender
            ], label);
            return label;
        }());
        framework.label = label;
        var HorizontalType;
        (function (HorizontalType) {
            HorizontalType[HorizontalType["Center"] = 0] = "Center";
            HorizontalType[HorizontalType["Left"] = 1] = "Left";
            HorizontalType[HorizontalType["Right"] = 2] = "Right";
        })(HorizontalType = framework.HorizontalType || (framework.HorizontalType = {}));
        var VerticalType;
        (function (VerticalType) {
            VerticalType[VerticalType["Center"] = 0] = "Center";
            VerticalType[VerticalType["Top"] = 1] = "Top";
            VerticalType[VerticalType["Boom"] = 2] = "Boom";
        })(VerticalType = framework.VerticalType || (framework.VerticalType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var rawImage2D = (function () {
            function rawImage2D() {
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.needRefreshImg = false;
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
            }
            Object.defineProperty(rawImage2D.prototype, "image", {
                get: function () {
                    return this._image;
                },
                set: function (_image) {
                    if (this._image == _image)
                        return;
                    this.needRefreshImg = true;
                    if (this._image) {
                        this._image.unuse();
                    }
                    this._image = _image;
                    if (_image) {
                        this._image.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(rawImage2D.prototype, "uimat", {
                get: function () {
                    if (this.image != null) {
                        var rectPostfix = this.transform.parentIsMask ? "_(" + this.transform.insId + ")" : "";
                        var matName = this._image.getName() + "_uimask" + rectPostfix;
                        var canvas_3 = this.transform.canvas;
                        if (!canvas_3.assetmgr)
                            return;
                        var mat = this._uimat;
                        if (!mat || mat.getName() != matName) {
                            if (mat)
                                mat.unuse();
                            mat = canvas_3.assetmgr.getAssetByName(matName);
                            if (mat)
                                mat.use();
                        }
                        if (mat == null) {
                            mat = new framework.material(matName);
                            mat.setShader(canvas_3.assetmgr.getShader("shader/defmaskui"));
                            mat.use();
                        }
                        mat.setFloat("MaskState", this.transform.parentIsMask ? 1 : 0);
                        this._uimat = mat;
                    }
                    return this._uimat;
                },
                enumerable: true,
                configurable: true
            });
            rawImage2D.prototype.render = function (canvas) {
                var img = this.image;
                var mat = this.uimat;
                if (!mat)
                    return;
                if (img != null) {
                    if (this.needRefreshImg) {
                        mat.setTexture("_MainTex", img);
                        this.needRefreshImg = false;
                    }
                    if (this.transform.parentIsMask) {
                        if (this._cacheMaskV4 == null)
                            this._cacheMaskV4 = new gd3d.math.vector4();
                        var rect = this.transform.maskRect;
                        if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h) {
                            this._cacheMaskV4.x = rect.x;
                            this._cacheMaskV4.y = rect.y;
                            this._cacheMaskV4.z = rect.w;
                            this._cacheMaskV4.w = rect.h;
                            mat.setVector4("_maskRect", this._cacheMaskV4);
                        }
                    }
                    canvas.pushRawData(mat, this.datar);
                }
            };
            rawImage2D.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                this.datar[0 * 13] = x0;
                this.datar[0 * 13 + 1] = y0;
                this.datar[1 * 13] = x1;
                this.datar[1 * 13 + 1] = y1;
                this.datar[2 * 13] = x2;
                this.datar[2 * 13 + 1] = y2;
                this.datar[3 * 13] = x2;
                this.datar[3 * 13 + 1] = y2;
                this.datar[4 * 13] = x1;
                this.datar[4 * 13 + 1] = y1;
                this.datar[5 * 13] = x3;
                this.datar[5 * 13 + 1] = y3;
                for (var i = 0; i < 6; i++) {
                    this.datar[i * 13 + 3] = this.color.r;
                    this.datar[i * 13 + 4] = this.color.g;
                    this.datar[i * 13 + 5] = this.color.b;
                    this.datar[i * 13 + 6] = this.color.a;
                }
            };
            rawImage2D.prototype.start = function () {
            };
            rawImage2D.prototype.update = function (delta) {
            };
            rawImage2D.prototype.remove = function () {
                if (this._image)
                    this._image.unuse(true);
                if (this._uimat)
                    this._uimat.unuse(true);
                this._image = null;
                this._cacheMaskV4 = null;
                this.transform = null;
                this.datar.length = 0;
            };
            rawImage2D.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            __decorate([
                gd3d.reflect.Field("texture"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [framework.texture])
            ], rawImage2D.prototype, "image", null);
            __decorate([
                gd3d.reflect.Field("color"),
                gd3d.reflect.UIStyle("vector4"),
                __metadata("design:type", gd3d.math.color)
            ], rawImage2D.prototype, "color", void 0);
            rawImage2D = __decorate([
                gd3d.reflect.node2DComponent,
                gd3d.reflect.nodeRender
            ], rawImage2D);
            return rawImage2D;
        }());
        framework.rawImage2D = rawImage2D;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var scrollRect = (function () {
            function scrollRect() {
                this.horizontal = true;
                this.vertical = true;
                this.isPointDown = false;
            }
            Object.defineProperty(scrollRect.prototype, "content", {
                get: function () {
                    return this._content;
                },
                set: function (content) {
                    this._content = content;
                },
                enumerable: true,
                configurable: true
            });
            scrollRect.prototype.start = function () {
            };
            scrollRect.prototype.update = function (delta) {
            };
            scrollRect.prototype.onPointEvent = function (canvas, ev, oncap) {
                if (oncap == false) {
                    var b = this.transform.ContainsCanvasPoint(new gd3d.math.vector2(ev.x, ev.y));
                    if (b) {
                        ev.eated = true;
                        if (this._content == null)
                            return;
                        if (!this.horizontal && !this.vertical)
                            return;
                        var temps = gd3d.math.pool.new_vector2();
                        temps.x = ev.x;
                        temps.y = ev.y;
                        var tempc = gd3d.math.pool.new_vector2();
                        this.transform.canvas.screenToCanvasPoint(temps, tempc);
                        if (this.strPoint == null)
                            this.strPoint = new gd3d.math.vector2();
                        var sp = this.strPoint;
                        if (ev.type == framework.PointEventEnum.PointDown) {
                            this.isPointDown = true;
                            sp.x = tempc.x;
                            sp.y = tempc.y;
                            if (this.strPos == null)
                                this.strPos = new gd3d.math.vector2();
                            gd3d.math.vec2Clone(this._content.transform.localTranslate, this.strPos);
                        }
                        if (ev.type == framework.PointEventEnum.PointHold && this.isPointDown) {
                            if (this.lastPoint == null)
                                this.lastPoint = new gd3d.math.vector2();
                            var lp = this.lastPoint;
                            if (lp.x != tempc.x || lp.y != tempc.y) {
                                lp.x = tempc.x;
                                lp.y = tempc.y;
                                var addtransX = lp.x - sp.x;
                                var addtransY = lp.y - sp.y;
                                this.SlideTo(addtransX, addtransY);
                            }
                        }
                        gd3d.math.pool.delete_vector2(temps);
                        gd3d.math.pool.delete_vector2(tempc);
                    }
                }
                if (ev.type == framework.PointEventEnum.PointUp) {
                    this.isPointDown = false;
                }
            };
            scrollRect.prototype.SlideTo = function (addtransX, addtransY) {
                if (this._content == null || this.strPos == null)
                    return;
                var ctrans = this._content.transform;
                var cpos = ctrans.localTranslate;
                var trans = this.transform;
                gd3d.math.vec2Clone(this.strPos, cpos);
                if (this.horizontal) {
                    cpos.x += addtransX;
                    if (cpos.x > 0)
                        cpos.x = 0;
                    if (ctrans.width >= trans.width && cpos.x + ctrans.width < trans.width)
                        cpos.x = -1 * (ctrans.width - trans.width);
                }
                if (this.vertical) {
                    cpos.y += addtransY;
                    if (cpos.y > 0)
                        cpos.y = 0;
                    if (ctrans.height >= trans.height && cpos.y + ctrans.height < trans.height)
                        cpos.y = -1 * (ctrans.height - trans.height);
                }
                ctrans.markDirty();
            };
            scrollRect.prototype.remove = function () {
                this._content = null;
                this.transform = null;
            };
            __decorate([
                gd3d.reflect.Field("reference"),
                __metadata("design:type", framework.transform2D),
                __metadata("design:paramtypes", [framework.transform2D])
            ], scrollRect.prototype, "content", null);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], scrollRect.prototype, "horizontal", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], scrollRect.prototype, "vertical", void 0);
            scrollRect = __decorate([
                gd3d.reflect.node2DComponent
            ], scrollRect);
            return scrollRect;
        }());
        framework.scrollRect = scrollRect;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var uirect = (function () {
            function uirect() {
                this.canbeClick = true;
            }
            uirect.prototype.start = function () {
            };
            uirect.prototype.update = function (delta) {
            };
            uirect.prototype.onPointEvent = function (canvas, ev, oncap) {
            };
            uirect.prototype.remove = function () {
                this.transform = null;
            };
            uirect = __decorate([
                gd3d.reflect.node2DComponent
            ], uirect);
            return uirect;
        }());
        framework.uirect = uirect;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var resID = (function () {
            function resID() {
                this.id = resID.next();
            }
            resID.next = function () {
                var next = resID.idAll;
                resID.idAll++;
                return next;
            };
            resID.prototype.getID = function () {
                return this.id;
            };
            resID.idAll = 1;
            return resID;
        }());
        framework.resID = resID;
        var constText = (function () {
            function constText(text) {
                this.name = text;
            }
            constText.prototype.getText = function () {
                return this.name;
            };
            constText = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], constText);
            return constText;
        }());
        framework.constText = constText;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetTypeEnum;
        (function (AssetTypeEnum) {
            AssetTypeEnum[AssetTypeEnum["Unknown"] = 0] = "Unknown";
            AssetTypeEnum[AssetTypeEnum["Auto"] = 1] = "Auto";
            AssetTypeEnum[AssetTypeEnum["Bundle"] = 2] = "Bundle";
            AssetTypeEnum[AssetTypeEnum["CompressBundle"] = 3] = "CompressBundle";
            AssetTypeEnum[AssetTypeEnum["GLVertexShader"] = 4] = "GLVertexShader";
            AssetTypeEnum[AssetTypeEnum["GLFragmentShader"] = 5] = "GLFragmentShader";
            AssetTypeEnum[AssetTypeEnum["Shader"] = 6] = "Shader";
            AssetTypeEnum[AssetTypeEnum["Texture"] = 7] = "Texture";
            AssetTypeEnum[AssetTypeEnum["TextureDesc"] = 8] = "TextureDesc";
            AssetTypeEnum[AssetTypeEnum["Mesh"] = 9] = "Mesh";
            AssetTypeEnum[AssetTypeEnum["Prefab"] = 10] = "Prefab";
            AssetTypeEnum[AssetTypeEnum["Material"] = 11] = "Material";
            AssetTypeEnum[AssetTypeEnum["Aniclip"] = 12] = "Aniclip";
            AssetTypeEnum[AssetTypeEnum["Scene"] = 13] = "Scene";
            AssetTypeEnum[AssetTypeEnum["Atlas"] = 14] = "Atlas";
            AssetTypeEnum[AssetTypeEnum["Font"] = 15] = "Font";
            AssetTypeEnum[AssetTypeEnum["TextAsset"] = 16] = "TextAsset";
            AssetTypeEnum[AssetTypeEnum["PackBin"] = 17] = "PackBin";
            AssetTypeEnum[AssetTypeEnum["PackTxt"] = 18] = "PackTxt";
            AssetTypeEnum[AssetTypeEnum["PathAsset"] = 19] = "PathAsset";
            AssetTypeEnum[AssetTypeEnum["KeyFrameAnimaionAsset"] = 20] = "KeyFrameAnimaionAsset";
            AssetTypeEnum[AssetTypeEnum["PVR"] = 21] = "PVR";
            AssetTypeEnum[AssetTypeEnum["F14Effect"] = 22] = "F14Effect";
            AssetTypeEnum[AssetTypeEnum["DDS"] = 23] = "DDS";
        })(AssetTypeEnum = framework.AssetTypeEnum || (framework.AssetTypeEnum = {}));
        var AssetBundleLoadState;
        (function (AssetBundleLoadState) {
            AssetBundleLoadState[AssetBundleLoadState["None"] = 0] = "None";
            AssetBundleLoadState[AssetBundleLoadState["Shader"] = 1] = "Shader";
            AssetBundleLoadState[AssetBundleLoadState["Mesh"] = 2] = "Mesh";
            AssetBundleLoadState[AssetBundleLoadState["Texture"] = 4] = "Texture";
            AssetBundleLoadState[AssetBundleLoadState["Material"] = 8] = "Material";
            AssetBundleLoadState[AssetBundleLoadState["Anclip"] = 16] = "Anclip";
            AssetBundleLoadState[AssetBundleLoadState["Prefab"] = 32] = "Prefab";
            AssetBundleLoadState[AssetBundleLoadState["Scene"] = 64] = "Scene";
            AssetBundleLoadState[AssetBundleLoadState["Textasset"] = 128] = "Textasset";
            AssetBundleLoadState[AssetBundleLoadState["Pvr"] = 256] = "Pvr";
            AssetBundleLoadState[AssetBundleLoadState["f14eff"] = 512] = "f14eff";
            AssetBundleLoadState[AssetBundleLoadState["Dds"] = 1024] = "Dds";
        })(AssetBundleLoadState = framework.AssetBundleLoadState || (framework.AssetBundleLoadState = {}));
        var ResourceState = (function () {
            function ResourceState() {
                this.res = null;
                this.state = 0;
                this.loadedLength = 0;
            }
            return ResourceState;
        }());
        framework.ResourceState = ResourceState;
        var RefResourceState = (function (_super) {
            __extends(RefResourceState, _super);
            function RefResourceState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.refLoadedLength = 0;
                return _this;
            }
            return RefResourceState;
        }(ResourceState));
        framework.RefResourceState = RefResourceState;
        var stateLoad = (function () {
            function stateLoad() {
                this.iserror = false;
                this.isfinish = false;
                this.resstate = {};
                this.curtask = 0;
                this.bundleLoadState = 0;
                this.totaltask = 0;
                this.totalByteLength = 0;
                this.progressCall = false;
                this.compressTextLoaded = 0;
                this.compressBinLoaded = 0;
                this.logs = [];
                this.errs = [];
            }
            Object.defineProperty(stateLoad.prototype, "fileProgress", {
                get: function () {
                    return this.curtask / this.totaltask;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(stateLoad.prototype, "curByteLength", {
                get: function () {
                    var result = 0;
                    for (var key in this.resstate) {
                        var _resState = this.resstate[key];
                        result += _resState.loadedLength;
                        if (_resState instanceof RefResourceState) {
                            result += _resState.refLoadedLength;
                        }
                    }
                    result += this.compressTextLoaded + this.compressBinLoaded;
                    return result;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(stateLoad.prototype, "progress", {
                get: function () {
                    return this.curByteLength / this.totalByteLength;
                },
                enumerable: true,
                configurable: true
            });
            return stateLoad;
        }());
        framework.stateLoad = stateLoad;
        var assetBundle = (function () {
            function assetBundle(url) {
                this.files = [];
                this.packages = [];
                this.bundlePackBin = {};
                this.totalLength = 0;
                this.mapNamed = {};
                this.url = url;
                var i = url.lastIndexOf("/");
                this.path = url.substring(0, i);
            }
            assetBundle.prototype.loadCompressBundle = function (url, onstate, state, assetmgr) {
                var _this = this;
                state.totalByteLength = this.totalLength;
                gd3d.io.loadText(url, function (txt, err) {
                    if (err != null) {
                        state.iserror = true;
                        state.errs.push(new Error(err.message));
                        onstate(state);
                        return;
                    }
                    var json = JSON.parse(txt);
                    _this.bundlePackJson = json;
                    _this.parse(json["bundleinfo"], _this.totalLength);
                    _this.load(assetmgr, onstate, state);
                    assetmgr.mapBundle[_this.name] = _this;
                }, function (loadedLength, totalLength) {
                    state.compressTextLoaded = loadedLength;
                    onstate(state);
                });
            };
            assetBundle.prototype.parse = function (json, totalLength) {
                if (totalLength === void 0) { totalLength = 0; }
                var files = json["files"];
                for (var i = 0; i < files.length; i++) {
                    var item = files[i];
                    var packes = -1;
                    if (item.packes != undefined)
                        packes = item.packes;
                    this.files.push({ name: item.name, length: item.length, packes: packes });
                }
                if (json["packes"] != undefined) {
                    var packes = json["packes"];
                    for (var i = 0; i < packes.length; i++) {
                        this.packages.push(packes[i]);
                    }
                }
                else {
                    if (json["totalLength"] != undefined) {
                        if (totalLength == 0) {
                            this.totalLength = json["totalLength"];
                        }
                    }
                }
            };
            assetBundle.prototype.unload = function () {
                for (var key in this.mapNamed) {
                    var asset = this.assetmgr.getAssetByName(key, this.name);
                    if (asset) {
                        this.assetmgr.unuse(asset);
                    }
                }
                this.assetmgr.removeAssetBundle(this.name);
            };
            assetBundle.prototype.load = function (assetmgr, onstate, state) {
                var _this = this;
                state.totalByteLength = this.totalLength;
                var totoal = this.files.length;
                this.assetmgr = assetmgr;
                this.curLoadState = AssetBundleLoadState.None;
                var glvshaders = [];
                var glfshaders = [];
                var shaders = [];
                var meshs = [];
                var textures = [];
                var texturedescs = [];
                var materials = [];
                var anclips = [];
                var prefabs = [];
                var scenes = [];
                var textassets = [];
                var pvrs = [];
                var packs = [];
                var f14effs = [];
                var fonts = [];
                var atlass = [];
                var ddss = [];
                var asslist = [];
                var assstatelist = [];
                asslist.push(packs, glvshaders, glfshaders, shaders, textassets, meshs, textures, pvrs, ddss, texturedescs, fonts, atlass, materials, anclips, f14effs, prefabs, scenes);
                assstatelist.push(AssetBundleLoadState.None, AssetBundleLoadState.None, AssetBundleLoadState.None, AssetBundleLoadState.Shader, AssetBundleLoadState.Prefab, AssetBundleLoadState.Mesh, AssetBundleLoadState.Material, AssetBundleLoadState.Scene, AssetBundleLoadState.None, AssetBundleLoadState.Texture, AssetBundleLoadState.Anclip, AssetBundleLoadState.Textasset, AssetBundleLoadState.Pvr, AssetBundleLoadState.f14eff, AssetBundleLoadState.Dds);
                var realTotal = 0;
                var mapPackes = {};
                for (var i = 0; i < this.packages.length; i++) {
                    var pack = this.packages[i];
                    var type_1 = assetmgr.calcType(pack);
                    var url = this.path + "/" + pack;
                    packs.push({ url: url, type: type_1, asset: null });
                }
                for (var i = 0; i < this.files.length; i++) {
                    var fitem = this.files[i];
                    var type = assetmgr.calcType(fitem.name);
                    var url = this.path + "/" + fitem.name;
                    var fileName = assetmgr.getFileName(url);
                    if (fitem.packes != -1) {
                        mapPackes[url] = fitem.packes;
                    }
                    {
                        var asset = null;
                        switch (type) {
                            case AssetTypeEnum.GLFragmentShader:
                                glfshaders.push({ url: url, type: type, asset: null });
                                break;
                            case AssetTypeEnum.GLVertexShader:
                                glvshaders.push({ url: url, type: type, asset: null });
                                break;
                            case AssetTypeEnum.Shader:
                                asset = new framework.shader(fileName);
                                shaders.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.Texture:
                                asset = new framework.texture(fileName);
                                textures.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.TextureDesc:
                                asset = new framework.texture(fileName);
                                texturedescs.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.Mesh:
                                asset = new framework.mesh(fileName);
                                meshs.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.Material:
                                asset = new framework.material(fileName);
                                materials.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.Aniclip:
                                asset = new framework.animationClip(fileName);
                                anclips.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.Prefab:
                                asset = new framework.prefab(fileName);
                                prefabs.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.Scene:
                                asset = new framework.rawscene(fileName);
                                scenes.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.TextAsset:
                                asset = new framework.textasset(fileName);
                                textassets.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.PVR:
                                asset = new framework.texture(fileName);
                                pvrs.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.F14Effect:
                                asset = new framework.f14eff(fileName);
                                f14effs.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.DDS:
                                asset = new framework.texture(fileName);
                                ddss.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.Font:
                                asset = new framework.font(fileName);
                                fonts.push({ url: url, type: type, asset: asset });
                                break;
                            case AssetTypeEnum.Atlas:
                                asset = new framework.atlas(fileName);
                                atlass.push({ url: url, type: type, asset: asset });
                                break;
                        }
                        if (type != AssetTypeEnum.GLVertexShader && type != AssetTypeEnum.GLFragmentShader && type != AssetTypeEnum.Shader
                            && type != AssetTypeEnum.PackBin && type != AssetTypeEnum.PackTxt) {
                            if (!asset)
                                continue;
                            this.mapNamed[fileName] = asset.getGUID();
                            assetmgr.regRes(fileName, asset);
                        }
                    }
                }
                var list = [];
                for (var i_1 = 0; i_1 < asslist.length; i_1++) {
                    for (var j = 0; j < asslist[i_1].length; j++) {
                        var url = asslist[i_1][j].url;
                        var type_2 = asslist[i_1][j].type;
                        var asset = asslist[i_1][j].asset;
                        var state_1 = null;
                        if (j == asslist[i_1].length - 1)
                            state_1 = assstatelist[i_1];
                        list.push({ url: url, type: type_2, asset: asset, state: state_1 });
                    }
                }
                realTotal = list.length;
                if (totoal > realTotal) {
                    console.log("assetBundle中某个file不是资源或后缀有问题");
                }
                state.totaltask = realTotal + 1;
                state.curtask = 1;
                onstate(state);
                assetmgr.doWaitState(this.url, state);
                state.bundleLoadState = AssetBundleLoadState.None;
                var loadcall = function () {
                    var surl = list[state.curtask - 1].url;
                    var type = list[state.curtask - 1].type;
                    var asset = list[state.curtask - 1].asset;
                    var _fileName = assetmgr.getFileName(surl);
                    var loadstate = list[state.curtask - 1].state;
                    if (mapPackes[surl] != undefined) {
                        var respack = void 0;
                        if (mapPackes[surl] == 0)
                            respack = _this.bundlePackJson;
                        else if (mapPackes[surl] == 1)
                            respack = _this.bundlePackBin;
                        else
                            console.log("未识别的packnum: " + mapPackes[surl]);
                        assetmgr.loadResByPack(respack, surl, type, function (s) {
                            if (s.progressCall) {
                                s.progressCall = false;
                                onstate(state);
                                return;
                            }
                            if (state != undefined)
                                state.bundleLoadState |= loadstate;
                            realTotal--;
                            state.curtask++;
                            if (realTotal === 0) {
                                state.isfinish = true;
                                onstate(state);
                                assetmgr.loadByMulQueue();
                            }
                            else {
                                onstate(state);
                                loadcall();
                            }
                            assetmgr.doWaitState(_this.url, state);
                        }, state, asset);
                    }
                    else {
                        if (type == AssetTypeEnum.PackBin) {
                            gd3d.io.loadArrayBuffer(surl, function (_buffer, err) {
                                if (err != null) {
                                    state.iserror = true;
                                    state.errs.push(new Error(err.message));
                                    onstate(state);
                                    assetmgr.loadByMulQueue();
                                    return;
                                }
                                var read = new gd3d.io.binReader(_buffer);
                                var index = read.readInt32();
                                read.position = index;
                                while (read.canread()) {
                                    var indindex = read.readInt32();
                                    if (index == 0)
                                        break;
                                    var key = read.readStringUtf8FixLength(indindex);
                                    var strs = key.split('|');
                                    var start = parseInt(strs[1]);
                                    var len = parseInt(strs[2]);
                                    var bufs = _buffer.slice(start, start + len);
                                    _this.bundlePackBin[strs[0]] = bufs;
                                }
                                if (state != undefined)
                                    state.bundleLoadState |= loadstate;
                                realTotal--;
                                state.curtask++;
                                if (realTotal === 0) {
                                    state.isfinish = true;
                                    onstate(state);
                                    assetmgr.loadByMulQueue();
                                }
                                else {
                                    onstate(state);
                                    loadcall();
                                }
                            }, function (loadedLength, totalLength) {
                                state.compressBinLoaded = loadedLength;
                                onstate(state);
                            });
                        }
                        else {
                            assetmgr.loadSingleRes(surl, type, function (s) {
                                if (s.iserror) {
                                    onstate(state);
                                    assetmgr.loadByMulQueue();
                                    return;
                                }
                                if (s.progressCall) {
                                    s.progressCall = false;
                                    onstate(state);
                                    return;
                                }
                                if (state != undefined)
                                    state.bundleLoadState |= loadstate;
                                realTotal--;
                                state.curtask++;
                                if (realTotal === 0) {
                                    state.isfinish = true;
                                    onstate(state);
                                    assetmgr.loadByMulQueue();
                                }
                                else {
                                    onstate(state);
                                    loadcall();
                                }
                                assetmgr.doWaitState(_this.url, state);
                            }, state, asset);
                        }
                    }
                };
                loadcall();
            };
            return assetBundle;
        }());
        framework.assetBundle = assetBundle;
        var assetMgr = (function () {
            function assetMgr(app) {
                this.mapShader = {};
                this.mapDefaultMesh = {};
                this.mapDefaultTexture = {};
                this.mapDefaultCubeTexture = {};
                this.mapDefaultSprite = {};
                this.mapMaterial = {};
                this.mapBundle = {};
                this.mapRes = {};
                this.mapNamed = {};
                this._loadingTag = "_AssetLoingTag_";
                this.mapInLoad = {};
                this.assetUrlDic = {};
                this.assetFactorys = {};
                this.waitStateDic = {};
                this.waitQueueState = [];
                this.loadingQueueState = [];
                this.loadingCountLimit = 2;
                this.app = app;
                this.webgl = app.webgl;
                this.shaderPool = new gd3d.render.shaderPool();
                this.initAssetFactorys();
            }
            assetMgr.prototype.initDefAsset = function () {
                framework.defMesh.initDefaultMesh(this);
                framework.defTexture.initDefaultTexture(this);
                framework.defsprite.initDefaultSprite(this);
                framework.defShader.initDefaultShader(this);
                framework.defmaterial.initDefaultMaterial(this);
            };
            assetMgr.prototype.getShader = function (name) {
                return this.mapShader[name];
            };
            assetMgr.prototype.getDefaultMesh = function (name) {
                return this.mapDefaultMesh[name];
            };
            assetMgr.prototype.getDefaultTexture = function (name) {
                return this.mapDefaultTexture[name];
            };
            assetMgr.prototype.getDefaultCubeTexture = function (name) {
                return this.mapDefaultCubeTexture[name];
            };
            assetMgr.prototype.getDefaultSprite = function (name) {
                return this.mapDefaultSprite[name];
            };
            assetMgr.prototype.getMaterial = function (name) {
                return this.mapMaterial[name];
            };
            assetMgr.prototype.getAsset = function (id) {
                var r = this.mapRes[id];
                if (r == null)
                    return null;
                return r.asset;
            };
            assetMgr.prototype.getAssetByName = function (name, bundlename) {
                if (bundlename === void 0) { bundlename = null; }
                var id = null;
                if (this.mapNamed[name] != null) {
                    id = this.mapNamed[name][this.mapNamed[name].length - 1];
                }
                if (bundlename != null) {
                    var assetbundle = this.mapBundle[bundlename];
                    if (assetbundle != null)
                        id = assetbundle.mapNamed[name] || id;
                }
                var flag = true;
                if (id != null) {
                    var r = this.mapRes[id];
                    if (r != null && !r[this._loadingTag])
                        return r.asset;
                }
                if (flag) {
                    if (this.mapDefaultMesh[name] != undefined)
                        return this.mapDefaultMesh[name];
                    if (this.mapDefaultTexture[name] != undefined)
                        return this.mapDefaultTexture[name];
                    if (this.mapShader[name] != undefined)
                        return this.mapShader[name];
                }
            };
            assetMgr.prototype.getAssetBundle = function (bundlename) {
                if (this.mapBundle[bundlename])
                    return this.mapBundle[bundlename];
                return null;
            };
            assetMgr.prototype.unuse = function (res, disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                var id = res.getGUID();
                var name = res.getName();
                if (res.defaultAsset) {
                    return;
                }
                if (!this.mapRes[id])
                    return;
                this.mapRes[id].refcount--;
                if (disposeNow && this.mapRes[id].refcount <= 0) {
                    this.mapRes[id].asset.dispose();
                    if (name != null) {
                        if (this.mapNamed[name].length <= 1) {
                            delete this.mapNamed[name];
                        }
                        else {
                            for (var key in this.mapNamed[name]) {
                                if (id == this.mapNamed[name][key]) {
                                    this.mapNamed[name].splice(parseInt(key), 1);
                                }
                            }
                        }
                    }
                    delete this.mapRes[id];
                }
            };
            assetMgr.prototype.use = function (res) {
                var id = res.getGUID();
                var name = res.getName();
                if (id <= 0) {
                    throw new Error("不合法的res guid:" + name);
                }
                if (res.defaultAsset) {
                    return;
                }
                if (this.mapRes[id] == null) {
                    this.mapRes[id] = { asset: res, refcount: 0 };
                    if (name != null) {
                        if (this.mapNamed[name] == null)
                            this.mapNamed[name] = [];
                        this.mapNamed[name].push(id);
                    }
                }
                this.mapRes[id].refcount++;
                if (this.mapRes[id][this._loadingTag]) {
                    delete this.mapRes[id][this._loadingTag];
                }
            };
            assetMgr.prototype.regRes = function (name, asset) {
                var id = asset.getGUID();
                if (this.mapRes[id] == null) {
                    this.mapRes[id] = { asset: asset, refcount: 0 };
                    this.mapRes[id][this._loadingTag] = true;
                    if (name != null) {
                        if (this.mapNamed[name] == null)
                            this.mapNamed[name] = [];
                        this.mapNamed[name].push(id);
                    }
                }
            };
            assetMgr.prototype.releaseUnuseAsset = function () {
                for (var k in this.mapRes) {
                    if (this.mapRes[k].refcount <= 0) {
                        if (this.mapRes[k][this._loadingTag])
                            continue;
                        var name_1 = this.mapRes[k].asset.getName();
                        if (this.mapNamed[name_1].length <= 1) {
                            delete this.mapNamed[name_1];
                        }
                        else {
                            for (var key in this.mapNamed[name_1]) {
                                if (this.mapRes[k].asset.getGUID() == this.mapNamed[name_1][key]) {
                                    this.mapNamed[name_1].splice(parseInt(key), 1);
                                }
                            }
                        }
                        this.mapRes[k].asset.dispose();
                        delete this.mapRes[k];
                    }
                }
            };
            assetMgr.prototype.getAssetsRefcount = function () {
                var mapRefcout = {};
                for (var k in this.mapNamed) {
                    if (this.mapNamed[k].length == 1) {
                        var res = this.mapRes[this.mapNamed[k][0]];
                        mapRefcout[k] = res.refcount;
                    }
                    else {
                        for (var key in this.mapNamed[k]) {
                            var res = this.mapRes[this.mapNamed[k][key]];
                            mapRefcout[k + "(" + key + ")"] = res.refcount;
                        }
                    }
                }
                return mapRefcout;
            };
            assetMgr.prototype.removeAssetBundle = function (name) {
                if (this.mapBundle[name] != null)
                    delete this.mapBundle[name];
                if (this.mapInLoad[name] != null)
                    delete this.mapInLoad[name];
            };
            assetMgr.prototype.setAssetUrl = function (asset, url) {
                this.assetUrlDic[asset.getGUID()] = url;
            };
            assetMgr.prototype.getAssetUrl = function (asset) {
                return this.assetUrlDic[asset.getGUID()];
            };
            assetMgr.prototype.loadResByPack = function (respack, url, type, onstate, state, asset) {
                var assetFactory = this.getAssetFactory(type);
                if (assetFactory != null) {
                    assetFactory.loadByPack(respack, url, onstate, state, this, asset);
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
            };
            assetMgr.prototype.regAssetFactory = function (type, factory) {
                this.assetFactorys[type.toString()] = factory;
            };
            assetMgr.prototype.getAssetFactory = function (type) {
                return this.assetFactorys[type];
            };
            assetMgr.prototype.initAssetFactorys = function () {
                this.regAssetFactory(AssetTypeEnum.GLVertexShader, new framework.AssetFactory_GLVertexShader());
                this.regAssetFactory(AssetTypeEnum.GLFragmentShader, new framework.AssetFactory_GLFragmentShader());
                this.regAssetFactory(AssetTypeEnum.Shader, new framework.AssetFactory_Shader());
                this.regAssetFactory(AssetTypeEnum.Texture, new framework.AssetFactory_Texture());
                this.regAssetFactory(AssetTypeEnum.TextureDesc, new framework.AssetFactory_TextureDesc());
                this.regAssetFactory(AssetTypeEnum.Mesh, new framework.AssetFactory_Mesh());
                this.regAssetFactory(AssetTypeEnum.Prefab, new framework.AssetFactory_Prefab());
                this.regAssetFactory(AssetTypeEnum.Material, new framework.AssetFactory_Material());
                this.regAssetFactory(AssetTypeEnum.Aniclip, new framework.AssetFactory_Aniclip());
                this.regAssetFactory(AssetTypeEnum.Scene, new framework.AssetFactory_Scene());
                this.regAssetFactory(AssetTypeEnum.Atlas, new framework.AssetFactory_Atlas());
                this.regAssetFactory(AssetTypeEnum.Font, new framework.AssetFactory_Font());
                this.regAssetFactory(AssetTypeEnum.TextAsset, new framework.AssetFactory_TextAsset());
                this.regAssetFactory(AssetTypeEnum.PathAsset, new framework.AssetFactory_PathAsset());
                this.regAssetFactory(AssetTypeEnum.PVR, new framework.AssetFactory_PVR());
                this.regAssetFactory(AssetTypeEnum.KeyFrameAnimaionAsset, new framework.AssetFactory_KeyframeAnimationPathAsset());
                this.regAssetFactory(AssetTypeEnum.F14Effect, new framework.AssetFactory_f14eff());
                this.regAssetFactory(AssetTypeEnum.DDS, new framework.AssetFactory_DDS());
            };
            assetMgr.prototype.loadSingleRes = function (url, type, onstate, state, asset) {
                if (url.indexOf("glsl") == -1 && url.indexOf(".shader.json") == -1) {
                }
                var assetFactory = this.getAssetFactory(type);
                if (assetFactory != null) {
                    assetFactory.load(url, onstate, state, this, asset);
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
            };
            assetMgr.prototype.doWaitState = function (name, state) {
                if (this.waitStateDic[name] == null)
                    return;
                for (var key in this.waitStateDic[name]) {
                    this.waitStateDic[name][key](state);
                }
                if (state.isfinish) {
                    this.waitStateDic[name].length = 0;
                }
            };
            assetMgr.prototype.checkFreeChannel = function () {
                var freechannel = -1;
                for (var k = 0; k < this.loadingQueueState.length; k++) {
                    if (this.loadingQueueState[k] == undefined) {
                        freechannel = k;
                        break;
                    }
                    else if (!this.loadingQueueState[k].state.isfinish && !this.loadingQueueState[k].state.iserror) {
                        continue;
                    }
                    else {
                        delete this.loadingQueueState[k];
                        freechannel = k;
                        break;
                    }
                }
                if (freechannel == -1 && this.loadingQueueState.length < this.loadingCountLimit) {
                    freechannel = this.loadingQueueState.length;
                }
                return freechannel;
            };
            assetMgr.prototype.loadByMulQueue = function () {
                var _this = this;
                if (this.waitQueueState.length == 0)
                    return;
                var freechannel = this.checkFreeChannel();
                if (freechannel == -1)
                    return;
                var curloadinfo = this.waitQueueState.shift();
                this.loadingQueueState[freechannel] = curloadinfo;
                var state = curloadinfo.state;
                var url = state.url;
                var type = curloadinfo.type;
                var onstate = curloadinfo.onstate;
                if (type == AssetTypeEnum.Bundle) {
                    gd3d.io.loadText(url, function (txt, err) {
                        if (err != null) {
                            curloadinfo.state.iserror = true;
                            curloadinfo.state.errs.push(new Error(err.message));
                            onstate(state);
                            return;
                        }
                        var json = JSON.parse(txt);
                        var filename = "";
                        if (json["files"]) {
                            filename = _this.getFileName(url);
                            var ab = new assetBundle(url);
                            ab.name = filename;
                            ab.parse(JSON.parse(txt));
                            ab.load(_this, onstate, state);
                        }
                        else {
                            var loadurl = url.replace(".assetbundle.json", ".packs.txt");
                            filename = _this.getFileName(url);
                            var ab = new assetBundle(url);
                            ab.name = filename;
                            ab.totalLength = json["totalLength"];
                            ab.loadCompressBundle(loadurl, onstate, state, _this);
                        }
                        _this.mapBundle[filename] = ab;
                    });
                }
                else if (type == AssetTypeEnum.CompressBundle) {
                    gd3d.io.loadText(url, function (txt, err) {
                        if (err != null) {
                            curloadinfo.state.iserror = true;
                            curloadinfo.state.errs.push(new Error(err.message));
                            onstate(state);
                            return;
                        }
                        var loadurl = url.replace(".assetbundle.json", ".packs.txt");
                        var filename = _this.getFileName(url);
                        var json = JSON.parse(txt);
                        var ab = new assetBundle(url);
                        ab.name = filename;
                        ab.totalLength = json["totalLength"];
                        ab.loadCompressBundle(loadurl, onstate, state, _this);
                    });
                }
                else {
                    state.totaltask = 1;
                    this.loadSingleRes(url, type, function (s) {
                        if (s.iserror) {
                            onstate(state);
                            _this.loadByMulQueue();
                            return;
                        }
                        if (s.progressCall) {
                            s.progressCall = false;
                            onstate(state);
                            return;
                        }
                        state.curtask = 1;
                        s.isfinish = true;
                        onstate(s);
                        _this.doWaitState(url, s);
                        _this.loadByMulQueue();
                    }, state);
                }
            };
            assetMgr.prototype.loadCompressBundle = function (url, onstate) {
                if (onstate === void 0) { onstate = null; }
                var name = this.getFileName(url);
                var type = this.calcType(url);
                var state = new stateLoad();
                this.mapInLoad[name] = state;
                state.url = url;
                if (type != AssetTypeEnum.Bundle) {
                    state.errs.push(new Error("is not bundle compress type:" + url));
                    state.iserror = true;
                    onstate(state);
                    this.doWaitState(url, state);
                    return;
                }
                type = AssetTypeEnum.CompressBundle;
                this.waitQueueState.push({ state: state, type: type, onstate: onstate });
                this.loadByMulQueue();
            };
            assetMgr.prototype.load = function (url, type, onstate) {
                if (type === void 0) { type = AssetTypeEnum.Auto; }
                if (onstate === void 0) { onstate = null; }
                if (onstate == null)
                    onstate = function () { };
                var name = this.getFileName(url);
                if (this.mapInLoad[name] != null) {
                    var _state = this.mapInLoad[name];
                    if (_state.isfinish) {
                        onstate(this.mapInLoad[name]);
                    }
                    else {
                        if (this.waitStateDic[name] == null)
                            this.waitStateDic[name] = [];
                        this.waitStateDic[name].push(onstate);
                    }
                    return;
                }
                var state = new stateLoad();
                this.mapInLoad[name] = state;
                state.url = url;
                if (type == AssetTypeEnum.Auto) {
                    type = this.calcType(url);
                }
                if (type == AssetTypeEnum.Unknown) {
                    state.errs.push(new Error("can not sure about type:" + url));
                    state.iserror = true;
                    onstate(state);
                    this.doWaitState(url, state);
                    return;
                }
                this.waitQueueState.push({ state: state, type: type, onstate: onstate });
                this.loadByMulQueue();
            };
            assetMgr.prototype.unload = function (url, onstate) {
                if (onstate === void 0) { onstate = null; }
                var name = this.getFileName(url);
                if (this.mapInLoad[name] == null)
                    return;
                var state = this.mapInLoad[name];
                for (var key in state.resstate) {
                    state.resstate[key].res.unuse();
                }
                delete this.mapInLoad[name];
            };
            assetMgr.prototype.loadScene = function (sceneName, onComplete) {
                if (sceneName.length > 0) {
                    var _rawscene = this.getAssetByName(sceneName);
                    var willLoadRoot = _rawscene.getSceneRoot();
                    while (willLoadRoot.children.length > 0) {
                        this.app.getScene().addChild(willLoadRoot.children.shift());
                    }
                    _rawscene.useLightMap(this.app.getScene());
                    _rawscene.useFog(this.app.getScene());
                }
                else {
                    var _camera = new framework.transform();
                    _camera.gameObject.addComponent("camera");
                    _camera.name = "camera";
                    this.app.getScene().addChild(_camera);
                }
                this.app.getScene().name = sceneName;
                this.app.getScene().getRoot().markDirty();
                onComplete();
            };
            assetMgr.prototype.saveScene = function (fun) {
                gd3d.io.SerializeDependent.resourseDatas = [];
                var info = new SaveInfo();
                var _scene = {};
                var scene = this.app.getScene();
                var _rootNode = gd3d.io.serializeObj(scene.getRoot(), null, this);
                var _lightmaps = [];
                var lightmaps = scene.lightmaps;
                for (var str in lightmaps) {
                    var _lightmap = {};
                    _lightmap["name"] = lightmaps[str].getName();
                    _lightmaps.push(_lightmap);
                    var lightMapUrl = this.getAssetUrl(lightmaps[str]);
                    gd3d.io.SerializeDependent.resourseDatas.push({ "url": lightMapUrl, "type": gd3d.io.SaveAssetType.FullUrl });
                }
                _scene["rootNode"] = _rootNode;
                _scene["lightmap"] = _lightmaps;
                _scene["fog"] = scene.fog;
                var _sceneStr = JSON.stringify(_scene);
                var _rawscene = this.getAssetByName(scene.name);
                _rawscene.Parse(_sceneStr, this);
                var url = this.getAssetUrl(_rawscene);
                info.files[url] = _sceneStr;
                fun(info, gd3d.io.SerializeDependent.resourseDatas);
            };
            assetMgr.prototype.savePrefab = function (trans, prefabName, fun) {
                gd3d.io.SerializeDependent.resourseDatas = [];
                var info = new SaveInfo();
                var _prefab = this.getAssetByName(prefabName);
                _prefab.apply(trans);
                var _rootTrans = gd3d.io.serializeObj(trans, null, this);
                var url = this.getAssetUrl(_prefab);
                info.files[url] = JSON.stringify(_rootTrans);
                fun(info, gd3d.io.SerializeDependent.resourseDatas);
            };
            assetMgr.prototype.saveMaterial = function (mat, fun) {
                var info = new SaveInfo();
                var data = {};
                var mapUniform = {};
                var shader = mat.getShader();
                var shaderPropertis = shader.defaultMapUniform;
                data["shader"] = shader.getName();
                data["mapUniform"] = mapUniform;
                var url = this.getAssetUrl(mat);
                info.files[url] = JSON.stringify(data);
                fun(info);
            };
            assetMgr.prototype.loadSingleResImmediate = function (url, type) {
                var _this = this;
                var result;
                var filename = this.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                if (type == AssetTypeEnum.GLVertexShader) {
                    gd3d.io.loadText(url, function (txt, err) {
                        _this.shaderPool.compileVS(_this.webgl, name, txt);
                    });
                }
                else if (type == AssetTypeEnum.GLFragmentShader) {
                    gd3d.io.loadText(url, function (txt, err) {
                        _this.shaderPool.compileFS(_this.webgl, name, txt);
                    });
                }
                else if (type == AssetTypeEnum.Shader) {
                    result = new framework.shader(filename);
                    gd3d.io.loadText(url, function (txt, err) {
                        result.parse(_this, JSON.parse(txt));
                        _this.mapShader[filename] = result;
                    });
                }
                else if (type == AssetTypeEnum.Texture) {
                    result = new framework.texture(filename);
                    var img = new Image();
                    img.src = url;
                    img.onload = function () {
                        var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                        result.glTexture = new gd3d.render.glTexture2D(_this.webgl, _textureFormat);
                        result.glTexture.uploadImage(img, true, true, true, true);
                        _this.use(result);
                    };
                }
                else if (type == AssetTypeEnum.Mesh) {
                    result = new framework.mesh(filename);
                    gd3d.io.loadArrayBuffer(url, function (txt, err) {
                        result.Parse(txt, _this.webgl);
                        _this.use(result);
                    });
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
                this.regRes(filename, result);
                return result;
            };
            assetMgr.prototype.loadImmediate = function (url, type) {
                if (type === void 0) { type = AssetTypeEnum.Auto; }
                var result;
                if (type == AssetTypeEnum.Auto) {
                    type = this.calcType(url);
                }
                if (type == AssetTypeEnum.Unknown) {
                    throw new Error("unknown format");
                }
                else if (type == AssetTypeEnum.Bundle) {
                    result = new assetBundle(url);
                    gd3d.io.loadText(url, function (txt, err) {
                        result.parse(JSON.parse(txt));
                    });
                }
                else {
                    result = this.loadSingleResImmediate(url, type);
                }
                return result;
            };
            assetMgr.prototype.getFileName = function (url) {
                var filei = url.lastIndexOf("/");
                var file = url.substr(filei + 1);
                return file;
            };
            assetMgr.prototype.calcType = function (url) {
                var filei = url.lastIndexOf("/");
                var file = url.substr(filei + 1);
                var i = file.indexOf(".", 0);
                var extname = null;
                while (i >= 0) {
                    extname = file.substr(i);
                    if (extname == ".vs.glsl") {
                        return AssetTypeEnum.GLVertexShader;
                    }
                    else if (extname == ".assetbundle.json") {
                        return AssetTypeEnum.Bundle;
                    }
                    else if (extname == ".fs.glsl") {
                        return AssetTypeEnum.GLFragmentShader;
                    }
                    else if (extname == ".shader.json") {
                        return AssetTypeEnum.Shader;
                    }
                    else if (extname == ".png" || extname == ".jpg") {
                        return AssetTypeEnum.Texture;
                    }
                    else if (extname == ".pvr.bin" || extname == ".pvr") {
                        return AssetTypeEnum.PVR;
                    }
                    else if (extname == ".imgdesc.json") {
                        return AssetTypeEnum.TextureDesc;
                    }
                    else if (extname == ".mat.json") {
                        return AssetTypeEnum.Material;
                    }
                    else if (extname == ".mesh.bin") {
                        return AssetTypeEnum.Mesh;
                    }
                    else if (extname == ".aniclip.bin") {
                        return AssetTypeEnum.Aniclip;
                    }
                    else if (extname == ".prefab.json") {
                        return AssetTypeEnum.Prefab;
                    }
                    else if (extname == ".scene.json") {
                        return AssetTypeEnum.Scene;
                    }
                    else if (extname == ".atlas.json") {
                        return AssetTypeEnum.Atlas;
                    }
                    else if (extname == ".font.json") {
                        return AssetTypeEnum.Font;
                    }
                    else if (extname == ".json" || extname == ".txt" || extname == ".effect.json") {
                        return AssetTypeEnum.TextAsset;
                    }
                    else if (extname == ".packs.bin") {
                        return AssetTypeEnum.PackBin;
                    }
                    else if (extname == ".packs.txt") {
                        return AssetTypeEnum.PackTxt;
                    }
                    else if (extname == ".path.json") {
                        return AssetTypeEnum.PathAsset;
                    }
                    else if (extname == ".keyFrameAnimationPath.json") {
                        return AssetTypeEnum.KeyFrameAnimaionAsset;
                    }
                    else if (extname == ".f14effect.json") {
                        return AssetTypeEnum.F14Effect;
                    }
                    else if (extname == ".dds" || extname == ".dds.bin") {
                        return AssetTypeEnum.DDS;
                    }
                    i = file.indexOf(".", i + 1);
                }
                return AssetTypeEnum.Unknown;
            };
            assetMgr.prototype.getDefParticleMat = function () {
                if (this.particlemat == null) {
                    var mat = new framework.material("defparticle");
                    var shader = this.getShader("particles_additive.shader.json");
                    if (shader == null) {
                        shader = this.getShader("shader/def");
                    }
                    mat.setShader(shader);
                    var tex = this.getDefaultTexture("grid");
                    mat.setTexture("_MainTex", tex);
                    this.particlemat = mat;
                }
                return this.particlemat;
            };
            return assetMgr;
        }());
        framework.assetMgr = assetMgr;
        var assetRef = (function () {
            function assetRef() {
            }
            return assetRef;
        }());
        framework.assetRef = assetRef;
        var SaveInfo = (function () {
            function SaveInfo() {
                this.files = {};
            }
            return SaveInfo;
        }());
        framework.SaveInfo = SaveInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var PvrParse = (function () {
    function PvrParse(gl) {
        this.version = 0x03525650;
        this.flags = 0;
        this.pixelFormatH = 0;
        this.pixelFormatL = 0;
        this.channelType = 0;
        this.height = 1;
        this.width = 1;
        this.depth = 1;
        this.numFaces = 1;
        this.mipMapCount = 1;
        this.metaDataSize = 0;
        this.gl = gl;
    }
    PvrParse.prototype.parse = function (_buffer) {
        var ar = new Uint8Array(_buffer);
        _buffer = null;
        var tool = new gd3d.io.binTool();
        tool.writeUint8Array(ar);
        this.version = tool.readUInt32();
        if (this.version === 0x03525650) {
            var tex = this.parseV3(tool);
            tool.dispose();
            return tex;
        }
        else if (this.version === 0x50565203) {
            console.error("v2");
        }
        else {
            console.error("pvr parse error!:" + this.version);
            return null;
        }
    };
    PvrParse.prototype.parseV3 = function (tool) {
        this.flags = tool.readUInt32();
        if (this.flags == 0)
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        else
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
        this.pixelFormatH = tool.readUInt32();
        this.pixelFormatL = tool.readUInt32();
        tool.readBytes(4);
        this.channelType = tool.readUInt32();
        this.height = tool.readUInt32();
        this.width = tool.readUInt32();
        this.depth = tool.readUInt32();
        tool.readBytes(4);
        this.numFaces = tool.readUInt32();
        this.mipMapCount = tool.readUInt32();
        this.metaDataSize = tool.readUInt32();
        tool.readBytes(this.metaDataSize);
        var engineFormat;
        var textureFormat;
        var textureType;
        var t2d = new gd3d.render.glTexture2D(this.gl);
        switch (this.pixelFormatH) {
            case 0:
                textureFormat = t2d.ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                break;
            case 1:
                textureFormat = t2d.ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC2_RGBA;
                break;
            case 2:
                textureFormat = t2d.ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC4_RGB;
                break;
            case 3:
                textureFormat = t2d.ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC4_RGBA;
                break;
            default:
                textureFormat = this.gl.RGB;
                engineFormat = gd3d.render.TextureFormatEnum.RGB;
                console.log("unknow pixel format::" + this.pixelFormatH);
        }
        t2d.format = engineFormat;
        switch (this.channelType) {
            case ChannelTypes.UnsignedByteNorm:
                textureType = this.gl.UNSIGNED_BYTE;
                break;
            case ChannelTypes.UnsignedShortNorm:
                break;
        }
        var target = this.gl.TEXTURE_2D;
        if (this.numFaces > 1)
            target = this.gl.TEXTURE_CUBE_MAP;
        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(target, t2d.texture);
        if (this.numFaces > 1)
            target = this.gl.TEXTURE_CUBE_MAP_POSITIVE_X;
        function textureLevelSize(format, width, height) {
            switch (format) {
                case t2d.ext.COMPRESSED_RGB_S3TC_DXT1_EXT:
                case t2d.ext.COMPRESSED_RGB_ATC_WEBGL:
                case t2d.ext.COMPRESSED_RGB_ETC1_WEBGL:
                    return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;
                case t2d.ext.COMPRESSED_RGBA_S3TC_DXT3_EXT:
                case t2d.ext.COMPRESSED_RGBA_S3TC_DXT5_EXT:
                case t2d.ext.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:
                case t2d.ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:
                    return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;
                case t2d.ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
                case t2d.ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
                    return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);
                case t2d.ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
                case t2d.ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
                    return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);
                default:
                    return 0;
            }
        }
        var offset = 0;
        var _width = this.width;
        var _height = this.height;
        for (var i = 0; i < this.mipMapCount; ++i) {
            var levelSize = textureLevelSize(textureFormat, _width, _height);
            var data = tool.readBytes(levelSize);
            this.gl.compressedTexImage2D(this.gl.TEXTURE_2D, i, textureFormat, _width, _height, 0, data);
            _width = _width >> 1;
            if (_width < 1)
                _width = 1;
            _height = _height >> 1;
            if (_height < 1)
                _height = 1;
            offset += levelSize;
        }
        if (this.mipMapCount > 1) {
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_NEAREST);
        }
        else {
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        }
        return t2d;
    };
    return PvrParse;
}());
var ChannelTypes;
(function (ChannelTypes) {
    ChannelTypes[ChannelTypes["UnsignedByteNorm"] = 0] = "UnsignedByteNorm";
    ChannelTypes[ChannelTypes["SignedByteNorm"] = 1] = "SignedByteNorm";
    ChannelTypes[ChannelTypes["UnsignedByte"] = 2] = "UnsignedByte";
    ChannelTypes[ChannelTypes["SignedByte"] = 3] = "SignedByte";
    ChannelTypes[ChannelTypes["UnsignedShortNorm"] = 4] = "UnsignedShortNorm";
    ChannelTypes[ChannelTypes["SignedShortNorm"] = 5] = "SignedShortNorm";
    ChannelTypes[ChannelTypes["UnsignedShort"] = 6] = "UnsignedShort";
    ChannelTypes[ChannelTypes["SignedShort"] = 7] = "SignedShort";
    ChannelTypes[ChannelTypes["UnsignedIntegerNorm"] = 8] = "UnsignedIntegerNorm";
    ChannelTypes[ChannelTypes["SignedIntegerNorm"] = 9] = "SignedIntegerNorm";
    ChannelTypes[ChannelTypes["UnsignedInteger"] = 10] = "UnsignedInteger";
    ChannelTypes[ChannelTypes["SignedInteger"] = 11] = "SignedInteger";
    ChannelTypes[ChannelTypes["SignedFloat"] = 12] = "SignedFloat";
    ChannelTypes[ChannelTypes["Float"] = 12] = "Float";
    ChannelTypes[ChannelTypes["UnsignedFloat"] = 13] = "UnsignedFloat";
})(ChannelTypes || (ChannelTypes = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defmaterial = (function () {
            function defmaterial() {
            }
            defmaterial.initDefaultMaterial = function (assetmgr) {
                {
                    var mat = new framework.material();
                    var sh = assetmgr.getShader("shader/defui");
                    mat.setShader(sh);
                    assetmgr.mapMaterial[sh.getName()] = mat;
                }
            };
            return defmaterial;
        }());
        framework.defmaterial = defmaterial;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defMesh = (function () {
            function defMesh() {
            }
            defMesh.initDefaultMesh = function (assetmgr) {
                assetmgr.mapDefaultMesh["cube"] = defMesh.createDefaultMesh("cube", gd3d.render.meshData.genBoxCCW(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["quad"] = defMesh.createDefaultMesh("circleline", gd3d.render.meshData.genQuad(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["quad_particle"] = defMesh.createDefaultMesh("quad_particle", gd3d.render.meshData.genQuad_forparticle(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["plane"] = defMesh.createDefaultMesh("plane", gd3d.render.meshData.genPlaneCCW(10), assetmgr.webgl);
                assetmgr.mapDefaultMesh["sphere"] = defMesh.createDefaultMesh("sphere", gd3d.render.meshData.genSphereCCW(), assetmgr.webgl);
                assetmgr.mapDefaultMesh["sphere_quality"] = defMesh.createDefaultMesh("sphere_quality", gd3d.render.meshData.genSphereCCW(2.58, 40, 40), assetmgr.webgl);
                assetmgr.mapDefaultMesh["pyramid"] = defMesh.createDefaultMesh("pyramid", gd3d.render.meshData.genPyramid(2, 0.5), assetmgr.webgl);
                assetmgr.mapDefaultMesh["cylinder"] = defMesh.createDefaultMesh("cylinder", gd3d.render.meshData.genCylinderCCW(2, 0.5), assetmgr.webgl);
                assetmgr.mapDefaultMesh["circleline"] = defMesh.createDefaultMesh("circleline", gd3d.render.meshData.genCircleLineCCW(1), assetmgr.webgl);
            };
            defMesh.createDefaultMesh = function (name, meshData, webgl) {
                var _mesh = new framework.mesh(name + ".mesh.bin");
                _mesh.defaultAsset = true;
                _mesh.data = meshData;
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                _mesh.data.originVF = vf;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArray();
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = false;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            return defMesh;
        }());
        framework.defMesh = defMesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defShader = (function () {
            function defShader() {
            }
            defShader.initDefaultShader = function (assetmgr) {
                var pool = assetmgr.shaderPool;
                pool.compileVS(assetmgr.webgl, "def", defShader.vscode);
                pool.compileFS(assetmgr.webgl, "def", defShader.fscode);
                pool.compileFS(assetmgr.webgl, "def2", defShader.fscode2);
                pool.compileFS(assetmgr.webgl, "defui", defShader.fscodeui);
                pool.compileVS(assetmgr.webgl, "defuifont", defShader.vscodeuifont);
                pool.compileFS(assetmgr.webgl, "defuifont", defShader.fscodeuifont);
                pool.compileVS(assetmgr.webgl, "diffuse", defShader.vsdiffuse);
                pool.compileFS(assetmgr.webgl, "diffuse", defShader.fsdiffuse);
                pool.compileVS(assetmgr.webgl, "line", defShader.vsline);
                pool.compileFS(assetmgr.webgl, "line", defShader.fsline);
                pool.compileVS(assetmgr.webgl, "materialcolor", defShader.vsmaterialcolor);
                pool.compileVS(assetmgr.webgl, "defUIMaskVS", defShader.vsUiMaskCode);
                pool.compileFS(assetmgr.webgl, "defUIMaskFS", defShader.fscodeMaskUi);
                pool.compileVS(assetmgr.webgl, "defuifontMaskVS", defShader.vscodeuifontmask);
                pool.compileFS(assetmgr.webgl, "defuifontMaskFS", defShader.fscodeuifontmask);
                var program = pool.linkProgram(assetmgr.webgl, "def", "def");
                var program2 = pool.linkProgram(assetmgr.webgl, "def", "defui");
                var programuifont = pool.linkProgram(assetmgr.webgl, "defuifont", "defuifont");
                var programdiffuse = pool.linkProgram(assetmgr.webgl, "diffuse", "diffuse");
                var programline = pool.linkProgram(assetmgr.webgl, "line", "line");
                var programmaterialcolor = pool.linkProgram(assetmgr.webgl, "materialcolor", "line");
                var programMaskUI = pool.linkProgram(assetmgr.webgl, "defUIMaskVS", "defUIMaskFS");
                var programMaskfont = pool.linkProgram(assetmgr.webgl, "defuifontMaskVS", "defuifontMaskFS");
                {
                    var sh = new framework.shader("shader/def");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(program);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = true;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/def3dbeforeui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(programdiffuse);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = false;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/def2");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(program2);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(program2);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend_PreMultiply);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defuifont");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(programuifont);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend_PreMultiply);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/line");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(programline);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = true;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/materialcolor");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(programmaterialcolor);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = false;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    sh.layer = framework.RenderLayerEnum.Overlay;
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defmaskui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.uishader).properties);
                    p.setProgram(programMaskUI);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend_PreMultiply);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defmaskfont");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.shaderuifront).properties);
                    p.setProgram(programMaskfont);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend_PreMultiply);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
            };
            defShader.shader0 = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\"\
            ]\
          }";
            defShader.vscode = "\
        attribute vec4 _glesVertex;   \
        attribute vec4 _glesColor;                  \
        attribute vec4 _glesMultiTexCoord0;         \
        uniform highp mat4 glstate_matrix_mvp;      \
        varying lowp vec4 xlv_COLOR;                \
        varying highp vec2 xlv_TEXCOORD0;           \
        void main()                                     \
        {                                               \
            highp vec4 tmpvar_1;                        \
            tmpvar_1.w = 1.0;                           \
            tmpvar_1.xyz = _glesVertex.xyz;             \
            xlv_COLOR = _glesColor;                     \
            xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;     \
            gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
        }";
            defShader.vsUiMaskCode = "\
        attribute vec4 _glesVertex;   \
        attribute vec4 _glesColor;                  \
        attribute vec4 _glesMultiTexCoord0;         \
        uniform highp mat4 glstate_matrix_mvp;      \
        uniform lowp float MaskState;      \
        varying lowp vec4 xlv_COLOR;                \
        varying highp vec2 xlv_TEXCOORD0;           \
        varying highp vec2 mask_TEXCOORD;           \
        void main()                                     \
        {                                               \
            highp vec4 tmpvar_1;                        \
            tmpvar_1.w = 1.0;                           \
            tmpvar_1.xyz = _glesVertex.xyz;             \
            xlv_COLOR = _glesColor;                     \
            xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);     \
            if(MaskState != 0.0){    \
                mask_TEXCOORD.x = (_glesVertex.x - 1.0)/-2.0;\
                mask_TEXCOORD.y = (_glesVertex.y - 1.0)/-2.0;\
            }\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
        }";
            defShader.fscodeMaskUi = "         \
        uniform sampler2D _MainTex;                                                 \
        uniform highp vec4 _maskRect;                                                 \
        uniform lowp float MaskState;      \
        varying lowp vec4 xlv_COLOR;                                                 \
        varying highp vec2 xlv_TEXCOORD0;   \
        varying highp vec2 mask_TEXCOORD;           \
        bool CalcuCut(){   \
            highp float l;\
            highp float t;\
            highp float r;\
            highp float b;\
            highp vec2 texc1;\
            bool beCut;\
            l = _maskRect.x;\
            t = _maskRect.y;\
            r = _maskRect.z + l;\
            b = _maskRect.w + t;\
            texc1 = mask_TEXCOORD;\
            if(texc1.x >(1.0 - l) || texc1.x <(1.0 - r) || texc1.y <t || texc1.y>b){ \
                beCut = true; \
            }else{\
                beCut = false;\
            }\
            return beCut;\
        }\
           \
        void main() \
        {\
            if(MaskState != 0.0 && CalcuCut()) discard;\
            lowp vec4 tmpvar_3;\
            tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\
            gl_FragData[0] = tmpvar_3 ;\
        }\
        ";
            defShader.fscode = "         \
        uniform sampler2D _MainTex;                                                 \
        varying lowp vec4 xlv_COLOR;                                                 \
        varying highp vec2 xlv_TEXCOORD0;   \
        void main() \
        {\
            lowp vec4 col_1;    \
            mediump vec4 prev_2;\
            lowp vec4 tmpvar_3;\
            tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\
            prev_2 = tmpvar_3;\
            mediump vec4 tmpvar_4;\
            tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\
            col_1 = tmpvar_4;\
            col_1.x =xlv_TEXCOORD0.x;\
            col_1.y =xlv_TEXCOORD0.y;\
            gl_FragData[0] = col_1;\
        }\
        ";
            defShader.fscode2 = "         \
        void main() \
        {\
            gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);\
        }\
        ";
            defShader.uishader = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\",\
              \"_MaskTex('MaskTex',Texture)='white'{}\"\
            ]\
            }";
            defShader.fscodeui = "         \
        uniform sampler2D _MainTex;                                                 \
        varying lowp vec4 xlv_COLOR;                                                 \
        varying highp vec2 xlv_TEXCOORD0;   \
        void main() \
        {\
            lowp vec4 tmpvar_3;\
            tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\
            gl_FragData[0] = tmpvar_3;\
        }\
        ";
            defShader.shaderuifront = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\"\
            ]\
            }";
            defShader.vscodeuifont = "\
        attribute vec4 _glesVertex;   \
        attribute vec4 _glesColor;                  \
        attribute vec4 _glesColorEx;                  \
        attribute vec4 _glesMultiTexCoord0;         \
        uniform highp mat4 glstate_matrix_mvp;      \
        varying lowp vec4 xlv_COLOR;                \
        varying lowp vec4 xlv_COLOREx;                                                 \
        varying highp vec2 xlv_TEXCOORD0;           \
        void main()                                     \
        {                                               \
            highp vec4 tmpvar_1;                        \
            tmpvar_1.w = 1.0;                           \
            tmpvar_1.xyz = _glesVertex.xyz;             \
            xlv_COLOR = _glesColor;                     \
            xlv_COLOREx = _glesColorEx;                     \
            xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);     \
            gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
        }";
            defShader.fscodeuifont = "\
        precision mediump float ;\
        uniform sampler2D _MainTex;\
        varying lowp vec4 xlv_COLOR;\
        varying lowp vec4 xlv_COLOREx;\
        varying highp vec2 xlv_TEXCOORD0;    \
        void main()  \
        { \
            float scale = 10.0;   \
            float d = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.5)*scale;   \
        float bd = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.34)*scale;   \
        \
        float c=xlv_COLOR.a * clamp ( d,0.0,1.0);  \
        float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0);  \
        bc =min(1.0-c,bc); \
        \
        \
        \
        gl_FragData[0] =xlv_COLOR*c + xlv_COLOREx*bc; \
    }";
            defShader.vscodeuifontmask = "\
        attribute vec4 _glesVertex;   \
        attribute vec4 _glesColor;                  \
        attribute vec4 _glesColorEx;                  \
        attribute vec4 _glesMultiTexCoord0;         \
        uniform highp mat4 glstate_matrix_mvp;      \
        uniform lowp float MaskState;      \
        varying lowp vec4 xlv_COLOR;                \
        varying lowp vec4 xlv_COLOREx;                                                 \
        varying highp vec2 xlv_TEXCOORD0;           \
        varying highp vec2 mask_TEXCOORD;           \
        void main()                                     \
        {                                               \
            highp vec4 tmpvar_1;                        \
            tmpvar_1.w = 1.0;                           \
            tmpvar_1.xyz = _glesVertex.xyz;             \
            xlv_COLOR = _glesColor;                     \
            xlv_COLOREx = _glesColorEx;                     \
            xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);     \
            if(MaskState != 0.0){    \
                mask_TEXCOORD.x = (_glesVertex.x - 1.0)/-2.0;\
                mask_TEXCOORD.y = (_glesVertex.y - 1.0)/-2.0;\
            }\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
        }";
            defShader.fscodeuifontmask = "\
        precision mediump float;\
            uniform sampler2D _MainTex;  \
            uniform lowp float MaskState;      \
            uniform highp vec4 _maskRect;       \
            varying lowp vec4 xlv_COLOR; \
            varying lowp vec4 xlv_COLOREx; \
            varying highp vec2 xlv_TEXCOORD0;    \
            varying highp vec2 mask_TEXCOORD;     \
            bool CalcuCut(){   \
                highp float l;\
                highp float t;\
                highp float r;\
                highp float b;\
                highp vec2 texc1;\
                bool beCut;\
                l = _maskRect.x;\
                t = _maskRect.y;\
                r = _maskRect.z + l;\
                b = _maskRect.w + t;\
                texc1 = mask_TEXCOORD;\
                if(texc1.x >(1.0 - l) || texc1.x <(1.0 - r) || texc1.y <t || texc1.y>b){ \
                    beCut = true; \
                }else{\
                    beCut = false;\
                }\
                return beCut;\
            }\
            \
            void main()  \
            { \
                if(MaskState != 0.0 && CalcuCut())  discard;\
            float scale = 10.0;   \
            float d = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.5)*scale;  \
            float bd = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.34)*scale;  \
            \
            float c=xlv_COLOR.a * clamp ( d,0.0,1.0);  \
            float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0);  \
            bc =min(1.0-c,bc); \
            lowp vec4 final =  xlv_COLOR*c + xlv_COLOREx*bc ;\
            gl_FragData[0] = final ;\
            }";
            defShader.diffuseShader = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\",\
              \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\"\
            ]\
            }";
            defShader.vsdiffuse = "\
        attribute vec4 _glesVertex;\
        attribute vec4 _glesMultiTexCoord0;\
        uniform highp mat4 glstate_matrix_mvp;\
        varying highp vec2 xlv_TEXCOORD0;\
        void main()\
        {\
            highp vec4 tmpvar_1;\
            tmpvar_1.w = 1.0;\
            tmpvar_1.xyz = _glesVertex.xyz;\
            xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);\
        }";
            defShader.fsdiffuse = "\
        uniform sampler2D _MainTex;\
        uniform lowp float _AlphaCut;\
        varying highp vec2 xlv_TEXCOORD0;\
        void main() \
        {\
            lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);\
            if(tmpvar_3.a < _AlphaCut)\
                discard;\
            gl_FragData[0] = tmpvar_3;\
        }";
            defShader.vsline = "\
        attribute vec4 _glesVertex;\
        attribute vec4 _glesColor;\
        uniform highp mat4 glstate_matrix_mvp;\
        varying lowp vec4 xlv_COLOR;\
        void main()\
        {\
            highp vec4 tmpvar_1;\
            tmpvar_1.w = 1.0;\
            tmpvar_1.xyz = _glesVertex.xyz;\
            xlv_COLOR = _glesColor;\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);\
        }";
            defShader.fsline = "\
        varying lowp vec4 xlv_COLOR;\
        void main()\
        {\
            gl_FragData[0] = xlv_COLOR;\
        }";
            defShader.materialShader = "{\
            \"properties\": [\
              \"_Color('Color',Vector) = (1,1,1,1)\"\
            ]\
            }";
            defShader.vsmaterialcolor = "\
        attribute vec4 _glesVertex;\
        uniform vec4 _Color;\
        uniform highp mat4 glstate_matrix_mvp;\
        varying lowp vec4 xlv_COLOR;\
        void main()\
        {\
            highp vec4 tmpvar_1;\
            tmpvar_1.w = 1.0;\
            tmpvar_1.xyz = _glesVertex.xyz;\
            xlv_COLOR = _Color;\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);\
        }";
            return defShader;
        }());
        framework.defShader = defShader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defsprite = (function () {
            function defsprite() {
            }
            defsprite.initDefaultSprite = function (assetmgr) {
                var spt_white = new framework.sprite("white_sprite");
                spt_white.texture = assetmgr.getDefaultTexture("white");
                spt_white.defaultAsset = true;
                spt_white.rect = new gd3d.math.rect(0, 0, spt_white.texture.glTexture.width, spt_white.texture.glTexture.height);
                assetmgr.mapDefaultSprite["white_sprite"] = spt_white;
                var spt_gray = new framework.sprite("gray_sprite");
                spt_gray.texture = assetmgr.getDefaultTexture("gray");
                spt_gray.defaultAsset = true;
                spt_gray.rect = new gd3d.math.rect(0, 0, spt_gray.texture.glTexture.width, spt_gray.texture.glTexture.height);
                assetmgr.mapDefaultSprite["gray_sprite"] = spt_gray;
                var spt_grid = new framework.sprite("grid_sprite");
                spt_grid.texture = assetmgr.getDefaultTexture("grid");
                spt_grid.defaultAsset = true;
                spt_grid.rect = new gd3d.math.rect(0, 0, spt_grid.texture.glTexture.width, spt_grid.texture.glTexture.height);
                assetmgr.mapDefaultSprite["grid_sprite"] = spt_grid;
            };
            return defsprite;
        }());
        framework.defsprite = defsprite;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var defTexture = (function () {
            function defTexture() {
            }
            defTexture.initDefaultTexture = function (assetmgr) {
                var t = new framework.texture("white");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "white");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["white"] = t;
                var t = new framework.texture("gray");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "gray");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["gray"] = t;
                var t = new framework.texture("normal");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "normal");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["normal"] = t;
                var t = new framework.texture("grid");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "grid");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["grid"] = t;
                defTexture.initDefaultCubeTexture(assetmgr);
            };
            defTexture.initDefaultCubeTexture = function (assetmgr) {
                var whiteTex = assetmgr.mapDefaultTexture["white"];
                var t = new framework.texture("white");
                t.glTexture = new gd3d.render.glTextureCube(assetmgr.app.webgl);
                t.glTexture.uploadImages(whiteTex, whiteTex, whiteTex, whiteTex, whiteTex, whiteTex);
                t.defaultAsset = true;
                assetmgr.mapDefaultCubeTexture["white"] = t;
            };
            return defTexture;
        }());
        framework.defTexture = defTexture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Aniclip = (function () {
            function AssetFactory_Aniclip() {
            }
            AssetFactory_Aniclip.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Aniclip.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadArrayBuffer(url, function (_buffer, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _clip = asset ? asset : new framework.animationClip(filename);
                    _clip.Parse(_buffer);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Aniclip.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                var _buffer = respack[filename];
                var _clip = asset ? asset : new framework.animationClip(filename);
                _clip.Parse(_buffer);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
            };
            return AssetFactory_Aniclip;
        }());
        framework.AssetFactory_Aniclip = AssetFactory_Aniclip;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Atlas = (function () {
            function AssetFactory_Atlas() {
            }
            AssetFactory_Atlas.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Atlas.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _atlas = asset ? asset : new framework.atlas(filename);
                    _atlas.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _atlas, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Atlas.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                var _atlas = asset ? asset : new framework.atlas(filename);
                _atlas.Parse(txt, assetMgr);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _atlas, url);
            };
            return AssetFactory_Atlas;
        }());
        framework.AssetFactory_Atlas = AssetFactory_Atlas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_DDS = (function () {
            function AssetFactory_DDS() {
            }
            AssetFactory_DDS.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_DDS.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
            };
            AssetFactory_DDS.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadArrayBuffer(url, function (_buffer, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _texture = asset ? asset : new framework.texture(filename);
                    assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                    var textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
                    textureUtil.loadDDS(url, null, function (texture, error, stats) {
                        var t2d = new gd3d.render.glTexture2D(assetMgr.webgl);
                        t2d.format = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                        t2d.texture = texture;
                        _texture.glTexture = t2d;
                    });
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            return AssetFactory_DDS;
        }());
        framework.AssetFactory_DDS = AssetFactory_DDS;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_f14eff = (function () {
            function AssetFactory_f14eff() {
            }
            AssetFactory_f14eff.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_f14eff.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var bundlename = framework.getFileName(state.url);
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _f14eff = asset ? asset : new framework.f14eff(filename);
                    _f14eff.assetbundle = bundlename;
                    _f14eff.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _f14eff, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_f14eff.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var bundlename = framework.getFileName(state.url);
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                var _f14eff = asset ? asset : new framework.f14eff(filename);
                _f14eff.assetbundle = bundlename;
                _f14eff.Parse(txt, assetMgr);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _f14eff, url);
            };
            return AssetFactory_f14eff;
        }());
        framework.AssetFactory_f14eff = AssetFactory_f14eff;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Font = (function () {
            function AssetFactory_Font() {
            }
            AssetFactory_Font.prototype.newAsset = function (filename) {
                return null;
            };
            AssetFactory_Font.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _font = asset ? asset : new framework.font(filename);
                    _font.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _font, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Font.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                var _font = asset ? asset : new framework.font(filename);
                _font.Parse(txt, assetMgr);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _font, url);
            };
            return AssetFactory_Font;
        }());
        framework.AssetFactory_Font = AssetFactory_Font;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_GLFragmentShader = (function () {
            function AssetFactory_GLFragmentShader() {
            }
            AssetFactory_GLFragmentShader.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_GLFragmentShader.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    state.resstate[filename].state = 1;
                    state.logs.push("load a glshader:" + filename);
                    assetMgr.shaderPool.mapFSString[name] = txt;
                    onstate(state);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_GLFragmentShader.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                txt = decodeURI(txt);
                state.resstate[filename].state = 1;
                state.logs.push("load a glshader:" + filename);
                assetMgr.shaderPool.mapFSString[name] = txt;
                onstate(state);
            };
            return AssetFactory_GLFragmentShader;
        }());
        framework.AssetFactory_GLFragmentShader = AssetFactory_GLFragmentShader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_GLVertexShader = (function () {
            function AssetFactory_GLVertexShader() {
            }
            AssetFactory_GLVertexShader.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_GLVertexShader.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    state.resstate[filename].state = 1;
                    state.logs.push("load a glshader:" + filename);
                    assetMgr.shaderPool.mapVSString[name] = txt;
                    onstate(state);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_GLVertexShader.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                txt = decodeURI(txt);
                state.resstate[filename].state = 1;
                state.logs.push("load a glshader:" + filename);
                assetMgr.shaderPool.mapVSString[name] = txt;
                onstate(state);
            };
            return AssetFactory_GLVertexShader;
        }());
        framework.AssetFactory_GLVertexShader = AssetFactory_GLVertexShader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactoryTools = (function () {
            function AssetFactoryTools() {
            }
            AssetFactoryTools.catchError = function (err, onstate, state) {
                if (err != null) {
                    state.iserror = true;
                    state.errs.push(new Error(err.message));
                    onstate(state);
                    return true;
                }
                return false;
            };
            AssetFactoryTools.useAsset = function (assetMgr, onstate, state, asset, url) {
                var fileName = getFileName(url);
                assetMgr.setAssetUrl(asset, url);
                assetMgr.use(asset);
                state.resstate[fileName].state = 1;
                state.resstate[fileName].res = asset;
                onstate(state);
            };
            AssetFactoryTools.onProgress = function (loadedLength, totalLength, onstate, state, filename) {
                state.resstate[filename].loadedLength = loadedLength;
                state.progressCall = true;
                onstate(state);
            };
            AssetFactoryTools.onRefProgress = function (loadedLength, totalLength, onstate, state, filename) {
                var _restate = state.resstate[filename];
                _restate.refLoadedLength = loadedLength;
                state.progressCall = true;
                onstate(state);
            };
            return AssetFactoryTools;
        }());
        framework.AssetFactoryTools = AssetFactoryTools;
        function getFileName(url) {
            var filei = url.lastIndexOf("/");
            var file = url.substr(filei + 1);
            return file;
        }
        framework.getFileName = getFileName;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_KeyframeAnimationPathAsset = (function () {
            function AssetFactory_KeyframeAnimationPathAsset() {
            }
            AssetFactory_KeyframeAnimationPathAsset.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_KeyframeAnimationPathAsset.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _keyframepath = asset ? asset : new framework.keyframeAnimationPathAsset(filename);
                    _keyframepath.Parse(JSON.parse(txt));
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _keyframepath, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_KeyframeAnimationPathAsset.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                var _keyframepath = asset ? asset : new framework.keyframeAnimationPathAsset(filename);
                _keyframepath.Parse(JSON.parse(txt));
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _keyframepath, url);
            };
            return AssetFactory_KeyframeAnimationPathAsset;
        }());
        framework.AssetFactory_KeyframeAnimationPathAsset = AssetFactory_KeyframeAnimationPathAsset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Material = (function () {
            function AssetFactory_Material() {
            }
            AssetFactory_Material.prototype.newAsset = function (filename) {
                return null;
            };
            AssetFactory_Material.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                var assetbundleName = framework.getFileName(state.url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _material = asset ? asset : new framework.material(filename);
                    _material.Parse(assetMgr, JSON.parse(txt), assetbundleName);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _material, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Material.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                var assetbundleName = framework.getFileName(state.url);
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                var _material = asset ? asset : new framework.material(filename);
                _material.Parse(assetMgr, JSON.parse(txt), assetbundleName);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _material, url);
            };
            return AssetFactory_Material;
        }());
        framework.AssetFactory_Material = AssetFactory_Material;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Mesh = (function () {
            function AssetFactory_Mesh() {
            }
            AssetFactory_Mesh.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Mesh.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadArrayBuffer(url, function (_buffer, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _mesh = asset ? asset : new framework.mesh(filename);
                    _mesh.onReadFinish = function () {
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
                    };
                    _mesh.Parse(_buffer, assetMgr.webgl);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Mesh.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                var _buffer = respack[filename];
                var _mesh = asset ? asset : new framework.mesh(filename);
                _mesh.onReadFinish = function () {
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
                };
                _mesh.Parse(_buffer, assetMgr.webgl);
            };
            return AssetFactory_Mesh;
        }());
        framework.AssetFactory_Mesh = AssetFactory_Mesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_PathAsset = (function () {
            function AssetFactory_PathAsset() {
            }
            AssetFactory_PathAsset.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_PathAsset.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _path = asset ? asset : new framework.pathasset(filename);
                    _path.Parse(JSON.parse(txt));
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _path, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_PathAsset.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                var _path = asset ? asset : new framework.pathasset(filename);
                _path.Parse(JSON.parse(txt));
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _path, url);
            };
            return AssetFactory_PathAsset;
        }());
        framework.AssetFactory_PathAsset = AssetFactory_PathAsset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Prefab = (function () {
            function AssetFactory_Prefab() {
            }
            AssetFactory_Prefab.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Prefab.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var bundlename = framework.getFileName(state.url);
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _prefab = asset ? asset : new framework.prefab(filename);
                    _prefab.assetbundle = bundlename;
                    _prefab.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Prefab.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var bundlename = framework.getFileName(state.url);
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                var _prefab = asset ? asset : new framework.prefab(filename);
                _prefab.assetbundle = bundlename;
                _prefab.Parse(txt, assetMgr);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
            };
            return AssetFactory_Prefab;
        }());
        framework.AssetFactory_Prefab = AssetFactory_Prefab;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_PVR = (function () {
            function AssetFactory_PVR() {
            }
            AssetFactory_PVR.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_PVR.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadArrayBuffer(url, function (_buffer, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _texture = asset ? asset : new framework.texture(filename);
                    var pvr = new PvrParse(assetMgr.webgl);
                    _texture.glTexture = pvr.parse(_buffer);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_PVR.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
            };
            return AssetFactory_PVR;
        }());
        framework.AssetFactory_PVR = AssetFactory_PVR;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Scene = (function () {
            function AssetFactory_Scene() {
            }
            AssetFactory_Scene.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Scene.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var bundlename = framework.getFileName(state.url);
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _scene = asset ? asset : new framework.rawscene(filename);
                    _scene.assetbundle = bundlename;
                    _scene.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _scene, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Scene.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var bundlename = framework.getFileName(state.url);
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                var _scene = asset ? asset : new framework.rawscene(filename);
                _scene.assetbundle = bundlename;
                _scene.Parse(txt, assetMgr);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _scene, url);
            };
            return AssetFactory_Scene;
        }());
        framework.AssetFactory_Scene = AssetFactory_Scene;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Shader = (function () {
            function AssetFactory_Shader() {
            }
            AssetFactory_Shader.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Shader.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _shader = new framework.shader(filename);
                    try {
                        _shader.parse(assetMgr, JSON.parse(txt));
                    }
                    catch (e) {
                        console.error("error  filename :" + filename);
                        throw new Error("shader on parse");
                    }
                    assetMgr.setAssetUrl(_shader, url);
                    assetMgr.mapShader[filename] = _shader;
                    state.resstate[filename].state = 1;
                    onstate(state);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Shader.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                var name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                state.resstate[filename].state = 1;
                var _shader = new framework.shader(filename);
                try {
                    _shader.parse(assetMgr, JSON.parse(txt));
                }
                catch (e) {
                    console.error("error  filename :" + filename);
                    throw new Error("shader on parse");
                }
                assetMgr.setAssetUrl(_shader, url);
                assetMgr.mapShader[filename] = _shader;
                onstate(state);
            };
            return AssetFactory_Shader;
        }());
        framework.AssetFactory_Shader = AssetFactory_Shader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_TextAsset = (function () {
            function AssetFactory_TextAsset() {
            }
            AssetFactory_TextAsset.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_TextAsset.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _textasset = asset ? asset : new framework.textasset(filename);
                    _textasset.content = txt;
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _textasset, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_TextAsset.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                var txt = respack[filename];
                var _textasset = asset ? asset : new framework.textasset(filename);
                _textasset.content = txt;
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _textasset, url);
            };
            return AssetFactory_TextAsset;
        }());
        framework.AssetFactory_TextAsset = AssetFactory_TextAsset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_Texture = (function () {
            function AssetFactory_Texture() {
            }
            AssetFactory_Texture.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_Texture.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadImg(url, function (_tex, _err) {
                    if (framework.AssetFactoryTools.catchError(_err, onstate, state))
                        return;
                    var _texture = asset ? asset : new framework.texture(filename);
                    var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                    var t2d = new gd3d.render.glTexture2D(assetMgr.webgl, _textureFormat);
                    t2d.uploadImage(_tex, true, true, true, true);
                    _texture.glTexture = t2d;
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_Texture.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
            };
            return AssetFactory_Texture;
        }());
        framework.AssetFactory_Texture = AssetFactory_Texture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AssetFactory_TextureDesc = (function () {
            function AssetFactory_TextureDesc() {
            }
            AssetFactory_TextureDesc.prototype.newAsset = function () {
                return null;
            };
            AssetFactory_TextureDesc.prototype.load = function (url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                state.resstate[filename] = new framework.RefResourceState();
                gd3d.io.loadText(url, function (txt, err) {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _texturedesc = JSON.parse(txt);
                    var _name = _texturedesc["name"];
                    var _filterMode = _texturedesc["filterMode"];
                    var _format = _texturedesc["format"];
                    var _mipmap = _texturedesc["mipmap"];
                    var _wrap = _texturedesc["wrap"];
                    var _premultiplyAlpha = _texturedesc["premultiplyAlpha"];
                    if (_premultiplyAlpha == undefined) {
                        _premultiplyAlpha = true;
                    }
                    var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                    if (_format == "RGB")
                        _textureFormat = gd3d.render.TextureFormatEnum.RGB;
                    else if (_format == "Gray")
                        _textureFormat = gd3d.render.TextureFormatEnum.Gray;
                    var _linear = true;
                    if (_filterMode.indexOf("linear") < 0)
                        _linear = false;
                    var _repeat = false;
                    if (_wrap.indexOf("Repeat") >= 0)
                        _repeat = true;
                    var _textureSrc = url.replace(filename, _name);
                    if (_textureSrc.indexOf(".pvr.bin") >= 0) {
                        gd3d.io.loadArrayBuffer(_textureSrc, function (_buffer, err) {
                            if (framework.AssetFactoryTools.catchError(err, onstate, state))
                                return;
                            var _texture = asset ? asset : new framework.texture(filename);
                            var pvr = new PvrParse(assetMgr.webgl);
                            _texture.glTexture = pvr.parse(_buffer);
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                        }, function (loadedLength, totalLength) {
                            framework.AssetFactoryTools.onRefProgress(loadedLength, totalLength, onstate, state, filename);
                        });
                    }
                    else if (_textureSrc.indexOf(".dds.bin") >= 0) {
                        gd3d.io.loadArrayBuffer(_textureSrc, function (_buffer, err) {
                            if (framework.AssetFactoryTools.catchError(err, onstate, state))
                                return;
                            var _texture = asset ? asset : new framework.texture(filename);
                            assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                            var textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
                            textureUtil.loadDDS(_textureSrc, null, function (texture, error, stats) {
                                var t2d = new gd3d.render.glTexture2D(assetMgr.webgl);
                                t2d.format = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                                t2d.texture = texture;
                                _texture.glTexture = t2d;
                            });
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                        }, function (loadedLength, totalLength) {
                            framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                        });
                    }
                    else {
                        gd3d.io.loadImg(_textureSrc, function (_tex, _err) {
                            if (framework.AssetFactoryTools.catchError(_err, onstate, state))
                                return;
                            var _texture = asset ? asset : new framework.texture(filename);
                            _texture.realName = _name;
                            var t2d = new gd3d.render.glTexture2D(assetMgr.webgl, _textureFormat);
                            t2d.uploadImage(_tex, _mipmap, _linear, _premultiplyAlpha, _repeat);
                            _texture.glTexture = t2d;
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                        }, function (loadedLength, totalLength) {
                            framework.AssetFactoryTools.onRefProgress(loadedLength, totalLength, onstate, state, filename);
                        });
                    }
                }, function (loadedLength, totalLength) {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            };
            AssetFactory_TextureDesc.prototype.loadByPack = function (respack, url, onstate, state, assetMgr, asset) {
                var filename = framework.getFileName(url);
                var txt = respack[filename];
                var _texturedesc = JSON.parse(txt);
                var _name = _texturedesc["name"];
                var _filterMode = _texturedesc["filterMode"];
                var _format = _texturedesc["format"];
                var _mipmap = _texturedesc["mipmap"];
                var _wrap = _texturedesc["wrap"];
                var _premultiplyAlpha = _texturedesc["premultiplyAlpha"];
                if (_premultiplyAlpha == undefined) {
                    _premultiplyAlpha = true;
                }
                var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                if (_format == "RGB") {
                    _textureFormat = gd3d.render.TextureFormatEnum.RGB;
                }
                else if (_format == "Gray") {
                    _textureFormat = gd3d.render.TextureFormatEnum.Gray;
                }
                var _linear = true;
                if (_filterMode.indexOf("linear") < 0) {
                    _linear = false;
                }
                var _repeat = false;
                if (_wrap.indexOf("Repeat") >= 0) {
                    _repeat = true;
                }
                var _textureSrc = url.replace(filename, _name);
                state.resstate[filename] = new framework.ResourceState();
                if (_textureSrc.indexOf(".pvr.bin") >= 0) {
                    gd3d.io.loadArrayBuffer(_textureSrc, function (_buffer, err) {
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _texture = asset ? asset : new framework.texture(filename);
                        var pvr = new PvrParse(assetMgr.webgl);
                        console.log(_textureSrc);
                        _texture.glTexture = pvr.parse(_buffer);
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                    }, function (loadedLength, totalLength) {
                        framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    });
                }
                else if (_textureSrc.indexOf(".dds.bin") >= 0) {
                    gd3d.io.loadArrayBuffer(_textureSrc, function (_buffer, err) {
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        var _texture = asset ? asset : new framework.texture(filename);
                        assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                        var textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
                        textureUtil.loadDDS(_textureSrc, null, function (texture, error, stats) {
                            var t2d = new gd3d.render.glTexture2D(assetMgr.webgl);
                            t2d.format = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                            t2d.texture = texture;
                            _texture.glTexture = t2d;
                        });
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                    }, function (loadedLength, totalLength) {
                        framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    });
                }
                else {
                    gd3d.io.loadImg(_textureSrc, function (_tex, _err) {
                        if (framework.AssetFactoryTools.catchError(_err, onstate, state))
                            return;
                        var _texture = asset ? asset : new framework.texture(filename);
                        _texture.realName = _name;
                        var t2d = new gd3d.render.glTexture2D(assetMgr.webgl, _textureFormat);
                        t2d.uploadImage(_tex, _mipmap, _linear, _premultiplyAlpha, _repeat);
                        _texture.glTexture = t2d;
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                    }, function (loadedLength, totalLength) {
                        framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    });
                }
            };
            return AssetFactory_TextureDesc;
        }());
        framework.AssetFactory_TextureDesc = AssetFactory_TextureDesc;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var animationClip = (function () {
            function animationClip(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.frames = {};
                if (!assetName) {
                    assetName = "animationClip_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            animationClip.prototype.getName = function () {
                return this.name.getText();
            };
            animationClip.prototype.getGUID = function () {
                return this.id.getID();
            };
            animationClip.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            animationClip.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            animationClip.prototype.dispose = function () {
                this.bones.length = 0;
                this.subclips.length = 0;
                delete this.frames;
            };
            animationClip.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.bones) {
                    total += gd3d.math.caclStringByteLength(this.bones[k]);
                }
                for (var k in this.frames) {
                    total += this.frames[k].byteLength;
                    total += gd3d.math.caclStringByteLength(k);
                }
                total += subClip.caclByteLength() * this.subclips.length;
                return total;
            };
            animationClip.prototype.Parse = function (buf) {
                var read = new gd3d.io.binReader(buf);
                var _name = read.readStringAnsi();
                this.fps = read.readFloat();
                this.loop = read.readBoolean();
                this.boneCount = read.readInt();
                this.bones = [];
                for (var i = 0; i < this.boneCount; i++) {
                    this.bones.push(read.readStringAnsi());
                }
                this.subclipCount = read.readInt();
                this.subclips = [];
                for (var i = 0; i < this.subclipCount; i++) {
                    var _subClip = new subClip();
                    _subClip.name = read.readStringAnsi();
                    _subClip.loop = read.readBoolean();
                    this.subclips.push(_subClip);
                }
                this.frameCount = read.readInt();
                this.frames = {};
                for (var i = 0; i < this.frameCount; i++) {
                    var _fid = read.readInt().toString();
                    var _key = read.readBoolean();
                    var _frame = new Float32Array(this.boneCount * 7 + 1);
                    _frame[0] = _key ? 1 : 0;
                    var _boneInfo = new PoseBoneMatrix();
                    for (var i_2 = 0; i_2 < this.boneCount; i_2++) {
                        _boneInfo.load(read);
                        _frame[i_2 * 7 + 1] = _boneInfo.r.x;
                        _frame[i_2 * 7 + 2] = _boneInfo.r.y;
                        _frame[i_2 * 7 + 3] = _boneInfo.r.z;
                        _frame[i_2 * 7 + 4] = _boneInfo.r.w;
                        _frame[i_2 * 7 + 5] = _boneInfo.t.x;
                        _frame[i_2 * 7 + 6] = _boneInfo.t.y;
                        _frame[i_2 * 7 + 7] = _boneInfo.t.z;
                    }
                    this.frames[_fid] = _frame;
                }
                buf = null;
            };
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], animationClip.prototype, "name", void 0);
            animationClip = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], animationClip);
            return animationClip;
        }());
        framework.animationClip = animationClip;
        var PoseBoneMatrix = (function () {
            function PoseBoneMatrix() {
            }
            PoseBoneMatrix_1 = PoseBoneMatrix;
            PoseBoneMatrix.caclByteLength = function () {
                var total = 12 + 16;
                return total;
            };
            PoseBoneMatrix.prototype.Clone = function () {
                var p = new PoseBoneMatrix_1();
                p.t = new gd3d.math.vector3();
                p.r = new gd3d.math.quaternion();
                gd3d.math.vec3Clone(this.t, p.t);
                gd3d.math.quatClone(this.r, p.r);
                return p;
            };
            PoseBoneMatrix.prototype.load = function (read) {
                {
                    var x = read.readSingle();
                    var y = read.readSingle();
                    var z = read.readSingle();
                    var w = read.readSingle();
                    this.r = new gd3d.math.quaternion(x, y, z, w);
                }
                {
                    var x = read.readSingle();
                    var y = read.readSingle();
                    var z = read.readSingle();
                    this.t = new gd3d.math.vector3(x, y, z);
                }
            };
            PoseBoneMatrix.createDefault = function () {
                var pt = new PoseBoneMatrix_1();
                pt.r = new gd3d.math.quaternion(0, 0, 0, 1);
                pt.t = new gd3d.math.vector3(0, 0, 0);
                return pt;
            };
            PoseBoneMatrix.prototype.copyFrom = function (src) {
                this.r.x = src.r.x;
                this.r.y = src.r.y;
                this.r.z = src.r.z;
                this.r.w = src.r.w;
                this.t.x = src.t.x;
                this.t.y = src.t.y;
                this.t.z = src.t.z;
            };
            PoseBoneMatrix.prototype.copyFromData = function (src, seek) {
                this.r.x = src[seek + 0];
                this.r.y = src[seek + 1];
                this.r.z = src[seek + 2];
                this.r.w = src[seek + 3];
                this.t.x = src[seek + 4];
                this.t.y = src[seek + 5];
                this.t.z = src[seek + 6];
            };
            PoseBoneMatrix.prototype.invert = function () {
                gd3d.math.quatInverse(this.r, this.r);
                gd3d.math.quatTransformVector(this.r, this.t, this.t);
                this.t.x *= -1;
                this.t.y *= -1;
                this.t.z *= -1;
            };
            PoseBoneMatrix.prototype.lerpInWorld = function (_tpose, from, to, v) {
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiply(to, _tpose);
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            };
            PoseBoneMatrix.prototype.lerpInWorldWithData = function (_tpose, from, todata, toseek, v) {
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiplyDataAndMatrix(todata, toseek, _tpose);
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            };
            PoseBoneMatrix.sMultiply = function (left, right, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(right.t, dir);
                var dirtran = gd3d.math.pool.new_vector3();
                gd3d.math.quatTransformVector(left.r, dir, dirtran);
                target.t.x = dirtran.x + left.t.x;
                target.t.y = dirtran.y + left.t.y;
                target.t.z = dirtran.z + left.t.z;
                gd3d.math.quatMultiply(left.r, right.r, target.r);
                gd3d.math.pool.delete_vector3(dir);
                gd3d.math.pool.delete_vector3(dirtran);
                return target;
            };
            PoseBoneMatrix.sMultiplyDataAndMatrix = function (leftdata, leftseek, right, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(right.t, dir);
                var dirtran = gd3d.math.pool.new_vector3();
                gd3d.math.quatTransformVectorDataAndQuat(leftdata, leftseek + 0, dir, dirtran);
                target.t.x = dirtran.x + leftdata[leftseek + 4];
                target.t.y = dirtran.y + leftdata[leftseek + 5];
                target.t.z = dirtran.z + leftdata[leftseek + 6];
                gd3d.math.quatMultiplyDataAndQuat(leftdata, leftseek + 0, right.r, target.r);
                gd3d.math.pool.delete_vector3(dir);
                gd3d.math.pool.delete_vector3(dirtran);
                return target;
            };
            PoseBoneMatrix.sLerp = function (left, right, v, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                target.t.x = left.t.x * (1 - v) + right.t.x * v;
                target.t.y = left.t.y * (1 - v) + right.t.y * v;
                target.t.z = left.t.z * (1 - v) + right.t.z * v;
                gd3d.math.quatLerp(left.r, right.r, target.r, v);
                return target;
            };
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3)
            ], PoseBoneMatrix.prototype, "t", void 0);
            __decorate([
                gd3d.reflect.Field("quaternion"),
                __metadata("design:type", gd3d.math.quaternion)
            ], PoseBoneMatrix.prototype, "r", void 0);
            PoseBoneMatrix = PoseBoneMatrix_1 = __decorate([
                gd3d.reflect.SerializeType
            ], PoseBoneMatrix);
            return PoseBoneMatrix;
            var PoseBoneMatrix_1;
        }());
        framework.PoseBoneMatrix = PoseBoneMatrix;
        var subClip = (function () {
            function subClip() {
            }
            subClip.caclByteLength = function () {
                var total = 0;
                total += gd3d.math.caclStringByteLength(name);
                total += 1;
                total += 8;
                return total;
            };
            return subClip;
        }());
        framework.subClip = subClip;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var atlas = (function () {
            function atlas(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.sprites = {};
                if (!assetName) {
                    assetName = "atlas_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            atlas.prototype.getName = function () {
                return this.name.getText();
            };
            atlas.prototype.getGUID = function () {
                return this.id.getID();
            };
            atlas.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            atlas.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            atlas.prototype.dispose = function () {
                for (var key in this.sprites) {
                    this.sprites[key].unuse();
                }
                this.texture.unuse();
                delete this.sprites;
            };
            atlas.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.sprites) {
                    total += this.sprites[k].caclByteLength();
                    total += gd3d.math.caclStringByteLength(k);
                }
                return total;
            };
            Object.defineProperty(atlas.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            atlas.prototype.Parse = function (jsonStr, assetmgr) {
                var json = JSON.parse(jsonStr);
                var name = json["t"];
                this.texturewidth = json["w"];
                this.textureheight = json["h"];
                var s = json["s"];
                this.texture = assetmgr.getAssetByName(name);
                if (this.texture == null) {
                    console.log("atlas的图片名字不对");
                }
                for (var i in s) {
                    var ss = s[i];
                    var spriteName = ss[0];
                    var r = new framework.sprite(this.getName() + "_" + spriteName);
                    assetmgr.use(r);
                    if (this.texture) {
                        r.texture = this.texture;
                    }
                    r.rect = new gd3d.math.rect(ss[1], ss[2], ss[3], ss[4]);
                    r.border = new gd3d.math.border(0, 0, 0, 0);
                    r.atlas = this.getName();
                    this.sprites[spriteName] = r;
                }
            };
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], atlas.prototype, "name", void 0);
            atlas = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], atlas);
            return atlas;
        }());
        framework.atlas = atlas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var f14node = (function () {
            function f14node() {
            }
            return f14node;
        }());
        framework.f14node = f14node;
        var f14eff = (function () {
            function f14eff(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.defaultAsset = false;
                this.name = null;
                this.id = new framework.resID();
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "f14eff_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            f14eff.prototype.getName = function () {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            };
            f14eff.prototype.getGUID = function () {
                return this.id.getID();
            };
            f14eff.prototype.use = function () {
            };
            f14eff.prototype.unuse = function (disposeNow) {
            };
            f14eff.prototype.dispose = function () {
            };
            f14eff.prototype.caclByteLength = function () {
                return 0;
            };
            f14eff.prototype.Parse = function (jsonStr, assetmgr) {
                var json = JSON.parse(jsonStr);
                this.data = new framework.F14EffectData();
                this.data.parsejson(json, assetmgr, this.assetbundle);
            };
            f14eff = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], f14eff);
            return f14eff;
        }());
        framework.f14eff = f14eff;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var font = (function () {
            function font(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                if (!assetName) {
                    assetName = "font_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            font.prototype.getName = function () {
                return this.name.getText();
            };
            font.prototype.getGUID = function () {
                return this.id.getID();
            };
            font.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            font.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            font.prototype.dispose = function () {
                if (this.texture) {
                    this.texture.unuse(true);
                }
                delete this.cmap;
            };
            font.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.cmap) {
                    total += gd3d.math.caclStringByteLength(k);
                    total += charinfo.caclByteLength();
                }
                return total;
            };
            Object.defineProperty(font.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            font.prototype.Parse = function (jsonStr, assetmgr) {
                var d1 = new Date().valueOf();
                var json = JSON.parse(jsonStr);
                var font = json["font"];
                this.fontname = font[0];
                var picName = font[1];
                this.texture = assetmgr.getAssetByName(picName);
                this.pointSize = font[2];
                this.padding = font[3];
                this.lineHeight = font[4];
                this.baseline = font[5];
                this.atlasWidth = font[6];
                this.atlasHeight = font[7];
                this.cmap = {};
                var map = json["map"];
                for (var c in map) {
                    var finfo = new charinfo();
                    this.cmap[c] = finfo;
                    finfo.x = (map[c][0] - 0.5) / this.atlasWidth;
                    finfo.y = (map[c][1] - 0.5) / this.atlasHeight;
                    finfo.w = (map[c][2] + 1.0) / this.atlasWidth;
                    finfo.h = (map[c][3] + 1.0) / this.atlasHeight;
                    finfo.xSize = map[c][2];
                    finfo.ySize = map[c][3];
                    finfo.xOffset = map[c][4];
                    finfo.yOffset = map[c][5];
                    finfo.xAddvance = map[c][6];
                }
                map = null;
                json = null;
                var d2 = new Date().valueOf();
                var n = d2 - d1;
            };
            font = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], font);
            return font;
        }());
        framework.font = font;
        var charinfo = (function () {
            function charinfo() {
            }
            charinfo.caclByteLength = function () {
                return 36;
            };
            return charinfo;
        }());
        framework.charinfo = charinfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var keyframeAnimationPathAsset = (function () {
            function keyframeAnimationPathAsset(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.beloop = false;
                this.positionitems = [];
                this.rotationitmes = [];
                this.pathdata = {};
                if (!assetName) {
                    assetName = "keyframepath_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            keyframeAnimationPathAsset.prototype.getName = function () {
                return this.name.getText();
            };
            keyframeAnimationPathAsset.prototype.getGUID = function () {
                return this.id.getID();
            };
            keyframeAnimationPathAsset.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            keyframeAnimationPathAsset.prototype.Parse = function (json) {
                var isloop = json["isLoop"];
                if (isloop == "True") {
                    this.beloop = true;
                }
                else {
                    this.beloop = false;
                }
                this.timeLength = json["timeLength"];
                this.frameRate = json["frameRate"];
                var position = json["position"];
                for (var key in position) {
                    var item = new keyframepathpositionitem();
                    var pointnode = position[key];
                    item.time = pointnode["time"];
                    var itemposition = pointnode["position"];
                    var arr = itemposition.split(",");
                    item.position = new gd3d.math.vector3(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]));
                    this.positionitems.push(item);
                }
                var rotation = json["rotation"];
                for (var key in rotation) {
                    var item1 = new keyframepathrotationitem();
                    var rotationnode = rotation[key];
                    item1.time = rotationnode["time"];
                    var itemrotation = rotationnode["rotation"];
                    var arr1 = itemrotation.split(",");
                    item1.rotation = new gd3d.math.quaternion(parseFloat(arr1[0]), parseFloat(arr1[1]), parseFloat(arr1[2]), parseFloat(arr1[3]));
                    this.rotationitmes.push(item1);
                }
                var children = json["children"];
                for (var i = 0; i < children.length; i++) {
                    var childname = children[i]["name"];
                    var childpathdata = new pathData();
                    var position_1 = children[i]["position"];
                    for (var key in position_1) {
                        var item_1 = new keyframepathpositionitem();
                        var positionnode = position_1[key];
                        item_1.time = positionnode["time"];
                        var itemposition = positionnode["position"];
                        var arr_1 = itemposition.split(",");
                        item_1.position = new gd3d.math.vector3(parseFloat(arr_1[0]), parseFloat(arr_1[1]), parseFloat(arr_1[2]));
                        childpathdata.positions.push(item_1);
                    }
                    var rotation_1 = children[i]["rotation"];
                    for (var key in rotation_1) {
                        var item_2 = new keyframepathrotationitem();
                        var rotationnode = rotation_1[key];
                        item_2.time = rotationnode["time"];
                        var itemrotation = rotationnode["rotation"];
                        var arr_2 = itemrotation.split(",");
                        item_2.rotation = new gd3d.math.quaternion(parseFloat(arr_2[0]), parseFloat(arr_2[1]), parseFloat(arr_2[2]), parseFloat(arr_2[3]));
                        childpathdata.rotations.push(item_2);
                    }
                    this.pathdata[childname] = childpathdata;
                    var nextchildren = children[i]["children"];
                    this.addPathData(nextchildren);
                }
            };
            keyframeAnimationPathAsset.prototype.addPathData = function (children) {
                for (var i = 0; i < children.length; i++) {
                    var childname = children[i]["name"];
                    var childpathdata = new pathData();
                    childpathdata.name = childname;
                    var position = children[i]["position"];
                    for (var key in position) {
                        var item = new keyframepathpositionitem();
                        var positionnode = position[key];
                        item.time = positionnode["time"];
                        var itemposition = positionnode["position"];
                        var arr = itemposition.split(",");
                        item.position = new gd3d.math.vector3(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]));
                        childpathdata.positions.push(item);
                    }
                    var rotation = children[i]["rotation"];
                    for (var key in rotation) {
                        var item = new keyframepathrotationitem();
                        var rotationnode = rotation[key];
                        item.time = rotationnode["time"];
                        var itemrotation = rotationnode["rotation"];
                        var arr = itemrotation.split(",");
                        item.rotation = new gd3d.math.quaternion(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]), parseFloat(arr[3]));
                        childpathdata.rotations.push(item);
                    }
                    this.pathdata[childname] = childpathdata;
                    var nextchildren = children[i]["children"];
                    this.addPathData(nextchildren);
                }
            };
            keyframeAnimationPathAsset.prototype.unuse = function () {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            };
            keyframeAnimationPathAsset.prototype.dispose = function () {
                this.positionitems.length = 0;
                this.rotationitmes.length = 0;
            };
            keyframeAnimationPathAsset.prototype.caclByteLength = function () {
                var number = 0;
                if (this.positionitems) {
                    number += this.positionitems.length * 16;
                }
                if (this.rotationitmes) {
                    number += this.rotationitmes.length * 20;
                }
                return number;
            };
            __decorate([
                gd3d.reflect.Field("ConstText"),
                __metadata("design:type", framework.constText)
            ], keyframeAnimationPathAsset.prototype, "name", void 0);
            keyframeAnimationPathAsset = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], keyframeAnimationPathAsset);
            return keyframeAnimationPathAsset;
        }());
        framework.keyframeAnimationPathAsset = keyframeAnimationPathAsset;
        var keyframepathpositionitem = (function () {
            function keyframepathpositionitem() {
            }
            return keyframepathpositionitem;
        }());
        framework.keyframepathpositionitem = keyframepathpositionitem;
        var keyframepathrotationitem = (function () {
            function keyframepathrotationitem() {
            }
            return keyframepathrotationitem;
        }());
        framework.keyframepathrotationitem = keyframepathrotationitem;
        var children = (function () {
            function children() {
                this.position = [];
                this.rotation = [];
                this.children = [];
            }
            return children;
        }());
        framework.children = children;
        var pathData = (function () {
            function pathData() {
                this.positions = [];
                this.rotations = [];
            }
            return pathData;
        }());
        framework.pathData = pathData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var UniformData = (function () {
            function UniformData(type, value, defaultValue) {
                if (defaultValue === void 0) { defaultValue = null; }
                this.type = type;
                this.value = value;
                this.defaultValue = defaultValue;
            }
            __decorate([
                gd3d.reflect.Field("number"),
                gd3d.reflect.UIStyle("UniformTypeEnum"),
                __metadata("design:type", Number)
            ], UniformData.prototype, "type", void 0);
            __decorate([
                gd3d.reflect.Field("any"),
                __metadata("design:type", Object)
            ], UniformData.prototype, "value", void 0);
            UniformData = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Object, Object])
            ], UniformData);
            return UniformData;
        }());
        framework.UniformData = UniformData;
        var material = (function () {
            function material(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.name = null;
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.queue = 0;
                this.statedMapUniforms = {};
                if (!assetName) {
                    assetName = "material_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
                gd3d.io.enumMgr.enumMap["UniformTypeEnum"] = gd3d.render.UniformTypeEnum;
            }
            material_1 = material;
            material.prototype.getName = function () {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            };
            material.prototype.getGUID = function () {
                return this.id.getID();
            };
            material.prototype.dispose = function () {
                for (var id in this.statedMapUniforms) {
                    switch (this.defaultMapUniform[id].type) {
                        case gd3d.render.UniformTypeEnum.Texture:
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            if (this.statedMapUniforms[id] != null)
                                this.statedMapUniforms[id].unuse(true);
                            break;
                    }
                }
                delete this.statedMapUniforms;
            };
            material.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            material.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            material.prototype.caclByteLength = function () {
                var total = 0;
                if (this.shader) {
                    total += this.shader.caclByteLength();
                }
                for (var k in this.statedMapUniforms) {
                    var type = this.defaultMapUniform[k].type;
                    var value = this.statedMapUniforms[k].value;
                    var defaultValue = this.defaultMapUniform[k].value;
                    switch (type) {
                        case gd3d.render.UniformTypeEnum.Float:
                            total += 4;
                            break;
                        case gd3d.render.UniformTypeEnum.Floatv:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            total += 16;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4v:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4:
                            total += 64;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4v:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Texture:
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            if (value != null) {
                                total += value.caclByteLength();
                            }
                            else if (defaultValue != null) {
                                total += defaultValue.caclByteLength();
                            }
                            break;
                    }
                }
                return total;
            };
            material.prototype.uploadUnifoms = function (pass, context) {
                gd3d.render.shaderUniform.texindex = 0;
                for (var key in pass.mapuniforms) {
                    var unifom = pass.mapuniforms[key];
                    var func = gd3d.render.shaderUniform.applyuniformFunc[unifom.type];
                    var unifomValue = void 0;
                    if (framework.uniformSetter.autoUniformDic[unifom.name] != null) {
                        var autoFunc = framework.uniformSetter.autoUniformDic[unifom.name];
                        unifomValue = autoFunc(context);
                    }
                    else {
                        if (this.statedMapUniforms[unifom.name] != null) {
                            unifomValue = this.statedMapUniforms[unifom.name];
                        }
                        else if (this.defaultMapUniform[unifom.name]) {
                            unifomValue = this.defaultMapUniform[unifom.name].value;
                        }
                        else {
                            console.error("Uniform don't be setted or have def value. uniform:" + unifom.name + "mat:" + this.getName());
                        }
                    }
                    func(unifom.location, unifomValue);
                }
            };
            material.prototype.setShader = function (shader) {
                this.shader = shader;
                this.defaultMapUniform = shader.defaultMapUniform;
            };
            material.prototype.getLayer = function () {
                return this.shader.layer;
            };
            material.prototype.getQueue = function () {
                return this.queue;
            };
            material.prototype.setQueue = function (queue) {
                this.queue = queue;
            };
            material.prototype.getShader = function () {
                return this.shader;
            };
            material.prototype.setFloat = function (_id, _number) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float) {
                    this.statedMapUniforms[_id] = _number;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setFloatv = function (_id, _numbers) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Floatv) {
                    this.statedMapUniforms[_id] = _numbers;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setVector4 = function (_id, _vector4) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4) {
                    this.statedMapUniforms[_id] = _vector4;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setVector4v = function (_id, _vector4v) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4v) {
                    this.statedMapUniforms[_id] = _vector4v;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setMatrix = function (_id, _matrix) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4x4) {
                    this.statedMapUniforms[_id] = _matrix;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setMatrixv = function (_id, _matrixv) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4x4v) {
                    this.statedMapUniforms[_id] = _matrixv;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setTexture = function (_id, _texture, resname) {
                if (resname === void 0) { resname = ""; }
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Texture) {
                    if (this.statedMapUniforms[_id] != null && (!this.statedMapUniforms[_id].defaultAsset)) {
                        this.statedMapUniforms[_id].unuse();
                    }
                    this.statedMapUniforms[_id] = _texture;
                    if (_texture != null) {
                        if (_texture.getName() == "_color") {
                            _texture;
                        }
                        if (!_texture.defaultAsset) {
                            _texture.use();
                        }
                        var _texelsizeName = _id + "_TexelSize";
                        var _gltexture = _texture.glTexture;
                        if (_gltexture != null && this.defaultMapUniform[_texelsizeName] != null) {
                            this.setVector4(_texelsizeName, new gd3d.math.vector4(1.0 / _gltexture.width, 1.0 / _gltexture.height, _gltexture.width, _gltexture.height));
                        }
                    }
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.setCubeTexture = function (_id, _texture) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.CubeTexture) {
                    if (this.statedMapUniforms[_id] != null && (!this.statedMapUniforms[_id].defaultAsset)) {
                        this.statedMapUniforms[_id].unuse();
                    }
                    this.statedMapUniforms[_id] = _texture;
                    if (_texture != null) {
                        if (!_texture.defaultAsset) {
                            _texture.use();
                        }
                        var _texelsizeName = _id + "_TexelSize";
                        var _gltexture = _texture.glTexture;
                        if (_gltexture != null) {
                            this.setVector4(_texelsizeName, new gd3d.math.vector4(1.0 / _gltexture.width, 1.0 / _gltexture.height, _gltexture.width, _gltexture.height));
                        }
                    }
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            material.prototype.draw = function (context, mesh, sm, basetype, useGLobalLightMap) {
                if (basetype === void 0) { basetype = "base"; }
                if (useGLobalLightMap === void 0) { useGLobalLightMap = true; }
                var drawPasses = this.shader.passes[basetype + context.drawtype];
                if (drawPasses == undefined) {
                    basetype = basetype.indexOf("fog") != -1 ? "base_fog" : "base";
                    drawPasses = this.shader.passes[basetype + context.drawtype];
                    if (drawPasses == undefined) {
                        drawPasses = this.shader.passes["base" + context.drawtype];
                        if (drawPasses == undefined)
                            return;
                    }
                }
                for (var i = 0; i < drawPasses.length; i++) {
                    var pass = drawPasses[i];
                    pass.use(context.webgl);
                    this.uploadUnifoms(pass, context);
                    mesh.glMesh.bind(context.webgl, pass.program, sm.useVertexIndex);
                    if (sm.useVertexIndex < 0) {
                        if (sm.line) {
                            mesh.glMesh.drawArrayLines(context.webgl, sm.start, sm.size);
                        }
                        else {
                            mesh.glMesh.drawArrayTris(context.webgl, sm.start, sm.size);
                        }
                    }
                    else {
                        if (sm.line) {
                            mesh.glMesh.drawElementLines(context.webgl, sm.start, sm.size);
                        }
                        else {
                            mesh.glMesh.drawElementTris(context.webgl, sm.start, sm.size);
                        }
                    }
                }
            };
            material.prototype.Parse = function (assetmgr, json, bundleName) {
                if (bundleName === void 0) { bundleName = null; }
                var shaderName = json["shader"];
                var shader = assetmgr.getShader(shaderName);
                if (shader == null) {
                    console.error("shader 为空！shadername：" + shaderName + " bundleName: " + bundleName);
                }
                this.setShader(shader);
                var queue = json["queue"];
                if (queue) {
                    this.queue = queue;
                }
                var mapUniform = json["mapUniform"];
                for (var i in mapUniform) {
                    var jsonChild = mapUniform[i];
                    var _uniformType = jsonChild["type"];
                    if (_uniformType == null)
                        continue;
                    switch (_uniformType) {
                        case gd3d.render.UniformTypeEnum.Texture:
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            var _value = jsonChild["value"];
                            var _texture = assetmgr.getAssetByName(_value, bundleName);
                            if (_texture == null) {
                                console.error("Material Mapuniform Texture 无效(" + _value + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            }
                            else {
                                this.setTexture(i, _texture, _value);
                            }
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            var _value = jsonChild["value"];
                            this.setFloat(i, parseFloat(_value));
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            var tempValue = jsonChild["value"];
                            try {
                                var values = tempValue.match(framework.RegexpUtil.vector4Regexp);
                                if (values != null) {
                                    var _float4 = new gd3d.math.vector4(parseFloat(values[1]), parseFloat(values[2]), parseFloat(values[3]), parseFloat(values[4]));
                                    this.setVector4(i, _float4);
                                }
                            }
                            catch (e) {
                                console.error("Material Mapuniform float4 无效:value (" + tempValue + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            }
                            break;
                        default:
                            console.error("Material Mapuniform 无效: 未识别类型(" + jsonChild["type"] + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            break;
                    }
                }
            };
            material.prototype.clone = function () {
                var mat = new material_1(this.getName());
                mat.setShader(this.shader);
                for (var i in this.statedMapUniforms) {
                    var _uniformType = this.statedMapUniforms[i].type;
                    var value = this.statedMapUniforms[i];
                    switch (_uniformType) {
                        case gd3d.render.UniformTypeEnum.Texture:
                            mat.setTexture(i, value);
                            break;
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            mat.setCubeTexture(i, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            mat.setFloat(i, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            mat.setVector4(i, value);
                            break;
                        default:
                            break;
                    }
                }
                return mat;
            };
            material.prototype.save = function () {
                var obj = {};
                obj["shader"] = this.shader.getName();
                obj["srcshader"] = "";
                obj["mapUniform"] = {};
                for (var item in this.statedMapUniforms) {
                    var __type = this.defaultMapUniform[item].type;
                    var val = this.statedMapUniforms;
                    var jsonValue = void 0;
                    switch (__type) {
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                        case gd3d.render.UniformTypeEnum.Texture:
                            jsonValue = "" + val.name.name;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            jsonValue = "(" + val.x + "," + val.y + "," + val.z + "," + val.w + ")";
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            jsonValue = val;
                            break;
                        default:
                            console.warn("\u65E0\u6CD5\u5B58\u50A8\u672A\u89E3\u6790\u7C7B\u578B:" + __type + "," + item);
                            continue;
                    }
                    obj["mapUniform"][item] = jsonValue;
                }
                return JSON.stringify(obj);
            };
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], material.prototype, "name", void 0);
            __decorate([
                gd3d.reflect.Field("shader"),
                __metadata("design:type", framework.shader)
            ], material.prototype, "shader", void 0);
            material = material_1 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], material);
            return material;
            var material_1;
        }());
        framework.material = material;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var mesh = (function () {
            function mesh(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.submesh = [];
                this.reading = false;
                if (!assetName) {
                    assetName = "mesh_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            mesh_1 = mesh;
            mesh.prototype.getName = function () {
                if (!this.name) {
                    return null;
                }
                return this.name.getText();
            };
            mesh.prototype.getGUID = function () {
                return this.id.getID();
            };
            mesh.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            mesh.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            mesh.prototype.dispose = function () {
                this.glMesh.dispose(framework.sceneMgr.app.getAssetMgr().webgl);
                this.data = null;
                delete this.submesh;
            };
            mesh.prototype.caclByteLength = function () {
                var total = 0;
                total += this.glMesh.caclByteLength();
                if (this.data) {
                    total += this.data.caclByteLength();
                }
                return total;
            };
            mesh.prototype.readProcess = function (read, data, objVF, vcount, vec10tpose, callback) {
                var _this = this;
                if (this.reading)
                    return;
                var tag = read.readUInt8();
                if (tag == 255) {
                    callback();
                    return;
                }
                if (tag == 1) {
                    if (data.pos == undefined) {
                        data.pos = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Position;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _position = new gd3d.math.vector3();
                        _position.x = read.readSingle();
                        _position.y = read.readSingle();
                        _position.z = read.readSingle();
                        data.pos.push(_position);
                    }
                }
                else if (tag == 2) {
                    if (data.color == undefined) {
                        data.color = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Color;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _color = new gd3d.math.color();
                        _color.a = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.r = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.g = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.b = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        data.color.push(_color);
                    }
                }
                else if (tag == 3) {
                    if (data.normal == undefined) {
                        data.normal = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Normal;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _normal = new gd3d.math.vector3();
                        _normal.x = read.readSingle();
                        _normal.y = read.readSingle();
                        _normal.z = read.readSingle();
                        data.normal.push(_normal);
                    }
                }
                else if (tag == 4) {
                    if (data.uv == undefined) {
                        data.uv = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.UV0;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var uv = new gd3d.math.vector2();
                        uv.x = read.readSingle();
                        uv.y = read.readSingle();
                        data.uv.push(uv);
                    }
                }
                else if (tag == 5) {
                    if (data.uv2 == undefined) {
                        data.uv2 = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.UV1;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var uv = new gd3d.math.vector2();
                        uv.x = read.readSingle();
                        uv.y = read.readSingle();
                        data.uv2.push(uv);
                    }
                }
                else if (tag == 6) {
                    for (var i = 0; i < vcount; i++) {
                        read.readSingle();
                        read.readSingle();
                    }
                }
                else if (tag == 7) {
                    if (data.tangent == undefined) {
                        data.tangent = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Tangent;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var tangent = new gd3d.math.vector3();
                        var x = read.readSingle();
                        var y = read.readSingle();
                        var z = read.readSingle();
                        var w = read.readSingle();
                        tangent.x = x / w;
                        tangent.y = y / w;
                        tangent.z = z / w;
                        data.tangent.push(tangent);
                    }
                }
                else if (tag == 8) {
                    for (var i = 0; i < vcount; i++) {
                        read.readSingle();
                        read.readSingle();
                    }
                }
                else if (tag == 16) {
                    var tposelen = read.readUInt8();
                    for (var i = 0; i < tposelen; i++) {
                        vec10tpose[i * 10 + 0] = read.readSingle();
                        vec10tpose[i * 10 + 1] = read.readSingle();
                        vec10tpose[i * 10 + 2] = read.readSingle();
                        vec10tpose[i * 10 + 3] = read.readSingle();
                        vec10tpose[i * 10 + 4] = read.readSingle();
                        vec10tpose[i * 10 + 5] = read.readSingle();
                        vec10tpose[i * 10 + 6] = read.readSingle();
                        vec10tpose[i * 10 + 7] = read.readSingle();
                        vec10tpose[i * 10 + 8] = read.readSingle();
                        vec10tpose[i * 10 + 9] = read.readSingle();
                    }
                }
                else if (tag == 17) {
                    if (data.blendIndex == undefined) {
                        data.blendIndex = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.BlendIndex4;
                    }
                    if (data.blendWeight == undefined) {
                        data.blendWeight = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.BlendWeight4;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _boneIndex = new gd3d.render.number4();
                        _boneIndex.v0 = read.readUInt32();
                        _boneIndex.v1 = read.readUInt32();
                        _boneIndex.v2 = read.readUInt32();
                        _boneIndex.v3 = read.readUInt32();
                        var _boneWeight = new gd3d.render.number4();
                        _boneWeight.v0 = read.readSingle();
                        _boneWeight.v1 = read.readSingle();
                        _boneWeight.v2 = read.readSingle();
                        _boneWeight.v3 = read.readSingle();
                        data.blendIndex.push(_boneIndex);
                        data.blendWeight.push(_boneWeight);
                    }
                }
                else {
                    throw "notwrite" + tag;
                }
                this.reading = false;
                setTimeout(function () {
                    _this.readProcess(read, data, objVF, vcount, vec10tpose, function () {
                        callback();
                    });
                });
            };
            mesh.prototype.readFinish = function (read, data, buf, objVF, webgl) {
                var subcount = read.readUInt8();
                data.trisindex = [];
                this.submesh = [];
                for (var i = 0; i < subcount; i++) {
                    var _submeshinfo = new subMeshInfo();
                    var tv = read.readUInt32();
                    var sublen = read.readUInt32();
                    _submeshinfo.start = data.trisindex.length;
                    _submeshinfo.size = sublen;
                    _submeshinfo.matIndex = i;
                    this.submesh.push(_submeshinfo);
                    for (var j = 0; j < sublen; j++) {
                        var index = read.readUInt32();
                        data.trisindex.push(index);
                    }
                }
                buf = null;
                data.originVF = objVF.vf;
                this.data = data;
                this.glMesh = new gd3d.render.glMesh();
                var vertexs = this.data.genVertexDataArray(objVF.vf);
                var indices = this.data.genIndexDataArray();
                this.glMesh.initBuffer(webgl, objVF.vf, this.data.pos.length);
                this.glMesh.uploadVertexData(webgl, vertexs);
                this.glMesh.addIndex(webgl, indices.length);
                this.glMesh.uploadIndexData(webgl, 0, indices);
                this.onReadFinish();
            };
            mesh.prototype.Parse = function (buf, webgl) {
                var _this = this;
                var objVF = { vf: 0 };
                var data = new gd3d.render.meshData();
                var read = new gd3d.io.binReader(buf);
                var meshName = read.readStringAnsi();
                read.position = read.position + 24;
                var vcount = read.readUInt32();
                var vec10tpose = [];
                this.readProcess(read, data, objVF, vcount, vec10tpose, function () {
                    _this.readFinish(read, data, buf, objVF, webgl);
                });
            };
            mesh.prototype.intersects = function (ray, matrix) {
                var pickinfo = null;
                if (!this.submesh)
                    return pickinfo;
                for (var i = 0; i < this.submesh.length; i++) {
                    var submesh = this.submesh[i];
                    if (submesh.line) {
                    }
                    else {
                        if (submesh.useVertexIndex < 0) {
                        }
                        else {
                            var t0 = gd3d.math.pool.new_vector3();
                            var t1 = gd3d.math.pool.new_vector3();
                            var t2 = gd3d.math.pool.new_vector3();
                            for (var index = submesh.start; index < submesh.size; index += 3) {
                                var p0 = this.data.pos[this.data.trisindex[index]];
                                var p1 = this.data.pos[this.data.trisindex[index + 1]];
                                var p2 = this.data.pos[this.data.trisindex[index + 2]];
                                gd3d.math.matrixTransformVector3(p0, matrix, t0);
                                gd3d.math.matrixTransformVector3(p1, matrix, t1);
                                gd3d.math.matrixTransformVector3(p2, matrix, t2);
                                var result = ray.intersectsTriangle(t0, t1, t2);
                                if (result) {
                                    if (result.distance < 0)
                                        continue;
                                    if (!pickinfo || pickinfo.distance > result.distance) {
                                        pickinfo = result;
                                        pickinfo.faceId = index / 3;
                                        pickinfo.subMeshId = i;
                                        var tdir = gd3d.math.pool.new_vector3();
                                        gd3d.math.vec3ScaleByNum(ray.direction, result.distance, tdir);
                                        gd3d.math.vec3Add(ray.origin, tdir, pickinfo.hitposition);
                                    }
                                }
                            }
                            gd3d.math.pool.delete_vector3(t0);
                            gd3d.math.pool.delete_vector3(t1);
                            gd3d.math.pool.delete_vector3(t2);
                        }
                    }
                }
                return pickinfo;
            };
            mesh.prototype.clone = function () {
                var _result = new mesh_1(this.getName());
                var vf = this.glMesh.vertexFormat;
                var data = new gd3d.render.meshData();
                if (this.data.pos != undefined) {
                    data.pos = [];
                    for (var i = 0; i < this.data.pos.length; i++) {
                        var _position = new gd3d.math.vector3();
                        _position.x = this.data.pos[i].x;
                        _position.y = this.data.pos[i].y;
                        _position.z = this.data.pos[i].z;
                        data.pos.push(_position);
                    }
                }
                if (this.data.color != undefined) {
                    data.color = [];
                    for (var i = 0; i < this.data.color.length; i++) {
                        var _color = new gd3d.math.color();
                        _color.a = this.data.color[i].a;
                        _color.r = this.data.color[i].r;
                        _color.g = this.data.color[i].g;
                        _color.b = this.data.color[i].b;
                        data.color.push(_color);
                    }
                }
                if (this.data.normal != undefined) {
                    data.normal = [];
                    for (var i = 0; i < this.data.normal.length; i++) {
                        var _normal = new gd3d.math.vector3();
                        _normal.x = this.data.normal[i].x;
                        _normal.y = this.data.normal[i].y;
                        _normal.z = this.data.normal[i].z;
                        data.normal.push(_normal);
                    }
                }
                if (this.data.uv != undefined) {
                    data.uv = [];
                    for (var i = 0; i < this.data.uv.length; i++) {
                        var uv = new gd3d.math.vector2();
                        uv.x = this.data.uv[i].x;
                        uv.y = this.data.uv[i].y;
                        data.uv.push(uv);
                    }
                }
                if (this.data.uv2 != undefined) {
                    data.uv2 = [];
                    for (var i = 0; i < this.data.uv2.length; i++) {
                        var uv = new gd3d.math.vector2();
                        uv.x = this.data.uv2[i].x;
                        uv.y = this.data.uv2[i].y;
                        data.uv2.push(uv);
                    }
                }
                if (this.data.tangent != undefined) {
                    data.tangent = [];
                    for (var i = 0; i < this.data.tangent.length; i++) {
                        var tangent = new gd3d.math.vector3();
                        tangent.x = this.data.tangent[i].x;
                        tangent.y = this.data.tangent[i].y;
                        tangent.z = this.data.tangent[i].z;
                        data.tangent.push(tangent);
                    }
                }
                if (this.data.blendIndex != undefined) {
                    data.blendIndex = [];
                    for (var i = 0; i < this.data.blendIndex.length; i++) {
                        var _boneIndex = new gd3d.render.number4();
                        _boneIndex.v0 = this.data.blendIndex[i].v0;
                        _boneIndex.v1 = this.data.blendIndex[i].v1;
                        _boneIndex.v2 = this.data.blendIndex[i].v2;
                        _boneIndex.v3 = this.data.blendIndex[i].v3;
                        data.blendIndex.push(_boneIndex);
                    }
                }
                if (this.data.blendWeight != undefined) {
                    data.blendWeight = [];
                    for (var i = 0; i < this.data.blendWeight.length; i++) {
                        var _boneWeight = new gd3d.render.number4();
                        _boneWeight.v0 = this.data.blendWeight[i].v0;
                        _boneWeight.v1 = this.data.blendWeight[i].v1;
                        _boneWeight.v2 = this.data.blendWeight[i].v2;
                        _boneWeight.v3 = this.data.blendWeight[i].v3;
                        data.blendWeight.push(_boneWeight);
                    }
                }
                _result.submesh = [];
                for (var i = 0; i < this.submesh.length; i++) {
                    var _submeshinfo = new subMeshInfo();
                    _submeshinfo.start = this.submesh[i].start;
                    _submeshinfo.size = this.submesh[i].size;
                    _submeshinfo.matIndex = i;
                    _result.submesh.push(_submeshinfo);
                }
                data.trisindex = this.data.trisindex.slice();
                _result.data = data;
                _result.glMesh = new gd3d.render.glMesh();
                var vertexs = _result.data.genVertexDataArray(vf);
                var indices = _result.data.genIndexDataArray();
                _result.glMesh.initBuffer(framework.sceneMgr.app.getAssetMgr().webgl, vf, this.data.pos.length);
                _result.glMesh.uploadVertexData(framework.sceneMgr.app.getAssetMgr().webgl, vertexs);
                _result.glMesh.addIndex(framework.sceneMgr.app.getAssetMgr().webgl, indices.length);
                _result.glMesh.uploadIndexData(framework.sceneMgr.app.getAssetMgr().webgl, 0, indices);
                return _result;
            };
            mesh = mesh_1 = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], mesh);
            return mesh;
            var mesh_1;
        }());
        framework.mesh = mesh;
        var subMeshInfo = (function () {
            function subMeshInfo() {
                this.useVertexIndex = 0;
                this.line = false;
            }
            return subMeshInfo;
        }());
        framework.subMeshInfo = subMeshInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var pathasset = (function () {
            function pathasset(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.paths = [];
                this.items = [];
                this.lines = [];
                if (!assetName) {
                    assetName = "path_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            pathasset.prototype.getName = function () {
                return this.name.getText();
            };
            pathasset.prototype.getGUID = function () {
                return this.id.getID();
            };
            pathasset.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            pathasset.prototype.unuse = function () {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            };
            pathasset.prototype.dispose = function () {
                this.paths.length = 0;
            };
            pathasset.prototype.caclByteLength = function () {
                if (this.paths) {
                    var length = this.paths.length;
                    var value = length * 12;
                    return value;
                }
            };
            pathasset.prototype.Parse = function (json) {
                var type = json["type"];
                switch (type) {
                    case "once":
                        this.type = pathtype.once;
                        break;
                    case "loop":
                        this.type = pathtype.loop;
                        break;
                    case "pingpong":
                        this.type = pathtype.pingpong;
                }
                this.instertPointcount = json["insertPointcount"];
                var paths = json["path"];
                for (var key in paths) {
                    var item = new pointitem();
                    var pointnode = paths[key];
                    var pointtype = pointnode["type"];
                    switch (pointtype) {
                        case "VertexPoint":
                            item.type = epointtype.VertexPoint;
                            break;
                        case "ControlPoint":
                            item.type = epointtype.ControlPoint;
                            break;
                    }
                    var pointlocation = pointnode["point"];
                    var arr = pointlocation.split(",");
                    item.point = new gd3d.math.vector3(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]));
                    this.items.push(item);
                }
                this.getpaths();
                this.items.length = 0;
                for (var i = 0; i < this.lines.length; i++) {
                    this.lines[i].length = 0;
                }
                this.lines.length = 0;
            };
            pathasset.prototype.getpaths = function () {
                var line = new Array();
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (i == 0) {
                        line.push(item.point);
                        this.lines.push(line);
                    }
                    else if (i == this.items.length - 1) {
                        if (this.type == pathtype.loop) {
                            if (item.type == epointtype.VertexPoint) {
                                line.push(item.point);
                                line = new Array();
                                line.push(item.point);
                                line.push(this.items[0].point);
                                this.lines.push(line);
                            }
                            else {
                                line.push(item.point);
                                line.push(this.items[0].point);
                            }
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                    else {
                        if (item.type == epointtype.VertexPoint) {
                            line.push(item.point);
                            line = new Array();
                            line.push(item.point);
                            this.lines.push(line);
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                }
                var linecount = this.lines.length;
                var pathindex = 0;
                for (var i = 0; i < linecount; i++) {
                    if (i == linecount - 1) {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / (this.instertPointcount - 1);
                            this.paths[pathindex] = this.getBeisaierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                    else {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / this.instertPointcount;
                            this.paths[pathindex] = this.getBeisaierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                }
            };
            pathasset.prototype.getBeisaierPointAlongCurve = function (points, rate, clearflag) {
                if (clearflag === void 0) { clearflag = false; }
                var length = points.length;
                if (points.length < 2) {
                    console.log("計算貝塞爾需要超過2個點");
                    return;
                }
                if (length == 2) {
                    var out = new gd3d.math.vector3();
                    this.vec3Lerp(points[0], points[1], rate, out);
                    if (clearflag) {
                        points.length = 0;
                    }
                    return out;
                }
                var temptpoints = [];
                for (var i = 0; i < length - 1; i++) {
                    var temp = gd3d.math.pool.new_vector3();
                    this.vec3Lerp(points[i], points[i + 1], rate, temp);
                    temptpoints[i] = temp;
                }
                if (clearflag) {
                    points.length = 0;
                }
                return this.getBeisaierPointAlongCurve(temptpoints, rate, true);
            };
            pathasset.prototype.vec3Lerp = function (start, end, lerp, out) {
                gd3d.math.vec3Subtract(end, start, out);
                gd3d.math.vec3ScaleByNum(out, lerp, out);
                gd3d.math.vec3Add(start, out, out);
            };
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], pathasset.prototype, "name", void 0);
            pathasset = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], pathasset);
            return pathasset;
        }());
        framework.pathasset = pathasset;
        var pathtype;
        (function (pathtype) {
            pathtype[pathtype["once"] = 0] = "once";
            pathtype[pathtype["loop"] = 1] = "loop";
            pathtype[pathtype["pingpong"] = 2] = "pingpong";
        })(pathtype = framework.pathtype || (framework.pathtype = {}));
        var epointtype;
        (function (epointtype) {
            epointtype[epointtype["VertexPoint"] = 0] = "VertexPoint";
            epointtype[epointtype["ControlPoint"] = 1] = "ControlPoint";
        })(epointtype = framework.epointtype || (framework.epointtype = {}));
        var pointitem = (function () {
            function pointitem() {
            }
            return pointitem;
        }());
        framework.pointitem = pointitem;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var prefab = (function () {
            function prefab(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "prefab_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            prefab.prototype.getName = function () {
                return this.name.getText();
            };
            prefab.prototype.getGUID = function () {
                return this.id.getID();
            };
            prefab.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            prefab.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            prefab.prototype.dispose = function () {
                this.trans.dispose();
                this.jsonstr = null;
            };
            prefab.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            prefab.prototype.getCloneTrans = function () {
                var temp = gd3d.io.cloneObj(this.trans);
                if (temp instanceof framework.transform)
                    return temp;
            };
            prefab.prototype.getCloneTrans2D = function () {
                var temp = gd3d.io.cloneObj(this.trans);
                if (temp instanceof framework.transform2D)
                    return temp;
            };
            prefab.prototype.apply = function (trans) {
                this.trans = trans;
            };
            prefab.prototype.Parse = function (jsonStr, assetmgr) {
                this.jsonstr = jsonStr;
                var jsonObj = JSON.parse(jsonStr);
                var type = jsonObj["type"];
                switch (type) {
                    case "transform":
                        this.trans = new framework.transform;
                        break;
                    case "transform2D":
                        this.trans = new framework.transform2D;
                        break;
                }
                if (type != null)
                    gd3d.io.deSerialize(jsonObj, this.trans, assetmgr, this.assetbundle);
            };
            prefab = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], prefab);
            return prefab;
        }());
        framework.prefab = prefab;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var rawscene = (function () {
            function rawscene(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "rawscene_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            rawscene.prototype.getName = function () {
                return this.name.getText();
            };
            rawscene.prototype.getGUID = function () {
                return this.id.getID();
            };
            rawscene.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            rawscene.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            rawscene.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            rawscene.prototype.resetLightMap = function (assetmgr) {
                this.lightmaps.length = 0;
                var lightmapCount = this.lightmapData.length;
                for (var i = 0; i < lightmapCount; i++) {
                    if (this.lightmapData[i] == null) {
                        this.lightmaps.push(null);
                    }
                    else {
                        var lightmapName = this.lightmapData[i].name;
                        var lightmap = assetmgr.getAssetByName(lightmapName);
                        if (lightmap)
                            lightmap.use();
                        this.lightmaps.push(lightmap);
                    }
                }
            };
            rawscene.prototype.Parse = function (txt, assetmgr) {
                var _json = JSON.parse(txt);
                this.rootNode = new framework.transform();
                this.rootNode.name = this.getName();
                gd3d.io.deSerialize(_json["rootNode"], this.rootNode, assetmgr, this.assetbundle);
                this.lightmaps = [];
                this.lightmapData = _json["lightmap"];
                var lightmapCount = this.lightmapData.length;
                for (var i = 0; i < lightmapCount; i++) {
                    if (this.lightmapData[i] == null) {
                        this.lightmaps.push(null);
                    }
                    else {
                        var lightmapName = this.lightmapData[i].name;
                        var lightmap = assetmgr.getAssetByName(lightmapName, this.assetbundle);
                        if (lightmap)
                            lightmap.use();
                        this.lightmaps.push(lightmap);
                    }
                }
                var fogData = _json["fog"];
                if (fogData != undefined) {
                    this.fog = new Fog();
                    this.fog._Start = fogData["_Start"];
                    this.fog._End = fogData["_End"];
                    var cor = fogData["_Color"];
                    if (typeof (cor) == "string") {
                        var array = cor.split(",");
                        this.fog._Color = new gd3d.math.vector4(parseFloat(array[0]), parseFloat(array[1]), parseFloat(array[2]), parseFloat(array[3]));
                    }
                    else
                        this.fog._Color = cor;
                    this.fog._Density = fogData["_Density"];
                }
            };
            rawscene.prototype.getSceneRoot = function () {
                return gd3d.io.cloneObj(this.rootNode);
            };
            rawscene.prototype.useLightMap = function (scene) {
                scene.lightmaps.length = 0;
                for (var i = 0; i < this.lightmaps.length; i++) {
                    scene.lightmaps.push(this.lightmaps[i]);
                }
            };
            rawscene.prototype.useFog = function (scene) {
                scene.fog = this.fog;
            };
            rawscene.prototype.dispose = function () {
                if (this.rootNode) {
                    this.rootNode.dispose();
                }
                for (var key in this.lightmaps) {
                    this.lightmaps[key].unuse(true);
                }
            };
            rawscene = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], rawscene);
            return rawscene;
        }());
        framework.rawscene = rawscene;
        var Fog = (function () {
            function Fog() {
            }
            return Fog;
        }());
        framework.Fog = Fog;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var shader = (function () {
            function shader(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.name = null;
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.passes = {};
                this.defaultMapUniform = {};
                this.layer = framework.RenderLayerEnum.Common;
                if (!assetName) {
                    assetName = "shader_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            shader.prototype.getName = function () {
                return this.name.getText();
            };
            shader.prototype.getGUID = function () {
                return this.id.getID();
            };
            shader.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            shader.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            shader.prototype.dispose = function () {
            };
            shader.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            shader.prototype.parse = function (assetmgr, json) {
                this._parseProperties(assetmgr, json.properties);
                if (json.layer) {
                    var layer = json.layer;
                    if (layer == "transparent")
                        this.layer = framework.RenderLayerEnum.Transparent;
                    else if (layer == "overlay")
                        this.layer = framework.RenderLayerEnum.Overlay;
                    else if (layer == "common")
                        this.layer = framework.RenderLayerEnum.Common;
                }
                var passes = json.passes;
                this.passes = {};
                for (var key in passes) {
                    var passbass = passes[key];
                    var curpasses;
                    if (key == "base" || key == "lightmap" || key == "skin" || key == "quad") {
                    }
                    else if (key.indexOf("base_") == 0 || key.indexOf("lightmap_") == 0 || key.indexOf("skin_") == 0) {
                    }
                    else {
                        continue;
                    }
                    this.passes[key] = [];
                    for (var i = 0; i < passbass.length; i++) {
                        this.passes[key].push(this._parsePass(assetmgr, passbass[i], key));
                    }
                }
                if (this.passes["base"] == undefined) {
                    throw new Error("do not have base passgroup.");
                }
                this.fillUnDefUniform(this.passes["base"][0]);
            };
            shader.prototype._parseProperties = function (assetmgr, properties) {
                this.defaultMapUniform = {};
                for (var index in properties) {
                    var property = properties[index];
                    var words = property.match(framework.RegexpUtil.floatRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.rangeRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.vectorRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.textureRegexp);
                    if (words == null) {
                        alert(this.getName() + " property error! info:\n" + property);
                        return;
                    }
                    if (words != null && words.length >= 4) {
                        var key = words[1];
                        var showName = words[2];
                        var type = words[3].toLowerCase();
                        switch (type) {
                            case "float":
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float, value: parseFloat(words[4]) };
                                break;
                            case "range":
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float, value: parseFloat(words[6]), min: parseFloat(words[4]), max: parseFloat(words[5]) };
                                break;
                            case "vector":
                                var _vector = new gd3d.math.vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float4, value: _vector };
                                break;
                            case "color":
                                var _color = new gd3d.math.vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float4, value: _color, becolor: true };
                                break;
                            case "texture":
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Texture, value: assetmgr.getDefaultTexture(words[4]) };
                                break;
                            default:
                                alert(this.getName() + " property error! unknown type : " + type);
                                break;
                        }
                    }
                }
            };
            shader.prototype._parsePass = function (assetmgr, json, type) {
                var pass = new gd3d.render.glDrawPass();
                var vs = json["vs"];
                var fs = json["fs"];
                switch (json["showface"]) {
                    case "cw":
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.CW;
                        break;
                    case "ccw":
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                        break;
                    default:
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                        break;
                }
                var blendmode = gd3d.render.BlendModeEnum.Close;
                switch (json["zwrite"]) {
                    case "off":
                        pass.state_zwrite = false;
                        break;
                    case "on":
                    default:
                        pass.state_zwrite = true;
                        break;
                }
                pass.state_ztest = true;
                switch (json["ztest"]) {
                    case "greater":
                        pass.state_ztest_method = gd3d.render.webglkit.GREATER;
                        break;
                    case "gequal":
                        pass.state_ztest_method = gd3d.render.webglkit.GEQUAL;
                        break;
                    case "less":
                        pass.state_ztest_method = gd3d.render.webglkit.LESS;
                        break;
                    case "equal":
                        pass.state_ztest_method = gd3d.render.webglkit.EQUAL;
                        break;
                    case "notequal":
                        pass.state_ztest_method = gd3d.render.webglkit.NOTEQUAL;
                        break;
                    case "always":
                    case "off":
                        pass.state_ztest = false;
                        break;
                    case "never":
                        pass.state_ztest_method = gd3d.render.webglkit.NEVER;
                        break;
                    case "lequal":
                    default:
                        pass.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                        break;
                }
                switch (json["blendmode"]) {
                    case "add":
                        blendmode = gd3d.render.BlendModeEnum.Add;
                        break;
                    case "addpremult":
                        blendmode = gd3d.render.BlendModeEnum.Add_PreMultiply;
                        break;
                    case "blend":
                        blendmode = gd3d.render.BlendModeEnum.Blend;
                        break;
                    case "blendpremult":
                        blendmode = gd3d.render.BlendModeEnum.Blend_PreMultiply;
                        break;
                }
                pass.setAlphaBlend(blendmode);
                var program = assetmgr.shaderPool.linkProgrambyPassType(assetmgr.webgl, type, vs, fs);
                pass.setProgram(program);
                if (this.layer == framework.RenderLayerEnum.Overlay) {
                    pass.state_ztest = true;
                    pass.state_zwrite = true;
                    pass.state_ztest_method = gd3d.render.webglkit.ALWAYS;
                }
                return pass;
            };
            shader.prototype.fillUnDefUniform = function (pass) {
                for (var key in pass.mapuniforms) {
                    var item = pass.mapuniforms[key];
                    if (framework.uniformSetter.autoUniformDic[item.name] == null && this.defaultMapUniform[item.name] == null) {
                        switch (item.type) {
                            case gd3d.render.UniformTypeEnum.Float:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float, value: 0 };
                                break;
                            case gd3d.render.UniformTypeEnum.Floatv:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4x4v, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Float4:
                                if (item.name.indexOf("_ST") >= 0 || item.name.indexOf("_st") >= 0) {
                                    this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4, value: new gd3d.math.vector4(1, 1, 0, 0) };
                                }
                                else {
                                    this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4, value: new gd3d.math.vector4(1, 1, 1, 1) };
                                }
                                break;
                            case gd3d.render.UniformTypeEnum.Float4v:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4v, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Float4x4:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4x4, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Float4x4v:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4x4v, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Texture:
                                var tex = framework.sceneMgr.app.getAssetMgr().getDefaultTexture("white");
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Texture, value: tex };
                                break;
                            case gd3d.render.UniformTypeEnum.CubeTexture:
                                var cubetex = framework.sceneMgr.app.getAssetMgr().getDefaultCubeTexture("white");
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.CubeTexture, value: cubetex };
                                break;
                        }
                    }
                }
            };
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], shader.prototype, "name", void 0);
            shader = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], shader);
            return shader;
        }());
        framework.shader = shader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var sprite = (function () {
            function sprite(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.border = new gd3d.math.border();
                if (!assetName) {
                    assetName = "sprite_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            sprite.prototype.getName = function () {
                return this.name.getText();
            };
            sprite.prototype.getGUID = function () {
                return this.id.getID();
            };
            sprite.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            sprite.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            sprite.prototype.dispose = function () {
                if (this.texture != null) {
                    this.texture.unuse(true);
                }
            };
            sprite.prototype.caclByteLength = function () {
                var total = 0;
                if (this._texture) {
                    total += this._texture.caclByteLength();
                }
                return total;
            };
            Object.defineProperty(sprite.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(sprite.prototype, "urange", {
                get: function () {
                    if (this._urange == null) {
                        this._urange = new gd3d.math.vector2();
                        this._urange.x = this.rect.x / this._texture.glTexture.width;
                        this._urange.y = (this.rect.x + this.rect.w) / this._texture.glTexture.width;
                    }
                    return this._urange;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(sprite.prototype, "vrange", {
                get: function () {
                    if (this._vrange == null) {
                        this._vrange = new gd3d.math.vector2();
                        this._vrange.x = this.rect.y / this._texture.glTexture.height;
                        this._vrange.y = (this.rect.y + this.rect.h) / this._texture.glTexture.height;
                    }
                    return this._vrange;
                },
                enumerable: true,
                configurable: true
            });
            sprite = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], sprite);
            return sprite;
        }());
        framework.sprite = sprite;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var textasset = (function () {
            function textasset(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "texture_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            textasset.prototype.getName = function () {
                return this.name.getText();
            };
            textasset.prototype.getGUID = function () {
                return this.id.getID();
            };
            textasset.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            textasset.prototype.unuse = function () {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            };
            textasset.prototype.dispose = function () {
                this.content == null;
            };
            textasset.prototype.caclByteLength = function () {
                if (this.content) {
                    return gd3d.math.caclStringByteLength(this.content);
                }
            };
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], textasset.prototype, "name", void 0);
            textasset = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], textasset);
            return textasset;
        }());
        framework.textasset = textasset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var texture = (function () {
            function texture(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "texture_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            texture.prototype.getName = function () {
                return this.name.getText();
            };
            texture.prototype.getGUID = function () {
                return this.id.getID();
            };
            texture.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            texture.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            texture.prototype.dispose = function () {
                if (this && this.glTexture) {
                    this.glTexture.dispose(framework.sceneMgr.app.getAssetMgr().webgl);
                }
            };
            texture.prototype.caclByteLength = function () {
                if (this.glTexture) {
                    return this.glTexture.caclByteLength();
                }
            };
            Object.defineProperty(texture.prototype, "realName", {
                get: function () {
                    return this._realName;
                },
                set: function (name) {
                    this._realName = name;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                gd3d.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], texture.prototype, "name", void 0);
            texture = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], texture);
            return texture;
        }());
        framework.texture = texture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AudioEx = (function () {
            function AudioEx() {
                try {
                    var _AudioContext = window["AudioContext"] || window["webkitAudioContext"] || window["mozAudioContext"] || window["msAudioContext"];
                    this.audioContext = new _AudioContext();
                    console.log("audio Context inited");
                }
                catch (e) {
                    console.error("!Your browser does not support AudioContext");
                }
            }
            AudioEx.instance = function () {
                if (AudioEx.g_this == null)
                    AudioEx.g_this = new AudioEx();
                return AudioEx.g_this;
            };
            AudioEx.prototype.clickInit = function () {
                if (!this.isAvailable())
                    return;
                if (this.audioContext != null) {
                    var buffer = this.audioContext.createBuffer(1, 1, 22050);
                    var source = this.audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(this.audioContext.destination);
                    source.start();
                }
            };
            AudioEx.prototype.loadAudioBufferFromArrayBuffer = function (ab, fun) {
                this.audioContext.decodeAudioData(ab, function (audiobuffer) {
                    fun(audiobuffer, null);
                });
            };
            AudioEx.prototype.loadAudioBuffer = function (url, fun) {
                var _this = this;
                AudioEx.loadArrayBuffer(url, function (_ab, __err) {
                    if (__err != null)
                        fun(null, __err);
                    else {
                        _this.audioContext.decodeAudioData(_ab, function (audiobuffer) {
                            fun(audiobuffer, null);
                        });
                    }
                });
            };
            AudioEx.prototype.isAvailable = function () {
                return this.audioContext ? true : false;
            };
            AudioEx.prototype.createAudioChannel = function (be3DSound) {
                var cc = new AudioChannel();
                cc.source = this.audioContext.createBufferSource();
                cc.gainNode = this.audioContext.createGain();
                cc.source.connect(cc.gainNode);
                if (be3DSound) {
                    cc.pannerNode = this.audioContext.createPanner();
                    cc.gainNode.connect(cc.pannerNode);
                    cc.pannerNode.connect(this.audioContext.destination);
                }
                else {
                    cc.gainNode.connect(this.audioContext.destination);
                }
                cc.gainNode.gain.value = 1;
                return cc;
            };
            AudioEx.loadArrayBuffer = function (url, fun) {
                var req = new XMLHttpRequest();
                req.open("GET", url);
                req.responseType = "arraybuffer";
                req.onreadystatechange = function () {
                    if (req.readyState == 4) {
                        if (req.status == 404)
                            fun(null, new Error("onerr 404"));
                        else
                            fun(req.response, null);
                    }
                };
                req.onerror = function () {
                    fun(null, new Error("onerr in req:"));
                };
                req.send();
            };
            return AudioEx;
        }());
        framework.AudioEx = AudioEx;
        var AudioChannel = (function () {
            function AudioChannel() {
            }
            Object.defineProperty(AudioChannel.prototype, "volume", {
                get: function () {
                    return this.gainNode.gain.value;
                },
                set: function (val) {
                    val = val > 1 ? 1 : val;
                    val = val <= 0 ? 0 : val;
                    this.gainNode.gain.value = val;
                },
                enumerable: true,
                configurable: true
            });
            AudioChannel.prototype.stop = function () {
                if (this.source != null) {
                    this.source.stop();
                    this.source = null;
                }
                this.isplay = false;
            };
            return AudioChannel;
        }());
        framework.AudioChannel = AudioChannel;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var aniplayer = (function () {
            function aniplayer() {
                this._clipnameCount = 0;
                this._clipnames = null;
                this.autoplay = true;
                this.playIndex = 0;
                this._playClip = null;
                this.tpose = {};
                this.nowpose = {};
                this.lerppose = {};
                this.carelist = {};
                this._playFrameid = 0;
                this._playTimer = 0;
                this.speed = 1.0;
                this.crossdelta = 0;
                this.crossspeed = 0;
                this.beRevert = false;
                this.playStyle = PlayStyle.NormalPlay;
                this.percent = 0;
                this.mix = false;
                this.isCache = false;
            }
            aniplayer_1 = aniplayer;
            Object.defineProperty(aniplayer.prototype, "clipnames", {
                get: function () {
                    if (this._clipnames == null || this._clipnameCount != this.clips.length) {
                        this._clipnameCount = this.clips.length;
                        this._clipnames = {};
                        for (var key in this.clips) {
                            if (this.clips[key])
                                this.clipnames[this.clips[key].getName()] = parseInt(key);
                        }
                    }
                    return this._clipnames;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(aniplayer.prototype, "cacheKey", {
                get: function () {
                    if (this._playClip)
                        return this._playClip.getGUID() + "_" + this._playFrameid;
                    return this._playFrameid;
                },
                enumerable: true,
                configurable: true
            });
            aniplayer.prototype.init = function () {
                for (var i = 0; i < this.bones.length; i++) {
                    var _info = this.bones[i];
                    var name_2 = _info.name;
                    var nb = new framework.PoseBoneMatrix();
                    nb.r = _info.tposeq;
                    nb.t = _info.tposep;
                    nb.invert();
                    this.tpose[name_2] = nb;
                    this.nowpose[name_2] = this.startPos[i].Clone();
                }
                var asbones = this.gameObject.getComponentsInChildren("asbone");
                for (var key in asbones) {
                    this.care(asbones[key].gameObject.transform);
                }
                if (this.autoplay && this.clips != null && this.clips.length > 0) {
                    this.playByIndex(this.playIndex);
                }
            };
            aniplayer.prototype.start = function () {
                if (this.bones != null) {
                    this.init();
                }
            };
            aniplayer.prototype.update = function (delta) {
                if (this._playClip == null)
                    return;
                this.checkFrameId(delta);
                this.mix = false;
                if (this.crossdelta > 0) {
                    this.crossdelta -= delta / this.speed * this.crossspeed;
                    this.mix = true;
                }
                var cached = false;
                if (this.isCache && !this.mix && aniplayer_1.playerCaches[this.cacheKey]) {
                    cached = true;
                    if (framework.StringUtil.isNullOrEmptyObject(this.carelist))
                        return;
                }
                for (var i = 0; i < this._playClip.boneCount; i++) {
                    var bone = this._playClip.bones[i];
                    if (cached && !this.carelist[bone])
                        continue;
                    var frame;
                    if (this._playClip != null && this._playClip.frames != null) {
                        frame = this._playClip.frames[this._playFrameid];
                    }
                    else {
                        console.warn("is null of animationclip.frames! ");
                        return;
                    }
                    var nextseek = i * 7 + 1;
                    var outb = this.nowpose[bone];
                    var tpose = this.tpose[bone];
                    if (outb != undefined || frame == null) {
                        if (this.mix) {
                            var last = this.lerppose[bone];
                            if (last != undefined) {
                                outb.lerpInWorldWithData(tpose, last, frame, nextseek, 1 - this.crossdelta);
                            }
                            else {
                                outb.copyFromData(frame, nextseek);
                            }
                        }
                        else {
                            outb.copyFromData(frame, nextseek);
                        }
                    }
                    var careobj = this.carelist[bone];
                    if (careobj != undefined) {
                        var fmat = framework.PoseBoneMatrix.sMultiply(outb, tpose);
                        var _matrix = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMakeTransformRTS(fmat.t, gd3d.math.pool.vector3_one, fmat.r, _matrix);
                        var _newmatrix = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(this.gameObject.transform.getWorldMatrix(), _matrix, _newmatrix);
                        careobj.setWorldMatrix(_newmatrix);
                        careobj.updateTran(false);
                        gd3d.math.pool.delete_matrix(_matrix);
                        gd3d.math.pool.delete_matrix(_newmatrix);
                    }
                }
                if (!cached) {
                    aniplayer_1.playerCaches[this.cacheKey] = this;
                }
            };
            aniplayer.prototype.playByIndex = function (animIndex, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                this.playIndex = animIndex;
                if (this.clips.length <= animIndex) {
                    console.error("animIndex out Array of clips");
                    return;
                }
                this.playAniamtion(animIndex.toString(), speed, beRevert);
                this.crossdelta = 0;
            };
            aniplayer.prototype.playCrossByIndex = function (animIndex, crosstimer, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                this.playIndex = animIndex;
                if (this.clips.length <= animIndex) {
                    console.error("animIndex out Array of clips");
                    return;
                }
                this.playAniamtion(animIndex.toString(), speed, beRevert);
                this.crossspeed = 1.0 / crosstimer;
                this.crossdelta = 1;
            };
            aniplayer.prototype.play = function (animName, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                if (this.clipnames[animName] == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                this.playByIndex(this.clipnames[animName], speed, beRevert);
            };
            aniplayer.prototype.getPlayName = function () {
                if (this.isPlay())
                    return this._playClip.getName();
            };
            aniplayer.prototype.playCross = function (animName, crosstimer, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                if (this.clipnames[animName] == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                if (crosstimer <= 0) {
                    this.playByIndex(this.clipnames[animName], speed, beRevert);
                }
                else {
                    this.playCrossByIndex(this.clipnames[animName], crosstimer, speed, beRevert);
                }
            };
            aniplayer.prototype.playAniamtion = function (index, speed, beRevert) {
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                if (this.clips[index] == undefined)
                    return;
                this._playClip = this.clips[index];
                this._playTimer = 0;
                this._playFrameid = 0;
                this.speed = speed;
                this.beRevert = beRevert;
                this.playStyle = PlayStyle.NormalPlay;
                this.speed = speed;
                this.lerppose = {};
                for (var key in this.nowpose) {
                    var src = this.nowpose[key];
                    this.lerppose[key] = src.Clone();
                }
            };
            aniplayer.prototype.updateAnimation = function (animIndex, _frame) {
                if (!this.clips)
                    return;
                if (animIndex >= this.clips.length)
                    return;
                var _clip = this.clips[animIndex];
                if (!_clip)
                    return;
                for (var i = 0; i < _clip.boneCount; i++) {
                    var bone = _clip.bones[i];
                    var frame = _clip.frames[_frame];
                    var nextseek = i * 7 + 1;
                    var outb = this.nowpose[bone];
                    var tpose = this.tpose[bone];
                    if (outb != undefined) {
                        outb.copyFromData(frame, nextseek);
                    }
                    var careobj = this.carelist[bone];
                    if (careobj != undefined) {
                        var fmat = framework.PoseBoneMatrix.sMultiply(outb, tpose);
                        var _matrix = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMakeTransformRTS(fmat.t, gd3d.math.pool.vector3_one, fmat.r, _matrix);
                        var _newmatrix = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(this.gameObject.transform.getWorldMatrix(), _matrix, _newmatrix);
                        careobj.setWorldMatrix(_newmatrix);
                        careobj.updateTran(false);
                        gd3d.math.pool.delete_matrix(_matrix);
                        gd3d.math.pool.delete_matrix(_newmatrix);
                    }
                }
                var renders = this.gameObject.getComponentsInChildren(framework.StringUtil.COMPONENT_SKINMESHRENDER);
                for (var key in renders) {
                    var _render = renders[key];
                    _render.update(0);
                }
            };
            aniplayer.prototype.stop = function () {
                this._playClip = null;
            };
            aniplayer.prototype.isPlay = function () {
                return this._playClip != null;
            };
            aniplayer.prototype.isStop = function () {
                if (this._playClip == null)
                    return false;
                if (this.playStyle != PlayStyle.NormalPlay)
                    return false;
                if (this._playClip.loop)
                    return false;
                if (this._playFrameid == this._playClip.frameCount - 1)
                    return true;
                return false;
            };
            aniplayer.prototype.remove = function () {
                this.clips.forEach(function (temp) {
                    if (temp)
                        temp.unuse();
                });
                this.clips.length = 0;
                this.bones.length = 0;
                this.startPos.length = 0;
                this._playClip = null;
                delete this.tpose;
                delete this.nowpose;
                delete this.lerppose;
                delete this.carelist;
                delete this._clipnames;
            };
            aniplayer.prototype.clone = function () {
            };
            aniplayer.prototype.addFinishedEventListener = function (finishCallBack, thisObject) {
                this.finishCallBack = finishCallBack;
                this.thisObject = thisObject;
            };
            aniplayer.prototype.checkFrameId = function (delay) {
                if (this.playStyle == PlayStyle.NormalPlay) {
                    this._playTimer += delay * this.speed;
                    this._playFrameid = (this._playClip.fps * this._playTimer) | 0;
                    if (this._playClip.loop) {
                        this._playFrameid %= this._playClip.frameCount;
                    }
                    else if (this._playFrameid > this._playClip.frameCount - 1) {
                        this._playFrameid = this._playClip.frameCount - 1;
                    }
                    if (this.beRevert) {
                        this._playFrameid = this._playClip.frameCount - this._playFrameid - 1;
                    }
                }
                else if (this.playStyle == PlayStyle.FramePlay) {
                    this._playFrameid = (this._playClip.frameCount * this.percent) - 1;
                    this._playFrameid = Math.round(this._playFrameid);
                }
                if (this._playFrameid < 0) {
                    this._playFrameid = 0;
                }
                if (this._playFrameid > this._playClip.frameCount - 1) {
                    this._playFrameid = this._playClip.frameCount - 1;
                }
                if (this.isStop()) {
                    if (this.finishCallBack) {
                        this.finishCallBack(this.thisObject);
                        this.finishCallBack = null;
                    }
                }
            };
            aniplayer.prototype.fillPoseData = function (data, bones, efficient) {
                if (efficient === void 0) { efficient = true; }
                var seek = 0;
                for (var i in bones) {
                    var key = bones[i].name;
                    var obj = this.nowpose[key];
                    if (obj == undefined) {
                        if (efficient) {
                            data[seek * 8 + 0] = 0;
                            data[seek * 8 + 1] = 0;
                            data[seek * 8 + 2] = 0;
                            data[seek * 8 + 3] = 1;
                            data[seek * 8 + 4] = 0;
                            data[seek * 8 + 5] = 0;
                            data[seek * 8 + 6] = 0;
                            data[seek * 8 + 7] = 1;
                        }
                        else {
                            data[seek * 16 + 0] = 1;
                            data[seek * 16 + 1] = 0;
                            data[seek * 16 + 2] = 0;
                            data[seek * 16 + 3] = 0;
                            data[seek * 16 + 4] = 0;
                            data[seek * 16 + 5] = 1;
                            data[seek * 16 + 6] = 0;
                            data[seek * 16 + 7] = 0;
                            data[seek * 16 + 8] = 0;
                            data[seek * 16 + 9] = 0;
                            data[seek * 16 + 10] = 1;
                            data[seek * 16 + 11] = 0;
                            data[seek * 16 + 12] = 0;
                            data[seek * 16 + 13] = 0;
                            data[seek * 16 + 14] = 0;
                            data[seek * 16 + 15] = 1;
                        }
                    }
                    else {
                        var _mat = gd3d.math.pool.new_matrix();
                        if (efficient) {
                            data[seek * 8 + 0] = obj.r.x;
                            data[seek * 8 + 1] = obj.r.y;
                            data[seek * 8 + 2] = obj.r.z;
                            data[seek * 8 + 3] = obj.r.w;
                            data[seek * 8 + 4] = obj.t.x;
                            data[seek * 8 + 5] = obj.t.y;
                            data[seek * 8 + 6] = obj.t.z;
                            data[seek * 8 + 7] = 1;
                        }
                        else {
                            gd3d.math.matrixMakeTransformRTS(obj.t, gd3d.math.pool.vector3_one, obj.r, _mat);
                            for (var j = 0; j < 16; j++) {
                                data[seek * 16 + j] = _mat.rawData[j];
                            }
                        }
                        gd3d.math.pool.delete_matrix(_mat);
                    }
                    seek++;
                }
            };
            aniplayer.prototype.care = function (node) {
                var pnode = node;
                while (true) {
                    if (this.nowpose[pnode.name] != undefined) {
                        this.carelist[pnode.name] = pnode;
                        return;
                    }
                    if (pnode.parent)
                        pnode = pnode.parent;
                    else
                        return;
                }
            };
            aniplayer.playerCaches = [];
            __decorate([
                gd3d.reflect.Field("animationClip[]"),
                __metadata("design:type", Array)
            ], aniplayer.prototype, "clips", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], aniplayer.prototype, "autoplay", void 0);
            __decorate([
                gd3d.reflect.Field("tPoseInfo[]"),
                __metadata("design:type", Array)
            ], aniplayer.prototype, "bones", void 0);
            __decorate([
                gd3d.reflect.Field("PoseBoneMatrix[]"),
                __metadata("design:type", Array)
            ], aniplayer.prototype, "startPos", void 0);
            aniplayer = aniplayer_1 = __decorate([
                gd3d.reflect.nodeComponent
            ], aniplayer);
            return aniplayer;
            var aniplayer_1;
        }());
        framework.aniplayer = aniplayer;
        var tPoseInfo = (function () {
            function tPoseInfo() {
            }
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], tPoseInfo.prototype, "name", void 0);
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3)
            ], tPoseInfo.prototype, "tposep", void 0);
            __decorate([
                gd3d.reflect.Field("quaternion"),
                __metadata("design:type", gd3d.math.quaternion)
            ], tPoseInfo.prototype, "tposeq", void 0);
            tPoseInfo = __decorate([
                gd3d.reflect.SerializeType
            ], tPoseInfo);
            return tPoseInfo;
        }());
        framework.tPoseInfo = tPoseInfo;
        var PlayStyle;
        (function (PlayStyle) {
            PlayStyle[PlayStyle["NormalPlay"] = 0] = "NormalPlay";
            PlayStyle[PlayStyle["FramePlay"] = 1] = "FramePlay";
            PlayStyle[PlayStyle["PingPang"] = 2] = "PingPang";
        })(PlayStyle = framework.PlayStyle || (framework.PlayStyle = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var asbone = (function () {
            function asbone() {
            }
            asbone.prototype.start = function () {
            };
            asbone.prototype.update = function (delta) {
            };
            asbone.prototype.remove = function () {
            };
            asbone.prototype.clone = function () {
            };
            asbone = __decorate([
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], asbone);
            return asbone;
        }());
        framework.asbone = asbone;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AudioListener = (function () {
            function AudioListener() {
                this.lastX = 0;
                this.lastY = 0;
                this.lastZ = 0;
            }
            AudioListener.prototype.start = function () {
                this.listener = framework.AudioEx.instance().audioContext.listener;
            };
            AudioListener.prototype.update = function (delta) {
                this.curPos = this.gameObject.transform.getWorldTranslate();
                if (this.curPos.x != this.lastX || this.curPos.y != this.lastY || this.curPos.z != this.lastZ) {
                    this.listener.setPosition(this.curPos.x, this.curPos.y, this.curPos.z);
                    this.lastX = this.curPos.x;
                    this.lastY = this.curPos.y;
                    this.lastZ = this.curPos.z;
                }
            };
            AudioListener.prototype.remove = function () {
            };
            AudioListener.prototype.clone = function () {
            };
            AudioListener = __decorate([
                gd3d.reflect.nodeComponent
            ], AudioListener);
            return AudioListener;
        }());
        framework.AudioListener = AudioListener;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AudioPlayer = (function () {
            function AudioPlayer() {
                this.be3DSound = true;
                this.lastX = 0;
                this.lastY = 0;
                this.lastZ = 0;
            }
            AudioPlayer.prototype.play = function (buffer, beLoop, volume, onended) {
                if (beLoop === void 0) { beLoop = false; }
                if (volume === void 0) { volume = 0; }
                if (this.audioChannel != null) {
                    if (this.audioChannel.isplay) {
                        this.stop();
                    }
                    this.audioChannel = null;
                }
                this.audioChannel = framework.AudioEx.instance().createAudioChannel(this.be3DSound);
                this.buffer = buffer;
                this.volume = volume;
                var c = this.audioChannel;
                c.source.loop = this.beLoop;
                c.source.buffer = this.buffer;
                c.volume = this.volume;
                c.source.start();
                c.isplay = true;
                if (!this.beLoop) {
                    c.source.onended = function () {
                        c.isplay = false;
                        c.source = null;
                        if (onended != undefined)
                            onended();
                    };
                }
            };
            AudioPlayer.prototype.stop = function () {
                if (this.audioChannel != null) {
                    this.audioChannel.stop();
                }
            };
            Object.defineProperty(AudioPlayer.prototype, "volume", {
                get: function () {
                    return this.audioChannel == null ? -1 : this.audioChannel.volume;
                },
                set: function (val) {
                    this.audioChannel == null ? 0 : this.audioChannel.volume = val;
                },
                enumerable: true,
                configurable: true
            });
            AudioPlayer.prototype.isPlaying = function () {
                return this.audioChannel == undefined ? false : this.audioChannel.isplay;
            };
            AudioPlayer.prototype.start = function () {
                this.audioChannel = framework.AudioEx.instance().createAudioChannel(this.be3DSound);
            };
            AudioPlayer.prototype.update = function (delta) {
                this.curPos = this.gameObject.transform.getWorldTranslate();
                if (this.curPos.x != this.lastX || this.curPos.y != this.lastY || this.curPos.z != this.lastZ) {
                    this.audioChannel.pannerNode.setPosition(this.curPos.x, this.curPos.y, this.curPos.z);
                    this.lastX = this.curPos.x;
                    this.lastY = this.curPos.y;
                    this.lastZ = this.curPos.z;
                }
            };
            AudioPlayer.prototype.remove = function () {
            };
            AudioPlayer.prototype.clone = function () {
            };
            AudioPlayer = __decorate([
                gd3d.reflect.nodeComponent
            ], AudioPlayer);
            return AudioPlayer;
        }());
        framework.AudioPlayer = AudioPlayer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var behaviour = (function () {
            function behaviour() {
            }
            behaviour.prototype.start = function () {
            };
            behaviour.prototype.update = function (delta) {
            };
            behaviour.prototype.remove = function () {
            };
            behaviour.prototype.clone = function () {
            };
            behaviour = __decorate([
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], behaviour);
            return behaviour;
        }());
        framework.behaviour = behaviour;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var bloomctr = (function () {
            function bloomctr() {
                this._bloomIntensity = 1.4;
                this._bloomThreshold = 0.5;
                this._blurSpread = 3;
                this.tag = "__bloomtag__";
                this._init = false;
            }
            Object.defineProperty(bloomctr.prototype, "bloomThreshold", {
                get: function () { return this._bloomThreshold; },
                set: function (value) {
                    this._bloomThreshold = value;
                    if (!this.material || !this.material_1 || !this.material_2)
                        return;
                    this.material.setFloat("_bloomThreshold", this._bloomThreshold);
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(bloomctr.prototype, "bloomIntensity", {
                get: function () { return this._bloomIntensity; },
                set: function (value) {
                    this._bloomIntensity = value;
                    if (!this.material || !this.material_3)
                        return;
                    this.material_3.setFloat("_bloomIntensity", this._bloomIntensity);
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(bloomctr.prototype, "blurSpread", {
                get: function () { return this._blurSpread; },
                set: function (value) {
                    this._blurSpread = value;
                    if (!this.material_1 || !this.material_2)
                        return;
                    var v4_1 = gd3d.math.pool.new_vector4();
                    var v4_2 = gd3d.math.pool.new_vector4();
                    v4_1.x = value;
                    v4_1.y = 0;
                    v4_2.x = 0;
                    v4_2.y = value;
                    this.material_1.setVector4("_blurSpread", v4_1);
                    this.material_2.setVector4("_blurSpread", v4_2);
                },
                enumerable: true,
                configurable: true
            });
            ;
            bloomctr.prototype.init = function () {
                var sh = this.scene.app.getAssetMgr().getShader("bloom.shader.json");
                if (!sh) {
                    console.warn("bloom.shader.json not find");
                    return;
                }
                var psize = 1024;
                var color = new framework.cameraPostQueue_Color();
                color[this.tag] = true;
                color.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                if (!this.camera.postQueues)
                    this.camera.postQueues = [];
                this.camera.postQueues.push(color);
                var textcolor = new framework.texture("_color");
                textcolor.glTexture = color.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material = post0.material;
                this.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", textcolor);
                post0.material.setFloat("_bloomIntensity", 1.2);
                post0.material.setFloat("_bloomThreshold", this._bloomThreshold);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(0, 0, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                var threTex = new framework.texture("_threshold");
                threTex.glTexture = post0.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material_1 = post0.material;
                this.material_1.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", threTex);
                post0.material.setTexture("_BlurTex", threTex);
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 1.0);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(this._blurSpread, 0, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                var hBlur = new framework.texture("_blur0");
                hBlur.glTexture = post0.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material_2 = post0.material;
                this.material_2.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", hBlur);
                post0.material.setTexture("_BlurTex", hBlur);
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 1.0);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(0, this._blurSpread, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                var hvBlur = new framework.texture("_blur1");
                hvBlur.glTexture = post0.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0[this.tag] = true;
                this.material_3 = post0.material;
                post0.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", hvBlur);
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 0.5);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(0.5, 0.5, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                this._init = true;
            };
            bloomctr.prototype.start = function () {
                this.app = this.gameObject.transform.scene.app;
                this.scene = this.app.getScene();
            };
            bloomctr.prototype.update = function (delta) {
                if (this._init)
                    return;
                if (!this.camera)
                    this.camera = this.gameObject.getComponent("camera");
                if (this.camera)
                    this.init();
            };
            bloomctr.prototype.remove = function () {
                this._init = false;
                if (this.camera) {
                    var arr_3 = this.camera.postQueues;
                    var dArr = [];
                    for (var i = 0; i < arr_3.length; i++) {
                        var temp = arr_3[i];
                        if (temp[this.tag]) {
                            dArr.push(temp);
                        }
                    }
                    dArr.forEach(function (element) {
                        if (element) {
                            var idx = arr_3.indexOf(element);
                            if (idx != -1) {
                                arr_3.splice(idx, 1);
                            }
                        }
                    });
                }
                if (this.material) {
                    this.material.unuse();
                    this.material = null;
                }
                if (this.material_1) {
                    this.material_1.unuse();
                    this.material_1 = null;
                }
                if (this.material_2) {
                    this.material_2.unuse();
                    this.material_2 = null;
                }
                if (this.material_3) {
                    this.material_3.unuse();
                    this.material_3 = null;
                }
            };
            bloomctr.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], bloomctr.prototype, "bloomThreshold", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], bloomctr.prototype, "bloomIntensity", null);
            bloomctr = __decorate([
                gd3d.reflect.nodeComponent
            ], bloomctr);
            return bloomctr;
        }());
        framework.bloomctr = bloomctr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var boxcollider = (function () {
            function boxcollider() {
                this._colliderVisible = false;
            }
            boxcollider.prototype.getBound = function () {
                return this.obb;
            };
            Object.defineProperty(boxcollider.prototype, "matrix", {
                get: function () {
                    if (this.gameObject)
                        return this.gameObject.transform.getWorldMatrix();
                    return new gd3d.math.matrix();
                },
                enumerable: true,
                configurable: true
            });
            boxcollider.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.build();
            };
            boxcollider.prototype.update = function (delta) {
                if (this.obb) {
                    this.obb.update(this.matrix);
                }
            };
            Object.defineProperty(boxcollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            boxcollider.prototype.intersectsTransform = function (tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.obb == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.obb.intersects(_obb);
            };
            boxcollider.prototype.build = function () {
                this.obb = new framework.obb();
                if (this.center && this.size) {
                    this.obb.buildByCenterSize(this.center, this.size);
                }
                else {
                    var minimum = new gd3d.math.vector3();
                    var maximum = new gd3d.math.vector3();
                    if (this.filter) {
                        var meshdata = this.filter.getMeshOutput().data;
                        gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                        gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                        for (var i = 0; i < meshdata.pos.length; i++) {
                            gd3d.math.vec3Max(meshdata.pos[i], maximum, maximum);
                            gd3d.math.vec3Min(meshdata.pos[i], minimum, minimum);
                        }
                        console.log("add obb filter " + minimum + "  " + maximum);
                    }
                    else {
                        minimum.x = -1;
                        minimum.y = -1;
                        minimum.z = -1;
                        maximum.x = 1;
                        maximum.y = 1;
                        maximum.z = 1;
                    }
                    this.obb.buildByMaxMin(minimum, maximum);
                }
                this.buildMesh();
            };
            boxcollider.prototype.buildMesh = function () {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "boxcollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
            };
            boxcollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                _mesh.data = gd3d.render.meshData.genBoxByArray_Quad(this.obb.vectors);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayQuad2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = true;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            boxcollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
                if (this.obb) {
                    this.obb.dispose();
                }
            };
            boxcollider.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3)
            ], boxcollider.prototype, "center", void 0);
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3)
            ], boxcollider.prototype, "size", void 0);
            boxcollider = __decorate([
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeBoxCollider
            ], boxcollider);
            return boxcollider;
        }());
        framework.boxcollider = boxcollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var cameraPostQueue_Depth = (function () {
            function cameraPostQueue_Depth() {
                this.renderTarget = null;
            }
            cameraPostQueue_Depth.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                context.webgl.depthMask(true);
                gd3d.render.glDrawPass.lastZWrite = true;
                context.webgl.clearColor(0, 0, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                camera._renderOnce(scene, context, "_depth");
                gd3d.render.glRenderTarget.useNull(context.webgl);
            };
            return cameraPostQueue_Depth;
        }());
        framework.cameraPostQueue_Depth = cameraPostQueue_Depth;
        var cameraPostQueue_Quad = (function () {
            function cameraPostQueue_Quad() {
                this.renderTarget = null;
                this.material = new framework.material();
            }
            cameraPostQueue_Quad.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                context.webgl.depthMask(true);
                gd3d.render.glDrawPass.lastZWrite = true;
                context.webgl.clearColor(0, 0.3, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                var mesh = scene.app.getAssetMgr().getDefaultMesh("quad");
                context.drawtype = "";
                mesh.glMesh.bindVboBuffer(context.webgl);
                this.material.draw(context, mesh, mesh.submesh[0], "quad");
            };
            return cameraPostQueue_Quad;
        }());
        framework.cameraPostQueue_Quad = cameraPostQueue_Quad;
        var cameraPostQueue_Color = (function () {
            function cameraPostQueue_Color() {
                this.renderTarget = null;
            }
            cameraPostQueue_Color.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, false);
                camera._renderOnce(scene, context, "");
                gd3d.render.glRenderTarget.useNull(context.webgl);
            };
            return cameraPostQueue_Color;
        }());
        framework.cameraPostQueue_Color = cameraPostQueue_Color;
        var camera = (function () {
            function camera() {
                this._near = 0.01;
                this._far = 1000;
                this.isMainCamera = false;
                this.CullingMask = CullingMask.default | CullingMask.ui;
                this.clearOption_Color = true;
                this.clearOption_Depth = true;
                this.backgroundColor = new gd3d.math.color(0.5, 0.8, 1, 1);
                this.viewport = new gd3d.math.rect(0, 0, 1, 1);
                this.renderTarget = null;
                this.order = 0;
                this.overlays = [];
                this.matView = new gd3d.math.matrix;
                this.matProjP = new gd3d.math.matrix;
                this.matProjO = new gd3d.math.matrix;
                this.matProj = new gd3d.math.matrix;
                this.frameVecs = [];
                this.fov = Math.PI * 0.25;
                this.size = 2;
                this._opvalue = 1;
                this.postQueues = [];
            }
            Object.defineProperty(camera.prototype, "near", {
                get: function () {
                    return this._near;
                },
                set: function (val) {
                    if (this.opvalue > 0) {
                        if (val < 0.01)
                            val = 0.01;
                    }
                    if (val >= this.far)
                        val = this.far - 0.01;
                    this._near = val;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(camera.prototype, "far", {
                get: function () {
                    return this._far;
                },
                set: function (val) {
                    if (val <= this.near)
                        val = this.near + 0.01;
                    this._far = val;
                },
                enumerable: true,
                configurable: true
            });
            camera.prototype.markDirty = function () {
            };
            camera.prototype.start = function () {
            };
            camera.prototype.update = function (delta) {
                for (var i = 0; i < this.overlays.length; i++) {
                    if (!this.overlays[i].init) {
                        this.overlays[i].start(this);
                        this.overlays[i].init = true;
                    }
                    this.overlays[i].update(delta);
                }
            };
            camera.prototype.addOverLay = function (overLay) {
                this.overlays.push(overLay);
            };
            camera.prototype.addOverLayAt = function (overLay, index) {
                this.overlays.splice(index, 0, overLay);
            };
            camera.prototype.getOverLays = function () {
                return this.overlays;
            };
            camera.prototype.removeOverLay = function (overLay) {
                if (this.overlays == null)
                    return;
                var index = this.overlays.indexOf(overLay);
                if (index >= 0)
                    this.overlays.splice(index, 1);
            };
            camera.prototype.calcViewMatrix = function (matrix) {
                var camworld = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixInverse(camworld, this.matView);
                gd3d.math.matrixClone(this.matView, matrix);
                return;
            };
            camera.prototype.calcViewPortPixel = function (app, viewPortPixel) {
                var w;
                var h;
                if (this.renderTarget == null) {
                    w = app.width;
                    h = app.height;
                }
                else {
                    w = this.renderTarget.width;
                    h = this.renderTarget.height;
                }
                viewPortPixel.x = w * this.viewport.x;
                viewPortPixel.y = h * this.viewport.y;
                viewPortPixel.w = w * this.viewport.w;
                viewPortPixel.h = h * this.viewport.h;
            };
            camera.prototype.calcProjectMatrix = function (asp, matrix) {
                if (this.opvalue > 0)
                    gd3d.math.matrixProject_PerspectiveLH(this.fov, asp, this.near, this.far, this.matProjP);
                if (this.opvalue < 1)
                    gd3d.math.matrixProject_OrthoLH(this.size * asp, this.size, this.near, this.far, this.matProjO);
                if (this.opvalue == 0)
                    gd3d.math.matrixClone(this.matProjO, this.matProj);
                else if (this.opvalue == 1)
                    gd3d.math.matrixClone(this.matProjP, this.matProj);
                else
                    gd3d.math.matrixLerp(this.matProjO, this.matProjP, this.opvalue, this.matProj);
                gd3d.math.matrixClone(this.matProj, matrix);
            };
            camera.prototype.creatRayByScreen = function (screenpos, app) {
                var src1 = gd3d.math.pool.new_vector3();
                src1.x = screenpos.x;
                src1.y = screenpos.y;
                src1.z = 0;
                var src2 = gd3d.math.pool.new_vector3();
                src2.x = screenpos.x;
                src2.y = screenpos.y;
                src2.z = 1;
                var dest1 = gd3d.math.pool.new_vector3();
                var dest2 = gd3d.math.pool.new_vector3();
                this.calcWorldPosFromScreenPos(app, src1, dest1);
                this.calcWorldPosFromScreenPos(app, src2, dest2);
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(dest2, dest1, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var ray = new gd3d.framework.ray(dest1, dir);
                gd3d.math.pool.delete_vector3(src1);
                gd3d.math.pool.delete_vector3(src2);
                gd3d.math.pool.delete_vector3(dest1);
                gd3d.math.pool.delete_vector3(dest2);
                gd3d.math.pool.delete_vector3(dir);
                return ray;
            };
            camera.prototype.calcWorldPosFromScreenPos = function (app, screenPos, outWorldPos) {
                var vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, vpp);
                var vppos = new gd3d.math.vector2(screenPos.x / vpp.w * 2 - 1, 1 - screenPos.y / vpp.h * 2);
                var matrixView = new gd3d.math.matrix();
                var matrixProject = new gd3d.math.matrix();
                var asp = vpp.w / vpp.h;
                this.calcViewMatrix(matrixView);
                this.calcProjectMatrix(asp, matrixProject);
                var matrixViewProject = new gd3d.math.matrix();
                var matinv = new gd3d.math.matrix();
                gd3d.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                gd3d.math.matrixInverse(matrixViewProject, matinv);
                var src1 = new gd3d.math.vector3(vppos.x, vppos.y, screenPos.z);
                gd3d.math.matrixTransformVector3(src1, matinv, outWorldPos);
            };
            camera.prototype.calcScreenPosFromWorldPos = function (app, worldPos, outScreenPos) {
                var vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, vpp);
                var matrixView = new gd3d.math.matrix();
                var matrixProject = new gd3d.math.matrix();
                var asp = vpp.w / vpp.h;
                this.calcViewMatrix(matrixView);
                this.calcProjectMatrix(asp, matrixProject);
                var matrixViewProject = new gd3d.math.matrix();
                gd3d.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                var ndcPos = gd3d.math.pool.new_vector3();
                gd3d.math.matrixTransformVector3(worldPos, matrixViewProject, ndcPos);
                outScreenPos.x = (ndcPos.x + 1) * vpp.w / 2;
                outScreenPos.y = (1 - ndcPos.y) * vpp.h / 2;
            };
            camera.prototype.calcCameraFrame = function (app) {
                var _vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, _vpp);
                var near_h = this.near * Math.tan(this.fov * 0.5);
                var asp = _vpp.w / _vpp.h;
                var near_w = near_h * asp;
                var nearLT = new gd3d.math.vector3(-near_w, near_h, this.near);
                var nearLD = new gd3d.math.vector3(-near_w, -near_h, this.near);
                var nearRT = new gd3d.math.vector3(near_w, near_h, this.near);
                var nearRD = new gd3d.math.vector3(near_w, -near_h, this.near);
                var far_h = this.far * Math.tan(this.fov * 0.5);
                var far_w = far_h * asp;
                var farLT = new gd3d.math.vector3(-far_w, far_h, this.far);
                var farLD = new gd3d.math.vector3(-far_w, -far_h, this.far);
                var farRT = new gd3d.math.vector3(far_w, far_h, this.far);
                var farRD = new gd3d.math.vector3(far_w, -far_h, this.far);
                var matrix = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixTransformVector3(farLD, matrix, farLD);
                gd3d.math.matrixTransformVector3(nearLD, matrix, nearLD);
                gd3d.math.matrixTransformVector3(farRD, matrix, farRD);
                gd3d.math.matrixTransformVector3(nearRD, matrix, nearRD);
                gd3d.math.matrixTransformVector3(farLT, matrix, farLT);
                gd3d.math.matrixTransformVector3(nearLT, matrix, nearLT);
                gd3d.math.matrixTransformVector3(farRT, matrix, farRT);
                gd3d.math.matrixTransformVector3(nearRT, matrix, nearRT);
                this.frameVecs.length = 0;
                this.frameVecs.push(farLD);
                this.frameVecs.push(nearLD);
                this.frameVecs.push(farRD);
                this.frameVecs.push(nearRD);
                this.frameVecs.push(farLT);
                this.frameVecs.push(nearLT);
                this.frameVecs.push(farRT);
                this.frameVecs.push(nearRT);
            };
            Object.defineProperty(camera.prototype, "opvalue", {
                get: function () {
                    return this._opvalue;
                },
                set: function (val) {
                    if (val > 0 && this._near < 0.01) {
                        this._near = 0.01;
                        if (this._far <= this._near)
                            this._far = this._near + 0.01;
                    }
                    this._opvalue = val;
                },
                enumerable: true,
                configurable: true
            });
            camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, app, z, out) {
                var vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, vpp);
                var nearpos = new gd3d.math.vector3;
                nearpos.z = -this.near;
                nearpos.x = screenPos.x - vpp.w * 0.5;
                nearpos.y = vpp.h * 0.5 - screenPos.y;
                var farpos = new gd3d.math.vector3;
                farpos.z = -this.far;
                farpos.x = this.far * nearpos.x / this.near;
                farpos.y = this.far * nearpos.y / this.near;
                ;
                var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
                out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
                out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
            };
            camera.prototype.fillRenderer = function (scene) {
                scene.renderList.clear();
                if (scene.app.isFrustumCulling)
                    this.calcCameraFrame(scene.app);
                this._fillRenderer(scene, scene.getRoot());
            };
            camera.prototype._fillRenderer = function (scene, node) {
                if (node.hasRendererComp == false && node.hasRendererCompChild == false)
                    return;
                if (scene.app.isFrustumCulling && !this.testFrustumCulling(scene, node))
                    return;
                if (node.gameObject != null && node.gameObject.renderer != null && node.gameObject.visible) {
                    scene.renderList.addRenderer(node.gameObject.renderer);
                }
                if (node.children != null && node.gameObject.visible) {
                    for (var i = 0; i < node.children.length; i++) {
                        this._fillRenderer(scene, node.children[i]);
                    }
                }
            };
            camera.prototype.testFrustumCulling = function (scene, node) {
                if (!node.gameObject.getComponent("frustumculling"))
                    return true;
                var spherecol = node.gameObject.getComponent("spherecollider");
                var worldPos = node.getWorldTranslate();
                if (!spherecol.caclPlaneInDir(this.frameVecs[0], this.frameVecs[1], this.frameVecs[5]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[1], this.frameVecs[3], this.frameVecs[7]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[3], this.frameVecs[2], this.frameVecs[6]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[2], this.frameVecs[0], this.frameVecs[4]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[5], this.frameVecs[7], this.frameVecs[6]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[0], this.frameVecs[2], this.frameVecs[3]))
                    return false;
                return true;
            };
            camera.prototype._targetAndViewport = function (target, scene, context, withoutClear) {
                {
                    var w;
                    var h;
                    if (target == null) {
                        w = scene.app.width;
                        h = scene.app.height;
                        gd3d.render.glRenderTarget.useNull(context.webgl);
                    }
                    else {
                        w = target.width;
                        h = target.height;
                        target.use(context.webgl);
                    }
                    context.webgl.viewport(w * this.viewport.x, h * this.viewport.y, w * this.viewport.w, h * this.viewport.h);
                    context.webgl.depthRange(0, 1);
                    if (withoutClear == false) {
                        if (this.clearOption_Color && this.clearOption_Depth) {
                            context.webgl.depthMask(true);
                            gd3d.render.glDrawPass.lastZWrite = true;
                            context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            context.webgl.clearDepth(1.0);
                            context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                        }
                        else if (this.clearOption_Depth) {
                            context.webgl.depthMask(true);
                            gd3d.render.glDrawPass.lastZWrite = true;
                            context.webgl.clearDepth(1.0);
                            context.webgl.clear(context.webgl.DEPTH_BUFFER_BIT);
                        }
                        else if (this.clearOption_Color) {
                            context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            context.webgl.clear(context.webgl.COLOR_BUFFER_BIT);
                        }
                        else {
                        }
                    }
                }
            };
            camera.prototype._renderOnce = function (scene, context, drawtype) {
                context.drawtype = drawtype;
                var assetmgr = scene.app.getAssetMgr();
                for (var i = 0; i < scene.renderList.renderLayers.length; i++) {
                    var layer = scene.renderList.renderLayers[i];
                    var list = layer.list;
                    for (var j = 0; j < list.length; j++) {
                        if (this.CullingMask & list[j].renderLayer) {
                            list[j].render(context, assetmgr, this);
                        }
                    }
                }
            };
            camera.prototype.renderScene = function (scene, context) {
                for (var i = 0; i < scene.renderList.renderLayers.length; i++) {
                    var layer = scene.renderList.renderLayers[i];
                    var list = layer.list;
                    if (layer.needSort) {
                        if (list.length > 1) {
                            list.sort(function (a, b) {
                                if (a.queue != b.queue) {
                                    return a.queue - b.queue;
                                }
                                else {
                                    var matrixView = context.matrixView;
                                    var az = gd3d.math.pool.new_vector3();
                                    var bz = gd3d.math.pool.new_vector3();
                                    gd3d.math.matrixTransformVector3(a.gameObject.transform.getWorldTranslate(), matrixView, az);
                                    gd3d.math.matrixTransformVector3(b.gameObject.transform.getWorldTranslate(), matrixView, bz);
                                    return bz.z - az.z;
                                }
                            });
                        }
                    }
                }
                if (this.postQueues.length == 0) {
                    this._targetAndViewport(this.renderTarget, scene, context, false);
                    this._renderOnce(scene, context, "");
                }
                else {
                    for (var i = 0; i < this.postQueues.length; i++) {
                        this.postQueues[i].render(scene, context, this);
                    }
                    context.webgl.flush();
                }
            };
            camera.prototype.remove = function () {
            };
            camera.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.UIStyle("rangeFloat", 1, 1000, 2),
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], camera.prototype, "near", null);
            __decorate([
                gd3d.reflect.UIStyle("rangeFloat", 1, 1000, 999),
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], camera.prototype, "far", null);
            __decorate([
                gd3d.reflect.compCall({ "use": "dirty", "display": "刷新camera" }),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", []),
                __metadata("design:returntype", void 0)
            ], camera.prototype, "markDirty", null);
            __decorate([
                gd3d.reflect.Field("IOverLay[]"),
                __metadata("design:type", Array)
            ], camera.prototype, "overlays", void 0);
            camera = __decorate([
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeCamera
            ], camera);
            return camera;
        }());
        framework.camera = camera;
        var CullingMask;
        (function (CullingMask) {
            CullingMask[CullingMask["ui"] = 1] = "ui";
            CullingMask[CullingMask["default"] = 2] = "default";
            CullingMask[CullingMask["editor"] = 4] = "editor";
            CullingMask[CullingMask["model"] = 8] = "model";
            CullingMask[CullingMask["everything"] = 4294967295] = "everything";
            CullingMask[CullingMask["nothing"] = 0] = "nothing";
            CullingMask[CullingMask["modelbeforeui"] = 8] = "modelbeforeui";
        })(CullingMask = framework.CullingMask || (framework.CullingMask = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var canvascontainer = (function () {
            function canvascontainer() {
                this.isCanvasinit = false;
                this._lastMode = canvasRenderMode.ScreenSpaceOverlay;
                this._renderMode = canvasRenderMode.ScreenSpaceOverlay;
            }
            Object.defineProperty(canvascontainer.prototype, "canvas", {
                get: function () {
                    if (this._overlay2d && this._overlay2d.canvas)
                        return this._overlay2d.canvas;
                },
                enumerable: true,
                configurable: true
            });
            canvascontainer.prototype.setOverLay = function (lay) {
                this._overlay2d = lay;
                this.canvasInit();
            };
            Object.defineProperty(canvascontainer.prototype, "sortOrder", {
                get: function () {
                    return this._overlay2d ? this._overlay2d.sortOrder : 0;
                },
                set: function (order) {
                    if (this._overlay2d)
                        this._overlay2d.sortOrder = order;
                },
                enumerable: true,
                configurable: true
            });
            canvascontainer.prototype.canvasInit = function () {
                if (!this.gameObject || !this.gameObject.transform || !this.gameObject.transform.scene)
                    return;
                if (!this._overlay2d || !this._overlay2d.canvas)
                    return;
                this._overlay2d.canvas.scene = this.gameObject.transform.scene;
                this._overlay2d.canvas.assetmgr = this._overlay2d.canvas.scene.app.getAssetMgr();
                this.isCanvasinit = true;
            };
            Object.defineProperty(canvascontainer.prototype, "renderMode", {
                get: function () { return this._renderMode; },
                set: function (mode) {
                    if (this._renderMode == mode)
                        return;
                    this._lastMode = this._renderMode;
                    this._renderMode = mode;
                    this.styleToMode();
                },
                enumerable: true,
                configurable: true
            });
            canvascontainer.prototype.styleToMode = function () {
                switch (this._renderMode) {
                    case canvasRenderMode.ScreenSpaceOverlay:
                        if (!this._overlay2d)
                            return;
                        var scene_1 = this.gameObject.getScene();
                        scene_1.addScreenSpaceOverlay(this._overlay2d);
                        break;
                }
            };
            canvascontainer.prototype.start = function () {
                this.styleToMode();
            };
            canvascontainer.prototype.update = function (delta) {
                if (!this.isCanvasinit)
                    this.canvasInit();
            };
            canvascontainer.prototype.remove = function () {
            };
            canvascontainer.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.Field("reference"),
                __metadata("design:type", framework.overlay2D)
            ], canvascontainer.prototype, "_overlay2d", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], canvascontainer.prototype, "renderMode", null);
            canvascontainer = __decorate([
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], canvascontainer);
            return canvascontainer;
        }());
        framework.canvascontainer = canvascontainer;
        var canvasRenderMode;
        (function (canvasRenderMode) {
            canvasRenderMode[canvasRenderMode["ScreenSpaceOverlay"] = 0] = "ScreenSpaceOverlay";
            canvasRenderMode[canvasRenderMode["ScreenSpaceCamera"] = 1] = "ScreenSpaceCamera";
            canvasRenderMode[canvasRenderMode["WorldSpace"] = 2] = "WorldSpace";
        })(canvasRenderMode = framework.canvasRenderMode || (framework.canvasRenderMode = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var effectSystem = (function () {
            function effectSystem() {
                this.layer = framework.RenderLayerEnum.Transparent;
                this.renderLayer = framework.CullingMask.default;
                this.queue = 0;
                this.autoplay = true;
                this.state = framework.EffectPlayStateEnum.None;
                this.curFrameId = -1;
                this.playTimer = 0;
                this.speed = 1;
                this.parser = new gd3d.framework.EffectParser();
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.effectBatchers = [];
                this.matDataGroups = [];
                this.particleElementDic = {};
                this.delayElements = [];
                this.refElements = [];
                this.beExecuteNextFrame = true;
            }
            effectSystem_1 = effectSystem;
            Object.defineProperty(effectSystem.prototype, "jsonData", {
                get: function () {
                    return this._textasset;
                },
                set: function (text) {
                    this._textasset = text;
                    this.setJsonDataStr(this.jsonData.content);
                },
                enumerable: true,
                configurable: true
            });
            effectSystem.prototype.setJsonData = function (_jsonData) {
                this._textasset = _jsonData;
                this.setJsonDataStr(this.jsonData.content);
            };
            effectSystem.prototype.setJsonDataStr = function (_jsonStr) {
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.data = this.parser.Parse(_jsonStr, gd3d.framework.sceneMgr.app.getAssetMgr());
            };
            effectSystem.prototype.updateJsonData = function (_jsonData) {
                this.jsonData = _jsonData;
                this.updateJsonDataStr(this.jsonData.content);
            };
            effectSystem.prototype.updateJsonDataStr = function (_jsonStr) {
                this.remove();
                this.data = this.parser.Parse(_jsonStr, gd3d.framework.sceneMgr.app.getAssetMgr());
                console.warn("开始解析特效");
            };
            Object.defineProperty(effectSystem.prototype, "data", {
                get: function () {
                    return this._data;
                },
                set: function (value) {
                    this._data = value;
                },
                enumerable: true,
                configurable: true
            });
            effectSystem.prototype.init = function () {
                if (this._data) {
                    this.addElements();
                }
            };
            Object.defineProperty(effectSystem.prototype, "totalFrameCount", {
                get: function () {
                    return this.data.life * effectSystem_1.fps;
                },
                enumerable: true,
                configurable: true
            });
            effectSystem.prototype.start = function () {
                this.init();
            };
            effectSystem.prototype.update = function (delta) {
                if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined)
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.playTimer += delta * this.speed;
                    if (!this.beLoop) {
                        if (this.playTimer >= this.data.life) {
                            this.stop();
                        }
                    }
                    this._update(delta);
                }
                else if (this.state == framework.EffectPlayStateEnum.BeReady) {
                    if (this.autoplay) {
                        this.play();
                        this._update(delta);
                    }
                    else {
                        this.gameObject.visible = false;
                        this.gameObject.transform.markDirty();
                    }
                }
            };
            effectSystem.prototype._update = function (delta) {
                if (this.delayElements.length > 0) {
                    if (this.refElements.length > 0)
                        this.refElements = [];
                    for (var i = this.delayElements.length - 1; i >= 0; i--) {
                        var data = this.delayElements[i];
                        if (data.delayTime <= this.playTimer) {
                            this.addElement(this.delayElements[i]);
                            this.delayElements.splice(i, 1);
                        }
                    }
                }
                if (this.particles != undefined) {
                    this.particles.updateForEmission(delta);
                }
                if (this.checkFrameId()) {
                    for (var i in this.effectBatchers) {
                        var subEffectBatcher = this.effectBatchers[i];
                        for (var key in subEffectBatcher.effectElements) {
                            var element = subEffectBatcher.effectElements[key];
                            if (element.delayTime == undefined || element.delayTime <= this.playTimer) {
                                subEffectBatcher.mesh.submesh[0].size = element.endEboIndex;
                            }
                            else {
                                if (subEffectBatcher.mesh.submesh[0].size > element.startEboIndex)
                                    subEffectBatcher.mesh.submesh[0].size = element.startEboIndex;
                            }
                            var frameId = (this.curFrameId - this.getDelayFrameCount(element.delayTime)) % element.loopFrame;
                            frameId = Math.floor(frameId);
                            if (element.active) {
                                element.actionActive = false;
                                this.mergeLerpAttribData(element.curAttrData, element.timelineFrame[frameId]);
                                if (element.actions != undefined) {
                                    element.actionActive = true;
                                    for (var j in element.actions) {
                                        element.actions[j].update(frameId);
                                    }
                                }
                            }
                            element.update();
                            if (element.isCurFrameNeedRefresh(frameId)) {
                                this.updateEffectBatcher(element.effectBatcher, element.curAttrData, element.data.initFrameData, element.startVboIndex);
                            }
                        }
                    }
                    if (this.particles != undefined) {
                        this.particles.update(1 / effectSystem_1.fps);
                    }
                }
            };
            effectSystem.prototype.mergeLerpAttribData = function (realUseCurFrameData, curFrameData) {
                if (curFrameData == undefined)
                    return;
                if (realUseCurFrameData == undefined)
                    return;
                for (var key in curFrameData.attrsData) {
                    if (curFrameData.attrsData[key] != undefined && realUseCurFrameData[key] != undefined) {
                        var val = curFrameData.attrsData.getAttribute(key);
                        if (val == null)
                            continue;
                        if (val instanceof gd3d.math.vector3 || val instanceof gd3d.math.vector2 || typeof (val) === 'number') {
                            if (key != "renderModel")
                                realUseCurFrameData[key] = val;
                        }
                    }
                }
            };
            effectSystem.prototype.updateEffectBatcher = function (effectBatcher, curAttrsData, initFrameData, vertexStartIndex) {
                var mesh = curAttrsData.mesh;
                if (mesh == undefined) {
                    mesh = initFrameData.attrsData.mesh;
                }
                if (mesh == undefined)
                    return;
                if (curAttrsData.meshdataVbo == undefined) {
                    curAttrsData.meshdataVbo = mesh.data.genVertexDataArray(this.vf);
                }
                var vertexCount = mesh.data.pos.length;
                var vertexArr = curAttrsData.meshdataVbo;
                var vertexSize = effectBatcher.vertexSize;
                for (var i = 0; i < vertexCount; i++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = vertexArr[i * vertexSize + 0];
                        vertex.y = vertexArr[i * vertexSize + 1];
                        vertex.z = vertexArr[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, curAttrsData.matrix, vertex);
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 0] = vertex.x;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 1] = vertex.y;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        var r = vertexArr[i * vertexSize + 9];
                        var g = vertexArr[i * vertexSize + 10];
                        var b = vertexArr[i * vertexSize + 11];
                        var a = vertexArr[i * vertexSize + 12];
                        if (curAttrsData.color != undefined) {
                            r = curAttrsData.color.x;
                            g = curAttrsData.color.y;
                            b = curAttrsData.color.z;
                        }
                        if (curAttrsData.alpha != undefined)
                            a = a * curAttrsData.alpha;
                        if (curAttrsData.colorRate != undefined) {
                            r *= curAttrsData.colorRate;
                            g *= curAttrsData.colorRate;
                            b *= curAttrsData.colorRate;
                            a *= curAttrsData.colorRate;
                        }
                        r = gd3d.math.floatClamp(r, 0, 3);
                        g = gd3d.math.floatClamp(g, 0, 3);
                        b = gd3d.math.floatClamp(b, 0, 3);
                        a = gd3d.math.floatClamp(a, 0, 3);
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 9] = r;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 10] = g;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 11] = b;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 12] = a;
                    }
                    {
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 13] = vertexArr[i * vertexSize + 13] * curAttrsData.tilling.x + curAttrsData.uv.x;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 14] = vertexArr[i * vertexSize + 14] * curAttrsData.tilling.y + curAttrsData.uv.y;
                    }
                }
            };
            effectSystem.prototype.render = function (context, assetmgr, camera) {
                if (!(camera.CullingMask & this.renderLayer))
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    context.updateModel(this.gameObject.transform);
                    for (var i in this.effectBatchers) {
                        var subEffectBatcher = this.effectBatchers[i];
                        var mesh_2 = subEffectBatcher.mesh;
                        if (subEffectBatcher.state === framework.EffectBatcherState.NotInitedStateType) {
                            mesh_2.glMesh.initBuffer(context.webgl, this.vf, subEffectBatcher.curTotalVertexCount);
                            if (mesh_2.glMesh.ebos.length == 0) {
                                mesh_2.glMesh.addIndex(context.webgl, subEffectBatcher.dataForEbo.length);
                            }
                            else {
                                mesh_2.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
                            }
                            mesh_2.glMesh.uploadIndexData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh_2.submesh[0].size = subEffectBatcher.dataForEbo.length;
                            subEffectBatcher.state = framework.EffectBatcherState.InitedStateType;
                        }
                        else if (subEffectBatcher.state === framework.EffectBatcherState.ResizeCapacityStateType) {
                            mesh_2.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
                            mesh_2.submesh[0].size = subEffectBatcher.dataForEbo.length;
                            mesh_2.glMesh.uploadIndexData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh_2.glMesh.resetVboSize(context.webgl, subEffectBatcher.curTotalVertexCount * subEffectBatcher.vertexSize);
                            subEffectBatcher.state = framework.EffectBatcherState.InitedStateType;
                        }
                        mesh_2.glMesh.uploadVertexData(context.webgl, subEffectBatcher.dataForVbo);
                        if (this.gameObject.getScene().fog) {
                            context.fog = this.gameObject.getScene().fog;
                            subEffectBatcher.mat.draw(context, mesh_2, mesh_2.submesh[0], "base_fog");
                        }
                        else {
                            subEffectBatcher.mat.draw(context, mesh_2, mesh_2.submesh[0], "base");
                        }
                    }
                    if (this.particles != undefined) {
                        this.particles.render(context, assetmgr, camera);
                    }
                }
            };
            effectSystem.prototype.clone = function () {
                var effect = new effectSystem_1();
                if (this.jsonData)
                    effect.jsonData = this.jsonData;
                if (this.data)
                    effect.data = this.data.clone();
                effect.autoplay = this.autoplay;
                effect.beLoop = this.beLoop;
                return effect;
            };
            effectSystem.prototype.play = function (speed) {
                if (speed === void 0) { speed = 1; }
                if (this.state != framework.EffectPlayStateEnum.Pause)
                    this.stop();
                this.speed = speed;
                this.state = framework.EffectPlayStateEnum.Play;
                this.gameObject.visible = true;
                this.gameObject.transform.markDirty();
            };
            effectSystem.prototype.pause = function () {
                this.state = framework.EffectPlayStateEnum.Pause;
            };
            effectSystem.prototype.stop = function () {
                this.reset();
                this.state = framework.EffectPlayStateEnum.Stop;
            };
            effectSystem.prototype.reset = function (restSinglemesh, resetParticle) {
                if (restSinglemesh === void 0) { restSinglemesh = true; }
                if (resetParticle === void 0) { resetParticle = true; }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.gameObject.visible = false;
                this.playTimer = 0;
                this.resetSingleMesh();
                this.resetparticle();
            };
            effectSystem.prototype.resetSingleMesh = function () {
                for (var i in this.effectBatchers) {
                    var subEffectBatcher = this.effectBatchers[i];
                    for (var key in subEffectBatcher.effectElements) {
                        var element = subEffectBatcher.effectElements[key];
                        element.setActive(true);
                        if (element.data.initFrameData != undefined)
                            element.curAttrData = element.data.initFrameData.attrsData.copyandinit();
                    }
                }
            };
            effectSystem.prototype.resetparticle = function () {
                if (this.particles != undefined)
                    this.particles.dispose();
                for (var name_3 in this.particleElementDic) {
                    var data = this.data.elementDic[name_3];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    if (data.refFrom == undefined) {
                        if (this.particles == undefined) {
                            this.particles = new framework.Particles(this);
                        }
                        this.particles.addEmission(data);
                    }
                    else {
                        this.refElements.push(data);
                    }
                }
            };
            effectSystem.prototype.addElements = function () {
                for (var name_4 in this.data.elementDic) {
                    var data = this.data.elementDic[name_4];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    this.addElement(data);
                }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.beLoop = this.data.beLoop;
            };
            effectSystem.prototype.addElement = function (data) {
                if (data.type == framework.EffectElementTypeEnum.EmissionType) {
                    if (this.particles == undefined) {
                        this.particles = new framework.Particles(this);
                    }
                    this.particles.addEmission(data);
                    this.particleElementDic[data.name] = data;
                }
                else if (data.type == framework.EffectElementTypeEnum.SingleMeshType) {
                    this.addInitFrame(data);
                }
            };
            effectSystem.prototype.addInitFrame = function (elementData) {
                var element = new framework.EffectElement(elementData);
                element.transform = this.gameObject.transform;
                var _initFrameData = element.data.initFrameData;
                if (_initFrameData == undefined || _initFrameData.attrsData == undefined || _initFrameData.attrsData.mesh == undefined)
                    return;
                var index = -1;
                if (_initFrameData.attrsData.mat != null) {
                    for (var i_3 = 0; i_3 < this.matDataGroups.length; i_3++) {
                        if (framework.EffectMatData.beEqual(this.matDataGroups[i_3], _initFrameData.attrsData.mat)) {
                            index = i_3;
                            break;
                        }
                    }
                }
                var vertexStartIndex = 0;
                var vertexCount = _initFrameData.attrsData.mesh.data.pos.length;
                var indexCount = _initFrameData.attrsData.mesh.data.genIndexDataArray;
                var subEffectBatcher = null;
                if (index >= 0) {
                    subEffectBatcher = this.effectBatchers[index];
                    vertexStartIndex = subEffectBatcher.curTotalVertexCount;
                    subEffectBatcher.curTotalVertexCount += vertexCount;
                    if (subEffectBatcher.state == framework.EffectBatcherState.InitedStateType)
                        subEffectBatcher.state = framework.EffectBatcherState.ResizeCapacityStateType;
                }
                else {
                    subEffectBatcher = new framework.EffectBatcher(this.vf);
                    subEffectBatcher.curTotalVertexCount = vertexCount;
                    subEffectBatcher.mesh = new framework.mesh();
                    subEffectBatcher.mesh.data = new gd3d.render.meshData();
                    subEffectBatcher.mesh.glMesh = new gd3d.render.glMesh();
                    subEffectBatcher.mat = new framework.material();
                    subEffectBatcher.mesh.submesh = [];
                    {
                        var sm = new framework.subMeshInfo();
                        sm.matIndex = 0;
                        sm.useVertexIndex = 0;
                        sm.start = 0;
                        sm.size = 0;
                        sm.line = false;
                        subEffectBatcher.mesh.submesh.push(sm);
                    }
                    vertexStartIndex = 0;
                    index = 0;
                    if (_initFrameData.attrsData.mat.shader == null) {
                        subEffectBatcher.mat.setShader(framework.sceneMgr.app.getAssetMgr().getShader("diffuse.shader.json"));
                        console.error("特效{0}shader为空", elementData.name);
                    }
                    else {
                        subEffectBatcher.mat.setShader(_initFrameData.attrsData.mat.shader);
                    }
                    if (_initFrameData.attrsData.mat.alphaCut != undefined)
                        subEffectBatcher.mat.setFloat("_AlphaCut", _initFrameData.attrsData.mat.alphaCut);
                    if (_initFrameData.attrsData.mat.diffuseTexture != null)
                        subEffectBatcher.mat.setTexture("_MainTex", _initFrameData.attrsData.mat.diffuseTexture);
                    if (_initFrameData.attrsData.mat.alphaTexture != null)
                        subEffectBatcher.mat.setTexture("_AlphaTex", _initFrameData.attrsData.mat.alphaTexture);
                    this.effectBatchers.push(subEffectBatcher);
                    this.matDataGroups.push(_initFrameData.attrsData.mat);
                }
                element.effectBatcher = subEffectBatcher;
                element.startVboIndex = vertexStartIndex;
                element.curAttrData = elementData.initFrameData.attrsData.copyandinit();
                var vertexSize = subEffectBatcher.vertexSize;
                var vertexArr = _initFrameData.attrsData.mesh.data.genVertexDataArray(this.vf);
                element.update();
                subEffectBatcher.effectElements.push(element);
                for (var i_4 = 0; i_4 < vertexCount; i_4++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = vertexArr[i_4 * vertexSize + 0];
                        vertex.y = vertexArr[i_4 * vertexSize + 1];
                        vertex.z = vertexArr[i_4 * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, element.curAttrData.matrix, vertex);
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 0] = vertex.x;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 1] = vertex.y;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 3] = vertexArr[i_4 * vertexSize + 3];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 4] = vertexArr[i_4 * vertexSize + 4];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 5] = vertexArr[i_4 * vertexSize + 5];
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 6] = vertexArr[i_4 * vertexSize + 6];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 7] = vertexArr[i_4 * vertexSize + 7];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 8] = vertexArr[i_4 * vertexSize + 8];
                    }
                    {
                        var r = gd3d.math.floatClamp(element.curAttrData.color.x, 0, 1);
                        var g = gd3d.math.floatClamp(element.curAttrData.color.y, 0, 1);
                        var b = gd3d.math.floatClamp(element.curAttrData.color.z, 0, 1);
                        var a = gd3d.math.floatClamp(vertexArr[i_4 * vertexSize + 12] * element.curAttrData.alpha, 0, 1);
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * 15 + 9] = r;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * 15 + 10] = g;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * 15 + 11] = b;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * 15 + 12] = a;
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 13] = vertexArr[i_4 * vertexSize + 13] * element.curAttrData.tilling.x;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_4) * vertexSize + 14] = vertexArr[i_4 * vertexSize + 14] * element.curAttrData.tilling.y;
                    }
                }
                var indexArray = _initFrameData.attrsData.mesh.data.genIndexDataArray();
                var _startIndex = subEffectBatcher.indexStartIndex;
                element.startEboIndex = _startIndex;
                subEffectBatcher.indexStartIndex += indexArray.length;
                element.endEboIndex = subEffectBatcher.indexStartIndex;
                for (var i = 0; i < indexArray.length; i++) {
                    subEffectBatcher.dataForEbo[_startIndex + i] = indexArray[i] + vertexStartIndex;
                }
            };
            effectSystem.prototype.setFrameId = function (id) {
                if (this.state == framework.EffectPlayStateEnum.Pause && id >= 0 && id < this.totalFrameCount)
                    this.curFrameId = id;
            };
            effectSystem.prototype.getDelayFrameCount = function (delayTime) {
                return delayTime * effectSystem_1.fps;
            };
            effectSystem.prototype.checkFrameId = function () {
                var curid = (effectSystem_1.fps * this.playTimer) | 0;
                if (curid != this.curFrameId) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.curFrameId = curid;
                    this.beExecuteNextFrame = true;
                    return true;
                }
                return false;
            };
            effectSystem.prototype.remove = function () {
                this.state = framework.EffectPlayStateEnum.Dispose;
                if (this.data)
                    this.data.dispose();
                while (this.effectBatchers.length > 0) {
                    this.effectBatchers[0].dispose();
                    this.effectBatchers.splice(0, 1);
                }
                while (this.matDataGroups.length > 0) {
                    this.matDataGroups.splice(0, 1);
                }
                if (this.particles)
                    this.particles.dispose();
                this.curFrameId = -1;
                this.playTimer = 0;
            };
            Object.defineProperty(effectSystem.prototype, "leftLifeTime", {
                get: function () {
                    if (this.data != null) {
                        return this.data.life - this.playTimer;
                    }
                    else
                        return 9999999999;
                },
                enumerable: true,
                configurable: true
            });
            effectSystem.fps = 30;
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], effectSystem.prototype, "autoplay", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], effectSystem.prototype, "beLoop", void 0);
            __decorate([
                gd3d.reflect.Field("textasset"),
                __metadata("design:type", framework.textasset),
                __metadata("design:paramtypes", [framework.textasset])
            ], effectSystem.prototype, "jsonData", null);
            effectSystem = effectSystem_1 = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent
            ], effectSystem);
            return effectSystem;
            var effectSystem_1;
        }());
        framework.effectSystem = effectSystem;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var TestEffectSystem = (function () {
            function TestEffectSystem() {
                this.layer = framework.RenderLayerEnum.Transparent;
                this.renderLayer = framework.CullingMask.default;
                this.queue = 0;
                this.autoplay = true;
                this.state = framework.EffectPlayStateEnum.None;
                this.curFrameId = -1;
                this.playTimer = 0;
                this.speed = 1;
                this.parser = new gd3d.framework.EffectParser();
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.effectBatchers = [];
                this.matDataGroups = [];
                this.particleElementDic = {};
                this.delayElements = [];
                this.refElements = [];
                this.beExecuteNextFrame = true;
            }
            TestEffectSystem.prototype.setJsonData = function (_jsonData) {
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.jsonData = _jsonData;
                this.data = this.parser.Parse(this.jsonData.content, gd3d.framework.sceneMgr.app.getAssetMgr());
            };
            Object.defineProperty(TestEffectSystem.prototype, "data", {
                get: function () {
                    return this._data;
                },
                set: function (value) {
                    this._data = value;
                },
                enumerable: true,
                configurable: true
            });
            TestEffectSystem.prototype.init = function () {
                if (this._data) {
                    this.addElements();
                }
            };
            Object.defineProperty(TestEffectSystem.prototype, "totalFrameCount", {
                get: function () {
                    return this.data.life * framework.effectSystem.fps;
                },
                enumerable: true,
                configurable: true
            });
            TestEffectSystem.prototype.start = function () {
                this.init();
            };
            TestEffectSystem.prototype.update = function (delta) {
                if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined)
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.playTimer += delta * this.speed;
                    if (!this.beLoop) {
                        if (this.playTimer >= this.data.life) {
                            this.stop();
                        }
                    }
                    this._update(delta);
                }
                else if (this.state == framework.EffectPlayStateEnum.BeReady) {
                    if (this.autoplay) {
                        this.play();
                        this._update(delta);
                    }
                    else {
                        this.gameObject.visible = false;
                        this.gameObject.transform.markDirty();
                    }
                }
            };
            TestEffectSystem.prototype._update = function (delta) {
                if (this.delayElements.length > 0) {
                    if (this.refElements.length > 0)
                        this.refElements = [];
                    for (var i_5 = this.delayElements.length - 1; i_5 >= 0; i_5--) {
                        var data = this.delayElements[i_5];
                        if (data.delayTime <= this.playTimer) {
                            this.addElement(this.delayElements[i_5]);
                            this.delayElements.splice(i_5, 1);
                        }
                    }
                }
                if (this.checkFrameId()) {
                    if (this.emissionElement != null) {
                        for (var i = 0; i < this.emissionElement.length; i++) {
                            this.emissionElement[i].update(1 / framework.effectSystem.fps);
                        }
                    }
                }
            };
            TestEffectSystem.prototype.render = function (context, assetmgr, camera) {
                if (!(camera.CullingMask & this.renderLayer))
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play) {
                    context.updateModel(this.gameObject.transform);
                    if (this.emissionElement != null) {
                        for (var i = 0; i < this.emissionElement.length; i++) {
                            this.emissionElement[i].render(context, assetmgr, camera);
                        }
                    }
                }
            };
            TestEffectSystem.prototype.clone = function () {
                var effect = new framework.effectSystem();
                effect.data = this.data.clone();
                return effect;
            };
            TestEffectSystem.prototype.play = function (speed) {
                if (speed === void 0) { speed = 1; }
                this.speed = speed;
                this.state = framework.EffectPlayStateEnum.Play;
                this.gameObject.visible = true;
                this.gameObject.transform.markDirty();
            };
            TestEffectSystem.prototype.pause = function () {
                this.state = framework.EffectPlayStateEnum.Pause;
            };
            TestEffectSystem.prototype.stop = function () {
                this.reset();
                this.state = framework.EffectPlayStateEnum.Stop;
            };
            TestEffectSystem.prototype.reset = function (restSinglemesh, resetParticle) {
                if (restSinglemesh === void 0) { restSinglemesh = true; }
                if (resetParticle === void 0) { resetParticle = true; }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.gameObject.visible = false;
                this.playTimer = 0;
                this.resetSingleMesh();
            };
            TestEffectSystem.prototype.resetSingleMesh = function () {
                for (var i in this.effectBatchers) {
                    var subEffectBatcher = this.effectBatchers[i];
                    for (var key in subEffectBatcher.effectElements) {
                        var element = subEffectBatcher.effectElements[key];
                        element.setActive(true);
                        if (element.data.initFrameData != undefined)
                            element.curAttrData = element.data.initFrameData.attrsData.copyandinit();
                    }
                }
            };
            TestEffectSystem.prototype.addElements = function () {
                for (var name_5 in this.data.elementDic) {
                    var data = this.data.elementDic[name_5];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    this.addElement(data);
                }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.beLoop = this.data.beLoop;
            };
            TestEffectSystem.prototype.addElement = function (data) {
            };
            TestEffectSystem.prototype.addEmissionElement = function (data) {
                if (data === void 0) { data = null; }
                if (this.emissionElement == null) {
                    this.emissionElement = [];
                }
                var emission = new framework.EffectElementEmission(this, data);
                this.emissionElement.push(emission);
            };
            TestEffectSystem.prototype.setFrameId = function (id) {
                if (this.state == framework.EffectPlayStateEnum.Pause && id >= 0 && id < this.totalFrameCount)
                    this.curFrameId = id;
            };
            TestEffectSystem.prototype.getDelayFrameCount = function (delayTime) {
                return delayTime * framework.effectSystem.fps;
            };
            TestEffectSystem.prototype.checkFrameId = function () {
                var curid = (framework.effectSystem.fps * this.playTimer) | 0;
                if (curid != this.curFrameId) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.curFrameId = curid;
                    this.beExecuteNextFrame = true;
                    return true;
                }
                return false;
            };
            TestEffectSystem.prototype.remove = function () {
                this.state = framework.EffectPlayStateEnum.Dispose;
                if (this.data)
                    this.data.dispose();
                for (var key in this.effectBatchers) {
                    this.effectBatchers[key].dispose();
                }
                if (this.particles)
                    this.particles.dispose();
            };
            Object.defineProperty(TestEffectSystem.prototype, "leftLifeTime", {
                get: function () {
                    if (this.data != null) {
                        return this.data.life - this.playTimer;
                    }
                    else
                        return 9999999999;
                },
                enumerable: true,
                configurable: true
            });
            TestEffectSystem.fps = 30;
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], TestEffectSystem.prototype, "autoplay", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], TestEffectSystem.prototype, "beLoop", void 0);
            __decorate([
                gd3d.reflect.Field("textasset"),
                __metadata("design:type", framework.textasset)
            ], TestEffectSystem.prototype, "jsonData", void 0);
            TestEffectSystem = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent,
                gd3d.reflect.selfClone
            ], TestEffectSystem);
            return TestEffectSystem;
        }());
        framework.TestEffectSystem = TestEffectSystem;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var frustumculling = (function () {
            function frustumculling() {
            }
            frustumculling.prototype.start = function () {
            };
            frustumculling.prototype.update = function (delta) {
            };
            frustumculling.prototype.remove = function () {
            };
            frustumculling.prototype.clone = function () {
            };
            frustumculling = __decorate([
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], frustumculling);
            return frustumculling;
        }());
        framework.frustumculling = frustumculling;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var guidpath = (function () {
            function guidpath() {
                this.speed = 1;
                this.isactived = false;
                this.datasafe = false;
                this.folowindex = 0;
                this.isloop = false;
                this.lookforward = false;
                this.loopCount = 1;
                this.adjustDir = false;
            }
            Object.defineProperty(guidpath.prototype, "pathasset", {
                get: function () {
                    return this._pathasset;
                },
                set: function (pathasset) {
                    if (this._pathasset) {
                        this._pathasset.unuse();
                    }
                    this._pathasset = pathasset;
                    if (this._pathasset) {
                        this._pathasset.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            guidpath.prototype.play = function (loopCount) {
                if (loopCount === void 0) { loopCount = 1; }
                this.isactived = true;
                this.loopCount = loopCount;
            };
            guidpath.prototype.pause = function () {
                this.isactived = false;
            };
            guidpath.prototype.stop = function () {
                this.isactived = false;
                this.folowindex = 0;
            };
            guidpath.prototype.replay = function (loopCount) {
                if (loopCount === void 0) { loopCount = 1; }
                this.isactived = true;
                this.folowindex = 0;
                this.loopCount = loopCount;
            };
            guidpath.prototype.setpathasset = function (pathasset, speed, oncomplete) {
                if (speed === void 0) { speed = 1; }
                if (oncomplete === void 0) { oncomplete = null; }
                this.pathasset = pathasset;
                if (pathasset == null) {
                    console.log(this.gameObject.getName().toString + ":are you sure set the right pathasset（error：null）");
                    return;
                }
                this.paths = pathasset.paths;
                if (this.paths[0] != null) {
                    gd3d.math.vec3Clone(this.paths[0], this.gameObject.transform.localTranslate);
                    this.gameObject.transform.markDirty();
                    this.datasafe = true;
                }
                this.mystrans = this.gameObject.transform;
                this.speed = speed;
                this.oncomplete = oncomplete;
            };
            guidpath.prototype.start = function () {
            };
            guidpath.prototype.update = function (delta) {
                if (!this.isactived || !this.datasafe)
                    return;
                this.followmove(delta);
            };
            guidpath.prototype.followmove = function (delta) {
                var dist = gd3d.math.vec3Distance(this.mystrans.localTranslate, this.paths[this.folowindex]);
                if (dist < 0.01) {
                    if (this.folowindex < this.paths.length - 1) {
                        var dir = new gd3d.math.vector3();
                        gd3d.math.vec3Clone(this.paths[this.folowindex], this.mystrans.localTranslate);
                        this.folowindex++;
                        this.adjustDir = true;
                        this.mystrans.markDirty();
                    }
                    else {
                        this.folowindex = 0;
                        if (!this.isloop) {
                            this.loopCount--;
                            if (this.loopCount == 0) {
                                this.isactived = false;
                                this.loopCount = 1;
                                if (this.oncomplete) {
                                    this.oncomplete();
                                }
                            }
                        }
                    }
                }
                else {
                    var dir = new gd3d.math.vector3();
                    gd3d.math.vec3Subtract(this.paths[this.folowindex], this.mystrans.localTranslate, dir);
                    if (this.adjustDir) {
                        var targetpos = this.paths[this.folowindex];
                        var localppos = this.mystrans.localTranslate;
                        var quat = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatLookat(localppos, targetpos, quat);
                        gd3d.math.quatClone(quat, this.mystrans.localRotate);
                        gd3d.math.pool.delete_quaternion(quat);
                        this.adjustDir = false;
                    }
                    var distadd = this.speed * delta;
                    if (distadd > dist)
                        distadd = dist;
                    var lerp = distadd / dist;
                    gd3d.math.vec3SLerp(this.mystrans.localTranslate, this.paths[this.folowindex], lerp, this.mystrans.localTranslate);
                    this.mystrans.markDirty();
                }
            };
            guidpath.prototype.remove = function () {
                if (this._pathasset) {
                    this._pathasset.unuse();
                }
            };
            guidpath.prototype.clone = function () {
            };
            guidpath = __decorate([
                gd3d.reflect.nodeComponent
            ], guidpath);
            return guidpath;
        }());
        framework.guidpath = guidpath;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var keyframeanimation = (function () {
            function keyframeanimation() {
                this.timelength = 0;
                this.beloop = false;
                this.frameRate = 0;
                this.pathdata = {};
                this.playingtime = 0;
                this.childrentrans = {};
                this.childrenpaths = [];
                this.isactived = false;
                this.lastpositionindex = 0;
                this.lastrotationindex = 0;
            }
            Object.defineProperty(keyframeanimation.prototype, "keyframeasset", {
                get: function () {
                    return this._keyframeasset;
                },
                set: function (keyframeasset) {
                    if (this._keyframeasset) {
                        this._keyframeasset.unuse();
                    }
                    this._keyframeasset = keyframeasset;
                    if (this._keyframeasset) {
                        this._keyframeasset.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            keyframeanimation.prototype.setkeyframeanimationasst = function (keyframeanimationpathasset) {
                this._keyframeasset = keyframeanimationpathasset;
                if (keyframeanimationpathasset == null) {
                    console.log(this.gameObject.getName().toString() + ":are you set the right keyframeanimationasset(error:null)?");
                    return;
                }
                this.positions = keyframeanimationpathasset.positionitems;
                this.rotations = keyframeanimationpathasset.rotationitmes;
                this.timelength = keyframeanimationpathasset.timeLength;
                this.beloop = keyframeanimationpathasset.beloop;
                this.frameRate = keyframeanimationpathasset.frameRate;
                this.pathdata = keyframeanimationpathasset.pathdata;
                if (this.positions[0] != null) {
                    gd3d.math.vec3Clone(this.positions[0].position, this.gameObject.transform.localTranslate);
                }
                if (this.rotations[0] != null) {
                    gd3d.math.quatClone(this.rotations[0].rotation, this.gameObject.transform.localRotate);
                }
                this.mystrans = this.gameObject.transform;
                this.setChildTrans(this.mystrans);
                this.mystrans.markDirty();
            };
            keyframeanimation.prototype.setChildTrans = function (mytrans) {
                if (mytrans.children) {
                    for (var i = 0; i < mytrans.children.length; i++) {
                        if (mytrans.children[i] != this.mystrans) {
                            var parent = new gd3d.framework.transform();
                            parent = mytrans.children[i].parent;
                            var name = mytrans.children[i].name;
                            while (parent != this.mystrans) {
                                name = parent.name + "/" + name;
                                parent = parent.parent;
                            }
                            for (var key in this.pathdata) {
                                if (name == key) {
                                    this.childrentrans[name] = mytrans.children[i];
                                    this.childrenpaths.push({ child: this.childrentrans[name], path: this.pathdata[key] });
                                }
                            }
                        }
                        this.setChildTrans(mytrans.children[i]);
                    }
                }
            };
            keyframeanimation.prototype.start = function () {
            };
            keyframeanimation.prototype.update = function (delta) {
                if (!this.isactived)
                    return;
                this.followmove(delta);
            };
            keyframeanimation.prototype.followmove = function (delta) {
                this.playingtime += delta;
                var lastpositionindex = this.lastpositionindex;
                var lastrotationindex = this.lastrotationindex;
                if (this.positions[0] != null) {
                    if (this.playingtime >= this.timelength) {
                        if (!this.beloop) {
                            this.isactived = false;
                        }
                        else {
                            this.replay();
                        }
                    }
                    if (lastpositionindex < this.positions.length - 1) {
                        while (this.playingtime > this.positions[lastpositionindex].time) {
                            lastpositionindex++;
                            if (lastpositionindex == this.positions.length - 1)
                                break;
                        }
                    }
                    if (this.positions[lastpositionindex].time > (this.playingtime - delta) && this.positions[lastpositionindex].time - this.playingtime < 0.016) {
                        this.mystrans.localTranslate.x = this.positions[lastpositionindex].position.x;
                        this.mystrans.localTranslate.y = this.positions[lastpositionindex].position.y;
                        this.mystrans.localTranslate.z = this.positions[lastpositionindex].position.z;
                        this.mystrans.markDirty();
                    }
                    else if (this.positions[lastpositionindex].time > (this.playingtime - delta)) {
                        var positionlerp = delta / (this.positions[lastpositionindex].time - (this.playingtime - delta));
                        gd3d.math.vec3SLerp(this.mystrans.localTranslate, this.positions[lastpositionindex].position, positionlerp, this.mystrans.localTranslate);
                        this.mystrans.markDirty();
                    }
                }
                if (this.rotations[0] != null) {
                    if (this.playingtime >= this.timelength) {
                        if (!this.beloop) {
                            this.isactived = false;
                        }
                        else {
                            this.replay();
                        }
                    }
                    if (lastrotationindex < this.rotations.length - 1) {
                        while (this.playingtime > this.rotations[lastrotationindex].time) {
                            lastrotationindex++;
                            if (lastrotationindex == this.rotations.length - 1)
                                break;
                        }
                    }
                    if (this.rotations[lastrotationindex].time > (this.playingtime - delta) && this.rotations[lastrotationindex].time - (this.playingtime - delta) < 0.01) {
                        this.mystrans.localRotate.x = this.rotations[lastrotationindex].rotation.x;
                        this.mystrans.localRotate.y = this.rotations[lastrotationindex].rotation.y;
                        this.mystrans.localRotate.z = this.rotations[lastrotationindex].rotation.z;
                        this.mystrans.localRotate.w = this.rotations[lastrotationindex].rotation.w;
                        this.mystrans.markDirty();
                    }
                    else if (this.rotations[lastrotationindex].time > (this.playingtime - delta)) {
                        var rotationlerp = delta / (this.rotations[lastrotationindex].time - (this.playingtime - delta));
                        gd3d.math.quatLerp(this.mystrans.localRotate, this.rotations[lastrotationindex].rotation, this.mystrans.localRotate, rotationlerp);
                        this.mystrans.markDirty();
                    }
                }
                this.childrenfollow(delta);
                this.lastpositionindex = lastpositionindex;
                this.lastrotationindex = lastrotationindex;
            };
            keyframeanimation.prototype.childrenfollow = function (delta) {
                var playingtime = this.playingtime;
                for (var i = 0; i < this.childrenpaths.length; i++) {
                    var item = this.childrenpaths[i];
                    var childtrans = item.child;
                    var childpositions = item.path.positions;
                    var childrotations = item.path.rotations;
                    if (childpositions.length > 0) {
                        var aheadpositionindex = 0;
                        while (playingtime > childpositions[aheadpositionindex].time) {
                            aheadpositionindex++;
                            if (aheadpositionindex == childpositions.length - 1)
                                break;
                        }
                        if (playingtime <= childpositions[aheadpositionindex].time) {
                            if (childpositions[aheadpositionindex].time - playingtime < 0.016) {
                                gd3d.math.vec3Clone(childpositions[aheadpositionindex].position, childtrans.localTranslate);
                                childtrans.markDirty();
                            }
                            else {
                                var positionlerp = delta / (childpositions[aheadpositionindex].time - (playingtime - delta));
                                gd3d.math.vec3SLerp(childtrans.localTranslate, childpositions[aheadpositionindex].position, positionlerp, childtrans.localTranslate);
                                childtrans.markDirty();
                            }
                        }
                    }
                    if (childrotations.length > 0) {
                        var aheadrotationindex = 0;
                        while (playingtime > childrotations[aheadrotationindex].time) {
                            aheadrotationindex++;
                            if (aheadrotationindex == childrotations.length - 1)
                                break;
                        }
                        if (playingtime <= childrotations[aheadrotationindex].time) {
                            if (childrotations[aheadrotationindex].time - playingtime < 0.016) {
                                gd3d.math.quatClone(childrotations[aheadrotationindex].rotation, childtrans.localRotate);
                                childtrans.markDirty();
                            }
                            else {
                                var rotationlerp = delta / (childrotations[aheadrotationindex].time - (playingtime - delta));
                                gd3d.math.quatLerp(childtrans.localRotate, childrotations[aheadrotationindex].rotation, childtrans.localRotate, rotationlerp);
                                childtrans.markDirty();
                            }
                        }
                    }
                }
            };
            keyframeanimation.prototype.remove = function () {
                if (this._keyframeasset) {
                    this._keyframeasset.unuse();
                }
            };
            keyframeanimation.prototype.clone = function () {
            };
            keyframeanimation.prototype.play = function () {
                this.isactived = true;
            };
            keyframeanimation.prototype.pause = function () {
                this.isactived = false;
            };
            keyframeanimation.prototype.stop = function () {
                this.isactived = false;
            };
            keyframeanimation.prototype.replay = function () {
                this.playingtime = 0;
                this.lastpositionindex = 0;
                this.lastrotationindex = 0;
                if (this.positions[0] != null) {
                    gd3d.math.vec3Clone(this.positions[0].position, this.mystrans.localTranslate);
                }
                if (this.rotations[0] != null) {
                    gd3d.math.quatClone(this.rotations[0].rotation, this.mystrans.localRotate);
                }
                this.isactived = true;
            };
            keyframeanimation = __decorate([
                gd3d.reflect.nodeComponent
            ], keyframeanimation);
            return keyframeanimation;
        }());
        framework.keyframeanimation = keyframeanimation;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var LightTypeEnum;
        (function (LightTypeEnum) {
            LightTypeEnum[LightTypeEnum["Direction"] = 0] = "Direction";
            LightTypeEnum[LightTypeEnum["Point"] = 1] = "Point";
            LightTypeEnum[LightTypeEnum["Spot"] = 2] = "Spot";
        })(LightTypeEnum = framework.LightTypeEnum || (framework.LightTypeEnum = {}));
        var light = (function () {
            function light() {
                this.spotAngelCos = 0.9;
                this.range = 10;
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
            }
            light.prototype.start = function () {
            };
            light.prototype.update = function (delta) {
            };
            light.prototype.remove = function () {
            };
            light.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], light.prototype, "type", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], light.prototype, "range", void 0);
            __decorate([
                gd3d.reflect.Field("color"),
                __metadata("design:type", gd3d.math.color)
            ], light.prototype, "color", void 0);
            light = __decorate([
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeLight
            ], light);
            return light;
        }());
        framework.light = light;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var meshcollider = (function () {
            function meshcollider() {
                this._colliderVisible = false;
            }
            meshcollider.prototype.getBound = function () {
                return this.mesh;
            };
            meshcollider.prototype.start = function () {
                var filter = this.gameObject.getComponent("meshFilter");
                if (filter != null) {
                    this.mesh = filter.getMeshOutput();
                    this.buildMesh();
                }
            };
            meshcollider.prototype.update = function (delta) {
            };
            Object.defineProperty(meshcollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            meshcollider.prototype.intersectsTransform = function (tran) {
                return false;
            };
            meshcollider.prototype.buildMesh = function () {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "meshcollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
            };
            meshcollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                _mesh.data = this.mesh.data;
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayTri2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = true;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            meshcollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
            };
            meshcollider.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], meshcollider.prototype, "_colliderVisible", void 0);
            meshcollider = __decorate([
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeMeshCollider
            ], meshcollider);
            return meshcollider;
        }());
        framework.meshcollider = meshcollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var meshFilter = (function () {
            function meshFilter() {
            }
            meshFilter.prototype.start = function () {
            };
            meshFilter.prototype.update = function (delta) {
            };
            Object.defineProperty(meshFilter.prototype, "mesh", {
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            meshFilter.prototype.getMeshOutput = function () {
                return this._mesh;
            };
            meshFilter.prototype.remove = function () {
                if (this.mesh)
                    this.mesh.unuse(true);
            };
            meshFilter.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.Field("mesh"),
                gd3d.reflect.UIStyle("WidgetDragSelect"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [framework.mesh])
            ], meshFilter.prototype, "mesh", null);
            meshFilter = __decorate([
                gd3d.reflect.nodeComponent
            ], meshFilter);
            return meshFilter;
        }());
        framework.meshFilter = meshFilter;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var meshRenderer = (function () {
            function meshRenderer() {
                this.materials = [];
                this.useGlobalLightMap = true;
                this.lightmapIndex = -1;
                this.lightmapScaleOffset = new gd3d.math.vector4(1, 1, 0, 0);
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.default;
                this.issetq = false;
                this._queue = 0;
            }
            Object.defineProperty(meshRenderer.prototype, "queue", {
                get: function () {
                    return this._queue;
                },
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: true,
                configurable: true
            });
            meshRenderer.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.refreshLayerAndQue();
                if (this.lightmapIndex == -2) {
                    this.useGlobalLightMap = false;
                }
            };
            meshRenderer.prototype.refreshLayerAndQue = function () {
                if (this.materials == null || this.materials.length == 0) {
                    this.materials = [];
                    var material_2 = new framework.material();
                    material_2.use();
                    this.materials.push(material_2);
                    this.materials[0].setShader(framework.sceneMgr.app.getAssetMgr().getShader("shader/def"));
                }
                this.layer = this.materials[0].getLayer();
                if (!this.issetq)
                    this._queue = this.materials[0].getQueue();
            };
            meshRenderer.prototype.update = function (delta) {
                if (this.materials != null && this.materials.length > 0) {
                    var _mat = this.materials[0];
                    if (_mat) {
                        this.layer = _mat.getLayer();
                        if (!this.issetq)
                            this._queue = _mat.getQueue();
                    }
                }
                if (this.filter == null) {
                    this.filter = this.gameObject.getComponent("meshFilter");
                }
            };
            meshRenderer.prototype.render = function (context, assetmgr, camera) {
                context.updateModel(this.gameObject.transform);
                if (this.filter != null) {
                    var mesh = this.filter.getMeshOutput();
                    if (mesh != null) {
                        mesh.glMesh.bindVboBuffer(context.webgl);
                        if (mesh.submesh != null) {
                            for (var i = 0; i < mesh.submesh.length; i++) {
                                var sm = mesh.submesh[i];
                                var mid = mesh.submesh[i].matIndex;
                                var usemat = this.materials[mid];
                                var drawtype = this.gameObject.transform.scene.fog ? "base_fog" : "base";
                                if (this.lightmapIndex >= 0) {
                                    drawtype = this.gameObject.transform.scene.fog ? "lightmap_fog" : "lightmap";
                                    if (this.gameObject.transform.scene.lightmaps.length > this.lightmapIndex) {
                                        context.lightmap = this.gameObject.transform.scene.lightmaps[this.lightmapIndex];
                                        context.lightmapOffset = this.lightmapScaleOffset;
                                        context.lightmapUV = mesh.glMesh.vertexFormat & gd3d.render.VertexFormatMask.UV1 ? 1 : 0;
                                    }
                                }
                                else {
                                    if (!this.useGlobalLightMap) {
                                        drawtype = this.gameObject.transform.scene.fog ? "lightmap_fog" : "lightmap";
                                        context.lightmapOffset = this.lightmapScaleOffset;
                                        context.lightmapUV = mesh.glMesh.vertexFormat & gd3d.render.VertexFormatMask.UV1 ? 1 : 0;
                                    }
                                }
                                if (this.gameObject.transform.scene.fog) {
                                    context.fog = this.gameObject.transform.scene.fog;
                                }
                                if (usemat != null)
                                    usemat.draw(context, mesh, sm, drawtype, this.useGlobalLightMap);
                            }
                        }
                    }
                }
            };
            meshRenderer.prototype.remove = function () {
                this.materials.forEach(function (element) {
                    if (element)
                        element.unuse();
                });
                this.materials.length = 0;
            };
            meshRenderer.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.Field("material[]"),
                __metadata("design:type", Array)
            ], meshRenderer.prototype, "materials", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], meshRenderer.prototype, "lightmapIndex", void 0);
            __decorate([
                gd3d.reflect.Field("vector4"),
                __metadata("design:type", gd3d.math.vector4)
            ], meshRenderer.prototype, "lightmapScaleOffset", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], meshRenderer.prototype, "layer", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], meshRenderer.prototype, "renderLayer", void 0);
            meshRenderer = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], meshRenderer);
            return meshRenderer;
        }());
        framework.meshRenderer = meshRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var skinnedMeshRenderer = (function () {
            function skinnedMeshRenderer() {
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.default;
                this.issetq = false;
                this._queue = 0;
                this.maxBoneCount = 0;
                this._skintype = 0;
                this._efficient = true;
            }
            skinnedMeshRenderer_1 = skinnedMeshRenderer;
            Object.defineProperty(skinnedMeshRenderer.prototype, "queue", {
                get: function () {
                    return this._queue;
                },
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "player", {
                get: function () {
                    if (this._player == null) {
                        this._player = this.gameObject.getComponentInParent("aniplayer");
                    }
                    return this._player;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "mesh", {
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: true,
                configurable: true
            });
            skinnedMeshRenderer.prototype.start = function () {
            };
            skinnedMeshRenderer.prototype.getMatByIndex = function (index) {
                var data = this.mesh.data;
                if (data.blendIndex[index].v0 >= this.maxBoneCount || data.blendIndex[index].v1 >= this.maxBoneCount || data.blendIndex[index].v2 >= this.maxBoneCount || data.blendIndex[index].v3 >= this.maxBoneCount) {
                    return null;
                }
                var mat = new gd3d.math.matrix();
                if (this._efficient) {
                    var vec40r = gd3d.math.pool.new_vector4();
                    var vec30p = gd3d.math.pool.new_vector3();
                    vec40r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 0];
                    vec40r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 1];
                    vec40r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 2];
                    vec40r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 3];
                    vec30p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 4];
                    vec30p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 5];
                    vec30p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 6];
                    var vec41r = gd3d.math.pool.new_vector4();
                    var vec31p = gd3d.math.pool.new_vector3();
                    vec41r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 0];
                    vec41r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 1];
                    vec41r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 2];
                    vec41r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 3];
                    vec31p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 4];
                    vec31p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 5];
                    vec31p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 6];
                    var vec42r = gd3d.math.pool.new_vector4();
                    var vec32p = gd3d.math.pool.new_vector3();
                    vec42r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 0];
                    vec42r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 1];
                    vec42r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 2];
                    vec42r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 3];
                    vec32p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 4];
                    vec32p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 5];
                    vec32p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 6];
                    var vec43r = gd3d.math.pool.new_vector4();
                    var vec33p = gd3d.math.pool.new_vector3();
                    vec43r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 0];
                    vec43r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 1];
                    vec43r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 2];
                    vec43r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 3];
                    vec33p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 4];
                    vec33p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 5];
                    vec33p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 6];
                    var mat0 = gd3d.math.pool.new_matrix();
                    var mat1 = gd3d.math.pool.new_matrix();
                    var mat2 = gd3d.math.pool.new_matrix();
                    var mat3 = gd3d.math.pool.new_matrix();
                    gd3d.math.matrixMakeTransformRTS(vec30p, gd3d.math.pool.vector3_one, vec40r, mat0);
                    gd3d.math.matrixMakeTransformRTS(vec31p, gd3d.math.pool.vector3_one, vec41r, mat1);
                    gd3d.math.matrixMakeTransformRTS(vec32p, gd3d.math.pool.vector3_one, vec42r, mat2);
                    gd3d.math.matrixMakeTransformRTS(vec33p, gd3d.math.pool.vector3_one, vec43r, mat3);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    gd3d.math.matrixAdd(mat0, mat1, mat);
                    gd3d.math.matrixAdd(mat, mat2, mat);
                    gd3d.math.matrixAdd(mat, mat3, mat);
                    gd3d.math.pool.delete_vector4(vec40r);
                    gd3d.math.pool.delete_vector4(vec41r);
                    gd3d.math.pool.delete_vector4(vec42r);
                    gd3d.math.pool.delete_vector4(vec43r);
                    gd3d.math.pool.delete_vector3(vec30p);
                    gd3d.math.pool.delete_vector3(vec31p);
                    gd3d.math.pool.delete_vector3(vec32p);
                    gd3d.math.pool.delete_vector3(vec33p);
                    gd3d.math.pool.delete_matrix(mat0);
                    gd3d.math.pool.delete_matrix(mat1);
                    gd3d.math.pool.delete_matrix(mat2);
                    gd3d.math.pool.delete_matrix(mat3);
                }
                else {
                    var mat0 = gd3d.math.pool.new_matrix();
                    mat0.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v0, 16 * data.blendIndex[index].v0 + 16);
                    var mat1 = gd3d.math.pool.new_matrix();
                    mat1.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v1, 16 * data.blendIndex[index].v1 + 16);
                    var mat2 = gd3d.math.pool.new_matrix();
                    mat2.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v2, 16 * data.blendIndex[index].v2 + 16);
                    var mat3 = gd3d.math.pool.new_matrix();
                    mat3.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v3, 16 * data.blendIndex[index].v3 + 16);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    gd3d.math.matrixAdd(mat0, mat1, mat);
                    gd3d.math.matrixAdd(mat, mat2, mat);
                    gd3d.math.matrixAdd(mat, mat3, mat);
                    gd3d.math.pool.delete_matrix(mat0);
                    gd3d.math.pool.delete_matrix(mat1);
                    gd3d.math.pool.delete_matrix(mat2);
                    gd3d.math.pool.delete_matrix(mat3);
                }
                return mat;
            };
            skinnedMeshRenderer.prototype.intersects = function (ray) {
                var mvpmat = this.player.gameObject.transform.getWorldMatrix();
                var pickinfo = null;
                var data = this.mesh.data;
                for (var i = 0; i < this.mesh.submesh.length; i++) {
                    var submesh = this.mesh.submesh[i];
                    var t0 = gd3d.math.pool.new_vector3();
                    var t1 = gd3d.math.pool.new_vector3();
                    var t2 = gd3d.math.pool.new_vector3();
                    for (var index = submesh.start; index < submesh.size; index += 3) {
                        var verindex0 = data.trisindex[index];
                        var verindex1 = data.trisindex[index + 1];
                        var verindex2 = data.trisindex[index + 2];
                        var p0 = data.pos[verindex0];
                        var p1 = data.pos[verindex1];
                        var p2 = data.pos[verindex2];
                        var mat0 = this.getMatByIndex(verindex0);
                        var mat1 = this.getMatByIndex(verindex1);
                        var mat2 = this.getMatByIndex(verindex2);
                        if (mat0 == null || mat1 == null || mat2 == null)
                            continue;
                        var mat00 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat0, mat00);
                        var mat11 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat1, mat11);
                        var mat22 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat2, mat22);
                        gd3d.math.matrixTransformVector3(p0, mat00, t0);
                        gd3d.math.matrixTransformVector3(p1, mat11, t1);
                        gd3d.math.matrixTransformVector3(p2, mat22, t2);
                        var result = ray.intersectsTriangle(t0, t1, t2);
                        if (result) {
                            if (result.distance < 0)
                                continue;
                            if (!pickinfo || pickinfo.distance > result.distance) {
                                pickinfo = result;
                                pickinfo.faceId = index / 3;
                                pickinfo.subMeshId = i;
                                var tdir = gd3d.math.pool.new_vector3();
                                gd3d.math.vec3ScaleByNum(ray.direction, result.distance, tdir);
                                gd3d.math.vec3Add(ray.origin, tdir, pickinfo.hitposition);
                            }
                        }
                    }
                    gd3d.math.pool.delete_vector3(t0);
                    gd3d.math.pool.delete_vector3(t1);
                    gd3d.math.pool.delete_vector3(t2);
                }
                return pickinfo;
            };
            skinnedMeshRenderer.prototype.update = function (delta) {
                if (this._skeletonMatrixData == null) {
                    this._skintype = this.useBoneShader(this.materials[0]);
                    if (this._skintype == 1) {
                        this.maxBoneCount = 24;
                        this._skeletonMatrixData = new Float32Array(16 * this.maxBoneCount);
                        this._efficient = false;
                    }
                    else if (this._skintype == 2) {
                        this.maxBoneCount = 55;
                        this._skeletonMatrixData = new Float32Array(8 * this.maxBoneCount);
                        this._efficient = true;
                    }
                }
                if (this.materials != null && this.materials.length > 0) {
                    var _mat = this.materials[0];
                    if (_mat) {
                        this.layer = _mat.getLayer();
                        if (!this.issetq)
                            this._queue = _mat.getQueue();
                    }
                }
                if (this.player != null) {
                    if (this.player.isCache && !this.player.mix) {
                        var cacheKey = this.player.cacheKey + "_" + this.mesh.getGUID();
                        var data = skinnedMeshRenderer_1.dataCaches[cacheKey];
                        if (!data) {
                            var _cachePlayer = framework.aniplayer.playerCaches[this.player.cacheKey];
                            if (_cachePlayer) {
                                var baseSize = this._efficient ? 8 : 16;
                                data = new Float32Array(this.maxBoneCount * baseSize);
                                _cachePlayer.fillPoseData(data, this.bones, this._efficient);
                                skinnedMeshRenderer_1.dataCaches[cacheKey] = data;
                                this.cacheData = data;
                                return;
                            }
                        }
                        else {
                            this.cacheData = data;
                            return;
                        }
                    }
                    this.cacheData = null;
                    if (this._skeletonMatrixData != null) {
                        this.player.fillPoseData(this._skeletonMatrixData, this.bones, this._efficient);
                    }
                }
            };
            skinnedMeshRenderer.prototype.render = function (context, assetmgr, camera) {
                if (this.player != null) {
                    context.updateModel(this.player.gameObject.transform);
                }
                for (var i_6 = 0; i_6 < this.materials.length; i_6++) {
                    if (this.materials[i_6] == null)
                        continue;
                    if (this.cacheData != null && this._skintype > 0) {
                        if (this._efficient) {
                            context.vec4_bones = this.cacheData;
                        }
                        else {
                            context.matrix_bones = this.cacheData;
                        }
                        continue;
                    }
                    if (this._skeletonMatrixData != null && this._skintype > 0) {
                        if (this._efficient) {
                            context.vec4_bones = this._skeletonMatrixData;
                        }
                        else {
                            context.matrix_bones = this._skeletonMatrixData;
                        }
                    }
                }
                if (this._mesh != null) {
                    if (this._mesh != null) {
                        this._mesh.glMesh.bindVboBuffer(context.webgl);
                        if (this._mesh.submesh != null) {
                            for (var i = 0; i < this._mesh.submesh.length; i++) {
                                var sm = this._mesh.submesh[i];
                                var mid = this._mesh.submesh[i].matIndex;
                                var usemat = this.materials[mid];
                                if (usemat != null) {
                                    if (this.gameObject.transform.scene.fog) {
                                        context.fog = this.gameObject.transform.scene.fog;
                                        usemat.draw(context, this._mesh, sm, "skin_fog");
                                    }
                                    else {
                                        usemat.draw(context, this._mesh, sm, "skin");
                                    }
                                }
                            }
                        }
                    }
                }
            };
            skinnedMeshRenderer.prototype.remove = function () {
                this.materials.forEach(function (element) {
                    if (element)
                        element.unuse();
                });
                if (this.mesh)
                    this.mesh.unuse(true);
                this.bones.length = 0;
            };
            skinnedMeshRenderer.prototype.clone = function () {
            };
            skinnedMeshRenderer.prototype.useBoneShader = function (mat) {
                var matpasses = mat.getShader().passes["skin"];
                if (matpasses == null || matpasses.length == 0)
                    return 0;
                if (matpasses[0].mapuniforms["glstate_vec4_bones"] != null)
                    return 2;
                else if (matpasses[0].mapuniforms["glstate_matrix_bones"] != null)
                    return 1;
                return 0;
            };
            skinnedMeshRenderer.dataCaches = [];
            __decorate([
                gd3d.reflect.Field("material[]"),
                __metadata("design:type", Array)
            ], skinnedMeshRenderer.prototype, "materials", void 0);
            __decorate([
                gd3d.reflect.Field("mesh"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [framework.mesh])
            ], skinnedMeshRenderer.prototype, "mesh", null);
            __decorate([
                gd3d.reflect.Field("transform[]"),
                __metadata("design:type", Array)
            ], skinnedMeshRenderer.prototype, "bones", void 0);
            __decorate([
                gd3d.reflect.Field("transform"),
                __metadata("design:type", framework.transform)
            ], skinnedMeshRenderer.prototype, "rootBone", void 0);
            skinnedMeshRenderer = skinnedMeshRenderer_1 = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], skinnedMeshRenderer);
            return skinnedMeshRenderer;
            var skinnedMeshRenderer_1;
        }());
        framework.skinnedMeshRenderer = skinnedMeshRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var spherestruct = (function () {
            function spherestruct(_center, _r) {
                this.center = gd3d.math.pool.clone_vector3(_center);
                this.srcradius = _r;
                this.tempScale = new gd3d.math.vector3();
            }
            spherestruct.prototype.update = function (worldmatrix) {
                gd3d.math.matrixGetTranslation(worldmatrix, this.center);
                gd3d.math.matrixGetScale(worldmatrix, this.tempScale);
                if (this.tempScale.x < this.tempScale.y)
                    this.tempScale.x = this.tempScale.y;
                if (this.tempScale.x < this.tempScale.z)
                    this.tempScale.x = this.tempScale.z;
                this.radius = this.srcradius * this.tempScale.x;
            };
            spherestruct.prototype.intersects = function (bound) {
                if (bound instanceof spherestruct) {
                    var dis = gd3d.math.vec3Distance(this.center, bound.center);
                    if (dis > this.radius + bound.radius)
                        return false;
                    return true;
                }
                else if (bound instanceof framework.obb) {
                }
            };
            return spherestruct;
        }());
        framework.spherestruct = spherestruct;
        var spherecollider = (function () {
            function spherecollider() {
                this._worldCenter = new gd3d.math.vector3();
                this._colliderVisible = false;
            }
            Object.defineProperty(spherecollider.prototype, "worldCenter", {
                get: function () {
                    gd3d.math.vec3Clone(this.center, this._worldCenter);
                    gd3d.math.matrixTransformVector3(this._worldCenter, this.gameObject.transform.getWorldMatrix(), this._worldCenter);
                    return this._worldCenter;
                },
                enumerable: true,
                configurable: true
            });
            spherecollider.prototype.getBound = function () {
                return this.spherestruct;
            };
            Object.defineProperty(spherecollider.prototype, "matrix", {
                get: function () {
                    if (this.gameObject)
                        return this.gameObject.transform.getWorldMatrix();
                    return new gd3d.math.matrix();
                },
                enumerable: true,
                configurable: true
            });
            spherecollider.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.build();
            };
            spherecollider.prototype.update = function (delta) {
                if (this.spherestruct) {
                    this.spherestruct.update(this.matrix);
                }
            };
            Object.defineProperty(spherecollider.prototype, "colliderVisible", {
                get: function () {
                    return this._colliderVisible;
                },
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: true,
                configurable: true
            });
            spherecollider.prototype.caclPlaneInDir = function (v0, v1, v2) {
                var subv0 = gd3d.math.pool.new_vector3();
                var subv1 = gd3d.math.pool.new_vector3();
                var cro0 = gd3d.math.pool.new_vector3();
                var point = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(v1, v0, subv0);
                gd3d.math.vec3Subtract(v2, v1, subv1);
                gd3d.math.vec3Cross(subv0, subv1, cro0);
                gd3d.math.calPlaneLineIntersectPoint(cro0, v0, cro0, this.worldCenter, point);
                var sublp = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(point, this.worldCenter, sublp);
                var val = gd3d.math.vec3Dot(cro0, sublp);
                gd3d.math.pool.delete_vector3(subv0);
                gd3d.math.pool.delete_vector3(subv1);
                gd3d.math.pool.delete_vector3(cro0);
                if (val <= 0)
                    return true;
                var dis = gd3d.math.vec3Distance(this.worldCenter, point);
                gd3d.math.pool.delete_vector3(point);
                if (dis < this.radius)
                    return true;
                return false;
            };
            spherecollider.prototype.intersectsTransform = function (tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.spherestruct == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.spherestruct.intersects(_obb);
            };
            spherecollider.prototype.build = function () {
                if (this.center && this.radius) {
                    this.spherestruct = new spherestruct(this.center, this.radius);
                }
            };
            spherecollider.prototype.buildMesh = function () {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "spherecollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
            };
            spherecollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                return _mesh;
            };
            spherecollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
            };
            spherecollider.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.Field("vector3"),
                __metadata("design:type", gd3d.math.vector3)
            ], spherecollider.prototype, "center", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], spherecollider.prototype, "radius", void 0);
            spherecollider = __decorate([
                gd3d.reflect.nodeComponent,
                gd3d.reflect.nodeSphereCollider
            ], spherecollider);
            return spherecollider;
        }());
        framework.spherecollider = spherecollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var trailRender_recorde = (function () {
            function trailRender_recorde() {
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.default;
                this.queue = 0;
                this._startWidth = 1;
                this._endWidth = 0;
                this.lifetime = 0.35;
                this.minStickDistance = 0.1;
                this.maxStickCout = 12;
                this.nodes = [];
                this.interpolate = false;
                this.interpNumber = 3;
                this.interpPath = [];
                this.activeMaxpointlimit = false;
                this.notRender = false;
            }
            Object.defineProperty(trailRender_recorde.prototype, "material", {
                get: function () {
                    if (this._material != undefined) {
                        return this._material;
                    }
                    else {
                        var mat = new gd3d.framework.material();
                        mat.setShader(this.app.getAssetMgr().getShader("shader/def"));
                        this._material = mat;
                        return this._material;
                    }
                },
                set: function (material) {
                    this._material = material;
                    this.layer = this._material.getLayer();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(trailRender_recorde.prototype, "startColor", {
                get: function () {
                    if (this._startColor == undefined) {
                        this._startColor = new gd3d.math.color(1, 1, 1, 1);
                    }
                    return this._startColor;
                },
                set: function (color) {
                    this._startColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(trailRender_recorde.prototype, "endColor", {
                get: function () {
                    if (this._endColor == undefined) {
                        this._endColor = new gd3d.math.color(this.startColor.r, this.startColor.g, this.startColor.b, 0);
                    }
                    return this._endColor;
                },
                set: function (color) {
                    this._endColor = color;
                },
                enumerable: true,
                configurable: true
            });
            trailRender_recorde.prototype.setWidth = function (startWidth, endWidth) {
                if (endWidth === void 0) { endWidth = 0; }
                this._startWidth = startWidth;
                this._endWidth = endWidth;
            };
            trailRender_recorde.prototype.setMaxpointcontroll = function (value) {
                if (value === void 0) { value = false; }
                this.activeMaxpointlimit = value;
            };
            trailRender_recorde.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                this.webgl = this.app.webgl;
                this.mesh = new gd3d.framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                if (this.interpolate) {
                    this.maxStickCout *= this.interpNumber;
                    this.targetPath = this.interpPath;
                }
                else {
                    this.targetPath = this.nodes;
                }
            };
            trailRender_recorde.prototype.update = function (delta) {
                var _time = this.app.getTotalTime();
                this.refreshTrailNode(_time);
                this.updateTrailData(_time);
            };
            trailRender_recorde.prototype.remove = function () {
            };
            trailRender_recorde.prototype.refreshTrailNode = function (curTime) {
                while (this.targetPath.length > 0 && curTime > this.targetPath[this.targetPath.length - 1].time + this.lifetime) {
                    this.targetPath.pop();
                }
                var pos = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), pos);
                var length = this.targetPath.length;
                if (length != 0) {
                    if (gd3d.math.vec3Distance(pos, this.targetPath[0].location) < this.minStickDistance)
                        return;
                }
                var updir = new gd3d.math.vector3();
                this.gameObject.transform.getUpInWorld(updir);
                var newNode = new trailNode(pos, updir, curTime);
                this.nodes.unshift(newNode);
                if (this.interpolate) {
                    if (this.nodes.length > 2) {
                        var handle1 = new gd3d.math.vector3();
                        gd3d.math.vec3Subtract(this.nodes[2].location, this.nodes[0].location, handle1);
                        gd3d.math.vec3Normalize(handle1, handle1);
                        this.nodes[1].handle = handle1;
                        if (this.nodes[2].handle == undefined) {
                            var handdle = new gd3d.math.vector3();
                            gd3d.math.vec3Subtract(this.nodes[2].location, this.nodes[1].location, handdle);
                            gd3d.math.vec3Normalize(handdle, handdle);
                            this.nodes[2].handle = handdle;
                        }
                        var vec3Distance = gd3d.math.vec3Distance(this.nodes[2].location, this.nodes[1].location);
                        for (var i = 0; i < this.interpNumber; i++) {
                            var lerp = (i + 1) / (this.interpNumber + 1);
                            var inter_pos = new gd3d.math.vector3();
                            var tempRhandle = gd3d.math.pool.new_vector3();
                            var tempLhandle = gd3d.math.pool.new_vector3();
                            tempLhandle.x = -this.nodes[2].handle.x;
                            tempLhandle.y = -this.nodes[2].handle.y;
                            tempLhandle.z = -this.nodes[2].handle.z;
                            gd3d.math.vec3ScaleByNum(tempLhandle, vec3Distance / 2, tempLhandle);
                            gd3d.math.vec3Add(tempLhandle, this.nodes[2].location, tempLhandle);
                            gd3d.math.vec3ScaleByNum(this.nodes[1].handle, vec3Distance / 2, tempRhandle);
                            gd3d.math.vec3Add(tempRhandle, this.nodes[1].location, tempRhandle);
                            gd3d.math.GetPointAlongCurve(this.nodes[2].location, tempLhandle, this.nodes[1].location, tempRhandle, (i + 1) / (this.interpNumber + 1), inter_pos);
                            var inter_updir = new gd3d.math.vector3();
                            gd3d.math.vec3SLerp(this.nodes[1].updir, this.nodes[2].updir, lerp, inter_updir);
                            var inter_node = new trailNode(inter_pos, inter_updir, curTime);
                            this.interpPath.splice(1, 0, inter_node);
                            gd3d.math.pool.delete_vector3(tempRhandle);
                            gd3d.math.pool.delete_vector3(tempLhandle);
                        }
                        this.interpPath.unshift(newNode);
                    }
                }
                if (this.activeMaxpointlimit) {
                    while (this.targetPath.length > this.maxStickCout) {
                        this.targetPath.pop();
                    }
                }
            };
            trailRender_recorde.prototype.updateTrailData = function (curTime) {
                if (this.nodes.length < 2) {
                    this.notRender = true;
                    return;
                }
                else {
                    this.notRender = false;
                }
                this.checkBufferSize();
                for (var i = 0; i < this.targetPath.length; i++) {
                    var curNode = this.targetPath[i];
                    var u = i / this.targetPath.length;
                    var timeAlong = (curTime - curNode.time) / this.lifetime;
                    var _updir = new gd3d.math.vector3();
                    gd3d.math.vec3Clone(curNode.updir, _updir);
                    var _width = this._startWidth + (this._endWidth - this._startWidth) * timeAlong;
                    gd3d.math.vec3ScaleByNum(_updir, _width, _updir);
                    var tempPos = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Add(curNode.location, _updir, tempPos);
                    this.dataForVbo[2 * i * 9 + 0] = tempPos.x;
                    this.dataForVbo[2 * i * 9 + 1] = tempPos.y;
                    this.dataForVbo[2 * i * 9 + 2] = tempPos.z;
                    var tempColor = gd3d.math.pool.new_color();
                    gd3d.math.colorLerp(this.startColor, this.endColor, timeAlong, tempColor);
                    this.dataForVbo[2 * i * 9 + 3] = tempColor.r;
                    this.dataForVbo[2 * i * 9 + 4] = tempColor.g;
                    this.dataForVbo[2 * i * 9 + 5] = tempColor.b;
                    this.dataForVbo[2 * i * 9 + 6] = tempColor.a;
                    this.dataForVbo[2 * i * 9 + 7] = u;
                    this.dataForVbo[2 * i * 9 + 8] = 1.0;
                    this.dataForVbo[(2 * i + 1) * 9 + 0] = curNode.location.x;
                    this.dataForVbo[(2 * i + 1) * 9 + 1] = curNode.location.y;
                    this.dataForVbo[(2 * i + 1) * 9 + 2] = curNode.location.z;
                    this.dataForVbo[(2 * i + 1) * 9 + 3] = tempColor.r;
                    this.dataForVbo[(2 * i + 1) * 9 + 4] = tempColor.g;
                    this.dataForVbo[(2 * i + 1) * 9 + 5] = tempColor.b;
                    this.dataForVbo[(2 * i + 1) * 9 + 6] = tempColor.a;
                    var u = i / this.nodes.length;
                    this.dataForVbo[(2 * i + 1) * 9 + 7] = u;
                    this.dataForVbo[(2 * i + 1) * 9 + 8] = 0;
                    gd3d.math.pool.delete_vector3(tempPos);
                    gd3d.math.pool.delete_color(tempColor);
                }
                for (var k = 0; k < this.nodes.length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
            };
            trailRender_recorde.prototype.checkBufferSize = function () {
                var stickNumber = this.targetPath.length;
                if (stickNumber * 2 * 9 > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    this.dataForVbo = new Float32Array(length * 2);
                }
                if ((stickNumber - 1) * 6 > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    this.dataForEbo = new Uint16Array(length * 2);
                }
            };
            trailRender_recorde.prototype.render = function (context, assetmgr, camera) {
                if (this.notRender)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = (this.targetPath.length - 1) * 6;
                if (this.gameObject.getScene().fog) {
                    context.fog = this.gameObject.getScene().fog;
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base_fog");
                }
                else {
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
                }
            };
            trailRender_recorde.prototype.clone = function () {
            };
            trailRender_recorde = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent
            ], trailRender_recorde);
            return trailRender_recorde;
        }());
        framework.trailRender_recorde = trailRender_recorde;
        var trailNode = (function () {
            function trailNode(p, updir, t) {
                this.location = p;
                this.updir = updir;
                this.time = t;
            }
            return trailNode;
        }());
        framework.trailNode = trailNode;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var trailRender = (function () {
            function trailRender() {
                this.layer = framework.RenderLayerEnum.Common;
                this.renderLayer = framework.CullingMask.default;
                this.queue = 0;
                this.width = 1.0;
                this.vertexcount = 24;
                this.active = false;
                this.reInit = false;
                this.extenedOneSide = true;
                this.lookAtCamera = false;
                this.speed = 0.5;
            }
            trailRender.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                this.webgl = this.app.webgl;
                this.initmesh();
            };
            trailRender.prototype.update = function (delta) {
                if (!this.active)
                    return;
                if (this.reInit) {
                    this.intidata();
                    this.reInit = false;
                }
                var targetpos = this.gameObject.transform.getWorldTranslate();
                if (this.lookAtCamera) {
                    this.camerapositon = framework.sceneMgr.app.getScene().mainCamera.gameObject.transform.getWorldTranslate();
                    var camdir = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Subtract(this.camerapositon, this.sticks[0].location, camdir);
                    gd3d.math.vec3Normalize(camdir, camdir);
                    var direction = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Subtract(targetpos, this.sticks[0].location, direction);
                    gd3d.math.vec3Normalize(direction, direction);
                    gd3d.math.vec3Cross(camdir, direction, this.sticks[0].updir);
                    gd3d.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    gd3d.math.pool.delete_vector3(direction);
                }
                gd3d.math.vec3Clone(targetpos, this.sticks[0].location);
                var length = this.sticks.length;
                for (var i = 1; i < length; i++) {
                    gd3d.math.vec3SLerp(this.sticks[i].location, this.sticks[i - 1].location, this.speed, this.sticks[i].location);
                }
                if (this.lookAtCamera) {
                    for (var i = 1; i < length; i++) {
                        var tocamdir = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Subtract(this.camerapositon, this.sticks[i].location, tocamdir);
                        gd3d.math.vec3Normalize(tocamdir, tocamdir);
                        var movedir = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Subtract(this.sticks[i - 1].location, this.sticks[i].location, movedir);
                        gd3d.math.vec3Normalize(movedir, movedir);
                        gd3d.math.vec3Cross(tocamdir, movedir, this.sticks[i].updir);
                        gd3d.math.vec3ScaleByNum(this.sticks[i].updir, this.width, this.sticks[i].updir);
                        gd3d.math.pool.delete_vector3(tocamdir);
                    }
                }
                else {
                    this.gameObject.transform.getUpInWorld(this.sticks[0].updir);
                    gd3d.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    for (var i = 1; i < length; i++) {
                        gd3d.math.vec3SLerp(this.sticks[i].updir, this.sticks[i - 1].updir, this.speed, this.sticks[i].updir);
                    }
                }
                this.updateTrailData();
            };
            Object.defineProperty(trailRender.prototype, "material", {
                get: function () {
                    if (this._material != undefined) {
                        return this._material;
                    }
                    else {
                        var mat = new gd3d.framework.material();
                        mat.setShader(this.app.getAssetMgr().getShader("shader/def"));
                        this.material = mat;
                        return this._material;
                    }
                },
                set: function (material) {
                    this._material = material;
                    this.layer = this.material.getLayer();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(trailRender.prototype, "color", {
                get: function () {
                    if (this._color == undefined) {
                        this._color = new gd3d.math.color(1, 1, 1, 1);
                    }
                    return this._color;
                },
                set: function (color) {
                    this._color = color;
                },
                enumerable: true,
                configurable: true
            });
            trailRender.prototype.setspeed = function (upspeed) {
                this.speed = upspeed;
            };
            trailRender.prototype.setWidth = function (Width) {
                this.width = Width;
            };
            trailRender.prototype.play = function () {
                this.reInit = true;
                this.active = true;
            };
            trailRender.prototype.stop = function () {
                this.active = false;
            };
            trailRender.prototype.initmesh = function () {
                this.mesh = new gd3d.framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.dataForVbo = new Float32Array(this.vertexcount * 9);
                this.dataForEbo = new Uint16Array((this.vertexcount / 2 - 1) * 6);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, this.vertexcount, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            };
            trailRender.prototype.intidata = function () {
                this.sticks = [];
                for (var i = 0; i < this.vertexcount / 2; i++) {
                    var ts = new trailStick();
                    this.sticks.push(ts);
                    ts.location = new gd3d.math.vector3();
                    gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), ts.location);
                    ts.updir = new gd3d.math.vector3();
                    this.gameObject.transform.getUpInWorld(ts.updir);
                    gd3d.math.vec3ScaleByNum(ts.updir, this.width, ts.updir);
                }
                var length = this.vertexcount / 2;
                var updir = gd3d.math.pool.new_vector3();
                this.gameObject.transform.getUpInWorld(updir);
                gd3d.math.vec3ScaleByNum(updir, this.width, updir);
                var pos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), pos);
                var uppos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Add(pos, updir, uppos);
                var downpos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(pos, updir, downpos);
                for (var i = 0; i < length; i++) {
                    this.dataForVbo[i * 2 * 9] = uppos.x;
                    this.dataForVbo[i * 2 * 9 + 1] = uppos.y;
                    this.dataForVbo[i * 2 * 9 + 2] = uppos.z;
                    this.dataForVbo[i * 2 * 9 + 3] = this.color.r;
                    this.dataForVbo[i * 2 * 9 + 4] = this.color.g;
                    this.dataForVbo[i * 2 * 9 + 5] = this.color.b;
                    this.dataForVbo[i * 2 * 9 + 6] = this.color.a;
                    this.dataForVbo[i * 2 * 9 + 7] = i / (length - 1);
                    this.dataForVbo[i * 2 * 9 + 8] = 0;
                    this.dataForVbo[(i * 2 + 1) * 9] = downpos.x;
                    this.dataForVbo[(i * 2 + 1) * 9 + 1] = downpos.y;
                    this.dataForVbo[(i * 2 + 1) * 9 + 2] = downpos.z;
                    this.dataForVbo[(i * 2 + 1) * 9 + 3] = this.color.r;
                    this.dataForVbo[(i * 2 + 1) * 9 + 4] = this.color.g;
                    this.dataForVbo[(i * 2 + 1) * 9 + 5] = this.color.b;
                    this.dataForVbo[(i * 2 + 1) * 9 + 6] = this.color.a;
                    this.dataForVbo[(i * 2 + 1) * 9 + 7] = i / (length - 1);
                    this.dataForVbo[(i * 2 + 1) * 9 + 8] = 1;
                }
                for (var k = 0; k < length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
                this.mesh.glMesh.uploadVertexData(this.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                gd3d.math.pool.delete_vector3(updir);
                gd3d.math.pool.delete_vector3(pos);
                gd3d.math.pool.delete_vector3(uppos);
                gd3d.math.pool.delete_vector3(downpos);
            };
            trailRender.prototype.updateTrailData = function () {
                var length = this.vertexcount / 2;
                if (this.extenedOneSide) {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
                else {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x - up.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y - up.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z - up.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
            };
            trailRender.prototype.render = function (context, assetmgr, camera) {
                if (!this.active)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (this.gameObject.getScene().fog) {
                    context.fog = this.gameObject.getScene().fog;
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base_fog");
                }
                else {
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
                }
            };
            trailRender.prototype.clone = function () {
            };
            trailRender.prototype.remove = function () {
            };
            trailRender = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent
            ], trailRender);
            return trailRender;
        }());
        framework.trailRender = trailRender;
        var trailStick = (function () {
            function trailStick() {
            }
            return trailStick;
        }());
        framework.trailStick = trailStick;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var vignettingCtr = (function () {
            function vignettingCtr() {
                this.tag = "__vignettingtag__";
                this._init = false;
            }
            vignettingCtr.prototype.init = function () {
                var sh = this.scene.app.getAssetMgr().getShader("vignetting.shader.json");
                if (!sh) {
                    console.warn("vignetting.shader.json not find");
                    return;
                }
                var psize = 1024;
                var color = new framework.cameraPostQueue_Color();
                color[this.tag] = true;
                color.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                if (!this.camera.postQueues)
                    this.camera.postQueues = [];
                this.camera.postQueues.push(color);
                var textcolor = new framework.texture("_color");
                textcolor.glTexture = color.renderTarget;
                var texsize = 512;
                var blur_post = new gd3d.framework.cameraPostQueue_Quad();
                blur_post.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, texsize, texsize, true, false);
                blur_post.material.setShader(this.scene.app.getAssetMgr().getShader("separate_blur.shader.json"));
                blur_post.material.setTexture("_MainTex", textcolor);
                blur_post.material.setVector4("sample_offsets", new gd3d.math.vector4(0, 1.0, 0, -1.0));
                blur_post.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1.0 / texsize, 1.0 / texsize, texsize, texsize));
                this.camera.postQueues.push(blur_post);
                var blur0 = new gd3d.framework.texture("_blur0");
                blur0.glTexture = blur_post.renderTarget;
                var blur_post1 = new gd3d.framework.cameraPostQueue_Quad();
                blur_post1.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, texsize, texsize, true, false);
                blur_post1.material.setShader(this.scene.app.getAssetMgr().getShader("separate_blur.shader.json"));
                blur_post1.material.setTexture("_MainTex", blur0);
                blur_post1.material.setVector4("sample_offsets", new gd3d.math.vector4(1.0, 0, -1.0, 0));
                blur_post1.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1.0 / texsize, 1.0 / texsize, texsize, texsize));
                this.camera.postQueues.push(blur_post1);
                var blur = new gd3d.framework.texture("_blur0");
                blur.glTexture = blur_post1.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                this.material_1 = post0.material;
                post0.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", blur);
                post0.material.setFloat("_Vignetting", 0.3);
                post0.material.setFloat("_Blurred_Corners", 3.0);
                post0.material.setFloat("_Chromatic_Aberration", 3.0);
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                this._init = true;
            };
            vignettingCtr.prototype.start = function () {
                this.app = this.gameObject.transform.scene.app;
                this.scene = this.app.getScene();
            };
            vignettingCtr.prototype.update = function (delta) {
                if (this._init)
                    return;
                if (!this.camera)
                    this.camera = this.gameObject.getComponent("camera");
                if (this.camera)
                    this.init();
            };
            vignettingCtr.prototype.remove = function () {
                this._init = false;
                if (this.camera) {
                    var arr_4 = this.camera.postQueues;
                    var dArr = [];
                    for (var i = 0; i < arr_4.length; i++) {
                        var temp = arr_4[i];
                        if (temp[this.tag]) {
                            dArr.push(temp);
                        }
                    }
                    dArr.forEach(function (element) {
                        if (element) {
                            var idx = arr_4.indexOf(element);
                            if (idx != -1) {
                                arr_4.splice(idx, 1);
                            }
                        }
                    });
                }
                if (this.material) {
                    this.material.unuse();
                    this.material = null;
                }
                if (this.material_1) {
                    this.material_1.unuse();
                    this.material_1 = null;
                }
                if (this.material_2) {
                    this.material_2.unuse();
                    this.material_2 = null;
                }
                if (this.material_3) {
                    this.material_3.unuse();
                    this.material_3 = null;
                }
            };
            vignettingCtr.prototype.clone = function () {
            };
            vignettingCtr = __decorate([
                gd3d.reflect.nodeComponent
            ], vignettingCtr);
            return vignettingCtr;
        }());
        framework.vignettingCtr = vignettingCtr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var f14EffectSystem = (function () {
            function f14EffectSystem() {
                this.layer = framework.RenderLayerEnum.Transparent;
                this.renderLayer = framework.CullingMask.default;
                this.queue = 0;
                this.fps = 30;
                this.layers = [];
                this.VF = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this._delayTime = 0;
                this.elements = [];
                this.renderBatch = [];
                this.loopCount = 0;
                this.allTime = 0;
                this.renderActive = false;
                this.beref = false;
                this.mvpMat = new gd3d.math.matrix();
                this.totalTime = 0;
                this.totalFrame = 0;
                this.playRate = 1.0;
                this.playState = PlayStateEnum.beReady;
                this.active = false;
                this.bePause = false;
            }
            f14EffectSystem.prototype.start = function () {
            };
            f14EffectSystem.prototype.remove = function () { };
            Object.defineProperty(f14EffectSystem.prototype, "f14eff", {
                get: function () {
                    return this._f14eff;
                },
                set: function (asset) {
                    if (this._f14eff != null) {
                        this._f14eff.unuse();
                    }
                    this._f14eff = asset;
                    this.setData(asset.data);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(f14EffectSystem.prototype, "delay", {
                get: function () {
                    return this._delayTime;
                },
                set: function (deley) {
                    this._delayTime = deley;
                },
                enumerable: true,
                configurable: true
            });
            f14EffectSystem.prototype.setData = function (data) {
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.data = data;
                for (var i = 0, count = this.data.layers.length; i < count; i++) {
                    var layerdata = this.data.layers[i];
                    this.addF14layer(layerdata.type, layerdata);
                }
                for (var i = 0; i < this.renderBatch.length; i++) {
                    if (this.renderBatch[i].type == framework.F14TypeEnum.SingleMeshType) {
                        this.renderBatch[i].OnEndCollectElement();
                    }
                }
            };
            Object.defineProperty(f14EffectSystem.prototype, "root", {
                get: function () {
                    return this._root || this.gameObject.transform;
                },
                enumerable: true,
                configurable: true
            });
            f14EffectSystem.prototype.update = function (deltaTime) {
                if (this.data == null || this.playState == PlayStateEnum.beReady) {
                    this.renderActive = false;
                    return;
                }
                if (this.playState == PlayStateEnum.play) {
                    this.allTime += deltaTime * this.playRate;
                    this.totalTime = this.allTime - this._delayTime;
                    if (this.totalTime <= 0) {
                        this.renderActive = false;
                        return;
                    }
                }
                this.renderActive = true;
                this.totalFrame = this.totalTime * this.fps;
                this.restartFrame = this.totalFrame % this.data.lifeTime;
                this.restartFrame = Math.floor(this.restartFrame);
                var newLoopCount = Math.floor(this.totalFrame / this.data.lifeTime);
                if (newLoopCount != this.loopCount) {
                    this.OnEndOnceLoop();
                }
                this.loopCount = newLoopCount;
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i].update(deltaTime, this.totalFrame, this.fps);
                }
            };
            f14EffectSystem.prototype.OnEndOnceLoop = function () {
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i].OnEndOnceLoop();
                }
            };
            Object.defineProperty(f14EffectSystem.prototype, "renderCamera", {
                get: function () {
                    if (this._renderCamera != null) {
                        return this._renderCamera;
                    }
                    else {
                        return gd3d.framework.sceneMgr.app.getScene().mainCamera;
                    }
                },
                enumerable: true,
                configurable: true
            });
            f14EffectSystem.prototype.render = function (context, assetmgr, camera, Effqueue) {
                if (Effqueue === void 0) { Effqueue = 0; }
                if (!this.renderActive)
                    return;
                this._renderCamera = camera;
                var curCount = 0;
                context.updateModel(this.root);
                gd3d.math.matrixClone(context.matrixModelViewProject, this.mvpMat);
                for (var i = 0; i < this.renderBatch.length; i++) {
                    this.renderBatch[i].render(context, assetmgr, camera, Effqueue + curCount);
                    curCount += this.renderBatch[i].getElementCount();
                }
            };
            f14EffectSystem.prototype.addF14layer = function (type, layerdata) {
                if (type == framework.F14TypeEnum.SingleMeshType) {
                    var layer = new framework.F14Layer(this, layerdata);
                    var element = new framework.F14SingleMesh(this, layer);
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    var data = layerdata.elementdata;
                    if (this.layers.length > 1 && this.layers[this.layers.length - 2].type == type) {
                        var batch = this.layers[this.layers.length - 2].batch;
                        if (batch.type == framework.F14TypeEnum.SingleMeshType && batch.canBatch(element)) {
                            batch.addElement(element);
                            layer.batch = batch;
                        }
                        else {
                            var _batch = new framework.F14SingleMeshBath(data.material, this);
                            _batch.addElement(element);
                            layer.batch = _batch;
                            this.renderBatch.push(_batch);
                        }
                    }
                    else if (this.layers.length = 1) {
                        var batch = new framework.F14SingleMeshBath(data.material, this);
                        batch.addElement(element);
                        layer.batch = batch;
                        this.renderBatch.push(batch);
                    }
                    return layer;
                }
                else if (type == framework.F14TypeEnum.particlesType) {
                    var layer = new framework.F14Layer(this, layerdata);
                    var element = new framework.F14Emission(this, layer);
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    var batch = new framework.F14EmissionBatch(this, element);
                    layer.batch = batch;
                    this.renderBatch.push(batch);
                    return layer;
                }
                else {
                    var layer = new framework.F14Layer(this, layerdata);
                    var element = new framework.F14RefElement(this, layer);
                    var data = layerdata.elementdata;
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    var refbath = new framework.F14RefElementBatch(this, element);
                    this.renderBatch.push(refbath);
                    layer.batch = refbath;
                    return layer;
                }
            };
            f14EffectSystem.prototype.getElementCount = function () {
                var totalcount = 0;
                for (var i = 0; i < this.layers.length; i++) {
                    if (this.layers[i].type == framework.F14TypeEnum.RefType) {
                        totalcount += this.layers[i].batch.getElementCount();
                    }
                    else {
                        totalcount++;
                    }
                }
                return totalcount;
            };
            f14EffectSystem.prototype.dispose = function () {
            };
            f14EffectSystem.prototype.play = function (PlayRate) {
                if (PlayRate === void 0) { PlayRate = 1.0; }
                if (this.playState != PlayStateEnum.beReady) {
                    this.reset();
                }
                this.playState = PlayStateEnum.play;
                this.playRate = PlayRate;
            };
            f14EffectSystem.prototype.stop = function () {
                this.playState = PlayStateEnum.beReady;
                this.reset();
            };
            f14EffectSystem.prototype.pause = function () {
                if (this.playState == PlayStateEnum.pause) {
                    this.playState = PlayStateEnum.play;
                }
                else {
                    this.playState = PlayStateEnum.pause;
                }
            };
            f14EffectSystem.prototype.reset = function () {
                this.allTime = 0;
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i].reset();
                }
            };
            f14EffectSystem.prototype.clone = function () {
            };
            __decorate([
                gd3d.reflect.Field("f14eff"),
                gd3d.reflect.UIStyle("WidgetDragSelect"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [framework.f14eff])
            ], f14EffectSystem.prototype, "f14eff", null);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Number])
            ], f14EffectSystem.prototype, "delay", null);
            f14EffectSystem = __decorate([
                gd3d.reflect.nodeRender,
                gd3d.reflect.nodeComponent
            ], f14EffectSystem);
            return f14EffectSystem;
        }());
        framework.f14EffectSystem = f14EffectSystem;
        var PlayStateEnum;
        (function (PlayStateEnum) {
            PlayStateEnum[PlayStateEnum["play"] = 0] = "play";
            PlayStateEnum[PlayStateEnum["beReady"] = 1] = "beReady";
            PlayStateEnum[PlayStateEnum["pause"] = 2] = "pause";
        })(PlayStateEnum = framework.PlayStateEnum || (framework.PlayStateEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14TypeEnum;
        (function (F14TypeEnum) {
            F14TypeEnum[F14TypeEnum["SingleMeshType"] = 0] = "SingleMeshType";
            F14TypeEnum[F14TypeEnum["particlesType"] = 1] = "particlesType";
            F14TypeEnum[F14TypeEnum["RefType"] = 2] = "RefType";
        })(F14TypeEnum = framework.F14TypeEnum || (framework.F14TypeEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14Layer = (function () {
            function F14Layer(effect, data) {
                this.active = true;
                this.frameList = [];
                this.frames = {};
                this.Attlines = {};
                this.effect = effect;
                this.data = data;
                this.type = data.type;
                for (var ff in this.data.frames) {
                    var framedata = this.data.frames[ff];
                    this.addFrame(framedata.frameindex, framedata);
                }
            }
            F14Layer.prototype.addFrame = function (index, framedata) {
                if (this.frames[index])
                    return this.frames[index];
                var frame = new F14Frame(this, framedata);
                this.frameList.push(index);
                this.frameList.sort(function (a, b) { return a - b; });
                this.frames[index] = frame;
                return frame;
            };
            F14Layer.prototype.removeFrame = function (frame) {
                if (this.frames[frame]) {
                    delete this.frames[frame];
                    var index = this.frameList.indexOf(frame);
                    this.frameList.splice(index, 1);
                    delete this.data.frames[frame];
                }
                for (var item in this.Attlines) {
                    this.Attlines[item].remove(frame);
                }
            };
            return F14Layer;
        }());
        framework.F14Layer = F14Layer;
        var F14Frame = (function () {
            function F14Frame(layer, data) {
                this.layer = layer;
                this.data = data;
                this.attDic = this.data.singlemeshAttDic;
                for (var key in this.data.singlemeshAttDic) {
                    this.setdata(key, this.data.singlemeshAttDic[key]);
                }
            }
            F14Frame.prototype.setdata = function (name, obj) {
                if (this.layer.Attlines[name] == null) {
                    if (obj instanceof gd3d.math.vector3) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, gd3d.math.vec3SLerp, gd3d.math.vec3Clone);
                    }
                    else if (obj instanceof gd3d.math.vector4) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, gd3d.math.vec4SLerp, gd3d.math.vec4Clone);
                    }
                    else if (obj instanceof gd3d.math.color) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, gd3d.math.colorLerp, gd3d.math.colorClone);
                    }
                }
                this.layer.Attlines[name].addNode(this.data.frameindex, obj);
                this.attDic[name] = obj;
            };
            F14Frame.prototype.removedata = function (name) {
                delete this.attDic[name];
                if (this.layer.Attlines[name]) {
                    this.layer.Attlines[name].remove(this.data.frameindex);
                }
            };
            F14Frame.prototype.getdata = function (name) {
                return this.attDic[name];
            };
            return F14Frame;
        }());
        framework.F14Frame = F14Frame;
        var F14AttTimeLine = (function () {
            function F14AttTimeLine(name, lerpfunc, clonefunc) {
                this.frameList = [];
                this.line = {};
                this.name = name;
                this.lerpFunc = lerpfunc;
                this.cloneFunc = clonefunc;
            }
            F14AttTimeLine.prototype.addNode = function (frame, value) {
                var index = this.frameList.indexOf(frame);
                if (index < 0) {
                    this.frameList.push(frame);
                    this.frameList.sort(function (a, b) { return a - b; });
                }
                this.line[frame] = value;
            };
            F14AttTimeLine.prototype.remove = function (frame) {
                if (this.line[frame]) {
                    delete this.line[frame];
                    var index = this.frameList.indexOf(frame);
                    this.frameList.splice(index, 1);
                }
            };
            F14AttTimeLine.prototype.getValue = function (frame, basedate, out) {
                if (this.frameList.length == 0) {
                    return;
                }
                if (this.line[frame]) {
                    this.cloneFunc(this.line[frame], out);
                    return;
                }
                if (frame < this.frameList[0]) {
                    var toindex = this.frameList[0];
                    var from = basedate[this.name];
                    var to = this.line[toindex];
                    var lerp = (frame - basedate.firtstFrame) / toindex;
                    this.lerpFunc(from, to, lerp, out);
                }
                else if (frame >= this.frameList[this.frameList.length - 1]) {
                    this.cloneFunc(this.line[this.frameList[this.frameList.length - 1]], out);
                }
                else {
                    for (var i = 0; i < this.frameList.length; i++) {
                        if (this.frameList[i] > frame) {
                            var to = this.frameList[i];
                            var from = this.frameList[i - 1];
                            this.lerpFunc(this.line[from], this.line[to], (frame - from) / (to - from), out);
                            return;
                        }
                    }
                }
            };
            return F14AttTimeLine;
        }());
        framework.F14AttTimeLine = F14AttTimeLine;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14EffectData = (function () {
            function F14EffectData() {
                this.beloop = false;
                this.lifeTime = 100;
                this.layers = [];
            }
            F14EffectData.prototype.parsejson = function (json, assetmgr, assetbundle) {
                this.beloop = json.beloop;
                this.lifeTime = json.lifeTime;
                var jsonlayer = json.layers;
                for (var i = 0; i < jsonlayer.length; i++) {
                    var layer = new F14LayerData();
                    layer.parse(jsonlayer[i], assetmgr, assetbundle);
                    this.layers.push(layer);
                }
            };
            return F14EffectData;
        }());
        framework.F14EffectData = F14EffectData;
        var F14LayerData = (function () {
            function F14LayerData() {
                this.Name = "newLayer";
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.frames = {};
            }
            F14LayerData.prototype.parse = function (json, assetmgr, assetbundle) {
                this.Name = json.Name;
                switch (json.type) {
                    case "particlesType":
                        this.type = framework.F14TypeEnum.particlesType;
                        this.elementdata = new framework.F14EmissionBaseData();
                        this.elementdata.parse(json.emissiondata, assetmgr, assetbundle);
                        break;
                    case "SingleMeshType":
                        this.type = framework.F14TypeEnum.SingleMeshType;
                        this.elementdata = new framework.F14SingleMeshBaseData(json.frames[0].frameindex);
                        this.elementdata.parse(json.singlemeshdata, assetmgr, assetbundle);
                        break;
                    case "RefType":
                        this.type = framework.F14TypeEnum.RefType;
                        this.elementdata = new framework.F14RefBaseData();
                        this.elementdata.parse(json.RefData, assetmgr, assetbundle);
                        break;
                    default:
                        console.log("f14Eff parse layerjson error!");
                        return;
                }
                for (var i = 0; i < json.frames.length; i++) {
                    var framejson = json.frames[i];
                    var frameindex = framejson.frameindex;
                    var frameitem = new F14FrameData(frameindex, this.type);
                    this.frames[frameindex] = frameitem;
                    switch (this.type) {
                        case framework.F14TypeEnum.SingleMeshType:
                            for (var k = 0; k < framejson.vec3Atts.length; k++) {
                                var name_6 = framejson.vec3Atts[k].name;
                                var strValue = framejson.vec3Atts[k].value;
                                var v3 = new gd3d.math.vector3();
                                gd3d.math.vec3FormJson(strValue, v3);
                                frameitem.singlemeshAttDic[name_6] = v3;
                            }
                            for (var k = 0; k < framejson.vec4Atts.length; k++) {
                                var name_7 = framejson.vec4Atts[k].name;
                                var strValue = framejson.vec4Atts[k].value;
                                var v4 = new gd3d.math.vector4();
                                gd3d.math.vec4FormJson(strValue, v4);
                                frameitem.singlemeshAttDic[name_7] = v4;
                            }
                            for (var k = 0; k < framejson.colorAtts.length; k++) {
                                var name_8 = framejson.colorAtts[k].name;
                                var strValue = framejson.colorAtts[k].value;
                                var color = new gd3d.math.color();
                                gd3d.math.colorFormJson(strValue, color);
                                frameitem.singlemeshAttDic[name_8] = color;
                            }
                            break;
                        case framework.F14TypeEnum.particlesType:
                            var data = new framework.F14EmissionBaseData();
                            data.parse(framejson.emissionData, assetmgr, assetbundle);
                            frameitem.EmissionData = data;
                    }
                }
            };
            return F14LayerData;
        }());
        framework.F14LayerData = F14LayerData;
        var F14FrameData = (function () {
            function F14FrameData(index, type) {
                this.frameindex = index;
                if (type == framework.F14TypeEnum.SingleMeshType) {
                    this.singlemeshAttDic = {};
                }
                else {
                    this.EmissionData = new framework.F14EmissionBaseData();
                }
            }
            return F14FrameData;
        }());
        framework.F14FrameData = F14FrameData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var NumberData = (function () {
            function NumberData(value) {
                if (value === void 0) { value = 0; }
                this.isRandom = false;
                this._value = 0;
                this._valueLimitMin = 0;
                this._valueLimitMax = 0;
                this.beInited = false;
                this._value = value;
            }
            NumberData.prototype.setValue = function (value) {
                this._value = value;
            };
            NumberData.prototype.setRandomValue = function (max, min) {
                this._valueLimitMax = max;
                this._valueLimitMin = min;
                this.isRandom = true;
            };
            NumberData.prototype.getValue = function (reRandom) {
                if (reRandom === void 0) { reRandom = false; }
                if (this.isRandom) {
                    if (reRandom || !this.beInited) {
                        this.key = Math.random();
                        this._value = this.key * (this._valueLimitMax - this._valueLimitMin) + this._valueLimitMin;
                        this.beInited = true;
                    }
                }
                return this._value;
            };
            NumberData.copyto = function (from, to) {
                to.isRandom = from.isRandom;
                to._value = from._value;
                to._valueLimitMin = from._valueLimitMin;
                to._valueLimitMax = from._valueLimitMax;
            };
            NumberData.FormJson = function (json, data) {
                if (json.indexOf("~") < 0) {
                    data.setValue(Number(json));
                }
                else {
                    var arr = json.split("~");
                    data.setRandomValue(Number(arr[1]), Number(arr[0]));
                }
            };
            return NumberData;
        }());
        framework.NumberData = NumberData;
        var Vector3Data = (function () {
            function Vector3Data(x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                this.x = new NumberData();
                this.y = new NumberData();
                this.z = new NumberData();
                this.x.setValue(x);
                this.y.setValue(y);
                this.z.setValue(z);
            }
            Vector3Data.prototype.getValue = function (reRandom) {
                if (reRandom === void 0) { reRandom = false; }
                var _out = new gd3d.math.vector3();
                _out.x = this.x.getValue(reRandom);
                _out.y = this.y.getValue(reRandom);
                _out.z = this.z.getValue(reRandom);
                return _out;
            };
            Vector3Data.copyto = function (from, to) {
                NumberData.copyto(from.x, to.x);
                NumberData.copyto(from.y, to.y);
                NumberData.copyto(from.z, to.z);
            };
            Vector3Data.FormJson = function (json, data) {
                var arr = json.split(",");
                NumberData.FormJson(arr[0], data.x);
                NumberData.FormJson(arr[1], data.y);
                NumberData.FormJson(arr[2], data.z);
            };
            return Vector3Data;
        }());
        framework.Vector3Data = Vector3Data;
        var NumberKey = (function () {
            function NumberKey(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
            return NumberKey;
        }());
        framework.NumberKey = NumberKey;
        var Vector3Key = (function () {
            function Vector3Key(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
            return Vector3Key;
        }());
        framework.Vector3Key = Vector3Key;
        var Vector2Key = (function () {
            function Vector2Key(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
            return Vector2Key;
        }());
        framework.Vector2Key = Vector2Key;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14Emission = (function () {
            function F14Emission(effect, layer) {
                this.particlelist = [];
                this.deadParticles = [];
                this.frameLife = 0;
                this.TotalTime = 0;
                this.newStartDataTime = 0;
                this.curTime = 0;
                this.beover = false;
                this.numcount = 0;
                this.localMatrix = new gd3d.math.matrix();
                this._worldMatrix = new gd3d.math.matrix();
                this.localrot = new gd3d.math.quaternion();
                this.worldRot = new gd3d.math.quaternion();
                this.lastFrame = 0;
                this.type = framework.F14TypeEnum.particlesType;
                this.effect = effect;
                this.layer = layer;
                this.baseddata = layer.data.elementdata;
                this.currentData = this.baseddata;
                this.newStartDataTime = this.baseddata.delayTime;
                this.initBycurrentdata();
                this.vertexCount = this.currentData.mesh.data.pos.length;
                this.posArr = this.currentData.mesh.data.pos;
                this.colorArr = this.currentData.mesh.data.color;
                this.uvArr = this.currentData.mesh.data.uv;
                this.dataforebo = this.currentData.mesh.data.genIndexDataArray();
                this.vertexLength = gd3d.render.meshData.calcByteSize(this.effect.VF) / 4;
                this.dataforvboLen = this.vertexCount * this.vertexLength;
            }
            F14Emission.prototype.update = function (deltaTime, frame, fps) {
                this.TotalTime += deltaTime;
                this.refreshByFrameData(fps);
                this.updateLife();
                for (var i = 0; i < this.particlelist.length; i++) {
                    this.particlelist[i].update(deltaTime);
                }
            };
            F14Emission.prototype.refreshByFrameData = function (fps) {
                this.frameLife = Math.floor(this.baseddata.duration * fps);
                if (this.frameLife == 0)
                    this.frameLife = 1;
                var frame = Math.floor(this.TotalTime * fps) % this.frameLife;
                if (frame != this.lastFrame && this.layer.frames[frame]) {
                    if (this.layer.frames[frame].data.EmissionData != this.currentData) {
                        this.changeCurrentBaseData(this.layer.frames[frame].data.EmissionData);
                    }
                }
                this.lastFrame = frame;
            };
            F14Emission.prototype.changeCurrentBaseData = function (data) {
                this.currentData = data;
                this.newStartDataTime = this.TotalTime;
                this.numcount = 0;
                this.initBycurrentdata();
            };
            F14Emission.prototype.initBycurrentdata = function () {
                gd3d.math.quatFromEulerAngles(this.currentData.rotEuler.x, this.currentData.rotEuler.y, this.currentData.rotEuler.z, this.localrot);
                gd3d.math.matrixMakeTransformRTS(this.currentData.rotPosition, this.currentData.rotScale, this.localrot, this.localMatrix);
            };
            F14Emission.prototype.getWorldMatrix = function () {
                var mat = this.effect.root.getWorldMatrix();
                gd3d.math.matrixMultiply(mat, this.localMatrix, this._worldMatrix);
                return this._worldMatrix;
            };
            F14Emission.prototype.getWorldRotation = function () {
                var rot = this.effect.root.getWorldRotate();
                gd3d.math.quatMultiply(rot, this.localrot, this.worldRot);
                return this.worldRot;
            };
            F14Emission.prototype.updateLife = function () {
                if (this.beover)
                    return;
                this.curTime = this.TotalTime - this.baseddata.delayTime;
                if (this.curTime <= 0)
                    return;
                this.updateEmission();
                if (this.curTime > this.baseddata.duration) {
                    if (this.baseddata.beloop) {
                        switch (this.baseddata.loopenum) {
                            case framework.LoopEnum.Restart:
                                this.reInit();
                                break;
                            case framework.LoopEnum.TimeContinue:
                                this.beover = true;
                                break;
                        }
                    }
                    else {
                        this.beover = true;
                    }
                }
            };
            F14Emission.prototype.reInit = function () {
                this.currentData = this.baseddata;
                this.newStartDataTime = 0;
                this.beover = false;
                this.TotalTime = 0;
                this.numcount = 0;
                this.currentData.rateOverTime.getValue(true);
                for (var i = 0; i < this.baseddata.bursts.length; i++) {
                    this.baseddata.bursts[i].burst(false);
                }
            };
            F14Emission.prototype.updateEmission = function () {
                var needCount = Math.floor(this.currentData.rateOverTime.getValue() * (this.TotalTime - this.newStartDataTime));
                var realcount = needCount - this.numcount;
                this.addParticle(realcount);
                this.numcount += realcount;
                if (this.baseddata.bursts.length > 0) {
                    for (var i = 0; i < this.baseddata.bursts.length; i++) {
                        if (!this.baseddata.bursts[i].beburst() && this.baseddata.bursts[i].time <= this.TotalTime) {
                            var count = this.baseddata.bursts[i].count.getValue(true);
                            this.baseddata.bursts[i].burst();
                            this.addParticle(count);
                        }
                    }
                }
            };
            F14Emission.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var pp = this.deadParticles.pop();
                        pp.initByEmissionData(this.currentData);
                    }
                    else {
                        var pp = new framework.F14Particle(this, this.currentData);
                        this.particlelist.push(pp);
                    }
                }
            };
            F14Emission.prototype.reset = function () {
                this.reInit();
                for (var i = 0; i < this.particlelist.length; i++) {
                    if (this.particlelist[i].actived) {
                        this.particlelist[i].actived = false;
                        this.deadParticles.push(this.particlelist[i]);
                    }
                }
            };
            F14Emission.prototype.OnEndOnceLoop = function () {
            };
            return F14Emission;
        }());
        framework.F14Emission = F14Emission;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var RenderModelEnum;
        (function (RenderModelEnum) {
            RenderModelEnum[RenderModelEnum["None"] = 0] = "None";
            RenderModelEnum[RenderModelEnum["BillBoard"] = 1] = "BillBoard";
            RenderModelEnum[RenderModelEnum["StretchedBillBoard"] = 2] = "StretchedBillBoard";
            RenderModelEnum[RenderModelEnum["HorizontalBillBoard"] = 3] = "HorizontalBillBoard";
            RenderModelEnum[RenderModelEnum["VerticalBillBoard"] = 4] = "VerticalBillBoard";
            RenderModelEnum[RenderModelEnum["Mesh"] = 5] = "Mesh";
        })(RenderModelEnum = framework.RenderModelEnum || (framework.RenderModelEnum = {}));
        var F14EmissionBaseData = (function () {
            function F14EmissionBaseData() {
                this.loopenum = framework.LoopEnum.Restart;
                this.rotPosition = new gd3d.math.vector3();
                this.rotScale = new gd3d.math.vector3(1, 1, 1);
                this.rotEuler = new gd3d.math.vector3();
                this.rendermodel = RenderModelEnum.Mesh;
                this.beloop = true;
                this.lifeTime = new framework.NumberData(20);
                this.simulateInLocalSpace = true;
                this.startScaleRate = new framework.NumberData(1);
                this.startScale = new framework.Vector3Data(1, 1, 1);
                this.startEuler = new framework.Vector3Data();
                this.startColor = new framework.Vector3Data(1, 1, 1);
                this.startAlpha = new framework.NumberData(1);
                this.colorRate = 1;
                this.simulationSpeed = new framework.NumberData(1);
                this.start_tex_st = new gd3d.math.vector4(1, 1, 0, 0);
                this.delayTime = 0;
                this.duration = 10;
                this.rateOverTime = new framework.NumberData(1);
                this.bursts = [];
                this.shapeType = framework.ParticleSystemShape.NORMAL;
                this.emitFrom = framework.emitfromenum.base;
                this.enableVelocityOverLifetime = false;
                this.moveSpeed = new framework.Vector3Data(0);
                this.enableSizeOverLifetime = false;
                this.sizeNodes = [];
                this.enableRotOverLifeTime = false;
                this.angleSpeed = new framework.NumberData(0);
                this.enableColorOverLifetime = false;
                this.colorNodes = [];
                this.alphaNodes = [];
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
            }
            F14EmissionBaseData.prototype.parse = function (json, assetmgr, assetbundle) {
                switch (json.loopenum) {
                    case "Restart":
                        this.loopenum = framework.LoopEnum.Restart;
                        break;
                    case "TimeContinue":
                        this.loopenum = framework.LoopEnum.TimeContinue;
                        break;
                }
                this.mesh = assetmgr.getAssetByName(json.mesh, assetbundle);
                this.material = assetmgr.getAssetByName(json.material, assetbundle);
                gd3d.math.vec3FormJson(json.rotPosition, this.rotPosition);
                gd3d.math.vec3FormJson(json.rotScale, this.rotScale);
                gd3d.math.vec3FormJson(json.rotEuler, this.rotEuler);
                switch (json.rendermodel) {
                    default:
                    case "BillBoard":
                        this.rendermodel = RenderModelEnum.BillBoard;
                        break;
                    case "HorizontalBillBoard":
                        this.rendermodel = RenderModelEnum.HorizontalBillBoard;
                        break;
                    case "Mesh":
                        this.rendermodel = RenderModelEnum.Mesh;
                        break;
                    case "StretchedBillBoard":
                        this.rendermodel = RenderModelEnum.StretchedBillBoard;
                        break;
                    case "VerticalBillBoard":
                        this.rendermodel = RenderModelEnum.VerticalBillBoard;
                        break;
                    case "None":
                        this.rendermodel = RenderModelEnum.None;
                        break;
                }
                this.beloop = json.beloop;
                framework.NumberData.FormJson(json.lifeTime, this.lifeTime);
                this.simulateInLocalSpace = json.simulateInLocalSpace;
                framework.NumberData.FormJson(json.startScaleRate, this.startScaleRate);
                framework.Vector3Data.FormJson(json.startScale, this.startScale);
                framework.Vector3Data.FormJson(json.startEuler, this.startEuler);
                framework.Vector3Data.FormJson(json.startColor, this.startColor);
                framework.NumberData.FormJson(json.startAlpha, this.startAlpha);
                this.colorRate = json.colorRate;
                framework.NumberData.FormJson(json.simulationSpeed, this.simulationSpeed);
                gd3d.math.vec4FormJson(json.start_tex_st, this.start_tex_st);
                this.delayTime = json.delayTime;
                this.duration = json.duration;
                framework.NumberData.FormJson(json.rateOverTime, this.rateOverTime);
                for (var i = 0; i < json.bursts.length; i++) {
                    var item = json.bursts[i];
                    var info = busrtInfo.CreatformJson(item);
                    this.bursts.push(info);
                }
                switch (json.shapeType) {
                    case "NORMAL":
                        this.shapeType = framework.ParticleSystemShape.NORMAL;
                        break;
                    case "BOX":
                        this.shapeType = framework.ParticleSystemShape.BOX;
                        this.width = json.width;
                        this.height = json.height;
                        this.depth = json.depth;
                        break;
                    case "SPHERE":
                        this.shapeType = framework.ParticleSystemShape.SPHERE;
                        this.radius = json.radius;
                        break;
                    case "HEMISPHERE":
                        this.shapeType = framework.ParticleSystemShape.HEMISPHERE;
                        this.radius = json.radius;
                        break;
                    case "CONE":
                        this.shapeType = framework.ParticleSystemShape.CONE;
                        this.height = json.height;
                        this.angle = json.angle;
                        this.radius = json.radius;
                        switch (json.emitFrom) {
                            case "base_":
                                this.emitFrom = framework.emitfromenum.base;
                                break;
                            case "volume":
                                this.emitFrom = framework.emitfromenum.volume;
                                break;
                        }
                        break;
                    case "CIRCLE":
                        this.shapeType = framework.ParticleSystemShape.CIRCLE;
                        break;
                    case "EDGE":
                        this.shapeType = framework.ParticleSystemShape.EDGE;
                        break;
                }
                this.enableVelocityOverLifetime = json.enableVelocityOverLifetime;
                if (this.enableVelocityOverLifetime) {
                    framework.Vector3Data.FormJson(json.moveSpeed, this.moveSpeed);
                }
                this.enableSizeOverLifetime = json.enableSizeOverLifetime;
                if (this.enableSizeOverLifetime) {
                    for (var i = 0; i < json.sizeNodes.length; i++) {
                        var jsonitem = json.sizeNodes[i];
                        var item = new framework.NumberKey(jsonitem.key, jsonitem.value);
                        this.sizeNodes.push(item);
                    }
                }
                this.enableRotOverLifeTime = json.enableRotOverLifeTime;
                if (this.enableRotOverLifeTime) {
                    framework.NumberData.FormJson(json.angleSpeed, this.angleSpeed);
                }
                this.enableColorOverLifetime = json.enableColorOverLifetime;
                if (this.enableColorOverLifetime) {
                    for (var i = 0; i < json.colorNodes.length; i++) {
                        var jsonitem = json.colorNodes[i];
                        var v3 = new gd3d.math.vector3();
                        gd3d.math.vec3FormJson(jsonitem.value, v3);
                        var item = new framework.Vector3Key(jsonitem.key, v3);
                        this.colorNodes.push(item);
                    }
                    for (var i = 0; i < json.alphaNodes.length; i++) {
                        var jsonitem = json.alphaNodes[i];
                        var item = new framework.NumberKey(jsonitem.key, jsonitem.value);
                        this.alphaNodes.push(item);
                    }
                }
                this.enableTexAnimation = json.enableTexAnimation;
                if (this.enableTexAnimation) {
                    switch (json.uvType) {
                        case "UVRoll":
                            this.uvType = framework.UVTypeEnum.UVRoll;
                            this.uSpeed = json.uSpeed;
                            this.vSpeed = json.vSpeed;
                            break;
                        case "UVSprite":
                            this.uvType = framework.UVTypeEnum.UVSprite;
                            this.row = json.row;
                            this.column = json.column;
                            this.count = json.count;
                            break;
                        case "NONE":
                            this.uvType = framework.UVTypeEnum.NONE;
                            break;
                    }
                }
            };
            F14EmissionBaseData.getRandomDirAndPosByZEmission = function (emission, outDir, outPos) {
                switch (emission.shapeType) {
                    case framework.ParticleSystemShape.NORMAL:
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_zero, outPos);
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_up, outDir);
                        break;
                    case framework.ParticleSystemShape.SPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        var radius = Math.random() * emission.radius;
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.HEMISPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI * 0.5;
                        var radius = Math.random() * emission.radius;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.BOX:
                        outPos.x = framework.ValueData.RandomRange(-emission.width / 2, emission.width / 2);
                        outPos.y = framework.ValueData.RandomRange(-emission.height / 2, emission.height / 2);
                        outPos.z = framework.ValueData.RandomRange(-emission.depth / 2, emission.depth / 2);
                        gd3d.math.vec3Normalize(outPos, outDir);
                        break;
                    case framework.ParticleSystemShape.CONE:
                        var randomAngle = Math.random() * Math.PI * 2;
                        var randomHeight = Math.random() * emission.height;
                        var upradius = randomHeight * Math.tan(emission.angle * Math.PI / 180) + emission.radius;
                        var radomRadius = Math.random() * upradius;
                        var bottompos = gd3d.math.pool.new_vector3();
                        bottompos.x = emission.radius * Math.cos(randomAngle);
                        bottompos.y = 0;
                        bottompos.z = emission.radius * Math.sin(randomAngle);
                        if (emission.emitFrom == framework.emitfromenum.base) {
                            gd3d.math.vec3Clone(bottompos, outPos);
                        }
                        else if (emission.emitFrom == framework.emitfromenum.volume) {
                            outPos.x = radomRadius * Math.cos(randomAngle);
                            outPos.z = radomRadius * Math.sin(randomAngle);
                            outPos.y = randomHeight;
                        }
                        outDir.x = Math.cos(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.z = Math.sin(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.y = Math.cos(emission.angle * Math.PI / 180);
                        break;
                }
            };
            return F14EmissionBaseData;
        }());
        framework.F14EmissionBaseData = F14EmissionBaseData;
        var busrtInfo = (function () {
            function busrtInfo() {
                this.time = 0;
                this.count = new framework.NumberData(10);
                this._beburst = false;
            }
            busrtInfo.prototype.beburst = function () {
                return this._beburst;
            };
            busrtInfo.prototype.burst = function (bebusrt) {
                if (bebusrt === void 0) { bebusrt = true; }
                this._beburst = bebusrt;
            };
            busrtInfo.CreatformJson = function (json) {
                var info = new busrtInfo();
                info.time = json.time;
                framework.NumberData.FormJson(json.count, info.count);
                return info;
            };
            return busrtInfo;
        }());
        framework.busrtInfo = busrtInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14EmissionBatch = (function () {
            function F14EmissionBatch(effect, element) {
                this.curRealVboCount = 0;
                this.curVertexcount = 0;
                this.curIndexCount = 0;
                this.vertexLength = 0;
                this.type = framework.F14TypeEnum.particlesType;
                this.effect = effect;
                this.emission = element;
                this.mesh = this.emission.baseddata.mesh;
                this.mat = this.emission.baseddata.material;
                this.vertexLength = gd3d.render.meshData.calcByteSize(this.effect.VF) / 4;
                var maxParticlesCount = this.getMaxParticleCount();
                var particleVertexCount = this.mesh.data.pos.length;
                var particleIndexCount = this.mesh.data.trisindex.length;
                var totalVertex = maxParticlesCount * particleVertexCount;
                var totalIndex = maxParticlesCount * particleIndexCount;
                this.dataForVbo = new Float32Array(totalVertex * this.vertexLength);
                this.dataForEbo = new Uint16Array(totalIndex);
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, totalVertex, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            }
            F14EmissionBatch.prototype.getMaxParticleCount = function () {
                var maxrate;
                var basrat = this.emission.baseddata.rateOverTime;
                maxrate = basrat.isRandom ? basrat._valueLimitMax : basrat._value;
                var liftime = this.emission.baseddata.lifeTime;
                var maxlife = liftime.isRandom ? liftime._valueLimitMax : liftime._value;
                if (!this.emission.baseddata.beloop) {
                    var duration = this.emission.baseddata.duration;
                    if (duration < maxlife) {
                        maxlife = duration;
                    }
                }
                for (var item in this.emission.layer.frameList) {
                    var frame = this.emission.layer.frameList[item];
                    var framerate = this.emission.layer.frames[frame].data.EmissionData.rateOverTime;
                    var rate = framerate.isRandom ? framerate._valueLimitMax : framerate._value;
                    if (rate > maxrate) {
                        maxrate = rate;
                    }
                }
                var burstCount = 0;
                for (var i = 0; i < this.emission.baseddata.bursts.length; i++) {
                    var info = this.emission.baseddata.bursts[i];
                    var Count = info.count.isRandom ? info.count._valueLimitMax : info.count._value;
                    burstCount += Count;
                }
                return Math.floor(maxrate * maxlife + burstCount + 1);
            };
            F14EmissionBatch.prototype.render = function (context, assetmgr, camera, Effqueue) {
                gd3d.math.matrixClone(this.effect.mvpMat, context.matrixModelViewProject);
                this.mat.setQueue(Effqueue);
                this.curIndexCount = 0;
                this.curVertexcount = 0;
                this.curRealVboCount = 0;
                for (var i = 0, len = this.emission.particlelist.length; i < len; i++) {
                    this.emission.particlelist[i].uploadMeshdata();
                }
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
                this.mat.draw(context, this.mesh, this.mesh.submesh[0]);
            };
            F14EmissionBatch.prototype.unRender = function () {
            };
            F14EmissionBatch.prototype.getElementCount = function () {
                return 1;
            };
            F14EmissionBatch.prototype.dispose = function () {
            };
            return F14EmissionBatch;
        }());
        framework.F14EmissionBatch = F14EmissionBatch;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14Particle = (function () {
            function F14Particle(element, data) {
                this.StartPos = new gd3d.math.vector3();
                this.speedDir = new gd3d.math.vector3();
                this.tex_ST = new gd3d.math.vector4();
                this.rotationByEuler = new gd3d.math.quaternion();
                this.rotationByShape = new gd3d.math.quaternion();
                this.startRotation = new gd3d.math.quaternion();
                this.rotAngle = 0;
                this.localMatrix = new gd3d.math.matrix();
                this.localTranslate = new gd3d.math.vector3();
                this.localRotation = new gd3d.math.quaternion();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.color = new gd3d.math.vector3(1, 1, 1);
                this.alpha = 1;
                this.Color = new gd3d.math.color();
                this.life01 = 0;
                this.actived = false;
                this.tempos = gd3d.math.pool.new_vector3();
                this.temcolor = gd3d.math.pool.new_color();
                this.temUv = gd3d.math.pool.new_vector2();
                this.transformVertex = new gd3d.math.matrix();
                this.angleRot = new gd3d.math.quaternion();
                this.worldpos = new gd3d.math.vector3();
                this.tarWorldpos = new gd3d.math.vector3();
                this.worldspeeddir = new gd3d.math.vector3();
                this.lookDir = new gd3d.math.vector3();
                this.temptx = new gd3d.math.vector3();
                this.worldRotation = new gd3d.math.quaternion();
                this.invParWorldRot = new gd3d.math.quaternion();
                this.worldStartPos = new gd3d.math.vector3();
                this.data = data;
                this.element = element;
                this.initByEmissionData(data);
            }
            F14Particle.prototype.initByEmissionData = function (data) {
                this.actived = true;
                this.curLife = 0;
                this.totalLife = data.lifeTime.getValue(true);
                this.simulateInLocalSpace = data.simulateInLocalSpace;
                this.simulationSpeed = data.simulationSpeed.getValue(true);
                this.startScaleRate = data.startScaleRate.getValue(true);
                this.startScale = data.startScale.getValue(true);
                gd3d.math.vec3ScaleByNum(this.startScale, this.startScaleRate, this.startScale);
                this.Starteuler = data.startEuler.getValue(true);
                this.startColor = data.startColor.getValue(true);
                this.startAlpha = data.startAlpha.getValue(true);
                this.colorRate = data.colorRate;
                this.starTex_ST = data.start_tex_st;
                this.movespeed = data.moveSpeed.getValue(true);
                this.sizeNodes = data.sizeNodes;
                this.eulerSpeed = data.angleSpeed.getValue(true);
                this.colorNodes = data.colorNodes;
                this.alphaNodes = data.alphaNodes;
                this.uvType = data.uvType;
                this.getCurTex_ST(data);
                framework.F14EmissionBaseData.getRandomDirAndPosByZEmission(data, this.speedDir, this.StartPos);
                gd3d.math.quatFromEulerAngles(this.Starteuler.x, this.Starteuler.y, this.Starteuler.z, this.rotationByEuler);
                this.rotAngle = 0;
                gd3d.math.vec3Clone(this.startScale, this.localScale);
                gd3d.math.vec3Clone(this.startColor, this.color);
                this.alpha = this.startAlpha;
                gd3d.math.vec4Clone(this.starTex_ST, this.tex_ST);
                if (data.rendermodel == framework.RenderModelEnum.StretchedBillBoard) {
                    this.emissionMatToWorld = this.element.getWorldMatrix();
                    gd3d.math.matrixTransformNormal(this.speedDir, this.emissionMatToWorld, this.worldspeeddir);
                    gd3d.math.vec3Normalize(this.worldspeeddir, this.worldspeeddir);
                    gd3d.math.matrixTransformVector3(this.StartPos, this.emissionMatToWorld, this.worldStartPos);
                }
            };
            F14Particle.prototype.update = function (deltaTime) {
                if (!this.actived)
                    return;
                this.curLife += deltaTime;
                this.life01 = this.curLife / this.totalLife;
                if (this.life01 > 1) {
                    this.actived = false;
                    this.element.deadParticles.push(this);
                    return;
                }
                this.updatePos();
                this.updateSize();
                this.updateEuler();
                this.updateRot();
                this.updateLocalMatrix();
                this.updateColor();
                this.updateUV();
            };
            F14Particle.prototype.uploadMeshdata = function () {
                if (this.actived) {
                    var batch = this.element.layer.batch;
                    for (var i = 0; i < this.element.vertexCount; i++) {
                        gd3d.math.matrixTransformVector3(this.element.posArr[i], this.transformVertex, this.tempos);
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 0] = this.tempos.x;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 1] = this.tempos.y;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 2] = this.tempos.z;
                        if (this.element.colorArr) {
                            gd3d.math.colorMultiply(this.element.colorArr[i], this.Color, this.temcolor);
                        }
                        else {
                            gd3d.math.colorClone(this.Color, this.temcolor);
                        }
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 3] = this.temcolor.r;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 4] = this.temcolor.g;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 5] = this.temcolor.b;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 6] = this.temcolor.a;
                        this.temUv.x = this.element.uvArr[i].x * this.tex_ST.x + this.tex_ST.z;
                        this.temUv.y = this.element.uvArr[i].y * this.tex_ST.y + this.tex_ST.w;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 7] = this.temUv.x;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 8] = this.temUv.y;
                    }
                    for (var i = 0; i < this.element.dataforebo.length; i++) {
                        batch.dataForEbo[i + batch.curIndexCount] = this.element.dataforebo[i] + batch.curVertexcount;
                    }
                    batch.curRealVboCount += this.element.dataforvboLen;
                    batch.curIndexCount += this.element.dataforebo.length;
                    batch.curVertexcount += this.element.vertexCount;
                }
            };
            F14Particle.prototype.updateLocalMatrix = function () {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.data.simulateInLocalSpace) {
                    gd3d.math.matrixMultiply(this.element.localMatrix, this.localMatrix, this.transformVertex);
                }
                else {
                    console.log("还未处理！");
                }
            };
            F14Particle.prototype.updatePos = function () {
                gd3d.math.vec3ScaleByNum(this.speedDir, this.simulationSpeed * this.curLife, this.localTranslate);
                gd3d.math.vec3Add(this.localTranslate, this.StartPos, this.localTranslate);
                if (this.data.enableVelocityOverLifetime) {
                    var moved = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3ScaleByNum(this.movespeed, this.curLife, moved);
                    gd3d.math.vec3Add(this.localTranslate, moved, this.localTranslate);
                    gd3d.math.pool.delete_vector3(moved);
                }
            };
            F14Particle.prototype.updateSize = function () {
                if (this.data.enableSizeOverLifetime && this.sizeNodes.length > 0) {
                    if (this.sizeNodes[0].key > this.life01) {
                        var tar = gd3d.math.numberLerp(1, this.sizeNodes[0].value, this.life01 / this.sizeNodes[0].key);
                        gd3d.math.vec3ScaleByNum(this.startScale, tar, this.localScale);
                        return;
                    }
                    for (var i = 0; i < this.sizeNodes.length - 1; i++) {
                        if (this.sizeNodes[i].key <= this.life01 && this.sizeNodes[i + 1].key >= this.life01) {
                            var tar = gd3d.math.numberLerp(this.sizeNodes[i].value, this.sizeNodes[i + 1].value, (this.life01 - this.sizeNodes[i].key) / (this.sizeNodes[i + 1].key - this.sizeNodes[i].key));
                            gd3d.math.vec3ScaleByNum(this.startScale, tar, this.localScale);
                            break;
                        }
                    }
                }
            };
            F14Particle.prototype.updateEuler = function () {
                if (this.data.enableRotOverLifeTime) {
                    this.rotAngle = this.eulerSpeed * this.curLife;
                }
            };
            F14Particle.prototype.updateRot = function () {
                if (this.data.rendermodel == framework.RenderModelEnum.Mesh) {
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_up, this.rotAngle, this.angleRot);
                    gd3d.math.quatMultiply(this.rotationByEuler, this.angleRot, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.BillBoard) {
                    this.emissionMatToWorld = this.element.getWorldMatrix();
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    this.tarWorldpos = this.element.effect.renderCamera.gameObject.transform.getWorldTranslate();
                    gd3d.math.quatLookat(this.worldpos, this.tarWorldpos, this.worldRotation);
                    this.emissionWorldRotation = this.element.getWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.HorizontalBillBoard) {
                    this.worldRotation.x = -0.5;
                    this.worldRotation.y = 0.5;
                    this.worldRotation.z = 0.5;
                    this.worldRotation.w = 0.5;
                    this.emissionWorldRotation = this.element.getWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.VerticalBillBoard) {
                    this.emissionMatToWorld = this.element.getWorldMatrix();
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    var campos = this.element.effect.renderCamera.gameObject.transform.getWorldTranslate();
                    gd3d.math.vec3Clone(campos, this.tarWorldpos);
                    this.tarWorldpos.y = this.worldpos.y;
                    gd3d.math.quatLookat(this.worldpos, this.tarWorldpos, this.worldRotation);
                    this.emissionWorldRotation = this.element.getWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.StretchedBillBoard) {
                    this.emissionMatToWorld = this.element.getWorldMatrix();
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    var campos = this.element.effect.renderCamera.gameObject.transform.getWorldTranslate();
                    gd3d.math.vec3Subtract(campos, this.worldpos, this.lookDir);
                    gd3d.math.vec3Normalize(this.lookDir, this.lookDir);
                    gd3d.math.vec3Cross(this.worldspeeddir, this.lookDir, this.temptx);
                    gd3d.math.vec3Cross(this.temptx, this.worldspeeddir, this.lookDir);
                    gd3d.math.unitxyzToRotation(this.temptx, this.worldspeeddir, this.lookDir, this.worldRotation);
                    this.emissionWorldRotation = this.element.getWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                }
            };
            F14Particle.prototype.updateColor = function () {
                if (this.data.enableColorOverLifetime) {
                    if (this.colorNodes.length > 0) {
                        if (this.colorNodes[0].key > this.life01) {
                            gd3d.math.vec3SLerp(this.startColor, this.colorNodes[0].value, this.life01 / this.colorNodes[0].key, this.color);
                        }
                        else {
                            for (var i = 0; i < this.colorNodes.length - 1; i++) {
                                if (this.colorNodes[i].key <= this.life01 && this.colorNodes[i + 1].key >= this.life01) {
                                    gd3d.math.vec3SLerp(this.colorNodes[i].value, this.colorNodes[i + 1].value, (this.life01 - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key), this.color);
                                    break;
                                }
                            }
                        }
                    }
                    if (this.alphaNodes.length > 0) {
                        if (this.alphaNodes[0].key > this.life01) {
                            this.alpha = gd3d.math.numberLerp(this.startAlpha, this.alphaNodes[0].value, this.life01 / this.alphaNodes[0].key);
                        }
                        else {
                            for (var i = 0; i < this.alphaNodes.length - 1; i++) {
                                if (this.alphaNodes[i].key <= this.life01 && this.alphaNodes[i + 1].key >= this.life01) {
                                    this.alpha = gd3d.math.numberLerp(this.alphaNodes[i].value, this.alphaNodes[i + 1].value, (this.life01 - this.alphaNodes[i].key) / (this.alphaNodes[i + 1].key - this.alphaNodes[i].key));
                                    break;
                                }
                            }
                        }
                    }
                }
                this.Color.r = this.color.x;
                this.Color.g = this.color.y;
                this.Color.b = this.color.z;
                this.Color.a = this.alpha;
            };
            F14Particle.prototype.updateUV = function () {
                this.getCurTex_ST(this.data);
            };
            F14Particle.prototype.getCurTex_ST = function (data) {
                if (!data.enableTexAnimation)
                    return;
                if (data.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.x = 1;
                    this.tex_ST.y = 1;
                    this.tex_ST.z = data.uSpeed * this.curLife;
                    this.tex_ST.w = data.vSpeed * this.curLife;
                }
                else {
                    var index = Math.floor(this.life01 * data.count);
                    gd3d.math.spriteAnimation(data.row, data.column, index, this.tex_ST);
                }
            };
            return F14Particle;
        }());
        framework.F14Particle = F14Particle;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14RefElementBatch = (function () {
            function F14RefElementBatch(effect, element) {
                this.type = framework.F14TypeEnum.RefType;
                this.effect = effect;
                this.element = element;
            }
            F14RefElementBatch.prototype.unRender = function () {
            };
            F14RefElementBatch.prototype.getElementCount = function () {
                return this.element.RefEffect.getElementCount();
            };
            F14RefElementBatch.prototype.render = function (context, assetmgr, camera, Effqueue) {
                if (this.element.drawActive) {
                    this.element.RefEffect.render(context, assetmgr, camera, Effqueue);
                }
                else {
                }
            };
            F14RefElementBatch.prototype.dispose = function () {
                this.element.RefEffect.dispose();
            };
            return F14RefElementBatch;
        }());
        framework.F14RefElementBatch = F14RefElementBatch;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14RefBaseData = (function () {
            function F14RefBaseData() {
                this.beLoop = false;
                this.localPos = new gd3d.math.vector3();
                this.localEuler = new gd3d.math.vector3();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
            }
            F14RefBaseData.prototype.parse = function (json, assetmgr, assetbundle) {
                this.beLoop = json.beLoop;
                this.refdataName = json.F14EffectData;
                gd3d.math.vec3FormJson(json.localPos, this.localPos);
                gd3d.math.vec3FormJson(json.localEuler, this.localEuler);
                gd3d.math.vec3FormJson(json.localScale, this.localScale);
            };
            return F14RefBaseData;
        }());
        framework.F14RefBaseData = F14RefBaseData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14RefElement = (function () {
            function F14RefElement(effect, layer) {
                this.type = framework.F14TypeEnum.RefType;
                this.effect = effect;
                this.baseddata = layer.data.elementdata;
                this.layer = layer;
                this.refreshStartEndFrame();
                this.RefEffect = new framework.f14EffectSystem();
                this.RefEffect._root = new framework.transform();
                this.RefEffect.gameObject = this.RefEffect._root.gameObject;
                var data = layer.data.elementdata;
                gd3d.math.vec3Clone(data.localPos, this.RefEffect._root.localTranslate);
                gd3d.math.vec3Clone(data.localScale, this.RefEffect._root.localScale);
                gd3d.math.quatFromEulerAngles(data.localEuler.x, data.localEuler.y, data.localEuler.z, this.RefEffect._root.localRotate);
                this.RefEffect._root.markDirty();
                this.RefEffect.beref = true;
                this.baseddata.refData = framework.sceneMgr.app.getAssetMgr().getAssetByName(this.baseddata.refdataName).data;
                this.RefEffect.setData(this.baseddata.refData);
            }
            F14RefElement.prototype.reset = function () {
                this.RefEffect.reset();
            };
            F14RefElement.prototype.refreshStartEndFrame = function () {
                if (this.layer.frameList.length == 0) {
                    this.startFrame = 0;
                }
                else {
                    this.startFrame = this.layer.frameList[0];
                }
                if (this.layer.frameList.length > 1) {
                    this.endFrame = this.layer.frameList[this.layer.frameList.length - 1];
                }
                else {
                    this.endFrame = this.effect.data.lifeTime;
                }
            };
            F14RefElement.prototype.update = function (deltaTime, frame, fps) {
                if (this.RefEffect._root.parent == null) {
                    this.RefEffect._root.parent = this.effect.gameObject.transform;
                    this.RefEffect._root.markDirty();
                    this.RefEffect._root.updateWorldTran();
                }
                if (this.layer.frameList.length == 0) {
                    this.drawActive = false;
                    return;
                }
                if (this.effect.data.beloop) {
                    frame = this.effect.restartFrame;
                }
                if (frame < this.startFrame || frame > this.endFrame) {
                    this.drawActive = false;
                    this.RefEffect["playState"] = framework.PlayStateEnum.beReady;
                    return;
                }
                else {
                    this.drawActive = true;
                    this.RefEffect["playState"] = framework.PlayStateEnum.play;
                }
                this.RefEffect.update(deltaTime);
            };
            F14RefElement.prototype.OnEndOnceLoop = function () {
            };
            return F14RefElement;
        }());
        framework.F14RefElement = F14RefElement;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14SingleMesh = (function () {
            function F14SingleMesh(effect, layer) {
                this.position = new gd3d.math.vector3();
                this.scale = new gd3d.math.vector3();
                this.euler = new gd3d.math.vector3();
                this.color = new gd3d.math.color();
                this.tex_ST = new gd3d.math.vector4();
                this.localRotate = new gd3d.math.quaternion();
                this.targetMat = new gd3d.math.matrix();
                this.tempos = gd3d.math.pool.new_vector3();
                this.temColor = gd3d.math.pool.new_color();
                this.temUv = gd3d.math.pool.new_vector2();
                this.eulerRot = new gd3d.math.quaternion();
                this.worldpos = new gd3d.math.vector3();
                this.worldRot = new gd3d.math.quaternion();
                this.inverseRot = new gd3d.math.quaternion();
                this.lookDir = new gd3d.math.vector3();
                this.worldDirx = new gd3d.math.vector3();
                this.worldDiry = new gd3d.math.vector3();
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.effect = effect;
                this.layer = layer;
                this.baseddata = layer.data.elementdata;
                gd3d.math.vec3Clone(this.baseddata.position, this.position);
                gd3d.math.vec3Clone(this.baseddata.scale, this.scale);
                gd3d.math.vec3Clone(this.baseddata.euler, this.euler);
                gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.localRotate);
                gd3d.math.colorClone(this.baseddata.color, this.color);
                gd3d.math.vec4Clone(this.baseddata.tex_ST, this.tex_ST);
                this.refreshStartEndFrame();
                this.posArr = this.baseddata.mesh.data.pos;
                this.colorArr = this.baseddata.mesh.data.color;
                this.uvArr = this.baseddata.mesh.data.uv;
                this.vertexCount = this.posArr.length;
                this.dataforvbo = this.baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                this.dataforebo = this.baseddata.mesh.data.genIndexDataArray();
            }
            F14SingleMesh.prototype.refreshStartEndFrame = function () {
                if (this.layer.frameList.length == 0) {
                    this.startFrame = 0;
                }
                else {
                    this.startFrame = this.layer.frameList[0];
                }
                if (this.layer.frameList.length > 1) {
                    this.endFrame = this.layer.frameList[this.layer.frameList.length - 1];
                }
                else {
                    this.endFrame = this.effect.data.lifeTime;
                }
            };
            F14SingleMesh.prototype.update = function (deltaTime, frame, fps) {
                if (this.layer.frameList.length == 0) {
                    this.drawActive = false;
                    return;
                }
                if (this.effect.data.beloop) {
                    switch (this.baseddata.loopenum) {
                        case framework.LoopEnum.Restart:
                            frame = this.effect.restartFrame;
                            break;
                        case framework.LoopEnum.TimeContinue:
                            break;
                    }
                }
                if (frame < this.startFrame || frame > this.endFrame) {
                    this.drawActive = false;
                    return;
                }
                else {
                    this.drawActive = true;
                }
                for (var item in this.layer.Attlines) {
                    var att = this.layer.Attlines[item];
                    att.getValue(frame, this.baseddata, this[item]);
                }
                if (this.baseddata.enableTexAnimation) {
                    this.refreshCurTex_ST(frame, deltaTime, fps);
                }
                this.updateRotByBillboard();
                this.refreshTargetMatrix();
            };
            F14SingleMesh.prototype.OnEndOnceLoop = function () {
                this.reset();
            };
            F14SingleMesh.prototype.refreshTargetMatrix = function () {
                gd3d.math.matrixMakeTransformRTS(this.position, this.scale, this.localRotate, this.targetMat);
            };
            F14SingleMesh.prototype.uploadMeshdata = function () {
                var batch = this.layer.batch;
                for (var i = 0; i < this.vertexCount; i++) {
                    gd3d.math.matrixTransformVector3(this.posArr[i], this.targetMat, this.tempos);
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 0] = this.tempos.x;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 1] = this.tempos.y;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 2] = this.tempos.z;
                    if (this.colorArr) {
                        gd3d.math.colorMultiply(this.colorArr[i], this.color, this.temColor);
                    }
                    else {
                        gd3d.math.colorClone(this.color, this.temColor);
                    }
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 3] = this.temColor.r;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 4] = this.temColor.g;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 5] = this.temColor.b;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 6] = this.temColor.a;
                    this.temUv.x = this.uvArr[i].x * this.tex_ST.x + this.tex_ST.z;
                    this.temUv.y = this.uvArr[i].y * this.tex_ST.y + this.tex_ST.w;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 7] = this.temUv.x;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 8] = this.temUv.y;
                }
                for (var i = 0; i < this.dataforebo.length; i++) {
                    batch.dataForEbo[i + batch.curIndexCount] = this.dataforebo[i] + batch.curVertexcount;
                }
                batch.curRealVboCount += this.dataforvbo.length;
                batch.curIndexCount += this.dataforebo.length;
                batch.curVertexcount += this.vertexCount;
            };
            F14SingleMesh.prototype.refreshCurTex_ST = function (curframe, detalTime, fps) {
                if (this.baseddata.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.z += this.baseddata.uSpeed * detalTime;
                    this.tex_ST.w += this.baseddata.vSpeed * detalTime;
                }
                else if (this.baseddata.uvType == framework.UVTypeEnum.UVSprite) {
                    var lerp = (curframe - this.startFrame) / (this.endFrame - this.startFrame);
                    var spritindex = Math.floor(lerp * this.baseddata.count);
                    gd3d.math.spriteAnimation(this.baseddata.row, this.baseddata.column, spritindex, this.tex_ST);
                }
            };
            F14SingleMesh.prototype.updateRotByBillboard = function () {
                if (this.baseddata.beBillboard) {
                    if (this.baseddata.bindAxis == framework.BindAxis.NONE) {
                        var mat = this.effect.root.getWorldMatrix();
                        gd3d.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        var targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        gd3d.math.quatLookat(this.worldpos, targetpos, this.worldRot);
                        var parentRot = this.effect.root.getWorldRotate();
                        gd3d.math.quatInverse(parentRot, this.inverseRot);
                        gd3d.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                        gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.euler.z, this.eulerRot);
                        gd3d.math.quatMultiply(this.localRotate, this.eulerRot, this.localRotate);
                    }
                    else if (this.baseddata.bindAxis == framework.BindAxis.X) {
                        var mat = this.effect.root.getWorldMatrix();
                        gd3d.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        var targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        gd3d.math.vec3Subtract(targetpos, this.worldpos, this.lookDir);
                        gd3d.math.vec3Normalize(this.lookDir, this.lookDir);
                        gd3d.math.matrixMakeTransformRTS(this.baseddata.position, this.baseddata.scale, this.localRotate, this.targetMat);
                        gd3d.math.matrixMultiply(mat, this.targetMat, this.targetMat);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_right, this.targetMat, this.worldDirx);
                        gd3d.math.vec3Normalize(this.worldDirx, this.worldDirx);
                        gd3d.math.vec3Cross(this.lookDir, this.worldDirx, this.worldDiry);
                        gd3d.math.vec3Cross(this.worldDirx, this.worldDiry, this.lookDir);
                        gd3d.math.unitxyzToRotation(this.worldDirx, this.worldDiry, this.lookDir, this.worldRot);
                        var parentRot = this.effect.root.getWorldRotate();
                        gd3d.math.quatInverse(parentRot, this.inverseRot);
                        gd3d.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                    }
                    else {
                        var mat = this.effect.root.getWorldMatrix();
                        gd3d.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        var targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        gd3d.math.vec3Subtract(targetpos, this.worldpos, this.lookDir);
                        gd3d.math.vec3Normalize(this.lookDir, this.lookDir);
                        gd3d.math.matrixMakeTransformRTS(this.position, this.scale, this.localRotate, this.targetMat);
                        gd3d.math.matrixMultiply(mat, this.targetMat, this.targetMat);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_up, this.targetMat, this.worldDiry);
                        gd3d.math.vec3Normalize(this.worldDiry, this.worldDiry);
                        gd3d.math.vec3Cross(this.worldDiry, this.lookDir, this.worldDirx);
                        gd3d.math.vec3Cross(this.worldDirx, this.worldDiry, this.lookDir);
                        gd3d.math.unitxyzToRotation(this.worldDirx, this.worldDiry, this.lookDir, this.worldRot);
                        var parentRot = this.effect.root.getWorldRotate();
                        gd3d.math.quatInverse(parentRot, this.inverseRot);
                        gd3d.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                    }
                }
                else {
                    gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.localRotate);
                }
            };
            F14SingleMesh.prototype.reset = function () {
                gd3d.math.vec3Clone(this.baseddata.position, this.position);
                gd3d.math.vec3Clone(this.baseddata.scale, this.scale);
                gd3d.math.vec3Clone(this.baseddata.euler, this.euler);
                gd3d.math.colorClone(this.baseddata.color, this.color);
                gd3d.math.vec4Clone(this.baseddata.tex_ST, this.tex_ST);
            };
            return F14SingleMesh;
        }());
        framework.F14SingleMesh = F14SingleMesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var F14SingleMeshBath = (function () {
            function F14SingleMeshBath(mat, effect) {
                this.meshlist = [];
                this.activemeshlist = [];
                this.mesh = new framework.mesh();
                this.indices = [];
                this.vertices = [];
                this.colors = [];
                this.uv = [];
                this.curRealVboCount = 0;
                this.curVertexcount = 0;
                this.curIndexCount = 0;
                this.vertexLength = 0;
                this.noBatch = false;
                this.mat = new gd3d.math.matrix();
                this.defST = new gd3d.math.vector4(1, 1, 0, 0);
                this.temptColorv4 = new gd3d.math.vector4();
                this.uploadData = false;
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.effect = effect;
                this.ElementMat = mat;
            }
            F14SingleMeshBath.prototype.OnEndCollectElement = function () {
                this.vertexLength = gd3d.render.meshData.calcByteSize(this.effect.VF) / 4;
                if (this.meshlist.length == 1) {
                    this.noBatch = true;
                    this.mesh.glMesh = new gd3d.render.glMesh();
                    this.dataForVbo = this.meshlist[0].baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                    this.dataForEbo = this.meshlist[0].baseddata.mesh.data.genIndexDataArray();
                    this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, this.meshlist[0].baseddata.mesh.data.pos.length, gd3d.render.MeshTypeEnum.Static);
                    this.mesh.glMesh.uploadVertexData(this.effect.webgl, this.dataForVbo);
                    this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                    this.mesh.glMesh.uploadIndexData(this.effect.webgl, 0, this.dataForEbo);
                    this.mesh.submesh = [];
                    {
                        var sm = new framework.subMeshInfo();
                        sm.matIndex = 0;
                        sm.useVertexIndex = 0;
                        sm.start = 0;
                        sm.size = this.dataForEbo.length;
                        sm.line = false;
                        this.mesh.submesh.push(sm);
                    }
                    return;
                }
                var totalVertexCount = 0;
                var toltalIndexCount = 0;
                for (var i = 0, len = this.meshlist.length; i < len; i++) {
                    totalVertexCount += this.meshlist[i].baseddata.mesh.data.pos.length;
                    toltalIndexCount += this.meshlist[i].baseddata.mesh.data.trisindex.length;
                }
                this.dataForVbo = new Float32Array(totalVertexCount * this.vertexLength);
                this.dataForEbo = new Uint16Array(toltalIndexCount);
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, totalVertexCount, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            };
            F14SingleMeshBath.prototype.reInit = function (mat, effect) {
                this.effect = effect;
                this.ElementMat = mat;
                this.meshlist.length = 0;
            };
            F14SingleMeshBath.prototype.addElement = function (mesh, insert) {
                if (insert === void 0) { insert = false; }
                this.meshlist.push(mesh);
                mesh.layer.batch = this;
            };
            F14SingleMeshBath.prototype.canBatch = function (mesh) {
                return this.ElementMat == mesh.baseddata.material;
            };
            F14SingleMeshBath.prototype.getElementCount = function () {
                return this.meshlist.length;
            };
            F14SingleMeshBath.prototype.render = function (context, assetmgr, camera, Effqueue) {
                if (this.meshlist.length == 0)
                    return;
                this.activemeshlist.length = 0;
                for (var i = 0, len = this.meshlist.length; i < len; i++) {
                    if (this.meshlist[i].drawActive) {
                        this.activemeshlist.push(this.meshlist[i]);
                    }
                }
                if (this.activemeshlist.length < 1)
                    return;
                this.ElementMat.setQueue(Effqueue);
                if (this.noBatch) {
                    gd3d.math.matrixMultiply(this.effect.mvpMat, this.activemeshlist[0].targetMat, context.matrixModelViewProject);
                    if (!this.uploadData) {
                        this.dataForVbo = this.activemeshlist[0].baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                        this.dataForEbo = this.activemeshlist[0].baseddata.mesh.data.genIndexDataArray();
                        this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                        this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                        this.mesh.submesh[0].size = this.dataForEbo.length;
                    }
                    this.temptColorv4.x = this.activemeshlist[0].color.r;
                    this.temptColorv4.y = this.activemeshlist[0].color.g;
                    this.temptColorv4.z = this.activemeshlist[0].color.b;
                    this.temptColorv4.w = this.activemeshlist[0].color.a;
                    this.ElementMat.setVector4("_Main_Color", this.temptColorv4);
                    this.ElementMat.setVector4("_Main_Tex_ST", this.activemeshlist[0].tex_ST);
                    this.ElementMat.draw(context, this.mesh, this.mesh.submesh[0]);
                }
                else {
                    gd3d.math.matrixClone(this.effect.mvpMat, context.matrixModelViewProject);
                    this.curIndexCount = 0;
                    this.curVertexcount = 0;
                    this.curRealVboCount = 0;
                    for (var i = 0, len = this.activemeshlist.length; i < len; i++) {
                        this.activemeshlist[i].uploadMeshdata();
                    }
                    this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                    this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                    this.mesh.submesh[0].size = this.curIndexCount;
                    this.ElementMat.setVector4("_Main_Color", new gd3d.math.vector4(1, 1, 1, 1));
                    this.ElementMat.setVector4("_Main_Tex_ST", new gd3d.math.vector4(1, 1, 0, 0));
                    this.ElementMat.draw(context, this.mesh, this.mesh.submesh[0]);
                }
            };
            F14SingleMeshBath.prototype.unRender = function () {
            };
            F14SingleMeshBath.prototype.dispose = function () {
            };
            return F14SingleMeshBath;
        }());
        framework.F14SingleMeshBath = F14SingleMeshBath;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var LoopEnum;
        (function (LoopEnum) {
            LoopEnum[LoopEnum["Restart"] = 0] = "Restart";
            LoopEnum[LoopEnum["TimeContinue"] = 1] = "TimeContinue";
        })(LoopEnum = framework.LoopEnum || (framework.LoopEnum = {}));
        var BindAxis;
        (function (BindAxis) {
            BindAxis[BindAxis["X"] = 0] = "X";
            BindAxis[BindAxis["Y"] = 1] = "Y";
            BindAxis[BindAxis["NONE"] = 2] = "NONE";
        })(BindAxis = framework.BindAxis || (framework.BindAxis = {}));
        var F14SingleMeshBaseData = (function () {
            function F14SingleMeshBaseData(firstFrame) {
                this.loopenum = LoopEnum.Restart;
                this.position = new gd3d.math.vector3();
                this.scale = new gd3d.math.vector3(1, 1, 1);
                this.euler = new gd3d.math.vector3();
                this.color = new gd3d.math.color(1, 1, 1, 1);
                this.tex_ST = new gd3d.math.vector4();
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
                this.beBillboard = false;
                this.bindAxis = BindAxis.NONE;
                this.firtstFrame = 0;
                this.firtstFrame = firstFrame;
                this.mesh = gd3d.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
                this.material = gd3d.framework.sceneMgr.app.getAssetMgr().getDefParticleMat();
            }
            F14SingleMeshBaseData.prototype.parse = function (json, assetmgr, assetbundle) {
                switch (json.loopenum) {
                    case "Restart":
                        this.loopenum = LoopEnum.Restart;
                        break;
                    case "TimeContinue":
                        this.loopenum = LoopEnum.TimeContinue;
                        break;
                }
                this.mesh = assetmgr.getAssetByName(json.mesh, assetbundle);
                this.material = assetmgr.getAssetByName(json.material, assetbundle);
                gd3d.math.vec3FormJson(json.position, this.position);
                gd3d.math.vec3FormJson(json.scale, this.scale);
                gd3d.math.vec3FormJson(json.euler, this.euler);
                gd3d.math.colorFormJson(json.color, this.color);
                gd3d.math.vec4FormJson(json.tex_ST, this.tex_ST);
                this.enableTexAnimation = json.enableTexAnimation;
                if (this.enableTexAnimation) {
                    switch (json.uvType) {
                        case "UVRoll":
                            this.uvType = framework.UVTypeEnum.UVRoll;
                            this.uSpeed = json.uSpeed;
                            this.vSpeed = json.vSpeed;
                            break;
                        case "UVSprite":
                            this.uvType = framework.UVTypeEnum.UVSprite;
                            this.row = json.row;
                            this.column = json.column;
                            this.count = json.count;
                            break;
                        case "NONE":
                            this.uvType = framework.UVTypeEnum.NONE;
                            break;
                    }
                }
                if (json.beBillboard != null) {
                    this.beBillboard = json.beBillboard;
                    switch (json.bindAxis) {
                        case "NONE":
                            this.bindAxis = BindAxis.NONE;
                            break;
                        case "X":
                            this.bindAxis = BindAxis.X;
                            break;
                        case "Y":
                            this.bindAxis = BindAxis.Y;
                            break;
                    }
                }
            };
            return F14SingleMeshBaseData;
        }());
        framework.F14SingleMeshBaseData = F14SingleMeshBaseData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var pointinfo = (function () {
            function pointinfo() {
                this.touch = false;
            }
            return pointinfo;
        }());
        framework.pointinfo = pointinfo;
        var inputMgr = (function () {
            function inputMgr(app) {
                var _this = this;
                this.inputlast = null;
                this.point = new pointinfo();
                this.touches = {};
                this.keyboardMap = {};
                this.rMtr_90 = new gd3d.math.matrix3x2();
                this.rMtr_n90 = new gd3d.math.matrix3x2();
                this.app = app;
                gd3d.math.matrix3x2MakeRotate(Math.PI * 90 / 180, this.rMtr_90);
                gd3d.math.matrix3x2MakeRotate(Math.PI * -90 / 180, this.rMtr_n90);
                app.webgl.canvas.addEventListener("touchstart", function (ev) {
                    _this.CalcuPoint(ev.touches[0].clientX, ev.touches[0].clientY);
                    _this.point.touch = true;
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (_this.touches[id] == null) {
                            _this.touches[id] = new pointinfo();
                            _this.touches[id].id = id;
                        }
                        _this.touches[id].touch = true;
                        _this.touches[id].x = touch.clientX;
                        _this.touches[id].y = touch.clientY;
                    }
                });
                app.webgl.canvas.addEventListener("touchmove", function (ev) {
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (_this.touches[id] == null) {
                            _this.touches[id] = new pointinfo();
                            _this.touches[id].id = id;
                        }
                        _this.touches[id].touch = true;
                        _this.touches[id].x = touch.clientX;
                        _this.touches[id].y = touch.clientY;
                    }
                    var count = 0;
                    var x = 0;
                    var y = 0;
                    for (var key in _this.touches) {
                        if (_this.touches[key].touch == true) {
                            x += _this.touches[key].x;
                            y += _this.touches[key].y;
                            count++;
                        }
                    }
                    _this.CalcuPoint(x / count, y / count);
                });
                app.webgl.canvas.addEventListener("touchend", function (ev) {
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (_this.touches[id] == null) {
                            _this.touches[id] = new pointinfo();
                            _this.touches[id].id = id;
                        }
                        _this.touches[id].touch = false;
                    }
                    for (var key in _this.touches) {
                        if (_this.touches[key].touch == true)
                            return;
                    }
                    _this.point.touch = false;
                });
                app.webgl.canvas.addEventListener("touchcancel", function (ev) {
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (_this.touches[id] == null) {
                            _this.touches[id] = new pointinfo();
                            _this.touches[id].id = id;
                        }
                        _this.touches[id].touch = false;
                    }
                    for (var key in _this.touches) {
                        if (_this.touches[key].touch == true)
                            return;
                    }
                    _this.point.touch = false;
                });
                app.webgl.canvas.addEventListener("mousedown", function (ev) {
                    _this.CalcuPoint(ev.clientX, ev.clientY);
                    _this.point.touch = true;
                });
                app.webgl.canvas.addEventListener("mouseup", function (ev) {
                    _this.point.touch = false;
                });
                app.webgl.canvas.addEventListener("mousemove", function (ev) {
                    _this.CalcuPoint(ev.clientX, ev.clientY);
                });
                app.webgl.canvas.addEventListener("keydown", function (ev) {
                    _this.keyboardMap[ev.keyCode] = true;
                }, false);
                app.webgl.canvas.addEventListener("keyup", function (ev) {
                    _this.keyboardMap[ev.keyCode] = false;
                }, false);
                app.webgl.canvas.addEventListener("blur", function (ev) {
                    _this.point.touch = false;
                }, false);
            }
            inputMgr.prototype.CalcuPoint = function (clientX, clientY) {
                if (!this.app || isNaN(clientX) || isNaN(clientY))
                    return;
                if (!this.tempV2_0)
                    this.tempV2_0 = gd3d.math.pool.new_vector2();
                if (!this.tempV2_1)
                    this.tempV2_1 = gd3d.math.pool.new_vector2();
                this.tempV2_0.x = clientX / this.app.scale;
                this.tempV2_0.y = clientY / this.app.scale;
                gd3d.math.vec2Clone(this.tempV2_0, this.tempV2_1);
                if (this.app.shouldRotate) {
                    switch (this.app.orientation) {
                        case gd3d.framework.OrientationMode.PORTRAIT:
                            gd3d.math.matrix3x2TransformVector2(this.rMtr_90, this.tempV2_0, this.tempV2_1);
                            this.point.x = this.tempV2_1.x + this.app.webgl.canvas.width;
                            this.point.y = this.tempV2_1.y;
                            break;
                        case gd3d.framework.OrientationMode.LANDSCAPE:
                            gd3d.math.matrix3x2TransformVector2(this.rMtr_n90, this.tempV2_0, this.tempV2_1);
                            this.point.x = this.tempV2_1.x;
                            this.point.y = this.tempV2_1.y + this.app.webgl.canvas.height;
                            break;
                        case gd3d.framework.OrientationMode.LANDSCAPE_FLIPPED:
                            gd3d.math.matrix3x2TransformVector2(this.rMtr_90, this.tempV2_0, this.tempV2_1);
                            this.point.x = this.tempV2_1.x + this.app.webgl.canvas.width;
                            this.point.y = this.tempV2_1.y;
                            break;
                    }
                }
                else {
                    this.point.x = this.tempV2_0.x;
                    this.point.y = this.tempV2_0.y;
                }
            };
            return inputMgr;
        }());
        framework.inputMgr = inputMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var binBuffer = (function () {
            function binBuffer(bufSize) {
                if (bufSize === void 0) { bufSize = 65536; }
                if (bufSize < 1024)
                    bufSize = 1024;
                if (bufSize > 1024 * 256)
                    bufSize = 1024 * 256;
                this._bufSize = bufSize;
                this._buf = [];
                this._seekWritePos = 0;
                this._seekWriteIndex = 0;
                this._buf[0] = new Uint8Array(bufSize);
                this._seekReadPos = 0;
            }
            binBuffer.prototype.getLength = function () {
                return (this._seekWriteIndex * this._bufSize + this._seekWritePos) - (this._seekReadPos);
            };
            binBuffer.prototype.getBufLength = function () {
                return this._buf.length * this._bufSize;
            };
            binBuffer.prototype.getBytesAvailable = function () {
                return this.getLength();
            };
            binBuffer.prototype.reset = function () {
                this._buf = [];
                this._seekWritePos = 0;
                this._seekWriteIndex = 0;
                this._buf[0] = new Uint8Array(this._bufSize);
                this._seekReadPos = 0;
            };
            binBuffer.prototype.dispose = function () {
                this._buf.splice(0);
                this._seekWritePos = 0;
                this._seekWriteIndex = 0;
                this._seekReadPos = 0;
            };
            binBuffer.prototype.read = function (target, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = offset; i < offset + length; i++) {
                    if (this._seekReadPos >= this._seekWritePos && 0 == this._seekWriteIndex) {
                        this.reset();
                        throw new Error("no data to read.");
                    }
                    target[i] = this._buf[0][this._seekReadPos];
                    this._seekReadPos++;
                    if (this._seekReadPos >= this._bufSize) {
                        this._seekWriteIndex--;
                        this._seekReadPos = 0;
                        var freebuf = this._buf.shift();
                        this._buf.push(freebuf);
                    }
                }
            };
            binBuffer.prototype.write = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                for (var i = offset; i < offset + length; i++) {
                    this._buf[this._seekWriteIndex][this._seekWritePos] = array[i];
                    this._seekWritePos++;
                    if (this._seekWritePos >= this._bufSize) {
                        this._seekWriteIndex++;
                        this._seekWritePos = 0;
                        if (this._buf.length <= this._seekWriteIndex) {
                            this._buf.push(new Uint8Array(this._bufSize));
                        }
                    }
                }
            };
            binBuffer.prototype.getBuffer = function () {
                var length = 0;
                if (this._seekWriteIndex > 0) {
                    length = this._bufSize * (this._seekWriteIndex - 1) + this._seekWritePos;
                }
                else {
                    length = this._seekWritePos;
                }
                var array = new Uint8Array(length);
                for (var i = 0; i < this._seekWriteIndex - 1; i++) {
                    array.set(this._buf[i], i * this._bufSize);
                }
                for (var i = 0; i < this._seekWritePos; i++) {
                    array[length - this._seekWritePos + i] = this._buf[this._seekWriteIndex][i];
                }
                return array;
            };
            binBuffer.prototype.getUint8Array = function () {
                return new Uint8Array(this.getBuffer());
            };
            return binBuffer;
        }());
        io.binBuffer = binBuffer;
        var converter = (function () {
            function converter() {
            }
            converter.getApplyFun = function (value) {
                return Array.prototype.concat.apply([], value);
            };
            converter.ULongToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                converter.dataView.setUint32(0, uint1, true);
                converter.dataView.setUint32(4, uint2, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = new Uint8Array(converter.dataView.buffer);
                }
                else {
                    for (var i = 0; i < 8; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.LongToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                converter.dataView.setInt32(0, uint1, true);
                converter.dataView.setInt32(4, uint2, true);
                var _array = new Int8Array(converter.dataView.buffer);
                if (target == null) {
                    target = new Int8Array(converter.dataView.buffer);
                }
                else {
                    for (var i = 0; i < 8; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Float64ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setFloat64(0, value, false);
                if (target == null) {
                    target = new Uint8Array(converter.dataView.buffer);
                }
                else {
                    for (var i = 0; i < 8; i++) {
                        target[offset + i] = converter.dataView.buffer[i];
                    }
                }
                return target;
            };
            converter.Float32ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setFloat32(0, value, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 4);
                }
                else {
                    for (var i = 0; i < 4; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Int32ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt32(0, value, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 4);
                }
                else {
                    for (var i = 0; i < 4; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Int16ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt16(0, value, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 2);
                }
                else {
                    for (var i = 0; i < 2; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Int8ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt8(0, value);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 1);
                }
                else {
                    for (var i = 0; i < 1; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Uint32toArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt32(0, value, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 4);
                }
                else {
                    for (var i = 0; i < 4; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Uint16ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setUint16(0, value, true);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 2);
                }
                else {
                    for (var i = 0; i < 2; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.Uint8ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setUint8(0, value);
                var _array = new Uint8Array(converter.dataView.buffer);
                if (target == null) {
                    target = converter.getApplyFun(_array).slice(0, 1);
                }
                else {
                    for (var i = 0; i < 1; i++) {
                        target[offset + i] = _array[i];
                    }
                }
                return target;
            };
            converter.StringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return new Uint8Array(bstr);
            };
            converter.ArrayToLong = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    converter.dataView.setInt8(i, buf[offset + i]);
                }
                var n1 = converter.dataView.getInt32(0, true);
                for (var i = 4; i < 8; i++) {
                    converter.dataView.setInt8(i, buf[offset + i]);
                }
                var n2 = converter.dataView.getInt32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            };
            converter.ArrayToULong = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                var n1 = converter.dataView.getUint32(0, true);
                for (var i = 4; i < 8; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                var n2 = converter.dataView.getUint32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            };
            converter.ArrayToFloat64 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 8; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getFloat64(0, true);
            };
            converter.ArrayToFloat32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getFloat32(0, true);
            };
            converter.ArrayToInt32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getInt32(0, true);
            };
            converter.ArrayToInt16 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 2; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getInt16(0, true);
            };
            converter.ArrayToInt8 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 1; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getInt8(0);
            };
            converter.ArraytoUint32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 4; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getUint32(0, true);
            };
            converter.ArrayToUint16 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 2; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getUint16(0, true);
            };
            converter.ArrayToUint8 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                for (var i = 0; i < 1; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getUint8(0);
            };
            converter.ArrayToString = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                var ret = [];
                for (var i = 0; i < buf.length; i++) {
                    var cc = buf[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = buf[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(buf[i]));
                    }
                }
                return ret.join('');
            };
            converter.dataView = new DataView(new ArrayBuffer(8), 0, 8);
            return converter;
        }());
        io.converter = converter;
        var binTool = (function (_super) {
            __extends(binTool, _super);
            function binTool() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            binTool.prototype.readSingle = function () {
                var array = new Uint8Array(4);
                this.read(array);
                return converter.ArrayToFloat32(array);
            };
            binTool.prototype.readLong = function () {
                var array = new Uint8Array(8);
                this.read(array);
                return converter.ArrayToLong(array);
            };
            binTool.prototype.readULong = function () {
                var array = new Uint8Array(8);
                this.read(array);
                return converter.ArrayToULong(array);
            };
            binTool.prototype.readDouble = function () {
                var array = new Uint8Array(8);
                this.read(array);
                return converter.ArrayToFloat64(array);
            };
            binTool.prototype.readInt8 = function () {
                var array = new Uint8Array(1);
                this.read(array);
                return converter.ArrayToInt8(array);
            };
            binTool.prototype.readUInt8 = function () {
                var array = new Uint8Array(1);
                this.read(array);
                return converter.ArrayToUint8(array);
            };
            binTool.prototype.readInt16 = function () {
                var array = new Uint8Array(2);
                this.read(array);
                return converter.ArrayToInt16(array);
            };
            binTool.prototype.readUInt16 = function () {
                var array = new Uint8Array(2);
                this.read(array);
                return converter.ArrayToUint16(array);
            };
            binTool.prototype.readInt32 = function () {
                var array = new Uint8Array(4);
                this.read(array);
                return converter.ArrayToInt32(array);
            };
            binTool.prototype.readUInt32 = function () {
                var array = new Uint8Array(4);
                this.read(array);
                return converter.ArraytoUint32(array);
            };
            binTool.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            binTool.prototype.readByte = function () {
                return this.readUInt8();
            };
            binTool.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            binTool.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            binTool.prototype.readFloat = function () {
                return this.readSingle();
            };
            binTool.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            binTool.prototype.readShort = function () {
                return this.readInt16();
            };
            binTool.prototype.readInt = function () {
                return this.readInt32();
            };
            binTool.prototype.readBytes = function (length) {
                var array = new Uint8Array(length);
                this.read(array);
                return array;
            };
            binTool.prototype.readStringUtf8 = function () {
                var length = this.readInt8();
                var array = new Uint8Array(length);
                this.read(array);
                return converter.ArrayToString(array);
            };
            binTool.prototype.readStringUtf8FixLength = function (length) {
                var array = new Uint8Array(length);
                this.read(array);
                return converter.ArrayToString(array);
            };
            binTool.prototype.readUTFBytes = function (length) {
                var array = new Uint8Array(length);
                this.read(array);
                return converter.ArrayToString(array);
            };
            binTool.prototype.readStringAnsi = function () {
                var slen = this.readUInt8();
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this.readByte());
                }
                return bs;
            };
            Object.defineProperty(binTool.prototype, "length", {
                get: function () {
                    return this.getLength();
                },
                enumerable: true,
                configurable: true
            });
            binTool.prototype.writeInt8 = function (num) {
                this.write(converter.Int8ToArray(num));
            };
            binTool.prototype.writeUInt8 = function (num) {
                this.write(converter.Uint8ToArray(num));
            };
            binTool.prototype.writeInt16 = function (num) {
                this.write(converter.Int16ToArray(num));
            };
            binTool.prototype.writeUInt16 = function (num) {
                this.write(converter.Uint16ToArray(num));
            };
            binTool.prototype.writeInt32 = function (num) {
                this.write(converter.Int32ToArray(num));
            };
            binTool.prototype.writeUInt32 = function (num) {
                this.write(converter.Uint32toArray(num));
            };
            binTool.prototype.writeSingle = function (num) {
                this.write(converter.Float32ToArray(num));
            };
            binTool.prototype.writeLong = function (num) {
                this.write(converter.LongToArray(num));
            };
            binTool.prototype.writeULong = function (num) {
                this.write(converter.ULongToArray(num));
            };
            binTool.prototype.writeDouble = function (num) {
                this.write(converter.Float64ToArray(num));
            };
            binTool.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.writeUInt8(slen);
                for (var i = 0; i < slen; i++) {
                    this.writeUInt8(str.charCodeAt(i));
                }
            };
            binTool.prototype.writeStringUtf8 = function (str) {
                var bstr = converter.StringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.write(bstr);
            };
            binTool.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = converter.StringToUtf8Array(str);
                this.write(bstr);
            };
            binTool.prototype.writeByte = function (num) {
                this.write(converter.Uint8ToArray(num));
            };
            binTool.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                this.write(array, offset, length);
            };
            binTool.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                this.write(array, offset, length);
            };
            binTool.prototype.writeUnsignedShort = function (num) {
                this.write(converter.Uint16ToArray(num));
            };
            binTool.prototype.writeUnsignedInt = function (num) {
                this.write(converter.Uint32toArray(num));
            };
            binTool.prototype.writeFloat = function (num) {
                this.write(converter.Float32ToArray(num));
            };
            binTool.prototype.writeUTFBytes = function (str) {
                this.write(converter.StringToUtf8Array(str));
            };
            binTool.prototype.writeSymbolByte = function (num) {
                this.write(converter.Int8ToArray(num));
            };
            binTool.prototype.writeShort = function (num) {
                this.write(converter.Int16ToArray(num));
            };
            binTool.prototype.writeInt = function (num) {
                this.write(converter.Int32ToArray(num));
            };
            return binTool;
        }(binBuffer));
        io.binTool = binTool;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        function cloneObj(instanceObj, clonedObj) {
            if (clonedObj === void 0) { clonedObj = undefined; }
            io.referenceInfo.oldmap = {};
            clonedObj = _cloneObj(instanceObj, clonedObj);
            io.referenceInfo.oldmap[instanceObj["insId"].getInsID()] = clonedObj;
            fillCloneReference(instanceObj, clonedObj);
            return clonedObj;
        }
        io.cloneObj = cloneObj;
        function fillCloneReference(instanceObj, clonedObj) {
            var _flag = gd3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.DontSaveInBuild) || (_flag & gd3d.framework.HideFlags.DontSaveInEditor) || (_flag & gd3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        io.fillCloneReference = fillCloneReference;
        function fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    fillCloneReferenceType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    for (var newkey in instanceObj[key]) {
                        var field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            var _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                            }
                            else {
                                fillCloneReferenceType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                    }
                    if (clonedObj["waitDelArray"]) {
                        var children = clonedObj[key];
                        for (var _i = 0, _a = clonedObj["waitDelArray"]; _i < _a.length; _i++) {
                            var index = _a[_i];
                            children.splice(index, 1);
                        }
                        delete clonedObj["waitDelArray"];
                    }
                }
            }
        }
        io.fillCloneReferenceTypeOrArray = fillCloneReferenceTypeOrArray;
        function fillCloneReferenceType(instanceObj, clonedObj, key, instanceParent, clonedParent, instanceKey) {
            if (instanceParent === void 0) { instanceParent = null; }
            if (clonedParent === void 0) { clonedParent = null; }
            if (instanceKey === void 0) { instanceKey = ""; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_1 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    var instance = void 0;
                    if ((isArray_1 && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_1 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid].gameObject.getComponent(type);
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid].getComponent(type);
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid];
                        }
                    }
                    if (isreference) {
                        if (isArray_1) {
                            clonedObj.push(instance);
                        }
                        else {
                            clonedObj[key] = instance;
                        }
                    }
                    else {
                        if (clonedObj[key])
                            fillCloneReference(instanceObj[key], clonedObj[key]);
                        else {
                            if (!clonedParent["waitDelArray"])
                                clonedParent["waitDelArray"] = [];
                            clonedParent["waitDelArray"].push(parseInt(key));
                        }
                    }
                }
            }
        }
        io.fillCloneReferenceType = fillCloneReferenceType;
        function _cloneObj(instanceObj, clonedObj) {
            if (clonedObj === void 0) { clonedObj = undefined; }
            if (clonedObj == undefined) {
                var insid = -1;
                clonedObj = gd3d.reflect.createInstance(instanceObj, null);
                if (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"]) {
                    insid = instanceObj["gameObject"]["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]) {
                    insid = instanceObj["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["typename"] == "transform" || instanceObj["__gdmeta__"]["class"]["typename"] == "transform2D") {
                    insid = instanceObj["insId"].getInsID();
                    io.referenceInfo.oldmap[insid] = clonedObj;
                }
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        clonedObj[key] = instanceObj[key];
                        break;
                    default:
                        cloneOtherTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        io._cloneObj = _cloneObj;
        function cloneOtherTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    cloneOtherType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_2 = instanceObj[key] instanceof Array;
                    if (isArray_2)
                        clonedObj[key] = [];
                    else
                        clonedObj[key] = {};
                    for (var newkey in instanceObj[key]) {
                        var field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            var _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                            }
                            else {
                                cloneOtherType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (field);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        if (isArray_2) {
                                            clonedObj[key].push(field);
                                        }
                                        else {
                                            clonedObj[key][newkey] = field;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        io.cloneOtherTypeOrArray = cloneOtherTypeOrArray;
        function cloneOtherType(instanceObj, clonedObj, key, instanceParent, clonedParent, instanceKey) {
            if (instanceParent === void 0) { instanceParent = null; }
            if (clonedParent === void 0) { clonedParent = null; }
            if (instanceKey === void 0) { instanceKey = ""; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_3 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    if (instanceObj[key].use) {
                        instanceObj[key].use();
                    }
                    if (isArray_3) {
                        clonedObj.push(instanceObj[key]);
                    }
                    else {
                        clonedObj[key] = instanceObj[key];
                    }
                }
                else {
                    var isreference = false;
                    if ((isArray_3 && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_3 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"] || type == "transform" || type == "transform2D") {
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray_3) {
                        }
                        else {
                        }
                    }
                    else {
                        var _clonedObj = void 0;
                        if (_meta["class"]["custom"]["selfclone"]) {
                            _clonedObj = instanceObj[key].clone();
                        }
                        else {
                            _clonedObj = _cloneObj(instanceObj[key], clonedObj[key]);
                        }
                        if (_clonedObj != null) {
                            if (isArray_3) {
                                if (type == "nodeComponent" && instanceKey == "components" && gd3d.reflect.getClassName(instanceParent) == "gameObject") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "transform" && instanceKey == "children" && gd3d.reflect.getClassName(instanceParent) == "transform") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else if (type == "C2DComponent" && instanceKey == "components" && gd3d.reflect.getClassName(instanceParent) == "transform2D") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "transform2D" && instanceKey == "children" && gd3d.reflect.getClassName(instanceParent) == "transform2D") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else {
                                    clonedObj.push(_clonedObj);
                                }
                            }
                            else {
                                clonedObj[key] = _clonedObj;
                            }
                        }
                        else if (isArray_3) {
                            clonedObj.push(null);
                        }
                    }
                }
            }
        }
        io.cloneOtherType = cloneOtherType;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        function stringToBlob(content) {
            var u8 = new Uint8Array(stringToUtf8Array(content));
            var blob = new Blob([u8]);
            return blob;
        }
        io.stringToBlob = stringToBlob;
        function stringToUtf8Array(str) {
            var bstr = [];
            for (var i = 0; i < str.length; i++) {
                var c = str.charAt(i);
                var cc = c.charCodeAt(0);
                if (cc > 0xFFFF) {
                    throw new Error("InvalidCharacterError");
                }
                if (cc > 0x80) {
                    if (cc < 0x07FF) {
                        var c1 = (cc >>> 6) | 0xC0;
                        var c2 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2);
                    }
                    else {
                        var c1 = (cc >>> 12) | 0xE0;
                        var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                        var c3 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2, c3);
                    }
                }
                else {
                    bstr.push(cc);
                }
            }
            return bstr;
        }
        io.stringToUtf8Array = stringToUtf8Array;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var SaveAssetType;
        (function (SaveAssetType) {
            SaveAssetType[SaveAssetType["FullUrl"] = 0] = "FullUrl";
            SaveAssetType[SaveAssetType["NameAndContent"] = 1] = "NameAndContent";
            SaveAssetType[SaveAssetType["DefaultAssets"] = 2] = "DefaultAssets";
        })(SaveAssetType = io.SaveAssetType || (io.SaveAssetType = {}));
        var SerializeDependent = (function () {
            function SerializeDependent() {
            }
            SerializeDependent.GetAssetContent = function (asset) {
                var data = {};
                if (asset instanceof gd3d.framework.material)
                    return { "name": asset.getName() + ".mat.json", "value": asset.save(), "type": SaveAssetType.NameAndContent };
            };
            SerializeDependent.GetAssetUrl = function (asset, assetMgr) {
                if (!assetMgr || !asset)
                    return;
                var url = assetMgr.getAssetUrl(asset);
                if (url)
                    SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                else
                    SerializeDependent.resourseDatas.push(SerializeDependent.GetAssetContent(asset));
                if (asset instanceof gd3d.framework.material) {
                    var ass = asset;
                    for (var newKey in ass.statedMapUniforms) {
                        if (!ass.statedMapUniforms[newKey])
                            continue;
                        if (ass.defaultMapUniform[newKey].type != gd3d.render.UniformTypeEnum.Texture)
                            continue;
                        var _texture = ass.statedMapUniforms[newKey];
                        if (!_texture)
                            continue;
                        url = assetMgr.getAssetUrl(_texture);
                        if (url)
                            SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                        else {
                            if (_texture.defaultAsset == true)
                                continue;
                            var content = SerializeDependent.GetAssetContent(_texture);
                            if (content)
                                SerializeDependent.resourseDatas.push(content);
                            continue;
                        }
                        if (url.indexOf(".imgdesc.json") < 0)
                            continue;
                        if (!_texture.realName)
                            continue;
                        url = url.replace(_texture.getName(), _texture.realName);
                        SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                    }
                }
            };
            SerializeDependent.resourseDatas = [];
            return SerializeDependent;
        }());
        io.SerializeDependent = SerializeDependent;
        function SerializeForInspector(obj) {
            var str = JSON.stringify(serializeObjForInspector(obj, false));
            return str;
        }
        io.SerializeForInspector = SerializeForInspector;
        function serializeObjForInspector(instanceObj, beComponent, serializedObj) {
            if (serializedObj === void 0) { serializedObj = undefined; }
            var _flag = gd3d.framework.HideFlags.None;
            var _type;
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform" && instanceObj["gameObject"]) {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.HideInInspector)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = {};
            }
            for (var key in instanceObj["__gdmeta__"]) {
                if (key == "children")
                    continue;
                var t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        var info = new inspectorValueInfo(instanceObj[key], valueType);
                        if (t["custom"]["FieldUIStyle"])
                            info.UIStyle = t["custom"]["FieldUIStyle"];
                        if (t["custom"]["defvalue"])
                            info.defvalue = t["custom"]["defvalue"];
                        if (t["custom"]["min"])
                            info.min = t["custom"]["min"];
                        if (t["custom"]["max"])
                            info.max = t["custom"]["max"];
                        serializedObj[key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObjForInspector = serializeObjForInspector;
        function serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent) {
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent);
                }
                else if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_4 = instanceObj[key] instanceof Array;
                    if (isArray_4)
                        serializedObj[key] = new inspectorValueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    else
                        serializedObj[key] = new inspectorValueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey] == null || instanceObj[key][newkey] == undefined) {
                            continue;
                        }
                        if (instanceObj[key][newkey]["__gdmeta__"]) {
                            var _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                            }
                            else {
                                serializeOtherTypeForInspector(instanceObj[key], serializedObj[key]["value"], newkey, beComponent, instanceObj);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        if (boolInNull(serializedObj[key]["value"])) {
                                            continue;
                                        }
                                        var info_1 = new inspectorValueInfo(instanceObj[key][newkey], baseType);
                                        if (isArray_4) {
                                            serializedObj[key]["value"].push(info_1);
                                        }
                                        else {
                                            serializedObj[key]["value"][newkey] = info_1;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            else {
                var isArray_5 = instanceObj instanceof Array;
                if (instanceObj["__gdmeta__"]) {
                    if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"]) {
                        var custom = instanceObj["__gdmeta__"][key]["custom"];
                        if (custom["valueType"]) {
                            var info = new inspectorValueInfo(null, custom["valueType"]);
                            if (custom["FieldUIStyle"])
                                info.UIStyle = custom["FieldUIStyle"];
                            if (custom["defvalue"])
                                info.defvalue = custom["defvalue"];
                            if (custom["min"])
                                info.min = custom["min"];
                            if (custom["max"])
                                info.max = custom["max"];
                            if (isArray_5) {
                                serializedObj.push(info);
                            }
                            else {
                                serializedObj[key] = info;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeOrArrayForInspector = serializeOtherTypeOrArrayForInspector;
        function serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent, arrayInst) {
            if (arrayInst === void 0) { arrayInst = null; }
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj[key]) || boolInNull(instanceObj[key]["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_6 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (isAssetInspector(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    var _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        var info = new inspectorValueInfo(_assetName, type);
                        if (isArray_6) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    if ((isArray_6 && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_6 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        beComponent = true;
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (!referenceInfo.isRegType(type)) {
                            return;
                        }
                    }
                    if (isreference) {
                        var info = new inspectorValueInfo(insid, type, "reference");
                        if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                            var custom = instanceObj["__gdmeta__"][key]["custom"];
                            info.UIStyle = instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"];
                            if (custom["defvalue"])
                                info.defvalue = custom;
                            if (custom["min"])
                                info.min = custom["min"];
                            if (custom["max"])
                                info.max = custom["max"];
                        }
                        if (isArray_6) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                    else {
                        if (!referenceInfo.isRegType(type) && beComponent)
                            return;
                        var _serializeObj = serializeObjForInspector(instanceObj[key], beComponent, serializedObj[key]);
                        if (_serializeObj != null) {
                            var info = new inspectorValueInfo(_serializeObj, type);
                            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                                var custom = instanceObj["__gdmeta__"][key]["custom"];
                                info.UIStyle = custom["FieldUIStyle"];
                                if (custom["defvalue"])
                                    info.defvalue = custom;
                                if (custom["min"])
                                    info.min = custom["min"];
                                if (custom["max"])
                                    info.max = custom["max"];
                            }
                            if (isArray_6) {
                                serializedObj.push(info);
                            }
                            else {
                                serializedObj[key] = info;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeForInspector = serializeOtherTypeForInspector;
        function Serialize(obj, assetMgr) {
            if (assetMgr === void 0) { assetMgr = null; }
            return JSON.stringify(serializeObj(obj, null, assetMgr));
        }
        io.Serialize = Serialize;
        function serializeObj(instanceObj, serializedObj, assetMgr) {
            if (serializedObj === void 0) { serializedObj = undefined; }
            if (assetMgr === void 0) { assetMgr = null; }
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _flag = gd3d.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.DontSaveInBuild) || (_flag & gd3d.framework.HideFlags.DontSaveInEditor) || (_flag & gd3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = new valueInfo({}, _type);
                if (instanceObj["insId"] != undefined) {
                    serializedObj["insid"] = instanceObj["insId"].getInsID();
                }
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t == null) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        var info = new valueInfo(instanceObj[key], valueType);
                        serializedObj["value"][key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArray(instanceObj, serializedObj["value"], key, assetMgr);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObj = serializeObj;
        function serializeOtherTypeOrArray(instanceObj, serializedObj, key, assetMgr) {
            if (assetMgr === void 0) { assetMgr = null; }
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherType(instanceObj, serializedObj, key, null, assetMgr);
                }
                else if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_7 = instanceObj[key] instanceof Array;
                    if (isArray_7)
                        serializedObj[key] = new valueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    else
                        serializedObj[key] = new valueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey] && instanceObj[key][newkey]["__gdmeta__"]) {
                            var _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                            }
                            else {
                                serializeOtherType(instanceObj[key], serializedObj[key]["value"], newkey, instanceObj, assetMgr);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                if (instanceObj[key][newkey] == null || instanceObj[key][newkey] == undefined) {
                                    continue;
                                }
                                var baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        var info = new valueInfo(instanceObj[key][newkey], baseType);
                                        if (serializedObj[key]["value"]) {
                                            if (isArray_7) {
                                                serializedObj[key]["value"].push(info);
                                            }
                                            else {
                                                serializedObj[key]["value"][newkey] = info;
                                            }
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeOrArray = serializeOtherTypeOrArray;
        function serializeOtherType(instanceObj, serializedObj, key, arrayInst, assetMgr) {
            if (arrayInst === void 0) { arrayInst = null; }
            if (assetMgr === void 0) { assetMgr = null; }
            if (boolInNull(instanceObj || boolInNull(serializedObj))) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj[key]) || boolInNull(instanceObj[key]["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_8 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (isAsset(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    var _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        else {
                            if (assetMgr) {
                                SerializeDependent.GetAssetUrl(instanceObj[key], assetMgr);
                            }
                        }
                        if (isArray_8) {
                            serializedObj.push(new valueInfo(_assetName, type));
                        }
                        else {
                            serializedObj[key] = new valueInfo(_assetName, type);
                        }
                    }
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    if ((isArray_8 && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_8 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray_8) {
                            serializedObj.push(new valueInfo(insid, type, "reference"));
                        }
                        else {
                            serializedObj[key] = new valueInfo(insid, type, "reference");
                        }
                    }
                    else {
                        var _serializeObj = serializeObj(instanceObj[key], serializedObj[key], assetMgr);
                        if (_serializeObj != null) {
                            if (isArray_8) {
                                serializedObj.push(_serializeObj);
                            }
                            else {
                                serializedObj[key] = _serializeObj;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherType = serializeOtherType;
        function deSerialize(serializedObj, instanceObj, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            referenceInfo.oldmap = {};
            deSerializeObj(serializedObj["value"], instanceObj, assetMgr, bundlename);
            var insid = serializedObj["insid"];
            if (!insid) {
            }
            else
                referenceInfo.oldmap[insid] = instanceObj;
            fillReference(serializedObj["value"], instanceObj);
        }
        io.deSerialize = deSerialize;
        function fillReference(serializedObj, instanceObj) {
            if (boolInNull(instanceObj) || boolInNull(instanceObj["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        dofillReferenceOrArray(serializedObj, instanceObj, key);
                        break;
                }
            }
        }
        io.fillReference = fillReference;
        function dofillReferenceOrArray(serializedObj, instanceObj, key) {
            if (boolInNull(serializedObj) || boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (serializedObj[key]) {
                var type = serializedObj[key].type;
                if (isArrayOrDic(type.toLowerCase())) {
                    var _isArray = serializedObj[key].value instanceof Array;
                    if (!instanceObj[key]) {
                        if (_isArray)
                            instanceObj[key] = [];
                        else
                            instanceObj[key] = {};
                    }
                    var arrayObj = null;
                    if (boolInNull(instanceObj["__gdmeta__"]) && boolInNull(instanceObj["__gdmeta__"][key]) && boolInNull(instanceObj["__gdmeta__"][key]["custom"])
                        && instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("反序列化失败，类型不匹配：" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        if (boolInNull(arrayObj[newkey])) {
                            continue;
                        }
                        var baseType = arrayObj[newkey].type;
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                break;
                            default:
                                dofillReference(serializedObj[key]["value"], instanceObj[key], newkey);
                                break;
                        }
                    }
                }
                else {
                    dofillReference(serializedObj, instanceObj, key);
                }
            }
        }
        io.dofillReferenceOrArray = dofillReferenceOrArray;
        function dofillReference(serializedObj, instanceObj, key) {
            if (boolInNull(instanceObj) || boolInNull(serializedObj) || boolInNull(serializedObj[key])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _isArray = instanceObj instanceof Array;
            var type = serializedObj[key].type;
            var _parentType = typeof (instanceObj);
            if (isAsset(type)) {
            }
            else {
                if (serializedObj[key].parse == "reference") {
                    var instance = referenceInfo.oldmap[serializedObj[key].value];
                    if (type == "transform" || type == "transform2D") {
                    }
                    else {
                        if (instance instanceof gd3d.framework.transform2D) {
                            instance = instance.getComponent(type);
                        }
                        else if (instance instanceof gd3d.framework.transform) {
                            instance = instance.gameObject.getComponent(type);
                        }
                    }
                    if (_isArray) {
                        instanceObj.push(instance);
                    }
                    else {
                        instanceObj[key] = instance;
                    }
                }
                else {
                    fillReference(serializedObj[key].value, instanceObj[key]);
                }
            }
        }
        io.dofillReference = dofillReference;
        function deSerializeObj(serializedObj, instanceObj, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (instanceObj == undefined) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        if (serializedObj[key] == undefined || valueType != serializedObj[key].type) {
                            continue;
                        }
                        else {
                            instanceObj[key] = serializedObj[key].value;
                        }
                        break;
                    default:
                        deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, assetMgr, bundlename);
                        break;
                }
            }
        }
        io.deSerializeObj = deSerializeObj;
        function deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (boolInNull(serializedObj) || boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (serializedObj[key]) {
                var type = serializedObj[key].type;
                if (type == null) {
                    throw new Error("必须传入一个实例，用来赋值");
                }
                if (isArrayOrDic(type.toLowerCase())) {
                    var _isArray = serializedObj[key].value instanceof Array;
                    if (!instanceObj[key]) {
                        if (_isArray)
                            instanceObj[key] = [];
                        else
                            instanceObj[key] = {};
                    }
                    var arrayObj = null;
                    if (boolInNull(instanceObj["__gdmeta__"]) && boolInNull(instanceObj["__gdmeta__"][key]) && boolInNull(instanceObj["__gdmeta__"][key]["custom"])
                        && instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("反序列化失败，类型不匹配：" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        var baseType = arrayObj[newkey].type;
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                if (baseType != serializedObj[key]["value"][newkey].type) {
                                    throw new Error("反序列化失败，类型不匹配：" + baseType + " as " + serializedObj[key]["value"][newkey].type);
                                }
                                if (_isArray) {
                                    instanceObj[key].push(serializedObj[key]["value"][newkey].value);
                                }
                                else {
                                    instanceObj[key][newkey] = serializedObj[key]["value"][newkey].value;
                                }
                                break;
                            default:
                                if (baseType == "nodeComponent" && key == "components" && gd3d.reflect.getClassName(instanceObj) == "gameObject") {
                                    var _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, assetMgr, bundlename);
                                    instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "transform" && key == "children" && gd3d.reflect.getClassName(instanceObj) == "transform") {
                                    var _transforms = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms, newkey, assetMgr, bundlename);
                                    instanceObj.addChild(_transforms[0]);
                                }
                                else if (baseType == "C2DComponent" && key == "components" && gd3d.reflect.getClassName(instanceObj) == "transform2D") {
                                    var _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, assetMgr, bundlename);
                                    instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "transform2D" && key == "children" && gd3d.reflect.getClassName(instanceObj) == "transform2D") {
                                    var _transforms2D = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms2D, newkey, assetMgr, bundlename);
                                    instanceObj.addChild(_transforms2D[0]);
                                }
                                else {
                                    deSerializeOtherType(serializedObj[key]["value"], instanceObj[key], newkey, assetMgr, bundlename);
                                }
                                break;
                        }
                    }
                }
                else {
                    deSerializeOtherType(serializedObj, instanceObj, key, assetMgr, bundlename);
                }
            }
        }
        io.deSerializeOtherTypeOrArray = deSerializeOtherTypeOrArray;
        function deSerializeOtherType(serializedObj, instanceObj, key, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (boolInNull(serializedObj) || boolInNull(instanceObj) || boolInNull(serializedObj[key])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _isArray = instanceObj instanceof Array;
            var type = serializedObj[key].type;
            var _parentType = typeof (instanceObj);
            if (isAsset(type)) {
                var assetName = serializedObj[key].value;
                var _asset = void 0;
                if (assetName.indexOf("SystemDefaultAsset-") >= 0) {
                    assetName = assetName.replace("SystemDefaultAsset-", "");
                    if (type == "mesh") {
                        assetName = assetName.replace(".mesh.bin", "");
                        _asset = assetMgr.getDefaultMesh(assetName);
                    }
                    else if (type == "texture") {
                        _asset = assetMgr.getDefaultTexture(assetName);
                    }
                }
                else {
                    _asset = assetMgr.getAssetByName(assetName, bundlename);
                }
                if (_asset == null && type == "animationClip") {
                    _asset = assetMgr.getAssetByName(assetName);
                    if (!_asset) {
                        _asset = new gd3d.framework.animationClip(assetName);
                        _asset.use();
                    }
                }
                {
                    if (instanceObj instanceof Array) {
                        instanceObj.push(_asset);
                    }
                    else {
                        instanceObj[key] = _asset;
                    }
                }
            }
            else {
                if (serializedObj[key].parse == "reference") {
                }
                else {
                    var _newInstance = void 0;
                    if (type == "gameObject" && key == "gameObject" && gd3d.reflect.getClassName(instanceObj) == "transform") {
                        _newInstance = instanceObj.gameObject;
                    }
                    else if (type == "transform2D" && key == "rootNode" && gd3d.reflect.getClassName(instanceObj) == "canvas") {
                        _newInstance = gd3d.reflect.createInstance(document["__gdmeta__"][type], null);
                        instanceObj.rootNode = _newInstance;
                        _newInstance.canvas = instanceObj;
                    }
                    else {
                        _newInstance = gd3d.reflect.createInstance(document["__gdmeta__"][type], null);
                        if (_isArray)
                            instanceObj.push(_newInstance);
                        else
                            instanceObj[key] = _newInstance;
                    }
                    deSerializeObj(serializedObj[key].value, _newInstance, assetMgr, bundlename);
                    var insid = serializedObj[key].insid;
                    if (!insid) {
                    }
                    else
                        referenceInfo.oldmap[insid] = _newInstance;
                }
            }
        }
        io.deSerializeOtherType = deSerializeOtherType;
        function isArray(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0) {
                return true;
            }
            return false;
        }
        io.isArray = isArray;
        function isArrayOrDic(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0 || type.indexOf("dic") >= 0) {
                return true;
            }
            return false;
        }
        io.isArrayOrDic = isArrayOrDic;
        function isAsset(type) {
            if (type == "mesh" || type == "texture" || type == "shader" ||
                type == "material" || type == "animationClip" || type == "atlas" ||
                type == "font" || type == "prefab" || type == "sprite" || type == "textasset" || type == "f14eff")
                return true;
            return false;
        }
        io.isAsset = isAsset;
        function isAssetInspector(type) {
            if (type == "prefab")
                return true;
        }
        io.isAssetInspector = isAssetInspector;
        var valueInfo = (function () {
            function valueInfo(value, type, _parse) {
                if (_parse === void 0) { _parse = "direct"; }
                if (isAsset(type)) {
                    _parse = "nameonly";
                    if (type == "material") {
                        if (value.lastIndexOf(".mat.json") < 0)
                            value += ".mat.json";
                    }
                }
                this.value = value;
                this.type = type;
                this.parse = _parse;
            }
            return valueInfo;
        }());
        var inspectorValueInfo = (function () {
            function inspectorValueInfo(_value, _type, _parse) {
                if (_parse === void 0) { _parse = "direct"; }
                this.value = _value;
                this.type = _type;
                if (isAssetInspector(_type)) {
                    _parse = "nameonly";
                }
                this.parse = _parse;
            }
            return inspectorValueInfo;
        }());
        var referenceInfo = (function () {
            function referenceInfo() {
            }
            referenceInfo.regDefaultType = function () {
                referenceInfo.regType("vector3");
                referenceInfo.regType("vector4");
                referenceInfo.regType("color");
                referenceInfo.regType("border");
                referenceInfo.regType("quaternion");
                referenceInfo.regType("material");
                referenceInfo.regType("gameObject");
                referenceInfo.regType("transform2D");
                referenceInfo.regType("shader");
                referenceInfo.regType("atlas");
                referenceInfo.regType("font");
                referenceInfo.regType("sprite");
                referenceInfo.regType("texture");
                referenceInfo.regType("mesh");
                referenceInfo.regType("animationclip");
                referenceInfo.regType("constText");
                referenceInfo.regType("UniformData");
                referenceInfo.regType("f14eff");
            };
            referenceInfo.regType = function (type) {
                referenceInfo.regtypelist.push(type);
            };
            referenceInfo.isRegType = function (type) {
                return this.regtypelist.indexOf(type) >= 0;
            };
            referenceInfo.oldmap = {};
            referenceInfo.regtypelist = [];
            return referenceInfo;
        }());
        io.referenceInfo = referenceInfo;
        var enumMgr = (function () {
            function enumMgr() {
            }
            enumMgr.enumMap = {};
            return enumMgr;
        }());
        io.enumMgr = enumMgr;
        function boolInNull(obj) {
            if (obj == null || obj == undefined) {
                return true;
            }
            return false;
        }
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var binReader = (function () {
            function binReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            binReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            binReader.prototype.peek = function () {
                return this._seek;
            };
            binReader.prototype.length = function () {
                return this._data.byteLength;
            };
            binReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            binReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            binReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            binReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return binReader.utf8ArrayToString(arr);
            };
            binReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return binReader.utf8ArrayToString(arr);
            };
            binReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            binReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            binReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            binReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            binReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            binReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readUint8Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            binReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            Object.defineProperty(binReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            binReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            binReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            binReader.prototype.readBytes = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            binReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            binReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            binReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            binReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return binReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            binReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            binReader.prototype.readShort = function () {
                return this.readInt16();
            };
            binReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return binReader;
        }());
        io.binReader = binReader;
        var binWriter = (function () {
            function binWriter() {
                {
                    var buf = new ArrayBuffer(1024);
                    this._length = 0;
                }
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            binWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            binWriter.prototype.getLength = function () {
                return length;
            };
            binWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            binWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            binWriter.prototype.peek = function () {
                return this._seek;
            };
            binWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            binWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            binWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            binWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            binWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            binWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            binWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = binWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            binWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            binWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = binWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            binWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(binWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            binWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            binWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            binWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            binWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            binWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            binWriter.prototype.writeUTFBytes = function (str) {
                var strArray = binWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            binWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            binWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            binWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return binWriter;
        }());
        io.binWriter = binWriter;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function colorSet_White(out) {
            out.r = 1;
            out.g = 1;
            out.b = 1;
            out.a = 1;
        }
        math.colorSet_White = colorSet_White;
        function colorSet_Black(out) {
            out.r = 0;
            out.g = 0;
            out.b = 0;
            out.a = 1;
        }
        math.colorSet_Black = colorSet_Black;
        function colorSet_Gray(out) {
            out.r = 0.5;
            out.g = 0.5;
            out.b = 0.5;
            out.a = 1;
        }
        math.colorSet_Gray = colorSet_Gray;
        function colorMultiply(srca, srcb, out) {
            out.r = srca.r * srcb.r;
            out.g = srca.g * srcb.g;
            out.b = srca.b * srcb.b;
            out.a = srca.a * srcb.a;
        }
        math.colorMultiply = colorMultiply;
        function scaleToRef(src, scale, out) {
            out.r = src.r * scale;
            out.g = src.g * scale;
            out.b = src.b * scale;
            out.a = src.a * scale;
        }
        math.scaleToRef = scaleToRef;
        function colorClone(src, out) {
            out.a = src.a;
            out.r = src.r;
            out.g = src.g;
            out.b = src.b;
        }
        math.colorClone = colorClone;
        function colorLerp(srca, srcb, t, out) {
            out.a = t * (srcb.a - srca.a) + srca.a;
            out.r = t * (srcb.r - srca.r) + srca.r;
            out.g = t * (srcb.g - srca.g) + srca.g;
            out.b = t * (srcb.b - srca.b) + srca.b;
        }
        math.colorLerp = colorLerp;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
            var vp1 = planeVector.x;
            var vp2 = planeVector.y;
            var vp3 = planeVector.z;
            var n1 = planePoint.x;
            var n2 = planePoint.y;
            var n3 = planePoint.z;
            var v1 = lineVector.x;
            var v2 = lineVector.y;
            var v3 = lineVector.z;
            var m1 = linePoint.x;
            var m2 = linePoint.y;
            var m3 = linePoint.z;
            var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
            if (vpt === 0) {
                out = null;
            }
            else {
                var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                out.x = m1 + v1 * t;
                out.y = m2 + v2 * t;
                out.z = m3 + v3 * t;
            }
        }
        math.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
        function isContain(p1, p2, p3, p4, mp) {
            if (Multiply(mp, p1, p2) * Multiply(mp, p4, p3) <= 0 && Multiply(mp, p4, p1) * Multiply(mp, p3, p2) <= 0)
                return true;
            return false;
        }
        math.isContain = isContain;
        function Multiply(p1, p2, p0) {
            return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
        }
        math.Multiply = Multiply;
        function getPointByTwoline(index, p2, dir2, outpoint) {
            var matrix = new gd3d.math.matrix();
            var dir1;
            if (index == 1) {
                dir1 = new gd3d.math.vector3(1, 0, 0);
                matrix.rawData[0] = 1;
            }
            else if (index == 2) {
                dir1 = new gd3d.math.vector3(0, 1, 0);
                matrix.rawData[0] = 0;
                matrix.rawData[1] = 1;
            }
            else if (index == 3) {
                dir1 = new gd3d.math.vector3(0, 0, 1);
                matrix.rawData[0] = 0;
                matrix.rawData[2] = 1;
            }
            var dirBt = new gd3d.math.vector3();
            gd3d.math.vec3Cross(dir1, dir2, dirBt);
            matrix.rawData[4] = dirBt.x;
            matrix.rawData[5] = dirBt.y;
            matrix.rawData[6] = dirBt.z;
            matrix.rawData[8] = -dir2.x;
            matrix.rawData[9] = -dir2.y;
            matrix.rawData[10] = -dir2.z;
            gd3d.math.matrixInverse(matrix, matrix);
            var outnode = new gd3d.math.vector3();
            gd3d.math.matrixTransformVector3(p2, matrix, outnode);
            if (index == 1) {
                outpoint = new gd3d.math.vector3(outnode.x, 0, 0);
            }
            else if (index == 2) {
                outpoint = new gd3d.math.vector3(0, outnode.y, 0);
            }
            else if (index == 3) {
                outpoint = new gd3d.math.vector3(0, 0, outnode.z);
            }
        }
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function matrixGetTranslation(src, out) {
            out.x = src.rawData[12];
            out.y = src.rawData[13];
            out.z = src.rawData[14];
        }
        math.matrixGetTranslation = matrixGetTranslation;
        function matrixTranspose(src, out) {
            out.rawData[1] = src.rawData[4];
            out.rawData[2] = src.rawData[8];
            out.rawData[3] = src.rawData[12];
            out.rawData[4] = src.rawData[1];
            out.rawData[6] = src.rawData[9];
            out.rawData[7] = src.rawData[13];
            out.rawData[8] = src.rawData[2];
            out.rawData[9] = src.rawData[6];
            out.rawData[11] = src.rawData[14];
            out.rawData[12] = src.rawData[3];
            out.rawData[13] = src.rawData[7];
            out.rawData[14] = src.rawData[11];
        }
        math.matrixTranspose = matrixTranspose;
        function matrixDecompose(src, scale, rotation, translation) {
            translation.x = src.rawData[12];
            translation.y = src.rawData[13];
            translation.z = src.rawData[14];
            var xs = math.sign(src.rawData[0] * src.rawData[1] * src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[4] * src.rawData[5] * src.rawData[6] * src.rawData[7]) < 0 ? -1 : 1;
            var zs = math.sign(src.rawData[8] * src.rawData[9] * src.rawData[10] * src.rawData[11]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            scale.y = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            scale.z = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
            if (scale.x === 0 || scale.y === 0 || scale.z === 0) {
                rotation.x = 0;
                rotation.y = 0;
                rotation.z = 0;
                rotation.w = 1;
                return false;
            }
            var mat = math.pool.new_matrix();
            mat.rawData[0] = src.rawData[0] / scale.x;
            mat.rawData[1] = src.rawData[1] / scale.x;
            mat.rawData[2] = src.rawData[2] / scale.x;
            mat.rawData[3] = 0;
            mat.rawData[4] = src.rawData[4] / scale.y;
            mat.rawData[5] = src.rawData[5] / scale.y;
            mat.rawData[6] = src.rawData[6] / scale.y;
            mat.rawData[7] = 0;
            mat.rawData[8] = src.rawData[8] / scale.z;
            mat.rawData[9] = src.rawData[9] / scale.z;
            mat.rawData[10] = src.rawData[10] / scale.z;
            mat.rawData[11] = 0;
            matrix2Quaternion(mat, rotation);
            return true;
        }
        math.matrixDecompose = matrixDecompose;
        var angelref = (function () {
            function angelref() {
            }
            return angelref;
        }());
        math.angelref = angelref;
        function matrix3x2Decompose(src, scale, rotation, translation) {
            translation.x = src.rawData[4];
            translation.y = src.rawData[5];
            scale.x = Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1]);
            scale.y = Math.sqrt(src.rawData[2] * src.rawData[2] + src.rawData[3] * src.rawData[3]);
            if (scale.x === 0 || scale.y === 0) {
                rotation.v = 0;
                return false;
            }
            var sx = src.rawData[0] / scale.x;
            var r1 = Math.acos(sx);
            var sxs = src.rawData[1] / scale.x;
            var r2 = Math.asin(sxs);
            if (sxs < 0) {
                r1 = 2 * Math.PI - r1;
            }
            rotation.v = r1;
            return true;
        }
        math.matrix3x2Decompose = matrix3x2Decompose;
        function matrix2Quaternion(matrix, result) {
            var data = matrix.rawData;
            var m11 = data[0], m12 = data[4], m13 = data[8];
            var m21 = data[1], m22 = data[5], m23 = data[9];
            var m31 = data[2], m32 = data[6], m33 = data[10];
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                result.w = 0.25 / s;
                result.x = (m32 - m23) * s;
                result.y = (m13 - m31) * s;
                result.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                result.w = (m32 - m23) / s;
                result.x = 0.25 * s;
                result.y = (m12 + m21) / s;
                result.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                result.w = (m13 - m31) / s;
                result.x = (m12 + m21) / s;
                result.y = 0.25 * s;
                result.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                result.w = (m21 - m12) / s;
                result.x = (m13 + m31) / s;
                result.y = (m23 + m32) / s;
                result.z = 0.25 * s;
            }
        }
        math.matrix2Quaternion = matrix2Quaternion;
        function unitxyzToRotation(xAxis, yAxis, zAxis, out) {
            var m11 = xAxis.x, m12 = yAxis.x, m13 = zAxis.x;
            var m21 = xAxis.y, m22 = yAxis.y, m23 = zAxis.y;
            var m31 = xAxis.z, m32 = yAxis.z, m33 = zAxis.z;
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                out.w = 0.25 / s;
                out.x = (m32 - m23) * s;
                out.y = (m13 - m31) * s;
                out.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                out.w = (m32 - m23) / s;
                out.x = 0.25 * s;
                out.y = (m12 + m21) / s;
                out.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                out.w = (m13 - m31) / s;
                out.x = (m12 + m21) / s;
                out.y = 0.25 * s;
                out.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                out.w = (m21 - m12) / s;
                out.x = (m13 + m31) / s;
                out.y = (m23 + m32) / s;
                out.z = 0.25 * s;
            }
        }
        math.unitxyzToRotation = unitxyzToRotation;
        function matrixClone(src, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = src.rawData[i];
            }
        }
        math.matrixClone = matrixClone;
        function matrix3x2Clone(src, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = src.rawData[i];
            }
        }
        math.matrix3x2Clone = matrix3x2Clone;
        function matrixMakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = 1;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = 1;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeIdentity = matrixMakeIdentity;
        function matrix3x2MakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 1;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeIdentity = matrix3x2MakeIdentity;
        function matrixInverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l3 = src.rawData[2];
            var l4 = src.rawData[3];
            var l5 = src.rawData[4];
            var l6 = src.rawData[5];
            var l7 = src.rawData[6];
            var l8 = src.rawData[7];
            var l9 = src.rawData[8];
            var l10 = src.rawData[9];
            var l11 = src.rawData[10];
            var l12 = src.rawData[11];
            var l13 = src.rawData[12];
            var l14 = src.rawData[13];
            var l15 = src.rawData[14];
            var l16 = src.rawData[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            out.rawData[0] = l23 * l27;
            out.rawData[4] = l24 * l27;
            out.rawData[8] = l25 * l27;
            out.rawData[12] = l26 * l27;
            out.rawData[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            out.rawData[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            out.rawData[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            out.rawData[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            out.rawData[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            out.rawData[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            out.rawData[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            out.rawData[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            out.rawData[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            out.rawData[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            out.rawData[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            out.rawData[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
        }
        math.matrixInverse = matrixInverse;
        function matrix3x2Inverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l5 = src.rawData[2];
            var l6 = src.rawData[3];
            var l13 = src.rawData[4];
            var l14 = src.rawData[5];
            var l26 = -(((l5 * -l14) - (l6 * -l13)));
            var l27 = 1.0 / ((((l1 * l6) + (l2 * -l5))));
            out.rawData[0] = l6 * l27;
            out.rawData[2] = -l5 * l27;
            out.rawData[4] = l26 * l27;
            out.rawData[1] = -(((l2))) * l27;
            out.rawData[3] = (((l1))) * l27;
            out.rawData[5] = (((l1 * -l14) - (l2 * -l13))) * l27;
        }
        math.matrix3x2Inverse = matrix3x2Inverse;
        function matrixMakeTransformRTS(pos, scale, rot, out) {
            var matS = gd3d.math.pool.new_matrix();
            matrixMakeScale(scale.x, scale.y, scale.z, matS);
            var matR = gd3d.math.pool.new_matrix();
            math.quatToMatrix(rot, matR);
            matrixMultiply(matR, matS, out);
            out.rawData[12] = pos.x;
            out.rawData[13] = pos.y;
            out.rawData[14] = pos.z;
            out.rawData[15] = 1;
            gd3d.math.pool.delete_matrix(matS);
            gd3d.math.pool.delete_matrix(matR);
        }
        math.matrixMakeTransformRTS = matrixMakeTransformRTS;
        function matrix3x2MakeTransformRTS(pos, scale, rot, out) {
            var matS = gd3d.math.pool.new_matrix3x2();
            matrix3x2MakeScale(scale.x, scale.y, matS);
            var matR = gd3d.math.pool.new_matrix3x2();
            matrix3x2MakeRotate(rot, matR);
            matrix3x2Multiply(matR, matS, out);
            out.rawData[4] = pos.x;
            out.rawData[5] = pos.y;
            gd3d.math.pool.delete_matrix3x2(matS);
            gd3d.math.pool.delete_matrix3x2(matR);
        }
        math.matrix3x2MakeTransformRTS = matrix3x2MakeTransformRTS;
        function matrixMakeTranslate(x, y, z, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0;
            out.rawData[4] = 0.0;
            out.rawData[5] = 1.0;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = 1.0;
            out.rawData[11] = 0.0;
            out.rawData[12] = x;
            out.rawData[13] = y;
            out.rawData[14] = z;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeTranslate = matrixMakeTranslate;
        function matrix3x2MakeTranslate(x, y, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 1.0;
            out.rawData[4] = x;
            out.rawData[5] = y;
        }
        math.matrix3x2MakeTranslate = matrix3x2MakeTranslate;
        function matrixGetScale(src, scale) {
            scale.x = src.rawData[0];
            scale.y = src.rawData[5];
            scale.z = src.rawData[10];
        }
        math.matrixGetScale = matrixGetScale;
        function matrixMakeScale(xScale, yScale, zScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0.0;
            out.rawData[4] = 0.0;
            out.rawData[5] = yScale;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = zScale;
            out.rawData[11] = 0.0;
            out.rawData[12] = 0.0;
            out.rawData[13] = 0.0;
            out.rawData[14] = 0.0;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeScale = matrixMakeScale;
        function matrix3x2TransformVector2(mat, inp, out) {
            out.x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2] + mat.rawData[4];
            out.y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3] + mat.rawData[5];
        }
        math.matrix3x2TransformVector2 = matrix3x2TransformVector2;
        function matrix3x2TransformNormal(mat, inp, out) {
            out.x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2];
            out.y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3];
        }
        math.matrix3x2TransformNormal = matrix3x2TransformNormal;
        function matrix3x2MakeScale(xScale, yScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = yScale;
            out.rawData[4] = 0.0;
            out.rawData[5] = 0.0;
        }
        math.matrix3x2MakeScale = matrix3x2MakeScale;
        function matrixMakeRotateAxisAngle(axis, angle, out) {
            var x = axis.x, y = axis.y, z = axis.z;
            var length = Math.sqrt(x * x + y * y + z * z);
            if (!length)
                return;
            if (length !== 1) {
                length = 1 / length;
                x *= length;
                y *= length;
                z *= length;
            }
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var t = 1.0 - c;
            var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
            out.rawData[0] = b00;
            out.rawData[1] = b01;
            out.rawData[2] = b02;
            out.rawData[3] = 0;
            out.rawData[4] = b10;
            out.rawData[5] = b11;
            out.rawData[6] = b12;
            out.rawData[7] = 0;
            out.rawData[8] = b20;
            out.rawData[9] = b21;
            out.rawData[10] = b22;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeRotateAxisAngle = matrixMakeRotateAxisAngle;
        function matrix3x2MakeRotate(angle, out) {
            var x = 0, y = 0, z = 1;
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            out.rawData[0] = c;
            out.rawData[1] = s;
            out.rawData[2] = -s;
            out.rawData[3] = c;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeRotate = matrix3x2MakeRotate;
        function matrixMultiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = lhs.rawData[2], a03 = lhs.rawData[3];
            var a10 = lhs.rawData[4], a11 = lhs.rawData[5], a12 = lhs.rawData[6], a13 = lhs.rawData[7];
            var a20 = lhs.rawData[8], a21 = lhs.rawData[9], a22 = lhs.rawData[10], a23 = lhs.rawData[11];
            var a30 = lhs.rawData[12], a31 = lhs.rawData[13], a32 = lhs.rawData[14], a33 = lhs.rawData[15];
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b2 = rhs.rawData[2], b3 = rhs.rawData[3];
            out.rawData[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b2 = rhs.rawData[6];
            b3 = rhs.rawData[7];
            out.rawData[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[8];
            b1 = rhs.rawData[9];
            b2 = rhs.rawData[10];
            b3 = rhs.rawData[11];
            out.rawData[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[12];
            b1 = rhs.rawData[13];
            b2 = rhs.rawData[14];
            b3 = rhs.rawData[15];
            out.rawData[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        }
        math.matrixMultiply = matrixMultiply;
        function matrix3x2Multiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = 0;
            var a10 = lhs.rawData[2], a11 = lhs.rawData[3], a12 = 0;
            var a30 = lhs.rawData[4], a31 = lhs.rawData[5], a32 = 1;
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b3 = 0;
            out.rawData[0] = b0 * a00 + b1 * a10 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[2];
            b1 = rhs.rawData[3];
            b3 = 0;
            out.rawData[2] = b0 * a00 + b1 * a10 + b3 * a30;
            out.rawData[3] = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b3 = 1;
            out.rawData[4] = b0 * a00 + b1 * a10 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b3 * a31;
        }
        math.matrix3x2Multiply = matrix3x2Multiply;
        function matrixProject_PerspectiveLH(fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = -zfar / (znear - zfar);
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = (znear * zfar) / (znear - zfar);
        }
        math.matrixProject_PerspectiveLH = matrixProject_PerspectiveLH;
        function matrixProject_OrthoLH(width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 2.0 / (zfar - znear);
            var nid = (zfar + znear) / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
        }
        math.matrixProject_OrthoLH = matrixProject_OrthoLH;
        function matrixLookatLH(forward, up, out) {
            var z = new math.vector3(-forward.x, -forward.y, -forward.z);
            math.vec3Normalize(z, z);
            var y = new math.vector3();
            math.vec3Clone(up, y);
            math.vec3Normalize(y, y);
            var x = new math.vector3();
            math.vec3Cross(y, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            var y = new math.vector3();
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixLookatLH = matrixLookatLH;
        function matrixViewLookatLH(eye, forward, up, out) {
            var z = new math.vector3(forward.x, forward.y, forward.z);
            math.vec3Normalize(z, z);
            var y = new math.vector3();
            math.vec3Clone(up, y);
            math.vec3Normalize(y, y);
            var x = new math.vector3();
            math.vec3Cross(y, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            var y = new math.vector3();
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            var ex = -math.vec3Dot(x, eye);
            var ey = -math.vec3Dot(y, eye);
            var ez = -math.vec3Dot(z, eye);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = ex;
            out.rawData[13] = ey;
            out.rawData[14] = ez;
            out.rawData[15] = 1;
        }
        math.matrixViewLookatLH = matrixViewLookatLH;
        function matrixLerp(left, right, v, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = left.rawData[i] * (1 - v) + right.rawData[i] * v;
            }
        }
        math.matrixLerp = matrixLerp;
        function matrixTransformVector3(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]) + transformation.rawData[12];
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]) + transformation.rawData[13];
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]) + transformation.rawData[14];
            var w = (vector.x * transformation.rawData[3]) + (vector.y * transformation.rawData[7]) + (vector.z * transformation.rawData[11]) + transformation.rawData[15];
            result.x = x / w;
            result.y = y / w;
            result.z = z / w;
        }
        math.matrixTransformVector3 = matrixTransformVector3;
        function matrixTransformNormal(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]);
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]);
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]);
            result.x = x;
            result.y = y;
            result.z = z;
        }
        math.matrixTransformNormal = matrixTransformNormal;
        function matrixGetVector3ByOffset(src, offset, result) {
            result.x = src.rawData[offset];
            result.y = src.rawData[offset + 1];
            result.z = src.rawData[offset + 2];
        }
        math.matrixGetVector3ByOffset = matrixGetVector3ByOffset;
        function matrixReset(mat) {
            mat.rawData[0] = 1;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 1;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 1;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixReset = matrixReset;
        function matrixZero(mat) {
            mat.rawData[0] = 0;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 0;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 0;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixZero = matrixZero;
        function matrixScaleByNum(value, mat) {
            mat.rawData[0] *= value;
            mat.rawData[1] *= value;
            mat.rawData[2] *= value;
            mat.rawData[3] *= value;
            mat.rawData[4] *= value;
            mat.rawData[5] *= value;
            mat.rawData[6] *= value;
            mat.rawData[7] *= value;
            mat.rawData[8] *= value;
            mat.rawData[9] *= value;
            mat.rawData[10] *= value;
            mat.rawData[11] *= value;
            mat.rawData[12] *= value;
            mat.rawData[13] *= value;
            mat.rawData[14] *= value;
            mat.rawData[15] *= value;
        }
        math.matrixScaleByNum = matrixScaleByNum;
        function matrixAdd(left, right, out) {
            out.rawData[0] = left.rawData[0] + right.rawData[0];
            out.rawData[1] = left.rawData[1] + right.rawData[1];
            out.rawData[2] = left.rawData[2] + right.rawData[2];
            out.rawData[3] = left.rawData[3] + right.rawData[3];
            out.rawData[4] = left.rawData[4] + right.rawData[4];
            out.rawData[5] = left.rawData[5] + right.rawData[5];
            out.rawData[6] = left.rawData[6] + right.rawData[6];
            out.rawData[7] = left.rawData[7] + right.rawData[7];
            out.rawData[8] = left.rawData[8] + right.rawData[8];
            out.rawData[9] = left.rawData[9] + right.rawData[9];
            out.rawData[10] = left.rawData[10] + right.rawData[10];
            out.rawData[11] = left.rawData[11] + right.rawData[11];
            out.rawData[12] = left.rawData[12] + right.rawData[12];
            out.rawData[13] = left.rawData[13] + right.rawData[13];
            out.rawData[14] = left.rawData[14] + right.rawData[14];
            out.rawData[15] = left.rawData[15] + right.rawData[15];
        }
        math.matrixAdd = matrixAdd;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function floatClamp(v, min, max) {
            if (min === void 0) { min = 0; }
            if (max === void 0) { max = 1; }
            if (v < min)
                return min;
            else if (v > max)
                return max;
            else
                return v;
        }
        math.floatClamp = floatClamp;
        function sign(value) {
            value = +value;
            if (value === 0 || isNaN(value))
                return value;
            return value > 0 ? 1 : -1;
        }
        math.sign = sign;
        function getKeyCodeByAscii(ev) {
            if (ev.shiftKey) {
                return ev.keyCode - 32;
            }
            else {
                return ev.keyCode;
            }
        }
        math.getKeyCodeByAscii = getKeyCodeByAscii;
        function numberLerp(fromV, toV, v) {
            return fromV * (1 - v) + toV * v;
        }
        math.numberLerp = numberLerp;
        function x_AXIS() {
            return commonStatic.x_axis;
        }
        math.x_AXIS = x_AXIS;
        function y_AXIS() {
            return commonStatic.y_axis;
        }
        math.y_AXIS = y_AXIS;
        function z_AXIS() {
            return commonStatic.z_axis;
        }
        math.z_AXIS = z_AXIS;
        var commonStatic = (function () {
            function commonStatic() {
            }
            commonStatic.x_axis = new gd3d.math.vector3(1, 0, 0);
            commonStatic.y_axis = new gd3d.math.vector3(0, 1, 0);
            commonStatic.z_axis = new gd3d.math.vector3(0, 0, 1);
            return commonStatic;
        }());
        math.commonStatic = commonStatic;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function quatIdentity(src) {
            src.x = 0;
            src.y = 0;
            src.z = 0;
            src.w = 1;
        }
        math.quatIdentity = quatIdentity;
        function quatNormalize(src, out) {
            var mag = 1 / Math.sqrt(src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w);
            out.x *= mag;
            out.y *= mag;
            out.z *= mag;
            out.w *= mag;
        }
        math.quatNormalize = quatNormalize;
        function quatTransformVector(src, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            w1 = -src.x * x2 - src.y * y2 - src.z * z2;
            x1 = src.w * x2 + src.y * z2 - src.z * y2;
            y1 = src.w * y2 - src.x * z2 + src.z * x2;
            z1 = src.w * z2 + src.x * y2 - src.y * x2;
            out.x = -w1 * src.x + x1 * src.w - y1 * src.z + z1 * src.y;
            out.y = -w1 * src.y + x1 * src.z + y1 * src.w - z1 * src.x;
            out.z = -w1 * src.z - x1 * src.y + y1 * src.x + z1 * src.w;
        }
        math.quatTransformVector = quatTransformVector;
        function quatTransformVectorDataAndQuat(src, srcseek, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            var srcx = src[srcseek];
            var srcy = src[srcseek + 1];
            var srcz = src[srcseek + 2];
            var srcw = src[srcseek + 3];
            w1 = -srcx * x2 - srcy * y2 - srcz * z2;
            x1 = srcw * x2 + srcy * z2 - srcz * y2;
            y1 = srcw * y2 - srcx * z2 + srcz * x2;
            z1 = srcw * z2 + srcx * y2 - srcy * x2;
            out.x = -w1 * srcx + x1 * srcw - y1 * srcz + z1 * srcy;
            out.y = -w1 * srcy + x1 * srcz + y1 * srcw - z1 * srcx;
            out.z = -w1 * srcz - x1 * srcy + y1 * srcx + z1 * srcw;
        }
        math.quatTransformVectorDataAndQuat = quatTransformVectorDataAndQuat;
        function quatMagnitude(src) {
            return Math.sqrt(src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z);
        }
        math.quatMagnitude = quatMagnitude;
        function quatClone(src, out) {
            out.x = src.x;
            out.y = src.y;
            out.z = src.z;
            out.w = src.w;
        }
        math.quatClone = quatClone;
        function quatToMatrix(src, out) {
            var xy2 = 2.0 * src.x * src.y, xz2 = 2.0 * src.x * src.z, xw2 = 2.0 * src.x * src.w;
            var yz2 = 2.0 * src.y * src.z, yw2 = 2.0 * src.y * src.w, zw2 = 2.0 * src.z * src.w;
            var xx = src.x * src.x, yy = src.y * src.y, zz = src.z * src.z, ww = src.w * src.w;
            out.rawData[0] = xx - yy - zz + ww;
            out.rawData[4] = xy2 - zw2;
            out.rawData[8] = xz2 + yw2;
            out.rawData[12] = 0;
            out.rawData[1] = xy2 + zw2;
            out.rawData[5] = -xx + yy - zz + ww;
            out.rawData[9] = yz2 - xw2;
            out.rawData[13] = 0;
            out.rawData[2] = xz2 - yw2;
            out.rawData[6] = yz2 + xw2;
            out.rawData[10] = -xx - yy + zz + ww;
            out.rawData[14] = 0;
            out.rawData[3] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[11] = 0;
            out.rawData[15] = 1;
        }
        math.quatToMatrix = quatToMatrix;
        function quatInverse(src, out) {
            var norm = src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z;
            if (norm > 0.0) {
                var invNorm = 1.0 / norm;
                out.w = src.w * invNorm;
                out.x = -src.x * invNorm;
                out.y = -src.y * invNorm;
                out.z = -src.z * invNorm;
            }
        }
        math.quatInverse = quatInverse;
        function quatFromYawPitchRoll(yaw, pitch, roll, result) {
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            result.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            result.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            result.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            result.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }
        math.quatFromYawPitchRoll = quatFromYawPitchRoll;
        function quatMultiply(srca, srcb, out) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
        }
        math.quatMultiply = quatMultiply;
        function quatMultiplyDataAndQuat(srca, srcaseek, srcb, out) {
            var w1 = srca[srcaseek + 3], x1 = srca[srcaseek + 0], y1 = srca[srcaseek + 1], z1 = srca[srcaseek + 2];
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
        }
        math.quatMultiplyDataAndQuat = quatMultiplyDataAndQuat;
        function quatMultiplyVector(vector, scr, out) {
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            out.w = -scr.x * x2 - scr.y * y2 - scr.z * z2;
            out.x = scr.w * x2 + scr.y * z2 - scr.z * y2;
            out.y = scr.w * y2 - scr.x * z2 + scr.z * x2;
            out.z = scr.w * z2 + scr.x * y2 - scr.y * x2;
        }
        math.quatMultiplyVector = quatMultiplyVector;
        function quatLerp(srca, srcb, out, t) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            out.w = w1 + t * (w2 - w1);
            out.x = x1 + t * (x2 - x1);
            out.y = y1 + t * (y2 - y1);
            out.z = z1 + t * (z2 - z1);
            var len = 1.0 / Math.sqrt(out.w * out.w + out.x * out.x + out.y * out.y + out.z * out.z);
            out.w *= len;
            out.x *= len;
            out.y *= len;
            out.z *= len;
        }
        math.quatLerp = quatLerp;
        function quatFromAxisAngle(axis, angle, out) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            out.w = Math.cos(halfAngle);
            out.x = axis.x * sin_a;
            out.y = axis.y * sin_a;
            out.z = axis.z * sin_a;
            math.quatNormalize(out, out);
        }
        math.quatFromAxisAngle = quatFromAxisAngle;
        function quatToAxisAngle(src, axis) {
            var sqrLength = src.x * src.x + src.y * src.y + src.z * src.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(src.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = src.x * sqrLength;
                axis.y = src.y * sqrLength;
                axis.z = src.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        }
        math.quatToAxisAngle = quatToAxisAngle;
        function quatFromEulerAngles(ax, ay, az, out) {
            ax *= Math.PI / 180;
            ay *= Math.PI / 180;
            az *= Math.PI / 180;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            out.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            out.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
            out.y = cosX * sinY * cosZ - sinX * cosY * sinZ;
            out.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            math.quatNormalize(out, out);
        }
        math.quatFromEulerAngles = quatFromEulerAngles;
        function quatToEulerAngles(src, out) {
            var temp = 2.0 * (src.w * src.x - src.y * src.z);
            temp = math.floatClamp(temp, -1.0, 1.0);
            out.x = Math.asin(temp);
            out.y = Math.atan2(2.0 * (src.w * src.y + src.z * src.x), 1.0 - 2.0 * (src.y * src.y + src.x * src.x));
            out.z = Math.atan2(2.0 * (src.w * src.z + src.y * src.x), 1.0 - 2.0 * (src.x * src.x + src.z * src.z));
            out.x /= Math.PI / 180;
            out.y /= Math.PI / 180;
            out.z /= Math.PI / 180;
        }
        math.quatToEulerAngles = quatToEulerAngles;
        function quatReset(src) {
            src.x = 0;
            src.y = 0;
            src.z = 0;
            src.w = 1;
        }
        math.quatReset = quatReset;
        function quatLookat(pos, targetpos, out) {
            var dir = new math.vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dirxz = new math.vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            var dirxz1 = new math.vector3(dir.x, 0, dir.z);
            var v3length = math.vec3Length(dirxz1);
            if (v3length > 0.999)
                v3length = 1;
            if (v3length < -0.999)
                v3length = -1;
            var pitch = Math.acos(v3length);
            if (dir.y > 0) {
                pitch = -pitch;
            }
            quatFromYawPitchRoll(yaw, pitch, 0, out);
            math.quatNormalize(out, out);
        }
        math.quatLookat = quatLookat;
        function quat2Lookat(pos, targetpos, out, updir) {
            if (updir === void 0) { updir = gd3d.math.pool.vector3_up; }
            var dir = gd3d.math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dot = gd3d.math.vec3Dot(gd3d.math.pool.vector3_forward, dir);
            dot = gd3d.math.floatClamp(dot, -1, 1);
            var rotangle = Math.acos(dot) * 180 / Math.PI;
            if (rotangle < 0.01) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
                return;
            }
            if (rotangle > 179.9) {
                gd3d.math.quatFromAxisAngle(updir, 180, out);
                return;
            }
            var rotAxis = gd3d.math.pool.new_vector3();
            gd3d.math.vec3Cross(gd3d.math.pool.vector3_forward, dir, rotAxis);
            gd3d.math.vec3Normalize(rotAxis, rotAxis);
            gd3d.math.quatFromAxisAngle(rotAxis, rotangle, out);
        }
        math.quat2Lookat = quat2Lookat;
        function quat2LookRotation(pos, targetpos, upwards, out) {
            var dir = gd3d.math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.quatLookRotation(dir, upwards, out);
        }
        math.quat2LookRotation = quat2LookRotation;
        function quatLookRotation(dir, upwards, out) {
            math.vec3Normalize(dir, dir);
            var ab = math.vec3Dot(dir, gd3d.math.pool.vector3_forward);
            var an_dz = Math.acos(ab);
            var cdz = gd3d.math.pool.new_vector3();
            math.vec3Cross(dir, gd3d.math.pool.vector3_forward, cdz);
            math.vec3Normalize(cdz, cdz);
            if (math.vec3Dot(cdz, gd3d.math.pool.vector3_forward) < 0) {
                an_dz = 2 * Math.PI - an_dz;
            }
            an_dz = 180 / Math.PI * an_dz;
            quatFromAxisAngle(cdz, -an_dz, out);
            var y = gd3d.math.pool.new_vector3();
            quatTransformVector(out, gd3d.math.pool.vector3_up, y);
            var cyw = cdz;
            math.vec3Cross(dir, upwards, cyw);
            math.vec3Normalize(y, y);
            math.vec3Normalize(cyw, cyw);
            var cos2Y = math.vec3Dot(cyw, y);
            var sin2Y = Math.sqrt(1 - cos2Y * cos2Y);
            console.log(math.vec3Dot(y, upwards));
            if (math.vec3Dot(y, upwards) <= 0) {
                sin2Y = -sin2Y;
            }
            var siny = Math.sqrt((1 - sin2Y) / 2);
            var cosy = -Math.sqrt((sin2Y + 1) / 2);
            console.log(cos2Y);
            if (cos2Y < 0) {
                cosy = -cosy;
            }
            var yq = gd3d.math.pool.new_quaternion();
            yq.x = 0;
            yq.y = 0;
            yq.z = siny;
            yq.w = cosy;
            quatMultiply(out, yq, out);
            gd3d.math.pool.delete_vector3(dir);
            gd3d.math.pool.delete_vector3(cdz);
        }
        math.quatLookRotation = quatLookRotation;
        function quatYAxis(pos, targetpos, out) {
            var dir = new math.vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dirxz = new math.vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            quatFromYawPitchRoll(yaw, 0, 0, out);
            math.quatNormalize(out, out);
        }
        math.quatYAxis = quatYAxis;
        function rotationTo(from, to, out) {
            var tmpvec3 = new math.vector3();
            var xUnitVec3 = math.pool.vector3_right;
            var yUnitVec3 = math.pool.vector3_up;
            var dot = math.vec3Dot(from, to);
            if (dot < -0.999999) {
                math.vec3Cross(xUnitVec3, from, tmpvec3);
                if (math.vec3Length(tmpvec3) < 0.000001) {
                    math.vec3Cross(yUnitVec3, from, tmpvec3);
                }
                math.vec3Normalize(tmpvec3, tmpvec3);
                quatFromAxisAngle(tmpvec3, 180, out);
            }
            else if (dot > 0.999999) {
                out[0] = 0;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
            }
            else {
                math.vec3Cross(from, to, tmpvec3);
                out[0] = tmpvec3[0];
                out[1] = tmpvec3[1];
                out[2] = tmpvec3[2];
                out[3] = 1 + dot;
                quatNormalize(out, out);
            }
        }
        math.rotationTo = rotationTo;
        function myLookRotation(dir, out, up) {
            if (up === void 0) { up = math.pool.vector3_up; }
            if (math.vec3Equal(dir, math.pool.vector3_zero)) {
                console.log("Zero direction in MyLookRotation");
                quatIdentity(out);
                return;
            }
            if (!math.vec3Equal(dir, up)) {
                var tempv = new math.vector3();
                math.vec3ScaleByNum(up, math.vec3Dot(up, dir), tempv);
                math.vec3Subtract(dir, tempv, tempv);
                var qu = new math.quaternion();
                this.rotationTo(math.pool.vector3_forward, tempv, qu);
                var qu2 = new math.quaternion();
                this.rotationTo(tempv, dir, qu2);
                quatMultiply(qu, qu2, out);
            }
            else {
                this.rotationTo(math.pool.vector3_forward, dir, out);
            }
        }
        math.myLookRotation = myLookRotation;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function rectSet_One(out) {
            out.x = 0;
            out.y = 0;
            out.w = 1;
            out.h = 1;
        }
        math.rectSet_One = rectSet_One;
        function rectSet_Zero(out) {
            out.x = 0;
            out.y = 0;
            out.w = 0;
            out.h = 0;
        }
        math.rectSet_Zero = rectSet_Zero;
        function rectEqul(src1, src2) {
            return !((src1.x != src2.x) ||
                (src1.y != src2.y) ||
                (src1.w != src2.w) ||
                (src1.h != src2.h));
        }
        math.rectEqul = rectEqul;
        function rectInner(x, y, src) {
            if (x < src.x || x > src.x + src.w ||
                y < src.y || y > src.y + src.h) {
                return false;
            }
            return true;
        }
        math.rectInner = rectInner;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function caclStringByteLength(value) {
            var total = 0;
            for (var i = 0; i < value.length; i++) {
                var charCode = value.charCodeAt(i);
                if (charCode <= 0x007f) {
                    total += 1;
                }
                else if (charCode <= 0x07ff) {
                    total += 2;
                }
                else if (charCode <= 0xffff) {
                    total += 3;
                }
                else {
                    total += 4;
                }
            }
            return total;
        }
        math.caclStringByteLength = caclStringByteLength;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function spriteAnimation(row, column, index, out) {
            var width = 1.0 / column;
            var height = 1.0 / row;
            var offsetx = width * (index % column);
            var offsety = height * (row - height * (Math.floor(index / column) + 1));
            out.x = width;
            out.y = height;
            out.z = offsetx;
            out.w = offsety;
        }
        math.spriteAnimation = spriteAnimation;
        function GetPointAlongCurve(curveStart, curveStartHandle, curveEnd, curveEndHandle, t, out, crease) {
            if (crease === void 0) { crease = 0.3; }
            var oneMinT = 1 - t;
            var oneMinTPow3 = Math.pow(oneMinT, 3);
            var oneMinTPow2 = Math.pow(oneMinT, 2);
            var oneMinCrease = 1 - crease;
            var tempt1 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveStart, oneMinTPow3 * oneMinCrease, tempt1);
            var tempt2 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveStartHandle, 3 * oneMinTPow2 * t * crease, tempt2);
            var tempt3 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveEndHandle, 3 * oneMinT * Math.pow(t, 2) * crease, tempt3);
            var tempt4 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveEnd, Math.pow(t, 3) * oneMinCrease, tempt4);
            var tempt5 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3Add(tempt1, tempt2, tempt5);
            gd3d.math.vec3Add(tempt5, tempt3, tempt5);
            gd3d.math.vec3Add(tempt5, tempt4, tempt5);
            gd3d.math.vec3ScaleByNum(tempt5, 1 / (oneMinTPow3 * oneMinCrease + 3 * oneMinTPow2 * t * crease + 3 * oneMinT * Math.pow(t, 2) * crease + Math.pow(t, 3) * oneMinCrease), out);
            gd3d.math.pool.delete_vector3(tempt1);
            gd3d.math.pool.delete_vector3(tempt2);
            gd3d.math.pool.delete_vector3(tempt3);
            gd3d.math.pool.delete_vector3(tempt4);
            gd3d.math.pool.delete_vector3(tempt5);
        }
        math.GetPointAlongCurve = GetPointAlongCurve;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function vec2Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
        }
        math.vec2Subtract = vec2Subtract;
        function vec2Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
        }
        math.vec2Add = vec2Add;
        function vec2Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
        }
        math.vec2Clone = vec2Clone;
        function vec2Distance(a, b) {
            var out = math.pool.new_vector2();
            vec2Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y);
            math.pool.delete_vector2(out);
            return result;
        }
        math.vec2Distance = vec2Distance;
        function vec2ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
        }
        math.vec2ScaleByNum = vec2ScaleByNum;
        function vec2ScaleByVec2(from, scale, out) {
            out.x = from.x * scale.x;
            out.y = from.y * scale.y;
        }
        math.vec2ScaleByVec2 = vec2ScaleByVec2;
        function vec4Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
            to.z = from.z;
            to.w = from.w;
        }
        math.vec4Clone = vec4Clone;
        function vec2Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y);
        }
        math.vec2Length = vec2Length;
        function vec2SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
        }
        math.vec2SLerp = vec2SLerp;
        function vec4SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
            out.z = vector.z * (1 - v) + vector2.z * v;
            out.w = vector.w * (1 - v) + vector2.w * v;
        }
        math.vec4SLerp = vec4SLerp;
        function vec2Normalize(from, out) {
            var num = vec2Length(from);
            if (num > Number.MIN_VALUE) {
                out.x = from.x / num;
                out.y = from.y / num;
            }
            else {
                out.x = 0;
                out.y = 0;
            }
        }
        math.vec2Normalize = vec2Normalize;
        function vec2Multiply(a, b) {
            return a.x * b.x + a.y * b.y;
        }
        math.vec2Multiply = vec2Multiply;
        function vec2Dot(lhs, rhs) {
            return lhs.x * rhs.x + lhs.y * rhs.y;
        }
        math.vec2Dot = vec2Dot;
        function vec2Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            return true;
        }
        math.vec2Equal = vec2Equal;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function vec3Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
            to.z = from.z;
        }
        math.vec3Clone = vec3Clone;
        function vec3ToString(result) {
            result = this.x + "," + this.y + "," + this.z;
        }
        math.vec3ToString = vec3ToString;
        function vec3Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
        }
        math.vec3Add = vec3Add;
        function vec3Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            out.z = a.z - b.z;
        }
        math.vec3Subtract = vec3Subtract;
        function vec3Minus(a, out) {
            out.x = -a.x;
            out.y = -a.y;
            out.z = -a.z;
        }
        math.vec3Minus = vec3Minus;
        function vec3Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
        }
        math.vec3Length = vec3Length;
        function vec3SqrLength(value) {
            return value.x * value.x + value.y * value.y + value.z * value.z;
        }
        math.vec3SqrLength = vec3SqrLength;
        function vec3Set_One(value) {
            value.x = value.y = value.z = 1;
        }
        math.vec3Set_One = vec3Set_One;
        function vec3Set_Forward(value) {
            value.x = value.y = 0;
            value.z = 1;
        }
        math.vec3Set_Forward = vec3Set_Forward;
        function vec3Set_Back(value) {
            value.x = value.y = 0;
            value.z = -1;
        }
        math.vec3Set_Back = vec3Set_Back;
        function vec3Set_Up(value) {
            value.x = value.z = 0;
            value.y = 1;
        }
        math.vec3Set_Up = vec3Set_Up;
        function vec3Set_Down(value) {
            value.x = value.z = 0;
            value.y = -1;
        }
        math.vec3Set_Down = vec3Set_Down;
        function vec3Set_Left(value) {
            value.x = -1;
            value.y = value.z = 0;
        }
        math.vec3Set_Left = vec3Set_Left;
        function vec3Set_Right(value) {
            value.x = 1;
            value.y = value.z = 0;
        }
        math.vec3Set_Right = vec3Set_Right;
        function vec3Normalize(value, out) {
            var num = vec3Length(value);
            if (num > Number.MIN_VALUE) {
                out.x = value.x / num;
                out.y = value.y / num;
                out.z = value.z / num;
            }
            else {
                out.x = 0;
                out.y = 0;
                out.z = 0;
            }
        }
        math.vec3Normalize = vec3Normalize;
        function vec3ScaleByVec3(from, scale, out) {
            out.x = from.x * scale.x;
            out.y = from.y * scale.y;
            out.z = from.z * scale.z;
        }
        math.vec3ScaleByVec3 = vec3ScaleByVec3;
        function vec3ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
            out.z = from.z * scale;
        }
        math.vec3ScaleByNum = vec3ScaleByNum;
        function vec3Product(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
        }
        math.vec3Product = vec3Product;
        function vec3Cross(lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
        }
        math.vec3Cross = vec3Cross;
        function vec3Reflect(inDirection, inNormal, out) {
            var v1 = 0;
            v1 = vec3Dot(inNormal, inDirection);
            vec3ScaleByNum(out, v1 * -2, out);
            vec3Add(out, inDirection, out);
        }
        math.vec3Reflect = vec3Reflect;
        function vec3Dot(lhs, rhs) {
            return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
        }
        math.vec3Dot = vec3Dot;
        function vec3Project(vector, onNormal, out) {
            var num = 0;
            num = vec3Dot(onNormal, onNormal);
            if (num < Number.MIN_VALUE) {
                out.x = out.y = out.z = 0;
            }
            else {
                var num2 = 0;
                num2 = vec3Dot(vector, onNormal);
                vec3ScaleByNum(onNormal, num2 / num, out);
            }
        }
        math.vec3Project = vec3Project;
        function vec3ProjectOnPlane(vector, planeNormal, out) {
            vec3Project(vector, planeNormal, out);
            vec3Subtract(vector, out, out);
        }
        math.vec3ProjectOnPlane = vec3ProjectOnPlane;
        function vec3Exclude(excludeThis, fromThat, out) {
            vec3Project(fromThat, excludeThis, out);
            vec3Subtract(fromThat, out, out);
        }
        math.vec3Exclude = vec3Exclude;
        function vec3Angle(from, to) {
            var out1 = math.pool.new_vector3();
            var out2 = math.pool.new_vector3();
            vec3Normalize(from, out1);
            vec3Normalize(to, out2);
            var result = vec3Dot(out1, out2);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result) * 57.29578;
            math.pool.delete_vector3(out1);
            math.pool.delete_vector3(out1);
            return result;
        }
        math.vec3Angle = vec3Angle;
        function vec3Distance(a, b) {
            var out = math.pool.new_vector3();
            vec3Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y + out.z * out.z);
            math.pool.delete_vector3(out);
            return result;
        }
        math.vec3Distance = vec3Distance;
        function vec3ClampLength(vector, maxLength, out) {
            var val = 0;
            val = vec3SqrLength(vector);
            if (val > maxLength * maxLength) {
                vec3Normalize(vector, out);
                vec3ScaleByNum(out, maxLength, out);
            }
            out = vector;
        }
        math.vec3ClampLength = vec3ClampLength;
        function vec3Min(lhs, rhs, out) {
            out.x = Math.min(lhs.x, rhs.x);
            out.y = Math.min(lhs.y, rhs.y);
            out.z = Math.min(lhs.z, rhs.z);
        }
        math.vec3Min = vec3Min;
        function vec3Max(lhs, rhs, out) {
            out.x = Math.max(lhs.x, rhs.x);
            out.y = Math.max(lhs.y, rhs.y);
            out.z = Math.max(lhs.z, rhs.z);
        }
        math.vec3Max = vec3Max;
        function vec3AngleBetween(from, to) {
            vec3Normalize(from, from);
            vec3Normalize(to, to);
            var result = vec3Dot(from, to);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result);
            return result;
        }
        math.vec3AngleBetween = vec3AngleBetween;
        function vec3Reset(val) {
            val.x = 0;
            val.y = 0;
            val.z = 0;
        }
        math.vec3Reset = vec3Reset;
        function vec3SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
            out.z = vector.z * (1 - v) + vector2.z * v;
        }
        math.vec3SLerp = vec3SLerp;
        function vec3SetByFloat(x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
        }
        math.vec3SetByFloat = vec3SetByFloat;
        function vec3Format(vector, maxDot, out) {
            out.x = floatFormat(vector.x, maxDot);
            out.y = floatFormat(vector.y, maxDot);
            out.z = floatFormat(vector.z, maxDot);
        }
        math.vec3Format = vec3Format;
        function quaternionFormat(vector, maxDot, out) {
            out.x = floatFormat(vector.x, maxDot);
            out.y = floatFormat(vector.y, maxDot);
            out.z = floatFormat(vector.z, maxDot);
            out.w = floatFormat(vector.w, maxDot);
        }
        math.quaternionFormat = quaternionFormat;
        function floatFormat(num, maxDot) {
            var vv = Math.pow(10, maxDot);
            return Math.round(num * vv) / vv;
        }
        math.floatFormat = floatFormat;
        function vec3Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            if (Math.abs(vector.z - vector2.z) > threshold)
                return false;
            return true;
        }
        math.vec3Equal = vec3Equal;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var navVec3 = (function () {
            function navVec3() {
                this.x = 0;
                this.y = 0;
                this.z = 0;
            }
            navVec3.prototype.clone = function () {
                var navVec = new navVec3();
                navVec.x = this.x;
                navVec.y = this.y;
                navVec.z = this.z;
                return navVec;
            };
            navVec3.DistAZ = function (start, end) {
                var num = end.x - start.x;
                var num2 = end.z - start.z;
                return Math.sqrt(num * num + num2 * num2);
            };
            navVec3.NormalAZ = function (start, end) {
                var num = end.x - start.x;
                var num2 = end.z - start.z;
                var num3 = Math.sqrt(num * num + num2 * num2);
                var navVec = new navVec3();
                navVec.x = num / num3;
                navVec.y = 0.0;
                navVec.z = num2 / num3;
                return navVec;
            };
            navVec3.Cross = function (start, end) {
                var navVec = new navVec3();
                navVec.x = start.y * end.z - start.z * end.y;
                navVec.y = start.z * end.x - start.x * end.z;
                navVec.z = start.x * end.y - start.y * end.x;
                return navVec;
            };
            navVec3.DotAZ = function (start, end) {
                return start.x * end.x + start.z * end.z;
            };
            navVec3.Angle = function (start, end) {
                var d = start.x * end.x + start.z * end.z;
                var navVec = navVec3.Cross(start, end);
                var num = Math.acos(d);
                var flag = navVec.y < 0.0;
                if (flag) {
                    num = -num;
                }
                return num;
            };
            navVec3.Border = function (start, end, dist) {
                var navVec = navVec3.NormalAZ(start, end);
                var navVec2 = new navVec3();
                navVec2.x = start.x + navVec.x * dist;
                navVec2.y = start.y + navVec.y * dist;
                navVec2.z = start.z + navVec.z * dist;
                return navVec2;
            };
            return navVec3;
        }());
        framework.navVec3 = navVec3;
        var navNode = (function () {
            function navNode() {
                this.nodeID = 0;
                this.poly = null;
                this.borderByPoly = null;
                this.borderByPoint = null;
                this.center = null;
            }
            navNode.prototype.genBorder = function () {
                var list = [];
                for (var i = 0; i < this.poly.length; i = i + 1) {
                    var num = i;
                    var num2 = i + 1;
                    var flag = num2 >= this.poly.length;
                    if (flag) {
                        num2 = 0;
                    }
                    var num3 = this.poly[num];
                    var num4 = this.poly[num2];
                    var flag2 = num3 < num4;
                    if (flag2) {
                        list.push(num3 + "-" + num4);
                    }
                    else {
                        list.push(num4 + "-" + num3);
                    }
                }
                this.borderByPoint = list;
            };
            navNode.prototype.isLinkTo = function (info, nid) {
                var flag = this.nodeID === nid;
                var result;
                if (flag) {
                    result = null;
                }
                else {
                    var flag2 = nid < 0;
                    if (flag2) {
                        result = null;
                    }
                    else {
                        var array = this.borderByPoly;
                        for (var i = 0; i < array.length; i = i + 1) {
                            var text = array[i];
                            var flag3 = (info.borders[text] == undefined);
                            if (!flag3) {
                                var flag4 = info.borders[text].nodeA === nid || info.borders[text].nodeB === nid;
                                if (flag4) {
                                    result = text;
                                    return result;
                                }
                            }
                        }
                        result = null;
                    }
                }
                return result;
            };
            navNode.prototype.getLinked = function (info) {
                var list = [];
                var array = this.borderByPoly;
                for (var i = 0; i < array.length; i = i + 1) {
                    var key = array[i];
                    var flag = (info.borders[key] == undefined);
                    if (!flag) {
                        var flag2 = info.borders[key].nodeA === this.nodeID;
                        var num;
                        if (flag2) {
                            num = info.borders[key].nodeB;
                        }
                        else {
                            num = info.borders[key].nodeA;
                        }
                        var flag3 = num >= 0;
                        if (flag3) {
                            list.push(num);
                        }
                    }
                }
                return list;
            };
            navNode.prototype.genCenter = function (info) {
                this.center = new navVec3();
                this.center.x = 0.0;
                this.center.y = 0.0;
                this.center.z = 0.0;
                var array = this.poly;
                for (var i = 0; i < array.length; i = i + 1) {
                    var num = array[i];
                    this.center.x += info.vecs[num].x;
                    this.center.y += info.vecs[num].y;
                    this.center.z += info.vecs[num].z;
                }
                this.center.x /= this.poly.length;
                this.center.y /= this.poly.length;
                this.center.z /= this.poly.length;
            };
            return navNode;
        }());
        framework.navNode = navNode;
        var navBorder = (function () {
            function navBorder() {
                this.borderName = null;
                this.nodeA = 0;
                this.nodeB = 0;
                this.pointA = 0;
                this.pointB = 0;
                this.length = 0;
                this.center = null;
            }
            return navBorder;
        }());
        framework.navBorder = navBorder;
        var navMeshInfo = (function () {
            function navMeshInfo() {
                this.vecs = null;
                this.nodes = null;
                this.borders = null;
                this.min = null;
                this.max = null;
            }
            navMeshInfo.prototype.calcBound = function () {
                this.min = new navVec3();
                this.max = new navVec3();
                this.min.x = 1.7976931348623157E+308;
                this.min.y = 1.7976931348623157E+308;
                this.min.z = 1.7976931348623157E+308;
                this.max.x = -1.7976931348623157E+308;
                this.max.y = -1.7976931348623157E+308;
                this.max.z = -1.7976931348623157E+308;
                for (var i = 0; i < this.vecs.length; i = i + 1) {
                    var flag = this.vecs[i].x < this.min.x;
                    if (flag) {
                        this.min.x = this.vecs[i].x;
                    }
                    var flag2 = this.vecs[i].y < this.min.y;
                    if (flag2) {
                        this.min.y = this.vecs[i].y;
                    }
                    var flag3 = this.vecs[i].z < this.min.z;
                    if (flag3) {
                        this.min.z = this.vecs[i].z;
                    }
                    var flag4 = this.vecs[i].x > this.max.x;
                    if (flag4) {
                        this.max.x = this.vecs[i].x;
                    }
                    var flag5 = this.vecs[i].y > this.max.y;
                    if (flag5) {
                        this.max.y = this.vecs[i].y;
                    }
                    var flag6 = this.vecs[i].z > this.max.z;
                    if (flag6) {
                        this.max.z = this.vecs[i].z;
                    }
                }
            };
            navMeshInfo.cross = function (p0, p1, p2) {
                return (p1.x - p0.x) * (p2.z - p0.z) - (p2.x - p0.x) * (p1.z - p0.z);
            };
            navMeshInfo.prototype.inPoly = function (p, poly) {
                var num = 0;
                var flag = poly.length < 3;
                var result;
                if (flag) {
                    result = false;
                }
                else {
                    var flag2 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[1]]) < (-num);
                    if (flag2) {
                        result = false;
                    }
                    else {
                        var flag3 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[poly.length - 1]]) > num;
                        if (flag3) {
                            result = false;
                        }
                        else {
                            var i = 2;
                            var num2 = poly.length - 1;
                            var num3 = -1;
                            while (i <= num2) {
                                var num4 = i + num2 >> 1;
                                var flag4 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[num4]]) < (-num);
                                if (flag4) {
                                    num3 = num4;
                                    num2 = num4 - 1;
                                }
                                else {
                                    i = num4 + 1;
                                }
                            }
                            var num5 = navMeshInfo.cross(this.vecs[poly[num3 - 1]], p, this.vecs[poly[num3]]);
                            result = (num5 > num);
                        }
                    }
                }
                return result;
            };
            navMeshInfo.prototype.genBorder = function () {
                var __border = {};
                for (var i0 = 0; i0 < this.nodes.length; i0 = i0 + 1) {
                    var n = this.nodes[i0];
                    for (var i1 = 0; i1 < n.borderByPoint.length; i1 = i1 + 1) {
                        var b = n.borderByPoint[i1];
                        if (__border[b] == undefined) {
                            __border[b] = new navBorder();
                            __border[b].borderName = b;
                            __border[b].nodeA = n.nodeID;
                            __border[b].nodeB = -1;
                            __border[b].pointA = -1;
                        }
                        else {
                            __border[b].nodeB = n.nodeID;
                            if (__border[b].nodeA > __border[b].nodeB) {
                                __border[b].nodeB = __border[b].nodeA;
                                __border[b].nodeB = n.nodeID;
                            }
                            var na = this.nodes[__border[b].nodeA];
                            var nb = this.nodes[__border[b].nodeB];
                            for (var i2 = 0; i2 < na.poly.length; i2 = i2 + 1) {
                                var i = na.poly[i2];
                                if (nb.poly.indexOf(i) >= 0) {
                                    if (__border[b].pointA == -1)
                                        __border[b].pointA = i;
                                    else
                                        __border[b].pointB = i;
                                }
                            }
                            var left = __border[b].pointA;
                            var right = __border[b].pointB;
                            var xd = this.vecs[left].x - this.vecs[right].x;
                            var yd = this.vecs[left].y - this.vecs[right].y;
                            var zd = this.vecs[left].z - this.vecs[right].z;
                            __border[b].length = Math.sqrt(xd * xd + yd * yd + zd * zd);
                            __border[b].center = new navVec3();
                            __border[b].center.x = this.vecs[left].x * 0.5 + this.vecs[right].x * 0.5;
                            __border[b].center.y = this.vecs[left].y * 0.5 + this.vecs[right].y * 0.5;
                            __border[b].center.z = this.vecs[left].z * 0.5 + this.vecs[right].z * 0.5;
                            __border[b].borderName = __border[b].nodeA + "-" + __border[b].nodeB;
                        }
                    }
                }
                var namechange = {};
                for (var key in __border) {
                    if (__border[key].nodeB < 0) {
                    }
                    else {
                        namechange[key] = __border[key].borderName;
                    }
                }
                this.borders = {};
                for (var key in __border) {
                    if (namechange[key] != undefined) {
                        this.borders[namechange[key]] = __border[key];
                    }
                }
                for (var m = 0; m < this.nodes.length; m = m + 1) {
                    var v = this.nodes[m];
                    var newborder = [];
                    for (var nnn = 0; nnn < v.borderByPoint.length; nnn = nnn + 1) {
                        var b = v.borderByPoint[nnn];
                        if (namechange[b] != undefined) {
                            newborder.push(namechange[b]);
                        }
                    }
                    v.borderByPoly = newborder;
                }
            };
            navMeshInfo.LoadMeshInfo = function (s) {
                var j = JSON.parse(s);
                var info = new navMeshInfo();
                var listVec = [];
                for (var jsonid in j["v"]) {
                    var v3 = new navVec3();
                    v3.x = j["v"][jsonid][0];
                    v3.y = j["v"][jsonid][1];
                    v3.z = j["v"][jsonid][2];
                    listVec.push(v3);
                }
                info.vecs = listVec;
                var polys = [];
                var list = j["p"];
                for (var i = 0; i < list.length; i++) {
                    var json = list[i];
                    var node = new navNode();
                    node.nodeID = i;
                    var poly = [];
                    for (var tt in json) {
                        poly.push(json[tt]);
                    }
                    node.poly = poly;
                    node.genBorder();
                    node.genCenter(info);
                    polys.push(node);
                }
                info.nodes = polys;
                info.calcBound();
                info.genBorder();
                return info;
            };
            return navMeshInfo;
        }());
        framework.navMeshInfo = navMeshInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Navigate = (function () {
            function Navigate(navinfo, navindexmap) {
                this.navinfo = navinfo;
                this.navindexmap = navindexmap;
            }
            Navigate.prototype.pathPoints = function (start, end, startIndex, endIndex) {
                var startVec = new framework.navVec3();
                startVec.x = start.x;
                startVec.y = start.y;
                startVec.z = start.z;
                var endVec = new framework.navVec3();
                endVec.x = end.x;
                endVec.y = end.y;
                endVec.z = end.z;
                var startPoly = this.navindexmap[startIndex];
                var endPoly = this.navindexmap[endIndex];
                if (startPoly >= 0 && endPoly >= 0) {
                    var polyPath = gd3d.framework.pathFinding.calcAStarPolyPath(this.navinfo, startPoly, endPoly, endVec, 0.3);
                }
                if (polyPath) {
                    var wayPoints = gd3d.framework.pathFinding.calcWayPoints(this.navinfo, startVec, endVec, polyPath);
                    var navmeshWayPoints = [];
                    for (var i = 0; i < wayPoints.length; i++) {
                        navmeshWayPoints[i] = new gd3d.math.vector3(wayPoints[i].x, wayPoints[i].y, wayPoints[i].z);
                    }
                    return navmeshWayPoints;
                }
                else {
                    return null;
                }
            };
            Navigate.prototype.dispose = function () {
                this.navinfo = null;
                this.navindexmap = null;
            };
            return Navigate;
        }());
        framework.Navigate = Navigate;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var NavMeshLoadManager = (function () {
            function NavMeshLoadManager() {
                this.navMeshVertexOffset = new gd3d.math.vector3(0, 0, 0);
            }
            NavMeshLoadManager.prototype.loadNavMesh = function (navMeshUrl, app, onstate) {
                var _this = this;
                if (!app)
                    return;
                this.app = app;
                if (this.navTrans)
                    this.navTrans.parent.removeChild(this.navTrans);
                app.getAssetMgr().load(navMeshUrl, gd3d.framework.AssetTypeEnum.Auto, function (s) {
                    if (s.isfinish) {
                        var data = app.getAssetMgr().getAssetByName(navMeshUrl.substring(navMeshUrl.lastIndexOf("/") + 1));
                        _this.navmeshLoaded(data.content, function () {
                            if (onstate) {
                                onstate(s);
                            }
                        });
                    }
                    else if (s.iserror) {
                        if (onstate) {
                            onstate(s);
                        }
                    }
                });
            };
            NavMeshLoadManager.prototype.navmeshLoaded = function (dataStr, callback) {
                console.warn("navmeshLoaded");
                if (this.navMesh != null) {
                }
                this.navTrans = new gd3d.framework.transform();
                this.navTrans.name = "navMesh";
                var meshD = new gd3d.render.meshData();
                meshD.pos = [];
                meshD.trisindex = [];
                var navinfo = gd3d.framework.navMeshInfo.LoadMeshInfo(dataStr);
                for (var i = 0; i < navinfo.vecs.length; i++) {
                    var v = navinfo.vecs[i];
                    var X = v.x - this.navMeshVertexOffset.x;
                    var Y = v.y - this.navMeshVertexOffset.y;
                    var Z = v.z - this.navMeshVertexOffset.z;
                    meshD.pos[i] = new gd3d.math.vector3(X, Y, Z);
                }
                var navindexmap = {};
                var indexDatas = [];
                for (var i = 0; i < navinfo.nodes.length; i++) {
                    var poly = navinfo.nodes[i].poly;
                    for (var fc = 0; fc < poly.length - 2; fc++) {
                        var sindex = indexDatas.length / 3;
                        navindexmap[sindex] = i;
                        indexDatas.push(poly[0]);
                        indexDatas.push(poly[fc + 2]);
                        indexDatas.push(poly[fc + 1]);
                    }
                }
                meshD.trisindex = indexDatas;
                var meshFiter = this.navTrans.gameObject.addComponent("meshFilter");
                this.navMesh = this.createMesh(meshD, this.app.webgl);
                meshFiter.mesh = this.navMesh;
                this.app.getScene().addChild(this.navTrans);
                this.navTrans.markDirty();
                this.navigate = new gd3d.framework.Navigate(navinfo, navindexmap);
                callback();
            };
            NavMeshLoadManager.prototype.createMesh = function (meshData, webgl) {
                var _mesh = new gd3d.framework.mesh();
                _mesh.data = meshData;
                var vf = gd3d.render.VertexFormatMask.Position;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArray();
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexSubData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new gd3d.framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = false;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            NavMeshLoadManager.prototype.showNavmesh = function (isshow, material) {
                if (material === void 0) { material = null; }
                if (this.navTrans) {
                    if (!isshow) {
                        this.navTrans.gameObject.visible = isshow;
                        this.navTrans.localTranslate = new gd3d.math.vector3(0, 0, 0);
                        this.navTrans.markDirty();
                        return;
                    }
                    var compent = this.navTrans.gameObject.getComponent("meshRenderer");
                    if (compent == null) {
                        compent = this.navTrans.gameObject.addComponent("meshRenderer");
                        if (material) {
                            compent.materials = [];
                            compent.materials[0] = material;
                        }
                    }
                    this.navTrans.localTranslate = new gd3d.math.vector3(0, 0, 0);
                    this.navTrans.markDirty();
                }
            };
            NavMeshLoadManager.prototype.dispose = function () {
                if (this.navTrans) {
                    this.navTrans.parent.removeChild(this.navTrans);
                    this.navTrans.dispose();
                    this.navTrans = null;
                    this.navMesh.dispose();
                    this.navMesh = null;
                    this.navigate.dispose();
                    this.navigate = null;
                }
            };
            Object.defineProperty(NavMeshLoadManager, "Instance", {
                get: function () {
                    if (NavMeshLoadManager._instance == null)
                        NavMeshLoadManager._instance = new NavMeshLoadManager();
                    return NavMeshLoadManager._instance;
                },
                enumerable: true,
                configurable: true
            });
            NavMeshLoadManager.prototype.moveToPoints = function (startPos, endPos) {
                var navTrans = NavMeshLoadManager.Instance.navTrans;
                var nav = NavMeshLoadManager.Instance.navigate;
                if (!nav)
                    return;
                var StratIndex = NavMeshLoadManager.findtriIndex(startPos, navTrans);
                if (StratIndex == undefined) {
                    var dir = new gd3d.math.vector3();
                    var direc = new gd3d.math.vector3();
                    gd3d.math.vec3Subtract(endPos, startPos, dir);
                    gd3d.math.vec3Normalize(dir, dir);
                    for (var i = 0; i < 5; i++) {
                        gd3d.math.vec3Clone(dir, direc);
                        gd3d.math.vec3ScaleByNum(direc, (i + 1) * 2, direc);
                        var pos = new gd3d.math.vector3();
                        gd3d.math.vec3Add(startPos, direc, pos);
                        StratIndex = NavMeshLoadManager.findtriIndex(pos, navTrans);
                        if (StratIndex != undefined)
                            break;
                    }
                }
                var endIndex = NavMeshLoadManager.findtriIndex(endPos, navTrans);
                var points = nav.pathPoints(startPos, endPos, StratIndex, endIndex);
                return points;
            };
            NavMeshLoadManager.findtriIndex = function (point, trans) {
                var pickinfo;
                var ray = new gd3d.framework.ray(new gd3d.math.vector3(point.x, point.y + 500, point.z), new gd3d.math.vector3(0, -1, 0));
                var mesh;
                var meshFilter = trans.gameObject.getComponent("meshFilter");
                if (meshFilter != null) {
                    mesh = meshFilter.getMeshOutput();
                }
                if (!mesh)
                    return;
                pickinfo = mesh.intersects(ray, trans.getWorldMatrix());
                if (!pickinfo)
                    return;
                return pickinfo.faceId;
            };
            return NavMeshLoadManager;
        }());
        framework.NavMeshLoadManager = NavMeshLoadManager;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var FindNode = (function () {
            function FindNode() {
                this.nodeid = 0;
                this.pathSessionId = 0;
                this.ParentID = -1;
                this.Open = false;
                this.HValue = 0;
                this.GValue = 0;
                this.ArrivalWall = 0;
            }
            FindNode.prototype.CalcHeuristic = function (info, endPos) {
                var center = info.nodes[this.nodeid].center;
                var num = Math.abs(center.x - endPos.x);
                var num2 = Math.abs(center.z - endPos.z);
                this.HValue = Math.sqrt(num * num + num2 * num2);
            };
            FindNode.prototype.GetCost = function (info, neighborID) {
                var bc = info.nodes[neighborID].center;
                var nc = info.nodes[this.nodeid].center;
                var xd = bc.x - nc.x;
                var yd = bc.y - nc.y;
                var zd = bc.z - nc.z;
                var d = Math.sqrt(xd * xd + yd * yd + zd * zd);
                return d;
            };
            return FindNode;
        }());
        var pathFinding = (function () {
            function pathFinding() {
            }
            pathFinding.calcAStarPolyPath = function (info, startPoly, endPoly, endPos, offset) {
                if (endPos === void 0) { endPos = null; }
                if (offset === void 0) { offset = 0.1; }
                var nodeFind = [];
                var nodes = info.nodes;
                for (var i = 0; i < nodes.length; i = i + 1) {
                    var navNode = nodes[i];
                    var findNode = new FindNode();
                    findNode.nodeid = navNode.nodeID;
                    nodeFind.push(findNode);
                }
                var flag = endPos === null;
                if (flag) {
                    endPos = info.nodes[endPoly].center.clone();
                }
                var findNode2 = nodeFind[startPoly];
                findNode2.nodeid = startPoly;
                var num = 1;
                var flag2 = false;
                var openList = [];
                var list2 = [];
                findNode2.pathSessionId = num;
                openList.push(startPoly);
                var sortfun = function (x, y) {
                    var xFvalue = nodeFind[x].HValue + nodeFind[x].GValue;
                    var yFvalue = nodeFind[y].HValue + nodeFind[y].GValue;
                    if (xFvalue < yFvalue - 0.001)
                        return 1;
                    if (xFvalue > yFvalue + 0.001)
                        return -1;
                    return 0;
                };
                while (openList.length > 0) {
                    var findNode3 = nodeFind[openList[openList.length - 1]];
                    openList.splice(openList.length - 1, 1);
                    list2.push(findNode3.nodeid);
                    var flag3 = findNode3.nodeid === endPoly;
                    if (flag3) {
                        flag2 = true;
                        break;
                    }
                    var linked = info.nodes[findNode3.nodeid].getLinked(info);
                    for (var j = 0; j < linked.length; j = j + 1) {
                        var num2 = linked[j];
                        var flag4 = num2 < 0;
                        if (!flag4) {
                            var findNode4 = nodeFind[num2];
                            var flag5 = findNode4 === null || findNode4.nodeid !== num2;
                            if (flag5) {
                                return null;
                            }
                            var flag6 = findNode4.pathSessionId !== num;
                            if (flag6) {
                                var text = info.nodes[findNode4.nodeid].isLinkTo(info, findNode3.nodeid);
                                var flag7 = text !== null && info.borders[text].length >= offset * 2;
                                if (flag7) {
                                    findNode4.pathSessionId = num;
                                    findNode4.ParentID = findNode3.nodeid;
                                    findNode4.Open = true;
                                    findNode4.CalcHeuristic(info, endPos);
                                    findNode4.GValue = findNode3.GValue + findNode3.GetCost(info, findNode4.nodeid);
                                    openList.push(findNode4.nodeid);
                                    openList.sort(sortfun);
                                    findNode4.ArrivalWall = findNode3.nodeid;
                                }
                            }
                            else {
                                var open = findNode4.Open;
                                if (open) {
                                    var flag8 = findNode4.GValue + findNode4.GetCost(info, findNode3.nodeid) < findNode3.GValue;
                                    if (flag8) {
                                        findNode3.GValue = findNode4.GValue + findNode4.GetCost(info, findNode3.nodeid);
                                        findNode3.ParentID = findNode4.nodeid;
                                        findNode3.ArrivalWall = findNode4.nodeid;
                                    }
                                }
                            }
                        }
                    }
                }
                var list3 = [];
                var flag9 = list2.length > 0;
                if (flag9) {
                    var findNode5 = nodeFind[list2[list2.length - 1]];
                    list3.push(findNode5.nodeid);
                    while (findNode5.ParentID !== -1) {
                        list3.push(findNode5.ParentID);
                        findNode5 = nodeFind[findNode5.ParentID];
                    }
                }
                return list3;
            };
            pathFinding.NearAngle = function (a, b) {
                var num = a;
                var flag = a >= 180.0;
                if (flag) {
                    num = 360.0 - a;
                }
                var num2 = b;
                var flag2 = b >= 180.0;
                if (flag2) {
                    num2 = 360.0 - b;
                }
                var flag3 = num < num2;
                var result;
                if (flag3) {
                    result = a;
                }
                else {
                    result = b;
                }
                return result;
            };
            pathFinding.FindPath = function (info, startPos, endPos, offset) {
                if (offset === void 0) { offset = 0.1; }
                var startPoly = -1;
                var endPoly = -1;
                for (var i = 0; i < info.nodes.length; i = i + 1) {
                    var flag = info.inPoly(startPos, info.nodes[i].poly);
                    if (flag) {
                        startPoly = i;
                    }
                    var flag2 = info.inPoly(startPos, info.nodes[i].poly);
                    if (flag2) {
                        endPoly = i;
                    }
                }
                var polyPath = pathFinding.calcAStarPolyPath(info, startPoly, endPoly, endPos, offset);
                return pathFinding.calcWayPoints(info, startPos, endPos, polyPath, offset);
            };
            pathFinding.calcWayPoints = function (info, startPos, endPos, polyPath, offset) {
                if (offset === void 0) { offset = 0.1; }
                var wayPoints = [];
                if (polyPath.length == 0 || startPos == null || endPos == null) {
                    return null;
                }
                var triPathList = polyPath.reverse();
                wayPoints.push(startPos);
                var ipoly = 0;
                var dirLeft = null;
                var ipolyLeft = -1;
                var dirRight = null;
                var ipolyRight = -1;
                var breakDir = 0;
                var posLeft = null;
                var posRight = null;
                var posNow = startPos.clone();
                for (var c = 0; c < 100; c++) {
                    for (var i = ipoly; i < triPathList.length; i++) {
                        if (i === triPathList.length - 1) {
                            if (dirLeft == null || dirRight == null) {
                                breakDir = 0;
                                break;
                            }
                            else {
                                var dirFinal = gd3d.framework.navVec3.NormalAZ(posNow, endPos);
                                var a1 = gd3d.framework.navVec3.Angle(dirLeft, dirFinal);
                                var b1 = gd3d.framework.navVec3.Angle(dirRight, dirFinal);
                                var flag4 = a1 * b1 > 0.0;
                                if (a1 * b1 > 0.0) {
                                    if (a1 > 0.0) {
                                        breakDir = 1;
                                    }
                                    else {
                                        breakDir = -1;
                                    }
                                }
                                else {
                                    breakDir = 0;
                                    break;
                                }
                            }
                        }
                        else {
                            var n1 = triPathList[i];
                            var n2 = triPathList[i + 1];
                            var bname = n1 + "-" + n2;
                            if (n2 < n1) {
                                bname = n2 + "-" + n1;
                            }
                            var border = info.borders[bname];
                            var pointA = gd3d.framework.navVec3.Border(info.vecs[border.pointA], info.vecs[border.pointB], offset);
                            var pointB = gd3d.framework.navVec3.Border(info.vecs[border.pointB], info.vecs[border.pointA], offset);
                            var dist1 = gd3d.framework.navVec3.DistAZ(posNow, pointA);
                            var dist2 = gd3d.framework.navVec3.DistAZ(posNow, pointB);
                            if (dist1 < 0.001 || dist2 < 0.001) {
                                continue;
                            }
                            if (dirLeft == null) {
                                dirLeft = gd3d.framework.navVec3.NormalAZ(posNow, pointA);
                                posLeft = pointA.clone();
                                ipolyLeft = i;
                            }
                            if (dirRight == null) {
                                dirRight = gd3d.framework.navVec3.NormalAZ(posNow, pointB);
                                posRight = pointB.clone();
                                ipolyRight = i;
                            }
                            var adir = gd3d.framework.navVec3.Angle(dirLeft, dirRight);
                            if (adir < 0.0) {
                                var navVec7 = dirLeft;
                                var navVec8 = posLeft;
                                var num12 = ipolyLeft;
                                dirLeft = dirRight;
                                posLeft = posRight;
                                ipolyLeft = ipolyRight;
                                dirRight = navVec7;
                                posRight = navVec8;
                                ipolyRight = num12;
                            }
                            if (ipolyLeft != i || ipolyRight != i) {
                                var ndirLeft = gd3d.framework.navVec3.NormalAZ(posNow, pointA);
                                var ndirRight = gd3d.framework.navVec3.NormalAZ(posNow, pointB);
                                var nadir = gd3d.framework.navVec3.Angle(ndirLeft, ndirRight);
                                if (nadir < 0.0) {
                                    var navVec11 = ndirLeft;
                                    var navVec12 = pointA;
                                    ndirLeft = ndirRight;
                                    pointA = pointB;
                                    ndirRight = navVec11;
                                    pointB = navVec12;
                                }
                                var aLL = gd3d.framework.navVec3.Angle(dirLeft, ndirLeft);
                                var aRL = gd3d.framework.navVec3.Angle(dirRight, ndirLeft);
                                var aLR = gd3d.framework.navVec3.Angle(dirLeft, ndirRight);
                                var aRR = gd3d.framework.navVec3.Angle(dirRight, ndirRight);
                                if ((aLL < 0 && aLR < 0)) {
                                    breakDir = -1;
                                    break;
                                }
                                if (aRL > 0.0 && aRR > 0.0) {
                                    breakDir = 1;
                                    break;
                                }
                                if (aLL > 0.0 && aRL < 0.0) {
                                    dirLeft = ndirLeft;
                                    posLeft = pointA;
                                    ipolyLeft = i;
                                }
                                if (aLR > 0.0 && aRR < 0.0) {
                                    dirRight = ndirRight;
                                    posRight = pointB;
                                    ipolyRight = i;
                                }
                            }
                        }
                    }
                    if (breakDir == 0) {
                        break;
                    }
                    else {
                        if (breakDir == -1) {
                            wayPoints.push(posLeft.clone());
                            posNow = posLeft;
                            ipoly = ipolyLeft;
                        }
                        else {
                            wayPoints.push(posRight.clone());
                            posNow = posRight;
                            ipoly = ipolyRight;
                        }
                        dirLeft = null;
                        dirRight = null;
                        ipolyLeft = -1;
                        ipolyRight = -1;
                    }
                }
                wayPoints.push(endPos);
                return wayPoints;
            };
            return pathFinding;
        }());
        framework.pathFinding = pathFinding;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var RVOManager = (function () {
            function RVOManager() {
                this.sim = new RVO.Simulator(1, 60, 20, 20, 5, 1.0, 0.1, [0, 0]);
                this.transforms = [];
                this.goals = [];
                this.radius = [];
                this.attackRanges = [];
                this.speeds = [];
                this.map = {};
                this.isRunning = false;
                this.currMoveDir = new gd3d.math.vector2();
                this._RoadPoints = [];
            }
            RVOManager.prototype.setRoadPoints = function (goalQueue) {
                var _this = this;
                if (!goalQueue || goalQueue.length < 1)
                    return;
                this._RoadPoints.forEach(function (sub) {
                    if (sub && sub != _this.lastGoal)
                        gd3d.math.pool.delete_vector3(sub);
                });
                this._RoadPoints.length = 0;
                for (var i = 0; i < goalQueue.length; i++) {
                    var v3 = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Clone(goalQueue[i], v3);
                    this._RoadPoints.push(v3);
                }
                this.currGoal = this._RoadPoints.pop();
                this.goals[0][0] = this.currGoal.x;
                this.goals[0][1] = this.currGoal.z;
            };
            RVOManager.prototype.addAgent = function (key, transform, radius, attackRanges, speed) {
                var index = this.sim.agents.length;
                var current_position = [transform.localTranslate.x, transform.localTranslate.z];
                this.transforms.push(transform);
                this.attackRanges.push(attackRanges);
                this.radius.push(radius);
                this.speeds.push(speed);
                this.goals.push(current_position);
                this.sim.addAgent(current_position);
                this.sim.agents[index].id = key;
                this.sim.agents[index].radius = radius;
                this.sim.agents[index].maxSpeed = speed;
                this.map[key] = index;
                if (index == 0) {
                    this.sim.agents[0].neighborDist = 0;
                }
                this.isRunning = true;
            };
            RVOManager.prototype.removeAgent = function (key) {
                var offset = this.map[key];
                this.transforms.splice(offset, 1);
                this.attackRanges.splice(offset, 1);
                this.radius.splice(offset, 1);
                this.speeds.splice(offset, 1);
                this.goals.splice(offset, 1);
                this.sim.agents.splice(offset, 1);
                this.reBuildHashMap();
            };
            RVOManager.prototype.reBuildHashMap = function () {
                for (var i = 0; i < this.sim.agents.length; i++) {
                    this.map[this.sim.agents[i].id] = i;
                }
                this.sim.kdTree.agents = [];
                this.sim.kdTree.agentTree = [];
                this.sim.kdTree.obstacleTree = 0;
            };
            RVOManager.prototype.getTransformByKey = function (key) {
                var offset = this.map[key];
                return this.transforms[offset];
            };
            RVOManager.prototype.setRadius = function (id, value) {
                var i = this.map[id];
                this.sim.agents[i].radius = value;
            };
            RVOManager.prototype.setSpeed = function (id, value) {
                var i = this.map[id];
                this.sim.agents[i].maxSpeed = value;
            };
            RVOManager.prototype.setAttackRange = function (id, value) {
                var i = this.map[id];
                this.attackRanges[i] = value;
            };
            RVOManager.prototype.disable = function () {
                this.isRunning = false;
            };
            RVOManager.prototype.enable = function () {
                this.isRunning = true;
                for (var i in this.transforms) {
                    this.sim.agents[i].position = [this.transforms[i].localTranslate.x, this.transforms[i].localTranslate.z];
                }
            };
            RVOManager.prototype.update = function () {
                if (this.isRunning && (this.transforms.length >= 1)) {
                    this.RVO_check(this.sim, this.goals);
                    this.RVO_walking(this.sim, this.goals);
                    this.updateTransform(this.sim);
                }
            };
            RVOManager.prototype.isAlmostStatic = function () {
                var threshold = 0.1;
                var amount = 0;
                for (var i = 0; i < this.sim.agents.length; i++) {
                    if (this.sim.agents[i].prefVelocity != null) {
                        if (this.sim.agents[i].prefVelocity[0] < 0.01 && this.sim.agents[i].prefVelocity[1] < 0.01) {
                            amount++;
                        }
                    }
                }
                if (amount / this.sim.agents.length >= threshold) {
                    return true;
                }
                return false;
            };
            RVOManager.prototype.RVO_walking = function (sim, goals) {
                for (var i = 0, len = sim.agents.length; i < len; i++) {
                    if (sim.agents[i] != null) {
                        var goalVector = RVO.Vector.subtract(goals[i], sim.agents[i].position);
                        if (RVO.Vector.absSq(goalVector) > 1) {
                            goalVector = RVO.Vector.normalize(goalVector);
                        }
                        sim.agents[i].prefVelocity = goalVector;
                    }
                }
                sim.doStep();
            };
            RVOManager.prototype.updateTransform = function (sim) {
                for (var i = 0; i < sim.agents.length; i++) {
                    this.transforms[i].localTranslate.x = sim.agents[i].position[0];
                    this.transforms[i].localTranslate.z = sim.agents[i].position[1];
                    if (i == 0 && this.currGoal && this.lastGoal) {
                        var pos = this.transforms[i].localTranslate;
                        var nowDir = gd3d.math.pool.new_vector2();
                        this.cal2dDir(this.lastGoal, pos, nowDir);
                        var nowLen = gd3d.math.vec2Length(nowDir);
                        var tLen = gd3d.math.vec2Length(this.currMoveDir);
                        var y = gd3d.math.numberLerp(this.lastGoal.y, this.currGoal.y, nowLen / tLen);
                        if (!isNaN(y)) {
                            pos.y = gd3d.math.numberLerp(this.lastGoal.y, this.currGoal.y, nowLen / tLen);
                        }
                        gd3d.math.pool.delete_vector2(nowDir);
                    }
                    this.transforms[i].markDirty();
                }
            };
            RVOManager.prototype.RVO_check = function (sim, goals) {
                if (this.currGoal) {
                    var player = this.transforms[0];
                    var v2_0 = gd3d.math.pool.new_vector2();
                    v2_0.x = player.localTranslate.x;
                    v2_0.y = player.localTranslate.z;
                    var v2_1 = gd3d.math.pool.new_vector2();
                    v2_1.x = this.currGoal.x;
                    v2_1.y = this.currGoal.z;
                    var dis = gd3d.math.vec2Distance(v2_0, v2_1);
                    if (dis < 0.01) {
                        if (this.currGoal) {
                            if (this.lastGoal)
                                gd3d.math.pool.delete_vector3(this.lastGoal);
                            this.lastGoal = this.currGoal;
                            this.currGoal = null;
                            goals[0] = sim.agents[0].position;
                            sim.agents[0].radius = this.radius[0];
                        }
                        if (this._RoadPoints && this._RoadPoints.length > 0) {
                            this.currGoal = this._RoadPoints.pop();
                            this.cal2dDir(this.lastGoal, this.currGoal, this.currMoveDir);
                            goals[0] = [this.currGoal.x, this.currGoal.z];
                            sim.agents[0].radius = 0.1;
                        }
                    }
                }
                else if (this._RoadPoints && this._RoadPoints.length > 0) {
                    this.currGoal = this._RoadPoints.pop();
                    goals[0] = [this.currGoal.x, this.currGoal.z];
                    sim.agents[0].radius = 0.1;
                }
                for (var i = 1, len = sim.agents.length; i < len; i++) {
                    var range = RVO.Vector.absSq(RVO.Vector.subtract(sim.agents[i].position, sim.agents[0].position));
                    if (range < this.attackRanges[i]) {
                        goals[i] = sim.agents[i].position;
                        sim.agents[i].neighborDist = 0;
                    }
                    else {
                        goals[i] = sim.agents[0].position;
                        sim.agents[i].neighborDist = sim.agentDefaults.neighborDist;
                    }
                }
            };
            RVOManager.prototype.cal2dDir = function (oPos, tPos, out) {
                if (!oPos || !tPos || !out)
                    return;
                var ov2 = gd3d.math.pool.new_vector2();
                ov2.x = oPos.x;
                ov2.y = oPos.z;
                var tv2 = gd3d.math.pool.new_vector2();
                tv2.x = tPos.x;
                tv2.y = tPos.z;
                gd3d.math.vec2Subtract(tv2, ov2, out);
                gd3d.math.pool.delete_vector2(ov2);
                gd3d.math.pool.delete_vector2(tv2);
            };
            return RVOManager;
        }());
        framework.RVOManager = RVOManager;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectSystemData = (function () {
            function EffectSystemData() {
                this.beLoop = false;
                this.elementDic = {};
            }
            EffectSystemData.prototype.clone = function () {
                var data = new EffectSystemData();
                data.life = this.life;
                data.beLoop = this.beLoop;
                for (var key in this.elementDic) {
                    data.elementDic[key] = this.elementDic[key].clone();
                }
                return data;
            };
            EffectSystemData.prototype.dispose = function () {
                for (var key in this.elementDic) {
                    this.elementDic[key].dispose();
                    delete this.elementDic[key];
                }
            };
            return EffectSystemData;
        }());
        framework.EffectSystemData = EffectSystemData;
        var EffectElement = (function () {
            function EffectElement(_data) {
                this.startVboIndex = 0;
                this.startEboIndex = 0;
                this.endEboIndex = 0;
                this.delayTime = 0;
                this.actionActive = false;
                this.loopFrame = Number.MAX_VALUE;
                this.active = true;
                this.data = _data;
                this.name = this.data.name;
                this.timelineFrame = {};
                this.delayTime = _data.delayTime;
                this.initActions();
                this.recordElementLerpAttributes();
            }
            EffectElement.prototype.recordElementLerpAttributes = function () {
                if (this.data.timelineFrame != undefined) {
                    for (var i in this.data.timelineFrame) {
                        var frameData = this.data.timelineFrame[i];
                        if (frameData.frameIndex != -1) {
                            if (frameData.lerpDatas != undefined && frameData.lerpDatas.length != 0) {
                                this.recordLerpValues(frameData);
                            }
                            else if (frameData.attrsData != undefined) {
                                if (this.timelineFrame[frameData.frameIndex] == undefined) {
                                    this.timelineFrame[frameData.frameIndex] = new EffectFrameData();
                                    this.timelineFrame[frameData.frameIndex].attrsData = new EffectAttrsData();
                                    this.timelineFrame[frameData.frameIndex].frameIndex = frameData.frameIndex;
                                }
                                for (var k in frameData.attrsData) {
                                    this.timelineFrame[frameData.frameIndex].attrsData.setLerpAttribute(k, frameData.attrsData.getAttribute(k));
                                }
                            }
                        }
                    }
                }
            };
            EffectElement.prototype.recordLerpValues = function (effectFrameData) {
                for (var i in effectFrameData.lerpDatas) {
                    if (effectFrameData.lerpDatas[i].type == EffectLerpTypeEnum.Linear) {
                        for (var key in effectFrameData.lerpDatas[i].attrsList) {
                            var attrname = effectFrameData.lerpDatas[i].attrsList[key];
                            this.recordLerp(effectFrameData, effectFrameData.lerpDatas[i], attrname);
                        }
                    }
                }
            };
            EffectElement.prototype.recordLerp = function (effectFrameData, lerpData, key) {
                var fromFrame = lerpData.fromFrame;
                var toFrame = lerpData.toFrame.getValue();
                var toVal = lerpData.attrsData.getAttribute(key);
                if (effectFrameData.attrsData[key] == undefined) {
                    effectFrameData.attrsData.initAttribute(key);
                }
                var fromVal = effectFrameData.attrsData.getAttribute(key);
                for (var i = fromFrame + 1; i <= toFrame; i++) {
                    var outVal = void 0;
                    if (fromVal instanceof gd3d.math.vector3) {
                        outVal = new gd3d.math.vector3();
                        gd3d.math.vec3SLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame), outVal);
                    }
                    else if (fromVal instanceof gd3d.math.vector2) {
                        outVal = new gd3d.math.vector2();
                        gd3d.math.vec2SLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame), outVal);
                    }
                    else if (typeof (fromVal) === 'number') {
                        outVal = gd3d.math.numberLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame));
                    }
                    var newFrameData = this.timelineFrame[i];
                    if (newFrameData == undefined) {
                        newFrameData = new EffectFrameData();
                        newFrameData.attrsData = new EffectAttrsData();
                        newFrameData.frameIndex = i;
                        this.timelineFrame[i] = newFrameData;
                    }
                    newFrameData.attrsData.setLerpAttribute(key, outVal);
                }
            };
            EffectElement.prototype.initActions = function () {
                this.actions = [];
                var action;
                for (var key in this.data.actionData) {
                    var actiondata = this.data.actionData[key];
                    switch (actiondata.actionType) {
                        case "linear":
                            action = new framework.LinearAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "loop":
                            action = new framework.LoopAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "rotation":
                            action = new framework.RotationAction();
                            break;
                        case "breath":
                            action = new framework.BreathAction();
                            break;
                        case "uvroll":
                            action = new framework.UVRollAction();
                            break;
                        case "uvsprite":
                            action = new framework.UVSpriteAnimationAction();
                            break;
                        case "rosepath":
                            action = new framework.RoseCurveAction();
                            break;
                        case "trail":
                            action = new framework.TrailAction();
                            break;
                    }
                    action.init(actiondata.startFrame, actiondata.endFrame, actiondata.params, this);
                    this.actions.push(action);
                }
            };
            EffectElement.prototype.update = function () {
                if (this.curAttrData == undefined || this.curAttrData == null)
                    return;
                if (this.active) {
                    if (this.curAttrData.euler != undefined) {
                        gd3d.math.quatFromEulerAngles(this.curAttrData.euler.x, this.curAttrData.euler.y, this.curAttrData.euler.z, this.curAttrData.rotationByEuler);
                    }
                    this.updateElementRotation();
                    gd3d.math.matrixMakeTransformRTS(this.curAttrData.pos, this.curAttrData.scale, this.curAttrData.localRotation, this.curAttrData.matrix);
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElement.prototype.updateElementRotation = function () {
                var cameraTransform = gd3d.framework.sceneMgr.app.getScene().mainCamera.gameObject.transform;
                var worldRotation = gd3d.math.pool.new_quaternion();
                var localRotation = gd3d.math.pool.new_quaternion();
                if (this.curAttrData.renderModel != RenderModel.None) {
                    var invTransformRotation = gd3d.math.pool.new_quaternion();
                    var worldTranslation = gd3d.math.pool.new_vector3();
                    var translation = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Clone(this.curAttrData.pos, translation);
                    if (this.transform != undefined) {
                        gd3d.math.matrixTransformVector3(translation, this.transform.getWorldMatrix(), worldTranslation);
                    }
                    if (this.curAttrData.renderModel == RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    else if (this.curAttrData.renderModel == RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.curAttrData.renderModel == RenderModel.VerticalBillBoard) {
                        var forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(cameraTransform.getWorldTranslate(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.curAttrData.renderModel == RenderModel.StretchedBillBoard) {
                        gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                        var lookRot = new gd3d.math.quaternion();
                        gd3d.math.quatClone(this.transform.getWorldRotate(), invTransformRotation);
                        gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                        gd3d.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        var inverRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatInverse(this.curAttrData.localRotation, inverRot);
                        gd3d.math.quatMultiply(inverRot, lookRot, lookRot);
                        var angle = gd3d.math.pool.new_vector3();
                        gd3d.math.quatToEulerAngles(lookRot, angle);
                        gd3d.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        gd3d.math.quatMultiply(this.curAttrData.localRotation, lookRot, this.curAttrData.localRotation);
                        gd3d.math.pool.delete_quaternion(inverRot);
                        gd3d.math.pool.delete_vector3(angle);
                        gd3d.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.curAttrData.renderModel == RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, worldRotation);
                    gd3d.math.quatClone(this.transform.gameObject.transform.getWorldRotate(), invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.curAttrData.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                }
                gd3d.math.pool.delete_quaternion(localRotation);
                gd3d.math.pool.delete_quaternion(worldRotation);
            };
            EffectElement.prototype.isCurFrameNeedRefresh = function (frameIndex) {
                if (this.timelineFrame[frameIndex] != undefined) {
                    return true;
                }
                if (this.curAttrData != undefined && this.curAttrData.renderModel != RenderModel.None) {
                    return true;
                }
                return this.actionActive;
            };
            EffectElement.prototype.setActive = function (_active) {
                if (this.active == _active)
                    return;
                this.active = _active;
                if (this.active) {
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElement.prototype.dispose = function () {
                this.data.dispose();
                this.curAttrData = null;
                this.actions.length = 0;
                delete this.timelineFrame;
            };
            return EffectElement;
        }());
        framework.EffectElement = EffectElement;
        var EffectElementData = (function () {
            function EffectElementData() {
                this.delayTime = 0;
            }
            EffectElementData.prototype.clone = function () {
                var elementdata = new EffectElementData();
                elementdata.name = this.name;
                elementdata.type = this.type;
                elementdata.refFrom = this.refFrom;
                elementdata.beloop = this.beloop;
                elementdata.actionData = [];
                elementdata.timelineFrame = [];
                if (this.initFrameData)
                    elementdata.initFrameData = this.initFrameData.clone();
                if (this.emissionData) {
                    elementdata.emissionData = this.emissionData.clone();
                }
                for (var key in this.timelineFrame) {
                    if (this.timelineFrame[key]) {
                        elementdata.timelineFrame[key] = this.timelineFrame[key].clone();
                    }
                }
                for (var key in this.actionData) {
                    if (this.actionData[key]) {
                        elementdata.actionData[key] = this.actionData[key].clone();
                    }
                }
                return elementdata;
            };
            EffectElementData.prototype.dispose = function () {
                if (this.actionData)
                    this.actionData.length = 0;
                if (this.initFrameData)
                    this.initFrameData.dispose();
                for (var key in this.timelineFrame) {
                    this.timelineFrame[key].dispose();
                }
                delete this.timelineFrame;
            };
            return EffectElementData;
        }());
        framework.EffectElementData = EffectElementData;
        var EffectAttrsData = (function () {
            function EffectAttrsData() {
                this.uv = new gd3d.math.vector2(1, 1);
                this.renderModel = RenderModel.None;
                this.matrix = new gd3d.math.matrix();
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localRotation = new gd3d.math.quaternion();
            }
            EffectAttrsData.prototype.setLerpAttribute = function (attribute, val) {
                switch (attribute) {
                    case "pos":
                        this.pos = val;
                        break;
                    case "scale":
                        this.scale = val;
                        break;
                    case "euler":
                        this.euler = val;
                        break;
                    case "alpha":
                        this.alpha = val;
                        break;
                    case "uv":
                        this.uv = val;
                        break;
                    case "color":
                        this.color = val;
                        break;
                    case "tilling":
                        console.log("tilling 逻辑上不需要插值");
                        break;
                }
            };
            EffectAttrsData.prototype.getAttribute = function (attribute) {
                switch (attribute) {
                    case "pos":
                        return gd3d.math.pool.clone_vector3(this.pos);
                    case "scale":
                        return gd3d.math.pool.clone_vector3(this.scale);
                    case "euler":
                        return gd3d.math.pool.clone_vector3(this.euler);
                    case "alpha":
                        return this.alpha;
                    case "color":
                        return gd3d.math.pool.clone_vector3(this.color);
                    case "tilling":
                        return gd3d.math.pool.clone_vector2(this.tilling);
                    case "uv":
                        return gd3d.math.pool.clone_vector2(this.uv);
                    case "mat":
                        return this.mat.clone();
                    case "renderModel":
                        return this.renderModel;
                    case "rotationByEuler":
                        return gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                    case "localRotation":
                        return gd3d.math.pool.clone_quaternion(this.localRotation);
                    case "matrix":
                        return gd3d.math.pool.clone_matrix(this.matrix);
                    case "colorRate":
                        return this.colorRate;
                }
            };
            EffectAttrsData.prototype.initAttribute = function (attribute) {
                switch (attribute) {
                    case "pos":
                        this.pos = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "scale":
                        this.scale = new gd3d.math.vector3(1, 1, 1);
                        break;
                    case "euler":
                        this.euler = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "alpha":
                        this.alpha = 0;
                        break;
                    case "color":
                        this.color = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "uv":
                        this.uv = new gd3d.math.vector2(0, 0);
                        break;
                    case "tilling":
                        this.tilling = new gd3d.math.vector2(1, 1);
                        break;
                    case "colorRate":
                        this.colorRate = 1;
                        break;
                    default:
                        console.log("不支持的属性：" + attribute);
                        break;
                }
            };
            EffectAttrsData.prototype.resetMatrix = function () {
                gd3d.math.matrixZero(this.matrix);
            };
            EffectAttrsData.prototype.copyandinit = function () {
                var data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = gd3d.math.pool.clone_vector3(this.pos);
                else
                    data.initAttribute("pos");
                if (this.euler != undefined)
                    data.euler = gd3d.math.pool.clone_vector3(this.euler);
                else
                    data.initAttribute("euler");
                if (this.color != undefined)
                    data.color = gd3d.math.pool.clone_vector3(this.color);
                else
                    data.initAttribute("color");
                if (this.scale != undefined)
                    data.scale = gd3d.math.pool.clone_vector3(this.scale);
                else
                    data.initAttribute("scale");
                if (this.uv != undefined)
                    data.uv = gd3d.math.pool.clone_vector2(this.uv);
                else
                    data.initAttribute("uv");
                if (this.tilling != undefined)
                    data.tilling = gd3d.math.pool.clone_vector2(this.tilling);
                else
                    data.initAttribute("tilling");
                if (this.colorRate != undefined)
                    data.colorRate = this.colorRate;
                else
                    data.initAttribute("colorRate");
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = gd3d.math.pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo;
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            };
            EffectAttrsData.prototype.clone = function () {
                var data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = gd3d.math.pool.clone_vector3(this.pos);
                if (this.euler != undefined)
                    data.euler = gd3d.math.pool.clone_vector3(this.euler);
                if (this.color != undefined)
                    data.color = gd3d.math.pool.clone_vector3(this.color);
                if (this.scale != undefined)
                    data.scale = gd3d.math.pool.clone_vector3(this.scale);
                if (this.tilling != undefined)
                    data.tilling = gd3d.math.pool.clone_vector2(this.tilling);
                if (this.colorRate != undefined)
                    data.colorRate = this.colorRate;
                if (this.uv != undefined)
                    data.uv = gd3d.math.pool.clone_vector2(this.uv);
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = gd3d.math.pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo;
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            };
            return EffectAttrsData;
        }());
        framework.EffectAttrsData = EffectAttrsData;
        var EffectFrameData = (function () {
            function EffectFrameData() {
            }
            EffectFrameData.prototype.clone = function () {
                var framedata = new EffectFrameData();
                framedata.frameIndex = this.frameIndex;
                framedata.attrsData = this.attrsData.clone();
                framedata.lerpDatas = [];
                for (var key in this.lerpDatas) {
                    framedata.lerpDatas[key] = this.lerpDatas[key].clone();
                }
                return framedata;
            };
            EffectFrameData.prototype.dispose = function () {
                this.attrsData = null;
                if (this.lerpDatas)
                    this.lerpDatas.length = 0;
            };
            return EffectFrameData;
        }());
        framework.EffectFrameData = EffectFrameData;
        var EffectLerpData = (function () {
            function EffectLerpData() {
                this.attrsList = [];
            }
            EffectLerpData.prototype.clone = function () {
                var lerpdata = new EffectLerpData();
                lerpdata.type = this.type;
                lerpdata.fromFrame = this.fromFrame;
                lerpdata.toFrame = this.toFrame;
                lerpdata.attrsData = this.attrsData.clone();
                for (var key in this.attrsList) {
                    lerpdata.attrsList[key] = this.attrsList[key];
                }
                return lerpdata;
            };
            return EffectLerpData;
        }());
        framework.EffectLerpData = EffectLerpData;
        var EffectActionData = (function () {
            function EffectActionData() {
            }
            EffectActionData.prototype.clone = function () {
                var actiondata = new EffectActionData();
                actiondata.actionType = this.actionType;
                actiondata.startFrame = this.startFrame;
                actiondata.endFrame = this.endFrame;
                actiondata.params = [];
                for (var key in this.params) {
                    actiondata.params[key] = this.params[key];
                }
                return actiondata;
            };
            return EffectActionData;
        }());
        framework.EffectActionData = EffectActionData;
        var EffectMatData = (function () {
            function EffectMatData() {
            }
            EffectMatData.beEqual = function (data0, data1) {
                return data0.alphaCut === data1.alphaCut && data0.diffuseTexture === data1.diffuseTexture && data0.shader === data1.shader && data0.alphaTexture === data1.alphaTexture;
            };
            EffectMatData.prototype.clone = function () {
                var data = new EffectMatData();
                data.shader = this.shader;
                data.diffuseTexture = this.diffuseTexture;
                data.alphaTexture = this.alphaTexture;
                data.alphaCut = this.alphaCut;
                return data;
            };
            return EffectMatData;
        }());
        framework.EffectMatData = EffectMatData;
        var EffectBatcherState;
        (function (EffectBatcherState) {
            EffectBatcherState[EffectBatcherState["NotInitedStateType"] = 0] = "NotInitedStateType";
            EffectBatcherState[EffectBatcherState["InitedStateType"] = 1] = "InitedStateType";
            EffectBatcherState[EffectBatcherState["ResizeCapacityStateType"] = 2] = "ResizeCapacityStateType";
        })(EffectBatcherState = framework.EffectBatcherState || (framework.EffectBatcherState = {}));
        var EffectBatcher = (function () {
            function EffectBatcher(formate) {
                this.state = EffectBatcherState.NotInitedStateType;
                this.effectElements = [];
                this._totalVertexCount = 0;
                this._indexStartIndex = 0;
                this._vbosize = 0;
                this.vertexSize = 0;
                this.vertexSize = gd3d.render.meshData.calcByteSize(formate) / 4;
            }
            Object.defineProperty(EffectBatcher.prototype, "curTotalVertexCount", {
                get: function () {
                    return this._totalVertexCount;
                },
                set: function (val) {
                    this._totalVertexCount = val;
                    this.resizeVboSize(this._totalVertexCount * this.vertexSize);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EffectBatcher.prototype, "indexStartIndex", {
                get: function () {
                    return this._indexStartIndex;
                },
                set: function (value) {
                    this._indexStartIndex = value;
                    if (this.dataForEbo != null) {
                        var ebo = new Uint16Array(this._indexStartIndex);
                        ebo.set(this.dataForEbo, 0);
                        this.dataForEbo = ebo;
                    }
                    else {
                        this.dataForEbo = new Uint16Array(this._indexStartIndex);
                    }
                },
                enumerable: true,
                configurable: true
            });
            EffectBatcher.prototype.resizeVboSize = function (value) {
                if (this._vbosize > value)
                    return;
                this._vbosize = value;
                if (this.dataForVbo != null) {
                    var vbo = new Float32Array(this._vbosize);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                else {
                    this.dataForVbo = new Float32Array(this._vbosize);
                }
            };
            EffectBatcher.prototype.dispose = function () {
                this.mesh.dispose();
                this.mat.dispose();
                this.dataForVbo = null;
                this.dataForEbo = null;
                for (var key in this.effectElements) {
                    this.effectElements[key].dispose();
                }
            };
            return EffectBatcher;
        }());
        framework.EffectBatcher = EffectBatcher;
        var EffectPlayStateEnum;
        (function (EffectPlayStateEnum) {
            EffectPlayStateEnum[EffectPlayStateEnum["None"] = 0] = "None";
            EffectPlayStateEnum[EffectPlayStateEnum["BeReady"] = 1] = "BeReady";
            EffectPlayStateEnum[EffectPlayStateEnum["Play"] = 2] = "Play";
            EffectPlayStateEnum[EffectPlayStateEnum["Pause"] = 3] = "Pause";
            EffectPlayStateEnum[EffectPlayStateEnum["Stop"] = 4] = "Stop";
            EffectPlayStateEnum[EffectPlayStateEnum["Dispose"] = 5] = "Dispose";
        })(EffectPlayStateEnum = framework.EffectPlayStateEnum || (framework.EffectPlayStateEnum = {}));
        var EffectElementTypeEnum;
        (function (EffectElementTypeEnum) {
            EffectElementTypeEnum[EffectElementTypeEnum["SingleMeshType"] = 0] = "SingleMeshType";
            EffectElementTypeEnum[EffectElementTypeEnum["EmissionType"] = 1] = "EmissionType";
            EffectElementTypeEnum[EffectElementTypeEnum["MultiMeshType"] = 2] = "MultiMeshType";
        })(EffectElementTypeEnum = framework.EffectElementTypeEnum || (framework.EffectElementTypeEnum = {}));
        var EffectLerpTypeEnum;
        (function (EffectLerpTypeEnum) {
            EffectLerpTypeEnum[EffectLerpTypeEnum["Linear"] = 0] = "Linear";
        })(EffectLerpTypeEnum = framework.EffectLerpTypeEnum || (framework.EffectLerpTypeEnum = {}));
        var RenderModel;
        (function (RenderModel) {
            RenderModel[RenderModel["None"] = 0] = "None";
            RenderModel[RenderModel["BillBoard"] = 1] = "BillBoard";
            RenderModel[RenderModel["StretchedBillBoard"] = 2] = "StretchedBillBoard";
            RenderModel[RenderModel["HorizontalBillBoard"] = 3] = "HorizontalBillBoard";
            RenderModel[RenderModel["VerticalBillBoard"] = 4] = "VerticalBillBoard";
            RenderModel[RenderModel["Mesh"] = 5] = "Mesh";
        })(RenderModel = framework.RenderModel || (framework.RenderModel = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ParticleEmissionType;
        (function (ParticleEmissionType) {
            ParticleEmissionType[ParticleEmissionType["burst"] = 0] = "burst";
            ParticleEmissionType[ParticleEmissionType["continue"] = 1] = "continue";
        })(ParticleEmissionType = framework.ParticleEmissionType || (framework.ParticleEmissionType = {}));
        var EmissionData = (function () {
            function EmissionData() {
                this.type = ParticleEmissionType.burst;
            }
            return EmissionData;
        }());
        framework.EmissionData = EmissionData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Emission = (function () {
            function Emission() {
                this.simulateInLocalSpace = true;
                this.renderModel = framework.RenderModel.Mesh;
                this.particleStartData = new gd3d.framework.ParticleStartData();
            }
            Emission.prototype.getVboData = function (vf) {
                if (this.dataForVbo == undefined) {
                    this.dataForVbo = this.mesh.data.genVertexDataArray(vf);
                }
                return this.dataForVbo;
            };
            Emission.prototype.clone = function () {
                var emission = new Emission();
                if (this.emissionType != undefined)
                    emission.emissionType = this.emissionType;
                emission.simulateInLocalSpace = this.simulateInLocalSpace;
                if (this.rootpos != undefined) {
                    emission.rootpos = gd3d.math.pool.clone_vector3(this.rootpos);
                }
                if (this.rootRotAngle != undefined) {
                    emission.rootRotAngle = gd3d.math.pool.clone_vector3(this.rootRotAngle);
                }
                if (this.rootScale != undefined) {
                    emission.rootScale = gd3d.math.pool.clone_vector3(this.rootScale);
                }
                if (this.maxEmissionCount != undefined)
                    emission.maxEmissionCount = this.maxEmissionCount;
                if (this.emissionCount != undefined)
                    emission.emissionCount = this.emissionCount;
                if (this.time != undefined)
                    emission.time = this.time;
                if (this.simulationSpeed != undefined) {
                    emission.simulationSpeed = this.simulationSpeed.clone();
                }
                if (this.moveSpeed != undefined)
                    emission.moveSpeed = this.moveSpeed.clone();
                if (this.gravity != undefined)
                    emission.gravity = this.gravity;
                if (this.euler != undefined)
                    emission.euler = this.euler.clone();
                if (this.eulerNodes != undefined)
                    emission.eulerNodes = this.cloneParticleNodeArray(this.eulerNodes);
                if (this.eulerSpeed != undefined)
                    emission.eulerSpeed = this.eulerSpeed.clone();
                if (this.scale != undefined)
                    emission.scale = this.scale.clone();
                if (this.scaleNodes != undefined)
                    emission.scaleNodes = this.cloneParticleNodeNumberArray(this.scaleNodes);
                if (this.scaleSpeed != undefined)
                    emission.scaleSpeed = this.scaleSpeed.clone();
                if (this.color != undefined)
                    emission.color = this.color.clone();
                if (this.colorRate != undefined)
                    emission.colorRate = this.colorRate;
                if (this.colorNodes != undefined)
                    emission.colorNodes = this.cloneParticleNodeArray(this.colorNodes);
                if (this.colorSpeed != undefined)
                    emission.colorSpeed = this.colorSpeed.clone();
                if (this.simulationSpeed != undefined)
                    emission.simulationSpeed = this.simulationSpeed.clone();
                if (this.alpha != undefined)
                    emission.alpha = this.alpha.clone();
                if (this.alphaNodes != undefined)
                    emission.alphaNodes = this.cloneParticleNodeNumberArray(this.alphaNodes);
                if (this.alphaSpeed != undefined)
                    emission.alphaSpeed = this.alphaSpeed.clone();
                if (this.uv != undefined)
                    emission.uv = this.uv.clone();
                if (this.uvType != undefined)
                    emission.uvType = this.uvType;
                if (this.uvRoll != undefined)
                    emission.uvRoll = this.uvRoll.clone();
                if (this.uvSprite != undefined)
                    emission.uvSprite = this.uvSprite.clone();
                if (this.mat != undefined)
                    emission.mat = this.mat.clone();
                if (this.life != undefined)
                    emission.life = this.life.clone();
                if (this.renderModel != undefined)
                    emission.renderModel = this.renderModel;
                if (this.mesh != undefined)
                    emission.mesh = this.mesh;
                if (this.dataForVbo != undefined)
                    emission.dataForVbo = this.dataForVbo;
                if (this.particleStartData != undefined)
                    emission.particleStartData = this.particleStartData.clone();
                return emission;
            };
            Emission.prototype.getworldRotation = function () {
            };
            Emission.prototype.cloneParticleNodeArray = function (_array) {
                var array = new Array();
                for (var i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            };
            Emission.prototype.cloneParticleNodeNumberArray = function (_array) {
                var array = new Array();
                for (var i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            };
            return Emission;
        }());
        framework.Emission = Emission;
        var UVSprite = (function () {
            function UVSprite() {
            }
            UVSprite.prototype.clone = function () {
                var sprite = new UVSprite();
                sprite.row = this.row;
                sprite.column = this.column;
                sprite.totalCount = this.totalCount;
                return sprite;
            };
            return UVSprite;
        }());
        framework.UVSprite = UVSprite;
        var UVRoll = (function () {
            function UVRoll() {
            }
            UVRoll.prototype.clone = function () {
                var roll = new UVRoll();
                if (this.uvSpeed != undefined)
                    roll.uvSpeed = this.uvSpeed;
                if (this.uvSpeedNodes != undefined) {
                    var array = new Array();
                    for (var i in this.uvSpeedNodes) {
                        array.push(this.uvSpeedNodes[i].clone());
                    }
                    roll.uvSpeedNodes = array;
                }
                return roll;
            };
            return UVRoll;
        }());
        framework.UVRoll = UVRoll;
        var UVTypeEnum;
        (function (UVTypeEnum) {
            UVTypeEnum[UVTypeEnum["NONE"] = 0] = "NONE";
            UVTypeEnum[UVTypeEnum["UVRoll"] = 1] = "UVRoll";
            UVTypeEnum[UVTypeEnum["UVSprite"] = 2] = "UVSprite";
        })(UVTypeEnum = framework.UVTypeEnum || (framework.UVTypeEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ParticleNode = (function () {
            function ParticleNode() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
                this.z = new framework.ValueData();
            }
            ParticleNode.prototype.getValue = function () {
                return new gd3d.math.vector3(this.x.getValue(), this.y.getValue(), this.z.getValue());
            };
            ParticleNode.prototype.getValueRandom = function () {
                return new gd3d.math.vector3(this.x.getValueRandom(), this.y.getValueRandom(), this.z.getValueRandom());
            };
            ParticleNode.prototype.clone = function () {
                var node = new ParticleNode();
                if (this.x != undefined)
                    node.x = this.x.clone();
                if (this.y != undefined)
                    node.y = this.y.clone();
                if (this.z != undefined)
                    node.z = this.z.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            };
            return ParticleNode;
        }());
        framework.ParticleNode = ParticleNode;
        var AlphaNode = (function () {
            function AlphaNode() {
                this.alpha = new framework.ValueData();
            }
            AlphaNode.prototype.getValue = function () {
                return this.alpha.getValue();
            };
            return AlphaNode;
        }());
        framework.AlphaNode = AlphaNode;
        var UVSpeedNode = (function () {
            function UVSpeedNode() {
                this.u = new framework.ValueData();
                this.v = new framework.ValueData();
            }
            UVSpeedNode.prototype.getValue = function () {
                return new gd3d.math.vector2(this.u.getValue(), this.v.getValue());
            };
            UVSpeedNode.prototype.getValueRandom = function () {
                return new gd3d.math.vector2(this.u.getValueRandom(), this.v.getValueRandom());
            };
            UVSpeedNode.prototype.clone = function () {
                var node = new UVSpeedNode();
                node.u = this.u.clone();
                node.v = this.v.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            };
            return UVSpeedNode;
        }());
        framework.UVSpeedNode = UVSpeedNode;
        var ParticleNodeVec2 = (function () {
            function ParticleNodeVec2() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
            }
            ParticleNodeVec2.prototype.getValue = function () {
                return new gd3d.math.vector2(this.x.getValue(), this.y.getValue());
            };
            ParticleNodeVec2.prototype.getValueRandom = function () {
                return new gd3d.math.vector2(this.x.getValueRandom(), this.y.getValueRandom());
            };
            ParticleNodeVec2.prototype.clone = function () {
                var vec = new ParticleNodeVec2();
                vec.x = this.x.clone();
                vec.y = this.y.clone();
                if (this.key != undefined)
                    vec.key = this.key;
                return vec;
            };
            return ParticleNodeVec2;
        }());
        framework.ParticleNodeVec2 = ParticleNodeVec2;
        var ParticleNodeNumber = (function () {
            function ParticleNodeNumber() {
                this.num = new framework.ValueData();
            }
            ParticleNodeNumber.prototype.getValue = function () {
                return this.num.getValue();
            };
            ParticleNodeNumber.prototype.getValueRandom = function () {
                return this.num.getValueRandom();
            };
            ParticleNodeNumber.prototype.clone = function () {
                var num = new ParticleNodeNumber();
                num.num = this.num.clone();
                if (this.key != undefined) {
                    num.key = this.key;
                }
                return num;
            };
            return ParticleNodeNumber;
        }());
        framework.ParticleNodeNumber = ParticleNodeNumber;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ParticleSystemShape;
        (function (ParticleSystemShape) {
            ParticleSystemShape[ParticleSystemShape["NORMAL"] = 0] = "NORMAL";
            ParticleSystemShape[ParticleSystemShape["BOX"] = 1] = "BOX";
            ParticleSystemShape[ParticleSystemShape["SPHERE"] = 2] = "SPHERE";
            ParticleSystemShape[ParticleSystemShape["HEMISPHERE"] = 3] = "HEMISPHERE";
            ParticleSystemShape[ParticleSystemShape["CONE"] = 4] = "CONE";
            ParticleSystemShape[ParticleSystemShape["EDGE"] = 5] = "EDGE";
            ParticleSystemShape[ParticleSystemShape["CIRCLE"] = 6] = "CIRCLE";
        })(ParticleSystemShape = framework.ParticleSystemShape || (framework.ParticleSystemShape = {}));
        var ParticleStartData = (function () {
            function ParticleStartData() {
                this.shapeType = ParticleSystemShape.NORMAL;
                this._position = new gd3d.math.vector3(0, 0, 0);
                this._direction = new gd3d.math.vector3(0, 1, 0);
                this._width = 0;
                this._height = 0;
                this.depth = 0;
                this._radius = 0;
                this._angle = 0;
                this.emitFrom = emitfromenum.base;
            }
            Object.defineProperty(ParticleStartData.prototype, "position", {
                get: function () {
                    return this._position;
                },
                set: function (_pos) {
                    gd3d.math.vec3Clone(_pos, this._position);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                set: function (_dir) {
                    gd3d.math.vec3Clone(_dir, this._direction);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "width", {
                get: function () {
                    return this._width;
                },
                set: function (_w) {
                    this._width = _w;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "height", {
                get: function () {
                    return this._height;
                },
                set: function (_h) {
                    this._height = _h;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "radius", {
                get: function () {
                    return this._radius;
                },
                set: function (_r) {
                    this._radius = _r;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "angle", {
                get: function () {
                    return this._angle;
                },
                set: function (_a) {
                    this._angle = _a;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "randomDirection", {
                get: function () {
                    switch (this.shapeType) {
                        case ParticleSystemShape.BOX:
                            return this.boxDirection;
                        case ParticleSystemShape.SPHERE:
                            return this.sphereDirection;
                        case ParticleSystemShape.HEMISPHERE:
                            return this.hemisphereDirection;
                        case ParticleSystemShape.CONE:
                            return this.coneDirection;
                        case ParticleSystemShape.CIRCLE:
                            return this.circleDirection;
                        case ParticleSystemShape.EDGE:
                            return this.edgeDirection;
                        default:
                            return this.direction;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "boxDirection", {
                get: function () {
                    this.position.x = framework.ValueData.RandomRange(-this.width / 2, this.width / 2);
                    this.position.y = framework.ValueData.RandomRange(-this.height / 2, this.height / 2);
                    this.position.z = framework.ValueData.RandomRange(-this.depth / 2, this.depth / 2);
                    gd3d.math.vec3Normalize(this.position, this.direction);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "sphereDirection", {
                get: function () {
                    var θ = Math.random() * Math.PI * 2;
                    var φ = Math.random() * Math.PI;
                    var radius = Math.random() * this.radius;
                    this.direction.x = Math.sin(φ) * Math.cos(θ);
                    this.direction.y = Math.cos(φ);
                    this.direction.z = Math.sin(φ) * Math.sin(θ);
                    gd3d.math.vec3ScaleByNum(this.direction, radius, this.position);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "hemisphereDirection", {
                get: function () {
                    var θ = Math.random() * Math.PI * 2;
                    var φ = Math.random() * Math.PI * 0.5;
                    var radius = Math.random() * this.radius;
                    this.direction.x = Math.sin(φ) * Math.cos(θ);
                    this.direction.y = Math.cos(φ);
                    this.direction.z = Math.sin(φ) * Math.sin(θ);
                    gd3d.math.vec3ScaleByNum(this.direction, radius, this.position);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "coneDirection", {
                get: function () {
                    var randomAngle = Math.random() * Math.PI * 2;
                    var randomHeight = Math.random() * this.height;
                    var upradius = randomHeight * Math.tan(this.angle * Math.PI / 180) + this.radius;
                    var radomRadius = Math.random() * upradius;
                    var bottompos = gd3d.math.pool.new_vector3();
                    bottompos.x = this.radius * Math.cos(randomAngle);
                    bottompos.y = 0;
                    bottompos.z = this.radius * Math.sin(randomAngle);
                    if (this.emitFrom == emitfromenum.base) {
                        gd3d.math.vec3Clone(bottompos, this.position);
                    }
                    else if (this.emitFrom == emitfromenum.volume) {
                        this.position.x = radomRadius * Math.cos(randomAngle);
                        this.position.z = radomRadius * Math.sin(randomAngle);
                        this.position.y = randomHeight;
                    }
                    this.direction.x = Math.cos(randomAngle) * Math.sin(this.angle * Math.PI / 180);
                    this.direction.z = Math.sin(randomAngle) * Math.sin(this.angle * Math.PI / 180);
                    this.direction.y = Math.cos(this.angle * Math.PI / 180);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "circleDirection", {
                get: function () {
                    var _arc = this.angle * (Math.PI / 180);
                    var a = framework.ValueData.RandomRange(-_arc / 2, _arc / 2);
                    var _radius = framework.ValueData.RandomRange(0, this.radius);
                    this.direction.x = _radius * Math.cos(a);
                    this.direction.z = _radius * Math.sin(a);
                    this.direction.y = 0;
                    var length = gd3d.math.vec3Length(this.direction);
                    gd3d.math.vec3Normalize(this.direction, this.direction);
                    framework.EffectUtil.RotateVector3(this.direction, this.direction, this.direction);
                    this.getposition(this.direction, length);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "edgeDirection", {
                get: function () {
                    var edgePos = new gd3d.math.vector3(0, 0, 0);
                    edgePos.y += framework.ValueData.RandomRange(-this.radius / 2, this.radius / 2);
                    var lenght = gd3d.math.vec3Length(edgePos);
                    framework.EffectUtil.RotateVector3(edgePos, this.direction, edgePos);
                    gd3d.math.vec3Clone(this.direction, this.direction);
                    this.getposition(edgePos, length);
                    return this.direction;
                },
                enumerable: true,
                configurable: true
            });
            ParticleStartData.prototype.getposition = function (dir, length) {
                gd3d.math.vec3ScaleByNum(dir, length, dir);
                this.position.x = dir.x;
                this.position.y = dir.y;
                this.position.z = dir.z;
            };
            ParticleStartData.prototype.clone = function () {
                var data = new ParticleStartData();
                data.shapeType = this.shapeType;
                data._position = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._position, data._position);
                data._direction = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._direction, data._direction);
                data._width = this._width;
                data._height = this._height;
                data.depth = this.depth;
                data._radius = this._radius;
                data._angle = this._angle;
                data.position = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.position, data.position);
                data.direction = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.direction, data.direction);
                return data;
            };
            return ParticleStartData;
        }());
        framework.ParticleStartData = ParticleStartData;
        var emitfromenum;
        (function (emitfromenum) {
            emitfromenum[emitfromenum["base"] = 0] = "base";
            emitfromenum[emitfromenum["volume"] = 1] = "volume";
        })(emitfromenum = framework.emitfromenum || (framework.emitfromenum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ValueData = (function () {
            function ValueData() {
                this.isRandom = true;
                this._value = 0;
                this._valueLimitMin = 0;
                this._valueLimitMax = 0;
                this.beInited = false;
            }
            Object.defineProperty(ValueData.prototype, "value", {
                set: function (_v) {
                    this._value = _v;
                    this.isRandom = false;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ValueData.prototype, "valueLimitMin", {
                set: function (_v) {
                    this._valueLimitMin = _v;
                    this.isRandom = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ValueData.prototype, "valueLimitMax", {
                set: function (_v) {
                    this._valueLimitMax = _v;
                    this.isRandom = true;
                },
                enumerable: true,
                configurable: true
            });
            ValueData.prototype.clone = function () {
                var valu = new ValueData();
                valu.isRandom = this.isRandom;
                valu._value = this._value;
                valu._valueLimitMin = this._valueLimitMin;
                valu._valueLimitMax = this._valueLimitMax;
                return valu;
            };
            ValueData.prototype.getValue = function () {
                if (this.isRandom) {
                    if (!this.beInited) {
                        this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                        this.beInited = true;
                    }
                }
                return this._value;
            };
            ValueData.prototype.getValueRandom = function () {
                if (this.isRandom) {
                    this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                }
                return this._value;
            };
            ValueData.RandomRange = function (min, max, isInteger) {
                if (isInteger === void 0) { isInteger = false; }
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            };
            return ValueData;
        }());
        framework.ValueData = ValueData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Vector3AttributeData = (function () {
            function Vector3AttributeData() {
                this.init();
            }
            Vector3AttributeData.prototype.init = function () {
                this.data = {};
                this.frameIndexs = [];
                var keyPoint = new FrameKeyPointData(0, new gd3d.math.vector3());
                this.addFramePoint(keyPoint);
            };
            Vector3AttributeData.prototype.addFramePoint = function (data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            };
            Vector3AttributeData.prototype.removeFramePoint = function (frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            };
            Vector3AttributeData.prototype.updateFramePoint = function (data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            };
            Vector3AttributeData = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], Vector3AttributeData);
            return Vector3AttributeData;
        }());
        framework.Vector3AttributeData = Vector3AttributeData;
        var Vector2AttributeData = (function () {
            function Vector2AttributeData() {
                this.init();
            }
            Vector2AttributeData.prototype.init = function () {
                this.data = {};
                this.frameIndexs = [];
                var keyPoint = new FrameKeyPointData(0, new gd3d.math.vector2());
                this.addFramePoint(keyPoint);
            };
            Vector2AttributeData.prototype.addFramePoint = function (data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            };
            Vector2AttributeData.prototype.removeFramePoint = function (frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            };
            Vector2AttributeData.prototype.updateFramePoint = function (data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            };
            Vector2AttributeData = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], Vector2AttributeData);
            return Vector2AttributeData;
        }());
        framework.Vector2AttributeData = Vector2AttributeData;
        var NumberAttributeData = (function () {
            function NumberAttributeData() {
                this.init();
            }
            NumberAttributeData.prototype.init = function () {
                this.data = {};
                this.frameIndexs = [];
                var keyPoint = new FrameKeyPointData(0, 0);
                this.addFramePoint(keyPoint, null);
            };
            NumberAttributeData.prototype.addFramePoint = function (data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            };
            NumberAttributeData.prototype.removeFramePoint = function (frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            };
            NumberAttributeData.prototype.updateFramePoint = function (data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            };
            NumberAttributeData = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], NumberAttributeData);
            return NumberAttributeData;
        }());
        framework.NumberAttributeData = NumberAttributeData;
        var AttributeUIState;
        (function (AttributeUIState) {
            AttributeUIState[AttributeUIState["None"] = 0] = "None";
            AttributeUIState[AttributeUIState["Show"] = 1] = "Show";
            AttributeUIState[AttributeUIState["Hide"] = 2] = "Hide";
        })(AttributeUIState = framework.AttributeUIState || (framework.AttributeUIState = {}));
        var AttributeUIType;
        (function (AttributeUIType) {
            AttributeUIType[AttributeUIType["Number"] = 0] = "Number";
            AttributeUIType[AttributeUIType["Vector2"] = 1] = "Vector2";
            AttributeUIType[AttributeUIType["Vector3"] = 2] = "Vector3";
            AttributeUIType[AttributeUIType["Vector4"] = 3] = "Vector4";
        })(AttributeUIType = framework.AttributeUIType || (framework.AttributeUIType = {}));
        var AttributeValType;
        (function (AttributeValType) {
            AttributeValType[AttributeValType["FixedValType"] = 0] = "FixedValType";
            AttributeValType[AttributeValType["LerpType"] = 1] = "LerpType";
        })(AttributeValType = framework.AttributeValType || (framework.AttributeValType = {}));
        var FrameKeyPointData = (function () {
            function FrameKeyPointData(frameIndex, val) {
                this.frameIndex = frameIndex;
                this.val = val;
            }
            return FrameKeyPointData;
        }());
        framework.FrameKeyPointData = FrameKeyPointData;
        var AttributeUtil = (function () {
            function AttributeUtil() {
            }
            AttributeUtil.addFrameIndex = function (datas, index) {
                for (var i = 0; i < datas.length - 1; i++) {
                    if (index > datas[i] && index <= datas[i + 1]) {
                        datas.splice(i, 0, index);
                        return;
                    }
                }
                datas.push(index);
            };
            return AttributeUtil;
        }());
        framework.AttributeUtil = AttributeUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var AttributeType;
        (function (AttributeType) {
            AttributeType[AttributeType["PositionType"] = 1] = "PositionType";
            AttributeType[AttributeType["EulerType"] = 2] = "EulerType";
            AttributeType[AttributeType["ScaleType"] = 3] = "ScaleType";
            AttributeType[AttributeType["ColorType"] = 4] = "ColorType";
            AttributeType[AttributeType["ColorRateType"] = 5] = "ColorRateType";
            AttributeType[AttributeType["AlphaType"] = 6] = "AlphaType";
            AttributeType[AttributeType["TillingType"] = 7] = "TillingType";
        })(AttributeType = framework.AttributeType || (framework.AttributeType = {}));
        var EffectElementSingleMesh = (function () {
            function EffectElementSingleMesh(sys, data) {
                if (data === void 0) { data = null; }
                this.elementType = gd3d.framework.EffectElementTypeEnum.SingleMeshType;
                this.beloop = false;
                this.delayTime = 0;
                this.life = 5;
                this.colorRate = 1;
                this.renderModel = gd3d.framework.RenderModel.Mesh;
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
                this.position = [];
                this.euler = [];
                this.scale = [];
                this.color = [];
                this.alpha = [];
                this.loopFrame = Number.MAX_VALUE;
                this.active = true;
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localRotation = new gd3d.math.quaternion();
                this.effectSys = sys;
                if (data != null) {
                    this.initByElementdata(data);
                }
                else {
                    this.initByDefData();
                }
            }
            EffectElementSingleMesh.prototype.initByElementdata = function (data) {
            };
            EffectElementSingleMesh.prototype.initByDefData = function () {
                this.mesh = this.mgr.getDefaultMesh("quad");
                var shader = this.mgr.getShader("diffuse.shader.json");
                this.mat.setShader(shader);
            };
            EffectElementSingleMesh.prototype.writeToJson = function (obj) {
            };
            EffectElementSingleMesh.prototype.update = function () {
                if (this.active) {
                    if (this.curAttrData.euler != undefined) {
                        gd3d.math.quatFromEulerAngles(this.curAttrData.euler.x, this.curAttrData.euler.y, this.curAttrData.euler.z, this.curAttrData.rotationByEuler);
                    }
                    this.updateElementRotation();
                    gd3d.math.matrixMakeTransformRTS(this.curAttrData.pos, this.curAttrData.scale, this.curAttrData.localRotation, this.curAttrData.matrix);
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElementSingleMesh.prototype.updateElementRotation = function () {
                var cameraTransform = gd3d.framework.sceneMgr.app.getScene().mainCamera.gameObject.transform;
                var worldRotation = gd3d.math.pool.new_quaternion();
                var localRotation = gd3d.math.pool.new_quaternion();
                if (this.curAttrData.renderModel != framework.RenderModel.None) {
                    var invTransformRotation = gd3d.math.pool.new_quaternion();
                    var worldTranslation = gd3d.math.pool.new_vector3();
                    var translation = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Clone(this.curAttrData.pos, translation);
                    if (this.transform != undefined) {
                        gd3d.math.matrixTransformVector3(translation, this.transform.getWorldMatrix(), worldTranslation);
                    }
                    if (this.curAttrData.renderModel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(cameraTransform.getWorldTranslate(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                        var lookRot = new gd3d.math.quaternion();
                        gd3d.math.quatClone(this.transform.getWorldRotate(), invTransformRotation);
                        gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                        gd3d.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        var inverRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatInverse(this.curAttrData.localRotation, inverRot);
                        gd3d.math.quatMultiply(inverRot, lookRot, lookRot);
                        var angle = gd3d.math.pool.new_vector3();
                        gd3d.math.quatToEulerAngles(lookRot, angle);
                        gd3d.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        gd3d.math.quatMultiply(this.curAttrData.localRotation, lookRot, this.curAttrData.localRotation);
                        gd3d.math.pool.delete_quaternion(inverRot);
                        gd3d.math.pool.delete_vector3(angle);
                        gd3d.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, worldRotation);
                    gd3d.math.quatClone(this.transform.gameObject.transform.getWorldRotate(), invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.curAttrData.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                }
                gd3d.math.pool.delete_quaternion(localRotation);
                gd3d.math.pool.delete_quaternion(worldRotation);
            };
            EffectElementSingleMesh.prototype.dispose = function () {
            };
            EffectElementSingleMesh = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [framework.TestEffectSystem, framework.EffectElementData])
            ], EffectElementSingleMesh);
            return EffectElementSingleMesh;
        }());
        framework.EffectElementSingleMesh = EffectElementSingleMesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectElementEmission = (function () {
            function EffectElementEmission(sys, data) {
                if (data === void 0) { data = null; }
                this.active = true;
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.maxVertexCount = 2048;
                this.rotTranslate = new gd3d.math.vector3();
                this.rotScale = new gd3d.math.vector3(1, 1, 1);
                this.rotRotation = new gd3d.math.vector3();
                this.rotQuta = new gd3d.math.quaternion();
                this.elementType = framework.EffectElementTypeEnum.EmissionType;
                this.delayTime = 0;
                this.beloop = true;
                this.lifeTime = new framework.NumberData(5);
                this.simulateInLocalSpace = true;
                this.startScale = new framework.Vector3Data(1, 1, 1);
                this.startEuler = new framework.Vector3Data();
                this.startColor = new gd3d.math.color(1, 1, 1, 1);
                this.colorRate = 1;
                this.duration = new framework.NumberData();
                this.emissionCount = new framework.NumberData();
                this.emissionType = framework.ParticleEmissionType.burst;
                this.shapeType = framework.ParticleSystemShape.NORMAL;
                this.simulationSpeed = new framework.NumberData();
                this.emitFrom = framework.emitfromenum.base;
                this.rendermodel = framework.RenderModel.BillBoard;
                this.enableVelocityOverLifetime = false;
                this.enableSizeOverLifetime = false;
                this.enableRotOverLifeTime = false;
                this.enableColorOverLifetime = false;
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
                this.beBurst = false;
                this.beover = false;
                this.worldRotation = new gd3d.math.quaternion();
                this.matToObj = new gd3d.math.matrix();
                this.matToWorld = new gd3d.math.matrix();
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.effectSys = sys;
                this.gameObject = sys.gameObject;
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.vf) / 4;
                if (data == null) {
                    this.initDefparticleData();
                }
                else {
                    this.initByEmissonData(data);
                }
                this.perVertexCount = this.mesh.data.pos.length;
                this.perIndexxCount = this.mesh.data.trisindex.length;
                if (this.emissionType == framework.ParticleEmissionType.continue) {
                    this._continueSpaceTime = this.duration.getValue() / this.emissionCount.getValue();
                }
                this.getmatrixToObj();
                this.emissionBatchers = [];
                this.deadParticles = [];
                this.curTime = 0;
                this.numcount = 0;
                this.addBatcher();
            }
            EffectElementEmission.prototype.initDefparticleData = function () {
                this.duration.setValue(2.0);
                this.emissionCount.setValue(10);
                this.shapeType = framework.ParticleSystemShape.CONE;
                this.simulationSpeed.setValue(0.1);
                this.radius = 1.0;
                this.angle = 45;
                this.height = 1.0;
                this.mat = framework.sceneMgr.app.getAssetMgr().getDefParticleMat();
                this.mesh = framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
            };
            EffectElementEmission.prototype.initByEmissonData = function (data) {
            };
            EffectElementEmission.prototype.getWorldRotation = function () {
                var parRot = this.gameObject.transform.getWorldRotate();
                gd3d.math.quatMultiply(parRot, this.rotQuta, this.worldRotation);
                return this.worldRotation;
            };
            EffectElementEmission.prototype.getmatrixToObj = function () {
                gd3d.math.quatFromEulerAngles(this.rotRotation.x, this.rotRotation.y, this.rotRotation.z, this.rotQuta);
                gd3d.math.matrixMakeTransformRTS(this.rotTranslate, this.rotScale, this.rotQuta, this.matToObj);
            };
            EffectElementEmission.prototype.getmatrixToWorld = function () {
                var mat = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixMultiply(mat, this.matToObj, this.matToWorld);
                return this.matToWorld;
            };
            EffectElementEmission.prototype.update = function (delta) {
                this.updateLife(delta);
                this.updateBatcher(delta);
            };
            EffectElementEmission.prototype.updateBatcher = function (delta) {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].update(delta);
                }
            };
            EffectElementEmission.prototype.updateLife = function (delta) {
                if (this.beover)
                    return;
                this.curTime += delta;
                this.updateEmission();
                if (this.curTime > this.lifeTime.getValue()) {
                    if (this.beloop) {
                        this.reInit();
                    }
                    else {
                        this.beover = true;
                    }
                }
            };
            EffectElementEmission.prototype.reInit = function () {
                this.beover = false;
                this.curTime = 0;
                this.beBurst = false;
            };
            EffectElementEmission.prototype.updateEmission = function () {
                if (this.emissionType == framework.ParticleEmissionType.continue) {
                    var rate = this.curTime / this.duration.getValue();
                    rate = gd3d.math.floatClamp(rate, 0, 1);
                    var needCount = Math.floor(rate * this.emissionCount.getValue());
                    needCount = needCount - this.numcount;
                    for (var i = 0; i < needCount; i++) {
                        this.addParticle();
                        this.numcount++;
                    }
                }
                else if (this.emissionType == framework.ParticleEmissionType.burst && !this.beBurst) {
                    this.addParticle(this.emissionCount.getValue());
                    this.beBurst = true;
                }
            };
            EffectElementEmission.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var particle = this.deadParticles.pop();
                        particle.initByData();
                        particle.actived = true;
                    }
                    else {
                        var total = this.curbatcher.curVerCount + this.perVertexCount;
                        if (total <= this.maxVertexCount) {
                            this.curbatcher.addParticle();
                        }
                        else {
                            this.addBatcher();
                            this.curbatcher.addParticle();
                        }
                    }
                }
            };
            EffectElementEmission.prototype.addBatcher = function () {
                var batcher = new framework.EmissionBatcher_new(this);
                this.emissionBatchers.push(batcher);
                this.curbatcher = batcher;
            };
            Object.defineProperty(EffectElementEmission.prototype, "renderCamera", {
                get: function () {
                    if (this._renderCamera != null) {
                        return this._renderCamera;
                    }
                    else {
                        return gd3d.framework.sceneMgr.app.getScene().mainCamera;
                    }
                },
                enumerable: true,
                configurable: true
            });
            EffectElementEmission.prototype.render = function (context, assetmgr, camera) {
                this._renderCamera = camera;
                if (this.simulateInLocalSpace) {
                    context.updateModel(this.gameObject.transform);
                }
                else {
                    context.updateModeTrail();
                }
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].render(context, assetmgr, camera);
                }
            };
            EffectElementEmission.prototype.dispose = function () {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].dispose();
                }
                this.emissionBatchers.length = 0;
            };
            EffectElementEmission.prototype.getMesh = function () {
                if (this.rendermodel == framework.RenderModel.Mesh) {
                    return this.mesh;
                }
                else if (this.rendermodel == framework.RenderModel.StretchedBillBoard) {
                    this.mesh = gd3d.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad_particle");
                }
                else {
                    this.mesh = gd3d.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
                }
            };
            EffectElementEmission.prototype.cloneMeshVBO = function () {
                if (this.vbo == null) {
                    this.vbo = this.mesh.data.genVertexDataArray(this.vf);
                }
                return new Float32Array(this.vbo);
            };
            EffectElementEmission.prototype.cloneMeshEBO = function () {
                if (this.ebo == null) {
                    this.ebo = this.mesh.data.genIndexDataArray();
                }
                return new Uint16Array(this.ebo);
            };
            EffectElementEmission.prototype.writeToJson = function (obj) {
                throw new Error("Method not implemented.");
            };
            EffectElementEmission = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [framework.TestEffectSystem, framework.EffectElementData])
            ], EffectElementEmission);
            return EffectElementEmission;
        }());
        framework.EffectElementEmission = EffectElementEmission;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EmissionBatcher_new = (function () {
            function EmissionBatcher_new(emissionElement) {
                this.particles = [];
                this.curVerCount = 0;
                this.curIndexCount = 0;
                this.emission = emissionElement;
                this.webgl = emissionElement.webgl;
                this.mat = this.emission.mat;
                this.initMesh();
            }
            EmissionBatcher_new.prototype.initMesh = function () {
                this.mesh = new framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = 0;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                this.mesh.glMesh.initBuffer(this.webgl, this.emission.vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
            };
            EmissionBatcher_new.prototype.addParticle = function () {
                this.refreshBuffer();
                var p = new framework.Particle_new(this);
                for (var i = 0; i < p.dataForEbo.length; i++) {
                    this.dataForEbo[this.curIndexCount + i] = p.dataForEbo[i] + this.curVerCount;
                }
                this.particles.push(p);
                this.curVerCount += this.emission.perVertexCount;
                this.curIndexCount += this.emission.perIndexxCount;
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
            };
            EmissionBatcher_new.prototype.refreshBuffer = function () {
                var needvercount = this.curVerCount + this.emission.perVertexCount;
                var needIndexCount = this.curIndexCount + this.emission.perIndexxCount;
                if (needvercount * this.emission.vertexSize > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    var vbo = new Float32Array(length * 2);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                if (needIndexCount > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    var ebo = new Uint16Array(length * 2);
                    ebo.set(this.dataForEbo, 0);
                    this.dataForEbo = ebo;
                }
            };
            EmissionBatcher_new.prototype.update = function (delta) {
                for (var key in this.particles) {
                    this.particles[key].update(delta);
                    this.particles[key].uploadData(this.dataForVbo);
                }
            };
            EmissionBatcher_new.prototype.render = function (context, assetmgr, camera) {
                var mesh = this.mesh;
                mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (assetmgr.app.getScene().fog) {
                    context.fog = assetmgr.app.getScene().fog;
                    this.mat.draw(context, mesh, mesh.submesh[0], "base_fog");
                }
                else {
                    this.mat.draw(context, mesh, mesh.submesh[0], "base");
                }
            };
            EmissionBatcher_new.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.mesh.dispose();
                this.mat.dispose();
                for (var key in this.particles) {
                    this.particles[key].dispose();
                }
            };
            return EmissionBatcher_new;
        }());
        framework.EmissionBatcher_new = EmissionBatcher_new;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var effTools = (function () {
            function effTools() {
            }
            effTools.getRandomDirAndPosByZEmission = function (emission, outDir, outPos) {
                switch (emission.shapeType) {
                    case framework.ParticleSystemShape.NORMAL:
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_zero, outPos);
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_up, outDir);
                        break;
                    case framework.ParticleSystemShape.SPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        var radius = Math.random() * emission.radius;
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.HEMISPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI * 0.5;
                        var radius = Math.random() * emission.radius;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.BOX:
                        outPos.x = framework.ValueData.RandomRange(-emission.width / 2, emission.width / 2);
                        outPos.y = framework.ValueData.RandomRange(-emission.height / 2, emission.height / 2);
                        outPos.z = framework.ValueData.RandomRange(-emission.depth / 2, emission.depth / 2);
                        gd3d.math.vec3Normalize(outPos, outDir);
                        break;
                    case framework.ParticleSystemShape.CONE:
                        var randomAngle = Math.random() * Math.PI * 2;
                        var randomHeight = Math.random() * emission.height;
                        var upradius = randomHeight * Math.tan(emission.angle * Math.PI / 180) + emission.radius;
                        var radomRadius = Math.random() * upradius;
                        var bottompos = gd3d.math.pool.new_vector3();
                        bottompos.x = emission.radius * Math.cos(randomAngle);
                        bottompos.y = 0;
                        bottompos.z = emission.radius * Math.sin(randomAngle);
                        if (emission.emitFrom == framework.emitfromenum.base) {
                            gd3d.math.vec3Clone(bottompos, outPos);
                        }
                        else if (emission.emitFrom == framework.emitfromenum.volume) {
                            outPos.x = radomRadius * Math.cos(randomAngle);
                            outPos.z = radomRadius * Math.sin(randomAngle);
                            outPos.y = randomHeight;
                        }
                        outDir.x = Math.cos(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.z = Math.sin(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.y = Math.cos(emission.angle * Math.PI / 180);
                        break;
                }
            };
            effTools.getTex_ST = function (emission, out_St) {
                if (emission.uvType != framework.UVTypeEnum.UVSprite) {
                    out_St.x = 1;
                    out_St.y = 1;
                    out_St.z = 0;
                    out_St.w = 0;
                }
                else {
                    gd3d.math.spriteAnimation(emission.row, emission.column, 0, out_St);
                }
            };
            return effTools;
        }());
        framework.effTools = effTools;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Particle_new = (function () {
            function Particle_new(batcher) {
                this.startScale = new gd3d.math.vector3();
                this.startRotation = new gd3d.math.quaternion();
                this.rotationByShape = new gd3d.math.quaternion();
                this.rotAngle = 0;
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localMatrix = new gd3d.math.matrix();
                this.localTranslate = new gd3d.math.vector3();
                this.localRotation = new gd3d.math.quaternion();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.color = new gd3d.math.vector3(1, 1, 1);
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
                this.curLife = 0;
                this.life = 0;
                this.speedDir = new gd3d.math.vector3(0, 0, 0);
                this.actived = true;
                this.transformVertex = new gd3d.math.matrix();
                this.matToworld = new gd3d.math.matrix();
                this.batcher = batcher;
                this.emisson = batcher.emission;
                this.gameObject = this.emisson.gameObject;
                this.vertexStartIndex = batcher.curVerCount;
                this.dataForVbo = this.emisson.cloneMeshVBO();
                this.dataForEbo = this.emisson.cloneMeshEBO();
                this.sourceVbo = this.emisson.vbo;
                this.initByData();
            }
            Particle_new.prototype.uploadData = function (array) {
                array.set(this.dataForVbo, this.vertexStartIndex * this.emisson.vertexSize);
            };
            Particle_new.prototype.initByData = function () {
                this.totalLife = this.emisson.lifeTime.getValue();
                framework.effTools.getRandomDirAndPosByZEmission(this.emisson, this.speedDir, this.localTranslate);
                this.simulationSpeed = this.emisson.simulationSpeed.getValue();
                this.Starteuler = this.emisson.startEuler.getValue();
                gd3d.math.quatFromEulerAngles(this.Starteuler.x, this.Starteuler.y, this.Starteuler.z, this.rotationByEuler);
                this.localScale = this.emisson.startScale.getValue();
                this.startColor = this.emisson.startColor;
                this.sizeNodes = this.emisson.sizeNodes;
                this.colorNodes = this.emisson.colorNodes;
                this.alphaNodes = this.emisson.alphaNodes;
                if (this.emisson.enableVelocityOverLifetime) {
                    this.movespeed = this.emisson.moveSpeed.getValue();
                }
                if (this.emisson.enableRotOverLifeTime) {
                    this.eulerSpeed = this.emisson.angleSpeed.getValue();
                }
                if (this.emisson.rendermodel == framework.RenderModel.StretchedBillBoard) {
                    var localOrgin = gd3d.math.pool.vector3_zero;
                    gd3d.math.quatLookat(localOrgin, this.speedDir, this.rotationByShape);
                    var initRot = gd3d.math.pool.new_quaternion();
                    gd3d.math.quatFromEulerAngles(90, 0, 90, initRot);
                    gd3d.math.quatMultiply(this.rotationByShape, initRot, this.rotationByShape);
                    gd3d.math.quatClone(this.rotationByShape, this.localRotation);
                    gd3d.math.pool.delete_quaternion(initRot);
                }
                if (!this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = new gd3d.math.matrix();
                    var mat = this.emisson.getmatrixToWorld();
                    gd3d.math.matrixClone(mat, this.emissionMatToWorld);
                    this.emissionWorldRotation = new gd3d.math.quaternion();
                    var quat = this.emisson.getWorldRotation();
                    gd3d.math.quatClone(quat, this.emissionWorldRotation);
                }
            };
            Particle_new.prototype.update = function (delta) {
                if (!this.actived)
                    return;
                this.curLife += delta;
                this.life = this.curLife / this.totalLife;
                gd3d.math.floatClamp(this.life, 0, 1);
                if (this.curLife >= this.totalLife) {
                    gd3d.math.matrixZero(this.transformVertex);
                    this._updateVBO();
                    this.emisson.deadParticles.push(this);
                    this.curLife = 0;
                    this.actived = false;
                    return;
                }
                this._updatePos(delta);
                this._updateScale(delta);
                this._updateEuler(delta);
                this._updateRotation(delta);
                this._updateLocalMatrix(delta);
                this._updateColor(delta);
                this._updateUV(delta);
                this._updateVBO();
            };
            Particle_new.prototype._updateLocalMatrix = function (delta) {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.emisson.simulateInLocalSpace) {
                    gd3d.math.matrixMultiply(this.emisson.matToObj, this.localMatrix, this.transformVertex);
                }
                else {
                    gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            };
            Particle_new.prototype.refreshEmissionData = function () {
                if (this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = this.emisson.getmatrixToWorld();
                    this.emissionWorldRotation = this.emisson.getWorldRotation();
                }
            };
            Particle_new.prototype._updateRotation = function (delta) {
                if (this.emisson.rendermodel == framework.RenderModel.Mesh) {
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_up, this.rotAngle, this.rotationByEuler);
                    gd3d.math.quatClone(this.rotationByEuler, this.localRotation);
                }
                else {
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle, this.rotationByEuler);
                    this.refreshEmissionData();
                    var translation = gd3d.math.pool.new_vector3();
                    var worldTranslation = gd3d.math.pool.new_vector3();
                    var worldRotation = gd3d.math.pool.new_quaternion();
                    var invTransformRotation = gd3d.math.pool.new_quaternion();
                    gd3d.math.vec3Clone(this.localTranslate, translation);
                    var cam = this.emisson.renderCamera;
                    var camPosInWorld = cam.gameObject.transform.getWorldTranslate();
                    gd3d.math.matrixTransformVector3(translation, this.emissionMatToWorld, worldTranslation);
                    if (this.emisson.rendermodel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, camPosInWorld, worldRotation);
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(camPosInWorld, forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                        gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.matToworld);
                        var xaxis = gd3d.math.pool.new_vector3();
                        var yaxis = gd3d.math.pool.new_vector3();
                        var zaxis = gd3d.math.pool.new_vector3();
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_right, this.matToworld, xaxis);
                        gd3d.math.vec3Normalize(xaxis, xaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_up, this.matToworld, yaxis);
                        gd3d.math.vec3Normalize(yaxis, yaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_forward, this.matToworld, zaxis);
                        gd3d.math.vec3Normalize(zaxis, zaxis);
                        framework.EffectUtil.lookatbyXAxis(worldTranslation, xaxis, yaxis, zaxis, camPosInWorld, worldRotation);
                        gd3d.math.quatMultiply(this.localRotation, worldRotation, this.localRotation);
                        gd3d.math.pool.delete_quaternion(worldRotation);
                        gd3d.math.pool.delete_vector3(translation);
                        gd3d.math.pool.delete_quaternion(invTransformRotation);
                        gd3d.math.pool.delete_vector3(xaxis);
                        gd3d.math.pool.delete_vector3(yaxis);
                        gd3d.math.pool.delete_vector3(zaxis);
                        return;
                    }
                    gd3d.math.quatClone(this.emissionWorldRotation, invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.localRotation);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(worldRotation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
            };
            Particle_new.prototype._updatePos = function (delta) {
                var currentTranslate = framework.EffectUtil.vecMuliNum(this.speedDir, this.simulationSpeed);
                gd3d.math.vec3Add(this.localTranslate, currentTranslate, this.localTranslate);
                if (this.emisson.enableVelocityOverLifetime) {
                    this.localTranslate.x += this.movespeed.x * delta;
                    this.localTranslate.y += this.movespeed.y * delta;
                    this.localTranslate.z += this.movespeed.z * delta;
                }
            };
            Particle_new.prototype._updateEuler = function (delta) {
                if (this.emisson.enableRotOverLifeTime) {
                    this.rotAngle = this.eulerSpeed * this.curLife;
                }
            };
            Particle_new.prototype._updateScale = function (delta) {
                if (this.emisson.enableSizeOverLifetime) {
                    for (var i = 0; i < this.sizeNodes.length - 1; i++) {
                        if (this.sizeNodes[i].key <= this.life && this.sizeNodes[i + 1].key >= this.life) {
                            var target = gd3d.math.numberLerp(this.sizeNodes[i].value, this.sizeNodes[i + 1].value, (this.life - this.sizeNodes[i].key) / (this.sizeNodes[i + 1].key - this.sizeNodes[i].key));
                            gd3d.math.vec3ScaleByNum(this.startScale, target, this.localScale);
                            break;
                        }
                    }
                }
            };
            Particle_new.prototype._updateColor = function (delta) {
                if (this.emisson.enableColorOverLifetime) {
                    if (this.colorNodes != null) {
                        for (var i = 0; i < this.colorNodes.length - 1; i++) {
                            if (this.colorNodes[i].key <= this.life && this.colorNodes[i + 1].key >= this.life) {
                                gd3d.math.vec3SLerp(this.colorNodes[i].value, this.colorNodes[i + 1].value, (this.life - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key), this.color);
                                break;
                            }
                        }
                    }
                    if (this.alphaNodes != null) {
                        for (var i = 0; i < this.alphaNodes.length - 1; i++) {
                            if (this.alphaNodes[i].key <= this.life && this.alphaNodes[i + 1].key >= this.life) {
                                this.alpha = gd3d.math.numberLerp(this.alphaNodes[i].value, this.alphaNodes[i + 1].value, (this.life - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key));
                                break;
                            }
                        }
                    }
                }
            };
            Particle_new.prototype._updateUV = function (delta) {
                if (this.emisson.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.z = this.emisson.uSpeed * this.curLife;
                    this.tex_ST.w = this.emisson.vSpeed * this.curLife;
                }
                else if (this.emisson.uvType == framework.UVTypeEnum.UVSprite) {
                    var spriteindex = Math.floor(this.life * this.emisson.count);
                    gd3d.math.spriteAnimation(this.emisson.row, this.emisson.column, spriteindex, this.tex_ST);
                }
            };
            Particle_new.prototype._updateVBO = function () {
                var vertexSize = this.emisson.vertexSize;
                for (var i = 0; i < this.emisson.perVertexCount; i++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = this.sourceVbo[i * vertexSize + 0];
                        vertex.y = this.sourceVbo[i * vertexSize + 1];
                        vertex.z = this.sourceVbo[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, this.transformVertex, vertex);
                        this.dataForVbo[i * vertexSize + 0] = vertex.x;
                        this.dataForVbo[i * vertexSize + 1] = vertex.y;
                        this.dataForVbo[i * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        var r = this.sourceVbo[i * vertexSize + 3] * this.startColor.r;
                        var g = this.sourceVbo[i * vertexSize + 4] * this.startColor.g;
                        var b = this.sourceVbo[i * vertexSize + 5] * this.startColor.b;
                        var a = this.sourceVbo[i * vertexSize + 6] * this.startColor.a;
                        if (this.colorNodes != null) {
                            r = this.color.x;
                            g = this.color.y;
                            b = this.color.z;
                        }
                        if (this.alphaNodes != null) {
                            a = this.alpha;
                        }
                        r *= this.emisson.colorRate;
                        g *= this.emisson.colorRate;
                        b *= this.emisson.colorRate;
                        a *= this.emisson.colorRate;
                        r = gd3d.math.floatClamp(r, 0, 3);
                        g = gd3d.math.floatClamp(g, 0, 3);
                        b = gd3d.math.floatClamp(b, 0, 3);
                        a = gd3d.math.floatClamp(a, 0, 3);
                        this.dataForVbo[i * this.emisson.vertexSize + 3] = r;
                        this.dataForVbo[i * this.emisson.vertexSize + 4] = g;
                        this.dataForVbo[i * this.emisson.vertexSize + 5] = b;
                        this.dataForVbo[i * this.emisson.vertexSize + 6] = a;
                    }
                    {
                        this.dataForVbo[i * vertexSize + 7] = this.sourceVbo[i * vertexSize + 7] * this.tex_ST.x + this.tex_ST.z;
                        this.dataForVbo[i * vertexSize + 8] = this.sourceVbo[i * vertexSize + 8] * this.tex_ST.y + this.tex_ST.w;
                    }
                }
            };
            Particle_new.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.startRotation = null;
                this.localRotation = null;
                this.rotationByEuler = null;
                this.rotationByShape = null;
                this.tex_ST = null;
                this.localMatrix = null;
                this.localTranslate = null;
                this.Starteuler = null;
                this.localScale = null;
                this.color = null;
            };
            return Particle_new;
        }());
        framework.Particle_new = Particle_new;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Curve3 = (function () {
            function Curve3(points, nbPoints) {
                this._beizerPoints = points;
                this._bezierPointNum = nbPoints;
            }
            Object.defineProperty(Curve3.prototype, "beizerPoints", {
                get: function () {
                    return this._beizerPoints;
                },
                set: function (value) {
                    this._beizerPoints = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Curve3.prototype, "bezierPointNum", {
                get: function () {
                    return this._bezierPointNum;
                },
                set: function (value) {
                    this._bezierPointNum = value;
                },
                enumerable: true,
                configurable: true
            });
            Curve3.CreateLinearBezier = function (start, end, indices) {
                indices = indices > 2 ? indices : 3;
                var bez = new Array();
                var equation = function (t, va10, va11) {
                    var res = (1.0 - t) * va10 + t * va11;
                    return res;
                };
                bez.push(start);
                for (var i = 1; i <= indices; i++) {
                    bez.push(new gd3d.math.vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
                }
                return new Curve3(bez, indices);
            };
            Curve3.GetLerpBezier = function (nodes) {
                var beizerPoint = new Array();
                for (var n = 0; n < nodes.length; n++) {
                    beizerPoint.push(nodes[n].getValue());
                }
                return new Curve3(beizerPoint, nodes.length);
            };
            Curve3.CreateQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
                bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
                var beizerPoint = new Array();
                var equation = function (t, val0, val1, val2) {
                    var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new gd3d.math.vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            };
            Curve3.CreateCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
                bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
                var beizerPoint = new Array();
                var equation = function (t, val0, val1, val2, val3) {
                    var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new gd3d.math.vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            };
            Curve3.prototype.getPoints = function () {
                return this._beizerPoints;
            };
            return Curve3;
        }());
        framework.Curve3 = Curve3;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var LinearAction = (function () {
            function LinearAction() {
            }
            LinearAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.attrival = framework.EffectUtil.parseEffectVec3(this.params["value"]);
                            break;
                        case "uv":
                            this.attrival = framework.EffectUtil.parseEffectUVSpeed(this.params["value"]);
                            break;
                        case "alpha":
                            this.attrival = this.params["value"];
                            break;
                    }
                }
            };
            LinearAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                var baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos.x = baseValue.pos.x + this.attrival.x.getValue();
                        baseValue.pos.y = baseValue.pos.y + this.attrival.y.getValue();
                        baseValue.pos.z = baseValue.pos.z + this.attrival.z.getValue();
                        break;
                    case "scale":
                        baseValue.scale.x = baseValue.scale.x + this.attrival.x.getValue();
                        baseValue.scale.y = baseValue.scale.y + this.attrival.y.getValue();
                        baseValue.scale.z = baseValue.scale.z + this.attrival.z.getValue();
                        break;
                    case "euler":
                        baseValue.euler.x = baseValue.euler.x + this.attrival.x.getValue();
                        baseValue.euler.y = baseValue.euler.y + this.attrival.y.getValue();
                        baseValue.euler.z = baseValue.euler.z + this.attrival.z.getValue();
                        break;
                    case "color":
                        baseValue.color.x = baseValue.color.x + this.attrival.x.getValue();
                        baseValue.color.y = baseValue.color.y + this.attrival.y.getValue();
                        baseValue.color.z = baseValue.color.z + this.attrival.z.getValue();
                        break;
                    case "uv":
                        baseValue.uv.x = baseValue.uv.x + this.attrival.u.getValue();
                        baseValue.uv.y = baseValue.uv.y + this.attrival.v.getValue();
                        break;
                    case "alpha":
                        baseValue.alpha = baseValue.alpha + this.attrival;
                        break;
                }
            };
            return LinearAction;
        }());
        framework.LinearAction = LinearAction;
        var DestroyAction = (function () {
            function DestroyAction() {
            }
            DestroyAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            };
            DestroyAction.prototype.update = function (frameIndex) {
                if (frameIndex >= this.startFrame) {
                    this.elements.setActive(false);
                }
            };
            return DestroyAction;
        }());
        framework.DestroyAction = DestroyAction;
        var LoopAction = (function () {
            function LoopAction() {
            }
            LoopAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            };
            LoopAction.prototype.update = function (frameIndex) {
                if (frameIndex == this.startFrame) {
                    this.elements.loopFrame = this.startFrame + 1;
                    this.elements.curAttrData = this.elements.data.initFrameData.attrsData.copyandinit();
                }
            };
            return LoopAction;
        }());
        framework.LoopAction = LoopAction;
        var UVRollAction = (function () {
            function UVRollAction() {
                this.speedu = 0;
                this.speedv = 0;
                this.startu = 0;
                this.startv = 0;
            }
            UVRollAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["speedu"] != undefined) {
                    this.speedu = this.params["speedu"];
                }
                if (this.params["speedv"] != undefined) {
                    this.speedv = this.params["speedv"];
                }
                if (this.params["startu"] != undefined) {
                    this.startu = this.params["startu"];
                }
                if (this.params["startv"] != undefined) {
                    this.startv = this.params["startv"];
                }
            };
            UVRollAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                if (this.startFrame == frameIndex) {
                    this.elements.curAttrData.uv.x = this.startu;
                    this.elements.curAttrData.uv.y = this.startv;
                    return;
                }
                this.elements.curAttrData.uv.x += this.speedu;
                this.elements.curAttrData.uv.y += this.speedv;
            };
            return UVRollAction;
        }());
        framework.UVRollAction = UVRollAction;
        var UVSpriteAnimationAction = (function () {
            function UVSpriteAnimationAction() {
                this.fps = 30;
                this.row = 1;
                this.colum = 1;
                this.totalCount = 1;
                this.frameInternal = 1;
                this.spriteIndex = 0;
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
            }
            UVSpriteAnimationAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["row"] != undefined) {
                    this.row = this.params["row"];
                }
                if (this.params["colum"] != undefined) {
                    this.colum = this.params["colum"];
                }
                if (this.params["count"] != undefined) {
                    this.totalCount = this.params["count"];
                }
            };
            UVSpriteAnimationAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                var spriteindex = Math.floor((frameIndex - this.startFrame) / (this.endFrame - this.startFrame) * this.totalCount);
                gd3d.math.spriteAnimation(this.row, this.colum, spriteindex, this.tex_ST);
                this.elements.curAttrData.uv.x = this.tex_ST.z;
                this.elements.curAttrData.uv.y = this.tex_ST.w;
                this.elements.curAttrData.tilling.x = this.tex_ST.x;
                this.elements.curAttrData.tilling.y = this.tex_ST.y;
            };
            return UVSpriteAnimationAction;
        }());
        framework.UVSpriteAnimationAction = UVSpriteAnimationAction;
        var RotationAction = (function () {
            function RotationAction() {
            }
            RotationAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["velocity"] != undefined) {
                    this.velocity = framework.EffectUtil.parseEffectVec3(this.params["velocity"]);
                }
                this.frameInternal = 1 / framework.effectSystem.fps;
            };
            RotationAction.prototype.update = function (frameIndex) {
                this.elements.curAttrData.euler.z = this.elements.curAttrData.euler.z + (this.velocity.z.getValue()) * this.frameInternal;
                if (this.elements.curAttrData.renderModel == framework.RenderModel.None) {
                    this.elements.curAttrData.euler.x = this.elements.curAttrData.euler.x + (this.velocity.x.getValue()) * this.frameInternal;
                    this.elements.curAttrData.euler.y = this.elements.curAttrData.euler.y + (this.velocity.y.getValue()) * this.frameInternal;
                }
            };
            return RotationAction;
        }());
        framework.RotationAction = RotationAction;
        var RoseCurveAction = (function () {
            function RoseCurveAction() {
            }
            RoseCurveAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["radius"] != undefined) {
                    this.radius = this.params["radius"];
                }
                if (this.params["level"] != undefined) {
                    this.level = this.params["radius"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["polar"] != undefined) {
                    this.polar = framework.EffectUtil.parseEffectVec3(this.params["polar"]);
                }
                this.frameInternal = 1 / framework.effectSystem.fps;
            };
            RoseCurveAction.prototype.update = function (frameIndex) {
                var initFrameDataPos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.elements.data.initFrameData.attrsData.pos, initFrameDataPos);
                var radius = this.radius;
                var curFrame = frameIndex % 360;
                var x = this.polar.x.getValue();
                var y = this.polar.y.getValue();
                var z = this.polar.z.getValue();
                {
                    var theta = frameIndex * this.speed;
                    this.elements.curAttrData.pos.x = initFrameDataPos.x + radius * Math.cos(3 * theta + x) * Math.cos(theta);
                    this.elements.curAttrData.pos.z = initFrameDataPos.z + radius * Math.cos(3 * theta + x) * Math.sin(theta);
                    this.elements.curAttrData.pos.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                }
                {
                    var deltaTheta = frameIndex * this.speed + 0.001;
                    var targetPoint = gd3d.math.pool.new_vector3();
                    targetPoint.x = initFrameDataPos.x + radius * Math.cos(3 * deltaTheta + x) * Math.cos(deltaTheta);
                    targetPoint.z = initFrameDataPos.z + radius * Math.cos(3 * deltaTheta + x) * Math.sin(deltaTheta);
                    targetPoint.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                    var rotation = gd3d.math.pool.new_quaternion();
                    gd3d.math.quatLookat(this.elements.curAttrData.pos, targetPoint, rotation);
                    gd3d.math.quatToEulerAngles(rotation, this.elements.curAttrData.euler);
                    gd3d.math.pool.delete_vector3(targetPoint);
                    gd3d.math.pool.delete_quaternion(rotation);
                }
                gd3d.math.pool.delete_vector3(initFrameDataPos);
            };
            return RoseCurveAction;
        }());
        framework.RoseCurveAction = RoseCurveAction;
        var TrailAction = (function () {
            function TrailAction() {
                this.offsetTransalte = new gd3d.math.vector3();
            }
            TrailAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["pos"] != undefined) {
                    this.position = framework.EffectUtil.parseEffectVec3(this.params["pos"]);
                }
                this.offsetTransalte.x = this.position.x.getValue();
                this.offsetTransalte.y = this.position.y.getValue();
                this.offsetTransalte.z = this.position.z.getValue();
                if (this.params["eular"] != undefined) {
                    this.eular = framework.EffectUtil.parseEffectVec3(this.params["eular"]);
                }
                if (this.params["color"] != undefined) {
                    this.color = framework.EffectUtil.parseEffectVec3(this.params["color"]);
                }
                if (this.params["width"] != undefined) {
                    this.width = this.params["width"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["alpha"] != undefined) {
                    this.alpha = this.params["alpha"];
                }
                var mat = new gd3d.framework.material();
                var shader = new gd3d.framework.shader();
                var texture = new gd3d.framework.texture();
                if (this.params["shader"] != undefined)
                    shader = framework.sceneMgr.app.getAssetMgr().getShader(this.params["shader"]);
                else
                    shader = framework.sceneMgr.app.getAssetMgr().getShader("shader/def");
                mat.setShader(shader);
                if (this.params["diffuseTexture"] != undefined)
                    texture = framework.sceneMgr.app.getAssetMgr().getAssetByName(this.params["diffuseTexture"]);
                mat.setTexture("_MainTex", texture);
                this.frameInternal = 1 / framework.effectSystem.fps;
                this.transform = new gd3d.framework.transform();
                framework.sceneMgr.scene.addChild(this.transform);
                var curAttrData = this.elements.data.initFrameData.attrsData.clone();
                var worldTranslate = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    gd3d.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                gd3d.math.vec3Clone(worldTranslate, this.transform.localTranslate);
                gd3d.math.pool.delete_vector3(worldTranslate);
                var trailTransform = new gd3d.framework.transform();
                this.transform.addChild(trailTransform);
                var x = this.eular.x.getValue();
                var y = this.eular.y.getValue();
                var z = this.eular.z.getValue();
                this.startRotation = new gd3d.math.quaternion();
                gd3d.math.quatFromEulerAngles(x, y, z, this.startRotation);
                gd3d.math.quatMultiply(this.startRotation, curAttrData.localRotation, this.transform.localRotate);
                this.transform.markDirty();
                trailTransform.markDirty();
                var trailrender = trailTransform.gameObject.addComponent("trailRender");
                trailrender.color = new gd3d.math.color(this.color.x.getValue(), this.color.y.getValue(), this.color.z.getValue(), this.alpha);
                trailrender.setspeed(this.speed);
                trailrender.setWidth(this.width);
                trailrender.material = mat;
            };
            TrailAction.prototype.update = function (frameIndex) {
                var worldTranslate = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.elements.curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    gd3d.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                gd3d.math.vec3Clone(worldTranslate, this.transform.localTranslate);
                gd3d.math.vec3Add(this.transform.localTranslate, this.offsetTransalte, this.transform.localTranslate);
                gd3d.math.pool.delete_vector3(worldTranslate);
                gd3d.math.quatMultiply(this.startRotation, this.elements.curAttrData.localRotation, this.transform.localRotate);
                this.transform.markDirty();
            };
            return TrailAction;
        }());
        framework.TrailAction = TrailAction;
        var BreathAction = (function () {
            function BreathAction() {
            }
            BreathAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    this.loopframe = this.params["loopframe"];
                    this.halfloopframe = this.loopframe / 2;
                    this.curTargetFrame = this.startFrame + this.halfloopframe;
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.startvalue = framework.EffectUtil.parseEffectVec3(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectVec3(this.params["targetvalue"]).getValue();
                            break;
                        case "uv":
                            this.startvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["targetvalue"]).getValue();
                            break;
                        case "alpha":
                            this.startvalue = this.params["startvalue"];
                            this.targetvalue = this.params["targetvalue"];
                            break;
                    }
                }
            };
            BreathAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex)
                    return;
                if (frameIndex >= this.curTargetFrame) {
                    this.swap();
                    this.curTargetFrame += this.halfloopframe;
                }
                var baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos = this.getLerpValue(frameIndex);
                        break;
                    case "scale":
                        baseValue.scale = this.getLerpValue(frameIndex);
                        break;
                    case "euler":
                        baseValue.euler = this.getLerpValue(frameIndex);
                        break;
                    case "color":
                        baseValue.color = this.getLerpValue(frameIndex);
                        break;
                    case "uv":
                        baseValue.uv = this.getLerpValue(frameIndex);
                        break;
                    case "alpha":
                        baseValue.alpha = this.getLerpValue(frameIndex);
                        break;
                }
            };
            BreathAction.prototype.swap = function () {
                var temp;
                if (this.startvalue instanceof gd3d.math.vector3) {
                    temp = gd3d.math.pool.clone_vector3(this.startvalue);
                    this.startvalue = gd3d.math.pool.clone_vector3(this.targetvalue);
                    this.targetvalue = temp;
                }
                else if (this.startvalue instanceof gd3d.math.vector2) {
                    temp = gd3d.math.pool.clone_vector2(this.startvalue);
                    this.startvalue = gd3d.math.pool.clone_vector2(this.targetvalue);
                    this.targetvalue = temp;
                }
                else {
                    temp = this.startvalue;
                    this.startvalue = this.targetvalue;
                    this.targetvalue = temp;
                }
            };
            BreathAction.prototype.getLerpValue = function (frameIndex) {
                var curframe = (frameIndex - this.startFrame) % this.halfloopframe;
                var outVal;
                if (this.startvalue instanceof gd3d.math.vector3) {
                    outVal = new gd3d.math.vector3();
                    gd3d.math.vec3SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else if (this.startvalue instanceof gd3d.math.vector2) {
                    outVal = new gd3d.math.vector2();
                    gd3d.math.vec2SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else {
                    outVal = gd3d.math.numberLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe);
                }
                return outVal;
            };
            return BreathAction;
        }());
        framework.BreathAction = BreathAction;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectParser = (function () {
            function EffectParser() {
            }
            EffectParser.prototype.Parse = function (str, assetmgr) {
                if (str == null)
                    return null;
                this.asMgr = assetmgr;
                var effectData = new framework.EffectSystemData();
                var content = JSON.parse(str);
                if (content["life"] != undefined)
                    effectData.life = content["life"];
                if (content["beloop"] != undefined) {
                    effectData.beLoop = content["beloop"];
                }
                var refOriDic = {};
                var unRefOriDic = {};
                var refCount = 0;
                if (content["elements"] != undefined) {
                    effectData.elementDic = {};
                    var elements = content["elements"];
                    for (var i in elements) {
                        var elementData = elements[i];
                        var name_9 = "";
                        if (elementData["name"] != undefined) {
                            name_9 = elementData["name"];
                            if (effectData.elementDic[name_9] != undefined || refOriDic[name_9] != undefined) {
                                console.error("特效中元素的名字重复：" + name_9);
                                continue;
                            }
                        }
                        else {
                            console.error("未设置特效中元素的名字！");
                            continue;
                        }
                        if (elementData["ref"] != undefined) {
                            refOriDic[name_9] = elementData;
                            refCount++;
                            continue;
                        }
                        else {
                            effectData.elementDic[name_9] = this._parse(elementData);
                            unRefOriDic[name_9] = elementData;
                        }
                    }
                    while (refCount > 0) {
                        for (var key in refOriDic) {
                            var desOriData = refOriDic[key];
                            if (desOriData == null)
                                continue;
                            var refFrom = desOriData["ref"];
                            if (unRefOriDic[refFrom] != undefined) {
                                var srcOriData = unRefOriDic[refFrom];
                                this.copyAndOverWrite(srcOriData, desOriData);
                                var element = this._parse(desOriData);
                                effectData.elementDic[desOriData["name"]] = element;
                                delete refOriDic[key];
                                refCount--;
                            }
                        }
                    }
                }
                return effectData;
            };
            EffectParser.prototype._parse = function (elementData) {
                var element = new framework.EffectElementData();
                if (elementData["beloop"] != undefined)
                    element.beloop = elementData["beloop"];
                if (elementData["delaytime"] != undefined)
                    element.delayTime = elementData["delaytime"];
                element.name = elementData["name"];
                if (elementData["type"] != undefined) {
                    switch (elementData["type"]) {
                        case "singlemesh":
                            element.type = framework.EffectElementTypeEnum.SingleMeshType;
                            break;
                        case "emission":
                            element.type = framework.EffectElementTypeEnum.EmissionType;
                            break;
                    }
                }
                switch (element.type) {
                    case framework.EffectElementTypeEnum.SingleMeshType:
                        this._parseSingleMeshTypeData(elementData, element);
                        break;
                    case framework.EffectElementTypeEnum.EmissionType:
                        this._parseEmissionTypeData(elementData, element);
                        break;
                }
                return element;
            };
            EffectParser.prototype.copyAndOverWrite = function (srcData, desData) {
                for (var key in srcData) {
                    var data = srcData[key];
                    if (data != undefined) {
                        var baseType = typeof (data);
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                if (desData[key] == undefined)
                                    desData[key] = data;
                                break;
                            default:
                                if (desData[key] == undefined) {
                                    desData[key] = srcData[key];
                                }
                                else {
                                    this.copyAndOverWrite(srcData[key], desData[key]);
                                }
                                break;
                        }
                    }
                }
            };
            EffectParser.prototype._parseSingleMeshTypeData = function (elementData, element) {
                if (elementData["timeline"] != undefined) {
                    element.timelineFrame = {};
                    element.actionData = [];
                    var _timelineArray = elementData["timeline"];
                    for (var j in _timelineArray) {
                        var _timeline = _timelineArray[j];
                        if (_timeline["frame"] == undefined) {
                            console.error("必须要配一个关键帧的索引");
                            continue;
                        }
                        var frame = new framework.EffectFrameData();
                        frame.frameIndex = _timeline["frame"];
                        element.timelineFrame[frame.frameIndex] = frame;
                        frame.attrsData = new framework.EffectAttrsData();
                        if (_timeline["attrs"] != undefined) {
                            var _attrs = _timeline["attrs"];
                            for (var key in _attrs) {
                                var val = this._parseToObjData(key, _attrs[key]);
                                if (key == "mat") {
                                    frame.attrsData.mat = val;
                                }
                                else if (key == "pos") {
                                    frame.attrsData.pos = val.getValue();
                                }
                                else if (key == "scale") {
                                    frame.attrsData.scale = val.getValue();
                                }
                                else if (key == "euler") {
                                    frame.attrsData.euler = val.getValue();
                                }
                                else if (key == "mesh") {
                                    frame.attrsData.mesh = val;
                                }
                                else if (key == "color") {
                                    frame.attrsData.color = val.getValue();
                                }
                                else if (key == "alpha") {
                                    frame.attrsData.alpha = val.getValue();
                                    ;
                                }
                                else if (key == "tilling") {
                                    frame.attrsData.tilling = val.getValue();
                                }
                                else if (key == "billboard") {
                                    frame.attrsData.renderModel = val;
                                }
                                else if (key == "colorRate") {
                                    frame.attrsData.colorRate = val;
                                }
                            }
                        }
                        if (frame.frameIndex == -1) {
                            element.initFrameData = frame;
                        }
                        if (_timeline["lerp"] != undefined) {
                            frame.lerpDatas = [];
                            for (var x in _timeline["lerp"]) {
                                var lerp = new framework.EffectLerpData();
                                lerp.fromFrame = frame.frameIndex;
                                frame.lerpDatas.push(lerp);
                                var _lerp = _timeline["lerp"][x];
                                if (_lerp["type"] != undefined) {
                                    switch (_lerp["type"]) {
                                        case "linear":
                                            lerp.type = framework.EffectLerpTypeEnum.Linear;
                                            break;
                                    }
                                }
                                if (_lerp["to"] != undefined)
                                    lerp.toFrame = this._parseToValueData(_lerp["to"]);
                                if (_lerp["attribute"] != undefined) {
                                    lerp.attrsData = new framework.EffectAttrsData();
                                    var _attribs = _lerp["attribute"];
                                    for (var key in _attribs) {
                                        lerp.attrsList.push(key);
                                        var val = this._parseToObjData(key, _attribs[key]);
                                        if (key == "pos") {
                                            lerp.attrsData.pos = val.getValue();
                                        }
                                        else if (key == "scale") {
                                            lerp.attrsData.scale = val.getValue();
                                        }
                                        else if (key == "euler") {
                                            lerp.attrsData.euler = val.getValue();
                                        }
                                        else if (key == "color") {
                                            lerp.attrsData.color = val.getValue();
                                        }
                                        else if (key == "alpha") {
                                            lerp.attrsData.alpha = val.getValue();
                                        }
                                        else {
                                            console.error("未支持的插值属性：" + key);
                                        }
                                    }
                                }
                            }
                        }
                        if (_timeline["actions"] != undefined) {
                            var _actions = _timeline["actions"];
                            for (var k in _actions) {
                                var action = new framework.EffectActionData();
                                var _action = _actions[k];
                                action.actionType = _action["action"];
                                action.startFrame = frame.frameIndex;
                                if (_action["end"] != undefined) {
                                    action.endFrame = _action["end"];
                                }
                                else {
                                    action.endFrame = -1;
                                }
                                if (_action["param"] != undefined) {
                                    action.params = _action["param"];
                                }
                                element.actionData.push(action);
                            }
                        }
                    }
                }
            };
            EffectParser.prototype._parseEmissionTypeData = function (elementData, element) {
                if (elementData["timeline"] != undefined) {
                    var timelines = elementData["timeline"];
                    if (timelines.length > 0 && timelines[0] != undefined && timelines[0]["attrs"] != undefined) {
                        var _data = timelines[0]["attrs"];
                        var data = new framework.Emission();
                        element.emissionData = data;
                        if (_data["emissionType"] != undefined) {
                            switch (_data["emissionType"]) {
                                case "burst":
                                    data.emissionType = framework.ParticleEmissionType.burst;
                                    break;
                                case "continue":
                                    data.emissionType = framework.ParticleEmissionType.continue;
                                    break;
                            }
                            if (_data["simulateinlocal"] != undefined) {
                                data.simulateInLocalSpace = _data["simulateinlocal"];
                            }
                            if (_data["maxcount"] != undefined)
                                data.maxEmissionCount = _data["maxcount"];
                            if (_data["emissioncount"] != undefined)
                                data.emissionCount = _data["emissioncount"];
                            if (_data["time"] != undefined)
                                data.time = _data["time"];
                            if (_data["mesh"] != undefined)
                                data.mesh = this._parseToObjData("mesh", _data["mesh"]);
                            if (_data["mat"] != undefined)
                                data.mat = this._parseToObjData("mat", _data["mat"]);
                            if (_data["rootpos"] != undefined) {
                                data.rootpos = framework.EffectUtil.parseVector3(_data["rootpos"]);
                            }
                            else {
                                data.rootpos = new gd3d.math.vector3();
                            }
                            if (_data["rootRotAngle"] != undefined) {
                                data.rootRotAngle = framework.EffectUtil.parseVector3(_data["rootRotAngle"]);
                            }
                            else {
                                data.rootRotAngle = new gd3d.math.vector3();
                            }
                            if (_data["rootscale"]) {
                                data.rootScale = framework.EffectUtil.parseVector3(_data["rootscale"]);
                            }
                            else {
                                data.rootScale = new gd3d.math.vector3(1, 1, 1);
                            }
                            if (_data["moveSpeed"] != undefined)
                                data.moveSpeed = this._parseToObjData("moveSpeed", _data["moveSpeed"]);
                            if (_data["gravity"] != undefined)
                                data.gravity = _data["gravity"];
                            if (_data["euler"] != undefined)
                                data.euler = this._parseToObjData("euler", _data["euler"]);
                            if (_data["eulerSpeed"] != undefined)
                                data.eulerSpeed = this._parseToObjData("eulerSpeed", _data["eulerSpeed"]);
                            if (_data["eulerNodes"] != undefined) {
                                data.eulerNodes = [];
                                if (data.euler != undefined) {
                                    data.eulerNodes.push(data.euler);
                                    data.euler.key = 0;
                                }
                                for (var i in _data["eulerNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["eulerNodes"][i]);
                                    data.eulerNodes.push(node);
                                }
                            }
                            if (_data["scale"] != undefined)
                                data.scale = this._parseToObjData("scale", _data["scale"]);
                            if (_data["scaleSpeed"] != undefined)
                                data.scaleSpeed = this._parseToObjData("scaleSpeed", _data["scaleSpeed"]);
                            if (_data["scaleNodes"] != undefined) {
                                data.scaleNodes = [];
                                var startscale = new framework.ParticleNodeNumber();
                                startscale.num.value = 1;
                                startscale.key = 0;
                                data.scaleNodes.push(startscale);
                                for (var i in _data["scaleNodes"]) {
                                    var node = framework.EffectUtil.parseEffectNumNode(_data["scaleNodes"][i]);
                                    data.scaleNodes.push(node);
                                }
                            }
                            if (_data["simulationSpeed"] != undefined) {
                                data.simulationSpeed = this._parseToObjData("simulationSpeed", _data["simulationSpeed"]);
                            }
                            if (_data["alpha"] != undefined) {
                                data.alpha = this._parseToObjData("alpha", _data["alpha"]);
                            }
                            if (_data["alphaSpeed"] != undefined)
                                data.alphaSpeed = this._parseToObjData("alphaSpeed", _data["alphaSpeed"]);
                            if (_data["alphaNodes"] != undefined) {
                                data.alphaNodes = [];
                                if (data.alpha != undefined) {
                                    data.alphaNodes.push(data.alpha);
                                    data.alpha.key = 0;
                                }
                                for (var i in _data["alphaNodes"]) {
                                    var node = new framework.ParticleNodeNumber();
                                    var item = _data["alphaNodes"][i];
                                    if (item["key"] != null) {
                                        node.key = item["key"];
                                    }
                                    var alphavalue = item["alpha"];
                                    if (alphavalue != null) {
                                        if (alphavalue instanceof Array) {
                                            node.num.valueLimitMin = alphavalue[0];
                                            node.num.valueLimitMax = alphavalue[1];
                                        }
                                        else {
                                            node.num.value = alphavalue;
                                        }
                                    }
                                    data.alphaNodes.push(node);
                                }
                            }
                            if (_data["color"] != undefined)
                                data.color = this._parseToObjData("color", _data["color"]);
                            if (_data["colorRate"] != undefined)
                                data.colorRate = _data["colorRate"];
                            if (_data["colorSpeed"] != undefined)
                                data.colorSpeed = this._parseToObjData("colorSpeed", _data["colorSpeed"]);
                            if (_data["colorNodes"] != undefined) {
                                data.colorNodes = [];
                                if (data.color != undefined) {
                                    data.colorNodes.push(data.color);
                                    data.color.key = 0;
                                }
                                for (var i in _data["colorNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["colorNodes"][i]);
                                    data.colorNodes.push(node);
                                }
                            }
                            if (_data["uv"] != undefined) {
                                data.uv = framework.EffectUtil.parseEffectVec2(_data["uv"]);
                            }
                            if (_data["uvtype"] != undefined) {
                                switch (_data["uvtype"]) {
                                    case "uvroll":
                                        data.uvType = framework.UVTypeEnum.UVRoll;
                                        if (_data["uvroll"] != undefined) {
                                            data.uvRoll = new framework.UVRoll();
                                            data.uvRoll.uvSpeed = framework.EffectUtil.parseEffectUVSpeed(_data["uvroll"]);
                                        }
                                        break;
                                    case "uvsprite":
                                        var _val = _data["uvsprite"];
                                        data.uvType = framework.UVTypeEnum.UVSprite;
                                        data.uvSprite = new framework.UVSprite();
                                        if (_val["row"] != undefined)
                                            data.uvSprite.row = _val["row"];
                                        if (_val["colum"] != undefined)
                                            data.uvSprite.column = _val["colum"];
                                        if (_val["count"] != undefined)
                                            data.uvSprite.totalCount = _val["count"];
                                        break;
                                    default:
                                        data.uvType = framework.UVTypeEnum.NONE;
                                        break;
                                }
                            }
                            else
                                data.uvType = framework.UVTypeEnum.NONE;
                            if (_data["billboard"] != undefined)
                                data.renderModel = this._parseToObjData("billboard", _data["billboard"]);
                            if (_data["life"] != undefined)
                                data.life = framework.EffectUtil.parseEffectValueData(_data["life"]);
                            if (_data["startpos"] != undefined) {
                                this._parseEmissionShape(_data["startpos"], element);
                            }
                        }
                    }
                }
            };
            EffectParser.prototype._parseEmissionShape = function (_startdata, element) {
                var startdata = element.emissionData.particleStartData;
                switch (_startdata["type"]) {
                    case "normal":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.NORMAL;
                        break;
                    case "box":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.BOX;
                        break;
                    case "sphere":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.SPHERE;
                        break;
                    case "hemisphere":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.HEMISPHERE;
                        break;
                    case "cone":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.CONE;
                        break;
                    case "circle":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.CIRCLE;
                        break;
                    case "edge":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.EDGE;
                        break;
                    default:
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.NORMAL;
                        break;
                }
                if (_startdata["width"] != undefined) {
                    startdata.width = _startdata["width"];
                }
                if (_startdata["height"] != undefined) {
                    startdata.height = _startdata["height"];
                }
                if (_startdata["depth"] != undefined) {
                    startdata.depth = _startdata["depth"];
                }
                if (_startdata["angle"] != undefined) {
                    startdata.angle = _startdata["angle"];
                }
                if (_startdata["radius"] != undefined) {
                    startdata.radius = _startdata["radius"];
                }
                if (_startdata["direction"] != undefined) {
                    var _startdir = _startdata["direction"];
                    startdata.direction.x = _startdir["x"];
                    startdata.direction.y = _startdir["y"];
                    startdata.direction.z = _startdir["z"];
                }
            };
            EffectParser.prototype._parseToObjData = function (attrib, content) {
                switch (attrib) {
                    case "pos":
                    case "scale":
                    case "euler":
                    case "color":
                    case "moveSpeed":
                    case "eulerSpeed":
                    case "scaleSpeed":
                    case "colorSpeed":
                        return framework.EffectUtil.parseEffectVec3(content);
                    case "":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "alphaSpeed":
                    case "alpha":
                    case "simulationSpeed":
                        return framework.EffectUtil.parseEffectNum(content);
                    case "tilling":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "mat":
                        var mat = new framework.EffectMatData();
                        if (content != undefined) {
                            if (content["shader"] != undefined)
                                mat.shader = this.asMgr.getShader(content["shader"]);
                            else
                                mat.shader = this.asMgr.getShader("shader/def");
                            if (content["diffuseTexture"] != undefined)
                                mat.diffuseTexture = this.asMgr.getAssetByName(content["diffuseTexture"]);
                            if (content["alphaCut"] != undefined)
                                mat.alphaCut = content["alphaCut"];
                            if (content["_AlphaTex"] != undefined)
                                mat.alphaTexture = this.asMgr.getAssetByName(content["_AlphaTex"]);
                        }
                        return mat;
                    case "emmision":
                        var emission = new framework.EmissionData();
                        if (content["type"] != undefined)
                            emission.type = content["type"];
                        if (content["time"] != undefined)
                            emission.time = content["time"];
                        if (content["count"] != undefined)
                            emission.count = content["count"];
                        return emission;
                    case "billboard":
                        var billboardType = framework.RenderModel.Mesh;
                        if (content == "billboard") {
                            billboardType = framework.RenderModel.BillBoard;
                        }
                        else if (content == "horizontal") {
                            billboardType = framework.RenderModel.HorizontalBillBoard;
                        }
                        else if (content == "stretched") {
                            billboardType = framework.RenderModel.StretchedBillBoard;
                        }
                        else if (content == "vertical") {
                            billboardType = framework.RenderModel.VerticalBillBoard;
                        }
                        else if (content == "mesh") {
                            billboardType = framework.RenderModel.Mesh;
                        }
                        else {
                            billboardType = framework.RenderModel.None;
                        }
                        return billboardType;
                    case "mesh":
                        var str = content;
                        if (content.toString().indexOf(".mesh.bin") >= 0)
                            return this.asMgr.getAssetByName(content);
                        else
                            return this.asMgr.getDefaultMesh(content);
                    default:
                        return content;
                }
            };
            EffectParser.prototype._parseToParticleNode = function (content) {
                content = framework.StringUtil.replaceAll(content, " ", "");
                var charArray = content.match(framework.RegexpUtil.vector3FloatOrRangeRegexp);
                if (charArray != undefined) {
                    var node = new framework.ParticleNode();
                    for (var i = 1; i < charArray.length; i++) {
                        if (i == 1) {
                            node.x = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 2) {
                            node.y = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 3) {
                            node.z = this._parseToValueData(charArray[i]);
                        }
                    }
                    return node;
                }
                return null;
            };
            EffectParser.prototype._parseToValueData = function (content) {
                var data = new framework.ValueData();
                var array = this._parseToNumberArray(content);
                if (array != null) {
                    if (array.length > 1) {
                        data.valueLimitMin = array[0];
                        data.valueLimitMax = array[1];
                        data.isRandom = true;
                    }
                    else {
                        data.value = array[0];
                        data.isRandom = false;
                    }
                }
                return data;
            };
            EffectParser.prototype._parseToNumberArray = function (content) {
                content = framework.StringUtil.trimAll(content);
                content = framework.StringUtil.replaceAll(content, "\\[", "");
                content = framework.StringUtil.replaceAll(content, "\\]", "");
                var _array = content.split(",");
                var result = [];
                for (var i = 0; i < _array.length; i++) {
                    result.push(parseInt(_array[i]));
                }
                return result;
            };
            return EffectParser;
        }());
        framework.EffectParser = EffectParser;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EffectUtil = (function () {
            function EffectUtil() {
            }
            EffectUtil.lookatbyXAxis = function (pos, xAxis, yAxis, zAxis, targetpos, quat) {
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(targetpos, pos, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var crossup = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(dir, xAxis, crossup);
                gd3d.math.vec3Normalize(crossup, crossup);
                var anglerot = gd3d.math.vec3Dot(yAxis, crossup);
                anglerot = Math.acos(anglerot) * 180 / Math.PI;
                var dot = gd3d.math.vec3Dot(zAxis, crossup);
                dot = Math.acos(dot) * 180 / Math.PI;
                if (dot > 90) {
                    anglerot = -anglerot;
                }
                gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_right, anglerot, quat);
                gd3d.math.pool.delete_vector3(dir);
                gd3d.math.pool.delete_vector3(crossup);
            };
            EffectUtil.eulerFromQuaternion = function (out, q, order) {
                var sqx = q.x * q.x;
                var sqy = q.y * q.y;
                var sqz = q.z * q.z;
                var sqw = q.w * q.w;
                if (order === 'XYZ') {
                    out.x = Math.atan2(2 * (q.x * q.w - q.y * q.z), (sqw - sqx - sqy + sqz));
                    out.y = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.z + q.y * q.w), -1, 1));
                    out.z = Math.atan2(2 * (q.z * q.w - q.x * q.y), (sqw + sqx - sqy - sqz));
                }
                else if (order === 'YXZ') {
                    out.x = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.w - q.y * q.z), -1, 1));
                    out.y = Math.atan2(2 * (q.x * q.z + q.y * q.w), (sqw - sqx - sqy + sqz));
                    out.z = Math.atan2(2 * (q.x * q.y + q.z * q.w), (sqw - sqx + sqy - sqz));
                }
                else if (order === 'ZXY') {
                    out.x = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.w + q.y * q.z), -1, 1));
                    out.y = Math.atan2(2 * (q.y * q.w - q.z * q.x), (sqw - sqx - sqy + sqz));
                    out.z = Math.atan2(2 * (q.z * q.w - q.x * q.y), (sqw - sqx + sqy - sqz));
                }
                else if (order === 'ZYX') {
                    out.x = Math.atan2(2 * (q.x * q.w + q.z * q.y), (sqw - sqx - sqy + sqz));
                    out.y = Math.asin(gd3d.math.floatClamp(2 * (q.y * q.w - q.x * q.z), -1, 1));
                    out.z = Math.atan2(2 * (q.x * q.y + q.z * q.w), (sqw + sqx - sqy - sqz));
                }
                else if (order === 'YZX') {
                    out.x = Math.atan2(2 * (q.x * q.w - q.z * q.y), (sqw - sqx + sqy - sqz));
                    out.y = Math.atan2(2 * (q.y * q.w - q.x * q.z), (sqw + sqx - sqy - sqz));
                    out.z = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.y + q.z * q.w), -1, 1));
                }
                else if (order === 'XZY') {
                    out.x = Math.atan2(2 * (q.x * q.w + q.y * q.z), (sqw - sqx + sqy - sqz));
                    out.y = Math.atan2(2 * (q.x * q.z + q.y * q.w), (sqw + sqx - sqy - sqz));
                    out.z = Math.asin(gd3d.math.floatClamp(2 * (q.z * q.w - q.x * q.y), -1, 1));
                }
                else {
                    console.log('No order given for quaternion to euler conversion.');
                    return;
                }
            };
            EffectUtil.RandomRange = function (min, max, isInteger) {
                if (isInteger === void 0) { isInteger = false; }
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            };
            EffectUtil.vecMuliNum = function (vec, num) {
                var v = new gd3d.math.vector3(vec.x * num, vec.y * num, vec.z * num);
                return v;
            };
            EffectUtil.parseVector3 = function (value) {
                var vector3 = new gd3d.math.vector3();
                vector3.x = value["x"];
                vector3.y = value["y"];
                vector3.z = value["z"];
                return vector3;
            };
            EffectUtil.parseEffectVec3 = function (value) {
                var node = new framework.ParticleNode();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectVec2 = function (value) {
                var node = new framework.ParticleNodeVec2();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectNum = function (value) {
                var node = new framework.ParticleNodeNumber();
                if (value instanceof Array) {
                    node.num.valueLimitMin = value[0];
                    node.num.valueLimitMax = value[1];
                    node.num.isRandom = true;
                }
                else {
                    node.num.value = value;
                    node.num.isRandom = false;
                }
                return node;
            };
            EffectUtil.parseEffectNumNode = function (value) {
                var node = new framework.ParticleNodeNumber();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node.num.value = value[key];
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectValueData = function (value) {
                var val = new framework.ValueData();
                if (value instanceof Array) {
                    val.valueLimitMin = value[0];
                    val.valueLimitMax = value[1];
                    val.isRandom = true;
                }
                else {
                    val.value = value;
                    val.isRandom = false;
                }
                return val;
            };
            EffectUtil.parseEffectUVSpeed = function (value) {
                var node = new framework.UVSpeedNode();
                for (var key in value) {
                    node[key].value = value[key];
                }
                return node;
            };
            EffectUtil.lookat = function (eye, targetpos, out, up) {
                if (up === void 0) { up = gd3d.math.pool.vector3_up; }
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var unitprojectedXZ = new gd3d.math.vector3(dir.x, 0, dir.z);
                gd3d.math.vec3Normalize(unitprojectedXZ, unitprojectedXZ);
                var yaw = Math.acos(unitprojectedXZ.z) / Math.PI * 180;
                if (unitprojectedXZ.x < 0) {
                    yaw = -yaw;
                }
                gd3d.math.quatFromAxisAngle(up, yaw, out);
                var right = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(up, dir, right);
                gd3d.math.vec3Normalize(right, right);
                var projectedXZ = new gd3d.math.vector3(dir.x, 0, dir.z);
                var length = gd3d.math.vec3Length(projectedXZ);
                var pitch = Math.acos(length) / Math.PI * 180;
                if (dir.y < 0) {
                    pitch = -pitch;
                }
                var quadRight = gd3d.math.pool.new_quaternion();
                gd3d.math.quatFromAxisAngle(right, pitch, quadRight);
            };
            EffectUtil.RotateVector3 = function (source, direction, out) {
                gd3d.math.vec3Normalize(source, source);
                gd3d.math.vec3Normalize(direction, direction);
                var forward = new gd3d.math.vector3(0, 0, 1);
                var axis = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(forward, direction, axis);
                gd3d.math.vec3Normalize(axis, axis);
                if (axis.x == 0 && axis.y == 0 && axis.z == 0) {
                    axis.x = 1;
                    axis.y = 0;
                    axis.z = 0;
                }
                var cos = gd3d.math.vec3Dot(forward, direction);
                var angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                var quatertion = gd3d.math.pool.new_quaternion();
                gd3d.math.quatFromAxisAngle(axis, angle, quatertion);
                gd3d.math.quatTransformVector(quatertion, source, out);
                gd3d.math.pool.delete_vector3(axis);
                gd3d.math.pool.delete_quaternion(quatertion);
            };
            EffectUtil.bindAxisBillboard = function (localAxis, out) {
                gd3d.math.vec3Normalize(localAxis, localAxis);
                var yAxis = gd3d.math.pool.vector3_up;
                var normal = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(yAxis, localAxis, normal);
                gd3d.math.vec3Normalize(normal, normal);
                if (normal.x == 0 && normal.y == 0 && normal.z == 0) {
                    normal.x = 1;
                    normal.y = 0;
                    normal.z = 0;
                }
                var cos = gd3d.math.vec3Dot(yAxis, localAxis);
                var angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                gd3d.math.quatFromAxisAngle(normal, angle, out);
            };
            EffectUtil.lookatVerticalBillboard = function (eye, targetpos, out, up) {
                if (up === void 0) { up = gd3d.math.pool.vector3_up; }
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var dirxz = new gd3d.math.vector3(dir.x, 0, dir.z);
                gd3d.math.vec3Normalize(dirxz, dirxz);
                var yaw = Math.acos(dirxz.z) / Math.PI * 180;
                if (dirxz.x < 0) {
                    yaw = -yaw;
                }
                gd3d.math.quatFromAxisAngle(up, yaw, out);
            };
            EffectUtil.quatLookatZ = function (eye, targetpos, out, forward) {
                if (forward === void 0) { forward = gd3d.math.pool.vector3_forward; }
                var dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var dirxy = new gd3d.math.vector3(-dir.x, dir.y, 0);
                gd3d.math.vec3Normalize(dirxy, dirxy);
                var roll = Math.acos(dirxy.y) / Math.PI * 180;
                if (dirxy.x < 0) {
                    roll = -roll;
                }
                gd3d.math.quatFromAxisAngle(forward, roll, out);
            };
            EffectUtil.quatLookatX = function (eye, targetpos, out, right) {
                if (right === void 0) { right = gd3d.math.pool.vector3_right; }
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var diryz = new gd3d.math.vector3(0, -dir.y, dir.z);
                gd3d.math.vec3Normalize(diryz, diryz);
                var pitch = Math.acos(diryz.z) / Math.PI * 180;
                if (diryz.y < 0) {
                    pitch = -pitch;
                }
                gd3d.math.quatFromAxisAngle(right, pitch, out);
            };
            return EffectUtil;
        }());
        framework.EffectUtil = EffectUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EmissionBatcher = (function () {
            function EmissionBatcher(emissionElement) {
                this.particles = [];
                this.vertexSize = 0;
                this.vf = 0;
                this.curVerCount = 0;
                this.curIndexCount = 0;
                this.emissionElement = emissionElement;
                this.webgl = emissionElement.webgl;
                this.gameObject = emissionElement.gameObject;
                this.vf = emissionElement.vf;
                this.data = emissionElement.emissionData;
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.vf) / 4;
                this.initMesh();
                this.mat = new framework.material();
                if (this.data.mat.shader == null) {
                    this.mat.setShader(framework.sceneMgr.app.getAssetMgr().getShader("diffuse.shader.json"));
                }
                else {
                    this.mat.setShader(this.data.mat.shader);
                }
                if (this.data.mat.alphaCut != undefined)
                    this.mat.setFloat("_AlphaCut", this.data.mat.alphaCut);
                if (this.data.mat.diffuseTexture != null)
                    this.mat.setTexture("_MainTex", this.data.mat.diffuseTexture);
                if (this.data.mat.alphaTexture != null)
                    this.mat.setTexture("_AlphaTex", this.data.mat.alphaTexture);
            }
            EmissionBatcher.prototype.initMesh = function () {
                this.mesh = new framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = 0;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                this.mesh.glMesh.initBuffer(this.webgl, this.vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
            };
            EmissionBatcher.prototype.addParticle = function () {
                this.refreshBuffer();
                var p = new framework.Particle(this);
                p.update(0);
                p.uploadData(this.dataForVbo);
                for (var i = 0; i < p.dataForEbo.length; i++) {
                    this.dataForEbo[this.curIndexCount + i] = p.dataForEbo[i] + this.curVerCount;
                }
                this.particles.push(p);
                this.curVerCount += this.emissionElement.perVertexCount;
                this.curIndexCount += this.emissionElement.perIndexxCount;
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
            };
            EmissionBatcher.prototype.refreshBuffer = function () {
                var needvercount = this.curVerCount + this.emissionElement.perVertexCount;
                var needIndexCount = this.curIndexCount + this.emissionElement.perIndexxCount;
                if (needvercount * this.vertexSize > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    var vbo = new Float32Array(length * 2);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                if (needIndexCount > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    var ebo = new Uint16Array(length * 2);
                    ebo.set(this.dataForEbo, 0);
                    this.dataForEbo = ebo;
                }
            };
            EmissionBatcher.prototype.update = function (delta) {
                for (var key in this.particles) {
                    this.particles[key].update(delta);
                    this.particles[key].uploadData(this.dataForVbo);
                }
            };
            EmissionBatcher.prototype.render = function (context, assetmgr, camera) {
                var mesh = this.mesh;
                mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (assetmgr.app.getScene().fog) {
                    context.fog = assetmgr.app.getScene().fog;
                    this.mat.draw(context, mesh, mesh.submesh[0], "base_fog");
                }
                else {
                    this.mat.draw(context, mesh, mesh.submesh[0], "base");
                }
            };
            EmissionBatcher.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.mesh.dispose();
                this.mat.dispose();
                for (var key in this.particles) {
                    this.particles[key].dispose();
                }
            };
            return EmissionBatcher;
        }());
        framework.EmissionBatcher = EmissionBatcher;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Particle = (function () {
            function Particle(batcher) {
                this.renderModel = framework.RenderModel.Mesh;
                this.startScale = new gd3d.math.vector3();
                this.startRotation = new gd3d.math.quaternion();
                this.rotationByShape = new gd3d.math.quaternion();
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localMatrix = new gd3d.math.matrix();
                this.localRotation = new gd3d.math.quaternion();
                this.tilling = new gd3d.math.vector2(1, 1);
                this.speedDir = new gd3d.math.vector3(0, 0, 0);
                this.actived = true;
                this.transformVertex = new gd3d.math.matrix();
                this.matToworld = new gd3d.math.matrix();
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
                this.batcher = batcher;
                this.gameObject = batcher.gameObject;
                this.emisson = batcher.emissionElement;
                this.vf = batcher.vf;
                this.data = batcher.data.clone();
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.vf) / 4;
                this.vertexStartIndex = batcher.curVerCount;
                this.vertexCount = this.emisson.perVertexCount;
                this.dataForVbo = new Float32Array(this.vertexCount * this.vertexSize);
                this.dataForEbo = this.data.mesh.data.genIndexDataArray();
                this.dataForVbo.set(this.data.mesh.data.genVertexDataArray(this.vf), 0);
                this.sourceVbo = this.data.getVboData(this.vf);
                this.initByData();
            }
            Particle.prototype.uploadData = function (array) {
                array.set(this.dataForVbo, this.vertexStartIndex * this.vertexSize);
            };
            Particle.prototype.initByData = function () {
                this.totalLife = this.data.life.getValueRandom();
                this.renderModel = this.data.renderModel;
                this.curLife = 0;
                var localRandomDirection = this.data.particleStartData.randomDirection;
                this.speedDir = gd3d.math.pool.clone_vector3(localRandomDirection);
                var localRandomTranslate = this.data.particleStartData.position;
                this.localTranslate = gd3d.math.pool.clone_vector3(localRandomTranslate);
                this.simulationSpeed = this.data.simulationSpeed != undefined ? this.data.simulationSpeed.getValue() : 0;
                if (this.data.euler == undefined)
                    this.euler = new gd3d.math.vector3(0, 0, 0);
                else
                    this.euler = this.data.euler.getValueRandom();
                if (this.data.scale == undefined)
                    this.localScale = new gd3d.math.vector3(1, 1, 1);
                else
                    this.localScale = this.data.scale.getValueRandom();
                if (this.data.color == undefined)
                    this.color = new gd3d.math.vector3(0, 0, 0);
                else
                    this.color = this.data.color.getValueRandom();
                if (this.data.alpha == undefined)
                    this.alpha = 1;
                else
                    this.alpha = this.data.alpha.getValueRandom();
                if (this.data.uv == undefined)
                    this.uv = new gd3d.math.vector2();
                else
                    this.uv = this.data.uv.getValueRandom();
                if (this.data.moveSpeed != undefined) {
                    this.movespeed = this.data.moveSpeed.getValue();
                }
                else {
                    this.movespeed = new gd3d.math.vector3();
                }
                if (this.data.colorRate == undefined)
                    this.colorRate = this.data.colorRate;
                else
                    this.colorRate = 1;
                gd3d.math.vec3Clone(this.localScale, this.startScale);
                gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                if (this.renderModel == framework.RenderModel.None || this.renderModel == framework.RenderModel.StretchedBillBoard) {
                    if (this.data.particleStartData.shapeType != framework.ParticleSystemShape.NORMAL) {
                        var localOrgin = gd3d.math.pool.vector3_zero;
                        gd3d.math.quatLookat(localOrgin, localRandomDirection, this.rotationByShape);
                        var initRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatFromEulerAngles(90, 0, 90, initRot);
                        gd3d.math.quatMultiply(this.rotationByShape, initRot, this.rotationByShape);
                        gd3d.math.quatClone(this.rotationByShape, this.localRotation);
                        gd3d.math.pool.delete_quaternion(initRot);
                    }
                }
                if (!this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = new gd3d.math.matrix();
                    var mat = this.emisson.getmatrixToWorld();
                    gd3d.math.matrixClone(mat, this.emissionMatToWorld);
                    this.emissionWorldRotation = new gd3d.math.quaternion();
                    var quat = this.emisson.getWorldRotation();
                    gd3d.math.quatClone(quat, this.emissionWorldRotation);
                }
            };
            Particle.prototype.update = function (delta) {
                if (!this.actived)
                    return;
                this.curLife += delta;
                if (this.curLife >= this.totalLife) {
                    gd3d.math.matrixZero(this.transformVertex);
                    this._updateVBO();
                    this.emisson.deadParticles.push(this);
                    this.curLife = 0;
                    this.actived = false;
                    return;
                }
                this._updatePos(delta);
                this._updateScale(delta);
                this._updateEuler(delta);
                this._updateRotation(delta);
                this._updateLocalMatrix(delta);
                this._updateColor(delta);
                this._updateAlpha(delta);
                this._updateUV(delta);
                this._updateVBO();
            };
            Particle.prototype._updateLocalMatrix = function (delta) {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.emisson.simulateInLocalSpace) {
                    gd3d.math.matrixMultiply(this.emisson.matToBatcher, this.localMatrix, this.transformVertex);
                }
                else {
                    gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            };
            Particle.prototype.refreshEmissionData = function () {
                if (this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = this.emisson.getmatrixToWorld();
                    this.emissionWorldRotation = this.emisson.getWorldRotation();
                }
            };
            Particle.prototype._updateRotation = function (delta) {
                this._updateElementRotation();
            };
            Particle.prototype._updateElementRotation = function () {
                if (this.renderModel != framework.RenderModel.Mesh) {
                    this.refreshEmissionData();
                    var translation = gd3d.math.pool.new_vector3();
                    var worldTranslation = gd3d.math.pool.new_vector3();
                    var worldRotation = gd3d.math.pool.new_quaternion();
                    var invTransformRotation = gd3d.math.pool.new_quaternion();
                    gd3d.math.vec3Clone(this.localTranslate, translation);
                    var cam = this.batcher.emissionElement.renderCamera;
                    if (cam == null) {
                        cam = gd3d.framework.sceneMgr.app.getScene().mainCamera;
                    }
                    var camPosInWorld = cam.gameObject.transform.getWorldTranslate();
                    gd3d.math.matrixTransformVector3(translation, this.emissionMatToWorld, worldTranslation);
                    if (this.renderModel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, camPosInWorld, worldRotation);
                    }
                    else if (this.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.renderModel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(camPosInWorld, forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.renderModel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                        gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.matToworld);
                        var xaxis = gd3d.math.pool.new_vector3();
                        var yaxis = gd3d.math.pool.new_vector3();
                        var zaxis = gd3d.math.pool.new_vector3();
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_right, this.matToworld, xaxis);
                        gd3d.math.vec3Normalize(xaxis, xaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_up, this.matToworld, yaxis);
                        gd3d.math.vec3Normalize(yaxis, yaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_forward, this.matToworld, zaxis);
                        gd3d.math.vec3Normalize(zaxis, zaxis);
                        framework.EffectUtil.lookatbyXAxis(worldTranslation, xaxis, yaxis, zaxis, camPosInWorld, worldRotation);
                        gd3d.math.quatMultiply(this.localRotation, worldRotation, this.localRotation);
                        gd3d.math.pool.delete_quaternion(worldRotation);
                        gd3d.math.pool.delete_vector3(translation);
                        gd3d.math.pool.delete_quaternion(invTransformRotation);
                        gd3d.math.pool.delete_vector3(xaxis);
                        gd3d.math.pool.delete_vector3(yaxis);
                        gd3d.math.pool.delete_vector3(zaxis);
                        return;
                    }
                    gd3d.math.quatClone(this.emissionWorldRotation, invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.localRotation);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(worldRotation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    gd3d.math.quatClone(this.rotationByEuler, this.localRotation);
                }
            };
            Particle.prototype._updatePos = function (delta) {
                if (this.data.moveSpeed != undefined) {
                    this.localTranslate.x += this.movespeed.x * delta;
                    this.localTranslate.y += this.movespeed.y * delta;
                    this.localTranslate.z += this.movespeed.z * delta;
                }
                var currentTranslate = framework.EffectUtil.vecMuliNum(this.speedDir, this.simulationSpeed);
                gd3d.math.vec3Add(this.localTranslate, currentTranslate, this.localTranslate);
            };
            Particle.prototype._updateEuler = function (delta) {
                var index = 0;
                if (this.data.eulerNodes != undefined && this.data.eulerSpeed != undefined) {
                    console.error("scale只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.eulerNodes != undefined) {
                    this._updateNode(this.data.eulerNodes, this.totalLife, this.euler);
                    gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                }
                else if (this.data.eulerSpeed != undefined) {
                    if (this.data.eulerSpeed.x != undefined)
                        this.euler.x += this.data.eulerSpeed.x.getValue() * delta;
                    if (this.data.eulerSpeed.y != undefined)
                        this.euler.y += this.data.eulerSpeed.y.getValue() * delta;
                    if (this.data.eulerSpeed.z != undefined)
                        this.euler.z += this.data.eulerSpeed.z.getValue() * delta;
                    gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                }
            };
            Particle.prototype._updateScale = function (delta) {
                var index = 0;
                if (this.data.scaleNodes != undefined && this.data.scaleSpeed != undefined) {
                    console.error("scale只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.scaleNodes != undefined) {
                    this._updateNode(this.data.scaleNodes, this.totalLife, this.localScale, nodeType.scale);
                }
                else if (this.data.scaleSpeed != undefined) {
                    if (this.data.scaleSpeed.x != undefined)
                        this.localScale.x += this.data.scaleSpeed.x.getValue() * delta;
                    if (this.data.scaleSpeed.y != undefined)
                        this.localScale.y += this.data.scaleSpeed.y.getValue() * delta;
                    if (this.data.scaleSpeed.z != undefined)
                        this.localScale.z += this.data.scaleSpeed.z.getValue() * delta;
                }
            };
            Particle.prototype._updateColor = function (delta) {
                var index = 0;
                if (this.data.colorNodes != undefined && this.data.colorSpeed != undefined) {
                    console.error("color只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.colorNodes != undefined) {
                    this._updateNode(this.data.colorNodes, this.totalLife, this.color);
                }
                else if (this.data.colorSpeed != undefined) {
                    if (this.data.colorSpeed.x != undefined)
                        this.color.x += this.data.colorSpeed.x.getValue() * delta;
                    if (this.data.colorSpeed.y != undefined)
                        this.color.y += this.data.colorSpeed.y.getValue() * delta;
                    if (this.data.colorSpeed.z != undefined)
                        this.color.z += this.data.colorSpeed.z.getValue() * delta;
                }
            };
            Particle.prototype._updateNode = function (nodes, life, out, nodetype) {
                if (nodetype === void 0) { nodetype = nodeType.none; }
                var index = 0;
                var duration = 0;
                if (nodes != undefined) {
                    for (var i = 0; i < nodes.length; i++) {
                        if (i + 1 < nodes.length) {
                            if (nodes[i].key * life <= this.curLife && nodes[i + 1].key * life >= this.curLife) {
                                this.tempStartNode = nodes[i];
                                this.tempEndNode = nodes[i + 1];
                                index++;
                                duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                                break;
                            }
                        }
                        else {
                            if (this.curLife < nodes[i].key * life) {
                                this.tempStartNode = nodes[i - 1];
                                this.tempEndNode = nodes[i];
                                duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                            }
                        }
                    }
                    if (this.tempStartNode instanceof framework.ParticleNode) {
                        if (duration > 0) {
                            gd3d.math.vec3SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                    else if (this.tempStartNode instanceof framework.ParticleNodeNumber) {
                        if (duration > 0) {
                            if (nodetype == nodeType.alpha) {
                                this.alpha = gd3d.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                            }
                            else if (nodetype = nodeType.scale) {
                                var targetscale = gd3d.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                                gd3d.math.vec3ScaleByNum(this.startScale, targetscale, out);
                            }
                        }
                    }
                    else if (this.tempStartNode instanceof framework.UVSpeedNode) {
                        if (duration > 0) {
                            gd3d.math.vec2SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                }
            };
            Particle.prototype._updateAlpha = function (delta) {
                var index = 0;
                if (this.data.alphaNodes != undefined && this.data.alphaSpeed != undefined) {
                    console.error("color只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.alphaNodes != undefined) {
                    this._updateNode(this.data.alphaNodes, this.totalLife, this.alpha, nodeType.alpha);
                }
                else if (this.data.alphaSpeed != undefined) {
                    this.alpha += this.data.alphaSpeed.getValue() * delta;
                }
            };
            Particle.prototype._updateUV = function (delta) {
                if (this.uv == undefined)
                    this.uv = new gd3d.math.vector2();
                if (this.data.uvType == framework.UVTypeEnum.NONE) {
                    this.uv = this.data.uv.getValue();
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVRoll) {
                    if (this.data.uvRoll != undefined) {
                        if (this.data.uvRoll.uvSpeedNodes != undefined && this.data.uvRoll.uvSpeed != undefined) {
                            console.error("uv只能通过插值或者speed来修改，不能两个同时存在！");
                            return;
                        }
                        var index = 0;
                        if (this.data.uvRoll.uvSpeedNodes != undefined) {
                            this._updateNode(this.data.uvRoll.uvSpeedNodes, this.totalLife, this.uv);
                        }
                        else if (this.data.uvRoll.uvSpeed != undefined) {
                            if (this.data.uvRoll.uvSpeed.u != undefined)
                                this.tex_ST.z += this.data.uvRoll.uvSpeed.u.getValue() * delta;
                            if (this.data.uvRoll.uvSpeed.v != undefined)
                                this.tex_ST.w += this.data.uvRoll.uvSpeed.v.getValue() * delta;
                        }
                    }
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVSprite) {
                    if (this.data.uvSprite != undefined) {
                        var spriteindex = Math.floor(this.curLife / this.totalLife * this.data.uvSprite.totalCount);
                        gd3d.math.spriteAnimation(this.data.uvSprite.row, this.data.uvSprite.column, spriteindex, this.tex_ST);
                    }
                }
            };
            Particle.prototype._updateVBO = function () {
                var vertexSize = this.vertexSize;
                for (var i = 0; i < this.vertexCount; i++) {
                    {
                        var vertex = gd3d.math.pool.new_vector3();
                        vertex.x = this.sourceVbo[i * vertexSize + 0];
                        vertex.y = this.sourceVbo[i * vertexSize + 1];
                        vertex.z = this.sourceVbo[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, this.transformVertex, vertex);
                        this.dataForVbo[i * vertexSize + 0] = vertex.x;
                        this.dataForVbo[i * vertexSize + 1] = vertex.y;
                        this.dataForVbo[i * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        var r = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 3], 0, 1);
                        var g = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 4], 0, 1);
                        var b = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 5], 0, 1);
                        var a = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 6], 0, 1);
                        if (this.color != undefined) {
                            r = this.color.x;
                            g = this.color.y;
                            b = this.color.z;
                        }
                        if (this.alpha != undefined)
                            a = this.alpha;
                        if (this.colorRate != undefined) {
                            r *= this.colorRate;
                            g *= this.colorRate;
                            b *= this.colorRate;
                            a *= this.colorRate;
                        }
                        r = gd3d.math.floatClamp(r, 0, 3);
                        g = gd3d.math.floatClamp(g, 0, 3);
                        b = gd3d.math.floatClamp(b, 0, 3);
                        a = gd3d.math.floatClamp(a, 0, 3);
                        this.dataForVbo[i * this.vertexSize + 3] = r;
                        this.dataForVbo[i * this.vertexSize + 4] = g;
                        this.dataForVbo[i * this.vertexSize + 5] = b;
                        this.dataForVbo[i * this.vertexSize + 6] = a;
                    }
                    {
                        this.dataForVbo[i * vertexSize + 7] = this.sourceVbo[i * vertexSize + 7] * this.tex_ST.x + this.tex_ST.z;
                        this.dataForVbo[i * vertexSize + 8] = this.sourceVbo[i * vertexSize + 8] * this.tex_ST.y + this.tex_ST.w;
                    }
                }
            };
            Particle.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.startRotation = null;
                this.localRotation = null;
                this.rotationByEuler = null;
                this.rotationByShape = null;
                this.tilling = null;
                this.localMatrix = null;
                this.localTranslate = null;
                this.euler = null;
                this.localScale = null;
                this.colorRate = 1;
                this.color = null;
                this.uv = null;
            };
            return Particle;
        }());
        framework.Particle = Particle;
        var nodeType;
        (function (nodeType) {
            nodeType[nodeType["none"] = 0] = "none";
            nodeType[nodeType["alpha"] = 1] = "alpha";
            nodeType[nodeType["scale"] = 2] = "scale";
        })(nodeType = framework.nodeType || (framework.nodeType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var Particles = (function () {
            function Particles(sys) {
                this.emissionElements = [];
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.effectSys = sys;
            }
            Particles.prototype.addEmission = function (_emissionNew) {
                var _emissionElement = new EmissionElement(_emissionNew, this.effectSys, this);
                this.emissionElements.push(_emissionElement);
            };
            Particles.prototype.updateForEmission = function (delta) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].updateForEmission(delta);
                }
            };
            Particles.prototype.update = function (delta) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].update(delta);
                }
            };
            Particles.prototype.render = function (context, assetmgr, camera) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].render(context, assetmgr, camera);
                }
            };
            Particles.prototype.dispose = function () {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].dispose();
                }
                this.emissionElements.length = 0;
            };
            return Particles;
        }());
        framework.Particles = Particles;
        var EmissionElement = (function () {
            function EmissionElement(_emission, sys, mgr) {
                this.maxVertexCount = 2048;
                this.localtranslate = new gd3d.math.vector3();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.localrotate = new gd3d.math.quaternion();
                this.eluerAngle = new gd3d.math.quaternion();
                this.beloop = false;
                this.simulateInLocalSpace = true;
                this.active = true;
                this.isover = false;
                this.worldRotation = new gd3d.math.quaternion();
                this.matToBatcher = new gd3d.math.matrix();
                this.matToWorld = new gd3d.math.matrix();
                this.testtime = 0;
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.effectSys = sys;
                this.ParticleMgr = mgr;
                this.vf = mgr.vf;
                this.gameObject = mgr.effectSys.gameObject;
                this.beloop = _emission.beloop;
                this.emissionData = _emission.emissionData;
                this.perVertexCount = this.emissionData.mesh.data.pos.length;
                this.perIndexxCount = this.emissionData.mesh.data.trisindex.length;
                this.simulateInLocalSpace = this.emissionData.simulateInLocalSpace;
                switch (this.emissionData.emissionType) {
                    case framework.ParticleEmissionType.burst:
                        break;
                    case framework.ParticleEmissionType.continue:
                        this._continueSpaceTime = this.emissionData.time / (this.emissionData.emissionCount);
                        break;
                }
                gd3d.math.vec3Clone(this.emissionData.rootpos, this.localtranslate);
                gd3d.math.vec3Clone(this.emissionData.rootRotAngle, this.eluerAngle);
                gd3d.math.vec3Clone(this.emissionData.rootScale, this.localScale);
                gd3d.math.quatFromEulerAngles(this.eluerAngle.x, this.eluerAngle.y, this.eluerAngle.z, this.localrotate);
                gd3d.math.matrixMakeTransformRTS(this.localtranslate, this.localScale, this.localrotate, this.matToBatcher);
                this.emissionBatchers = [];
                this.deadParticles = [];
                this.curTime = 0;
                this.numcount = 0;
                this.addBatcher();
            }
            EmissionElement.prototype.getWorldRotation = function () {
                var parRot = this.gameObject.transform.getWorldRotate();
                gd3d.math.quatMultiply(parRot, this.localrotate, this.worldRotation);
                return this.worldRotation;
            };
            EmissionElement.prototype.getmatrixToWorld = function () {
                var mat = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixMultiply(mat, this.matToBatcher, this.matToWorld);
                return this.matToWorld;
            };
            EmissionElement.prototype.update = function (delta) {
                this.updateBatcher(delta);
            };
            EmissionElement.prototype.updateForEmission = function (delta) {
                this.testtime += delta;
                this.curTime += delta;
                this.updateEmission(delta);
            };
            EmissionElement.prototype.updateBatcher = function (delta) {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].update(delta);
                }
            };
            EmissionElement.prototype.updateEmission = function (delta) {
                if (this.isover)
                    return;
                if (this.emissionData.emissionType == framework.ParticleEmissionType.continue) {
                    var rate = this.curTime / this.emissionData.time;
                    rate = gd3d.math.floatClamp(rate, 0, 1);
                    var needCount = Math.floor(rate * this.emissionData.emissionCount);
                    needCount = needCount - this.numcount;
                    for (var i = 0; i < needCount; i++) {
                        this.addParticle();
                        this.numcount++;
                    }
                    if (rate == 1) {
                        if (this.beloop) {
                            this.curTime = 0;
                            this.numcount = 0;
                            this.isover = false;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
                else if (this.emissionData.emissionType == framework.ParticleEmissionType.burst) {
                    if (this.curTime > this.emissionData.time) {
                        this.addParticle(this.emissionData.emissionCount);
                        if (this.beloop) {
                            this.curTime = 0;
                            this.isover = false;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
            };
            EmissionElement.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var particle = this.deadParticles.pop();
                        particle.initByData();
                        particle.update(0);
                        particle.actived = true;
                    }
                    else {
                        var total = this.curbatcher.curVerCount + this.perVertexCount;
                        if (total <= this.maxVertexCount) {
                            this.curbatcher.addParticle();
                        }
                        else {
                            this.addBatcher();
                            this.curbatcher.addParticle();
                        }
                    }
                }
            };
            EmissionElement.prototype.addBatcher = function () {
                var batcher = new framework.EmissionBatcher(this);
                this.emissionBatchers.push(batcher);
                this.curbatcher = batcher;
            };
            EmissionElement.prototype.render = function (context, assetmgr, camera) {
                this.renderCamera = camera;
                if (this.simulateInLocalSpace) {
                    context.updateModel(this.gameObject.transform);
                }
                else {
                    context.updateModeTrail();
                }
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].render(context, assetmgr, camera);
                }
            };
            EmissionElement.prototype.dispose = function () {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].dispose();
                }
                this.emissionBatchers.length = 0;
            };
            EmissionElement.prototype.isOver = function () {
                return this.isover;
            };
            return EmissionElement;
        }());
        framework.EmissionElement = EmissionElement;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var HideFlags;
        (function (HideFlags) {
            HideFlags[HideFlags["None"] = 0] = "None";
            HideFlags[HideFlags["HideInHierarchy"] = 1] = "HideInHierarchy";
            HideFlags[HideFlags["HideInInspector"] = 2] = "HideInInspector";
            HideFlags[HideFlags["DontSaveInEditor"] = 4] = "DontSaveInEditor";
            HideFlags[HideFlags["NotEditable"] = 8] = "NotEditable";
            HideFlags[HideFlags["DontSaveInBuild"] = 16] = "DontSaveInBuild";
            HideFlags[HideFlags["DontUnloadUnusedAsset"] = 32] = "DontUnloadUnusedAsset";
            HideFlags[HideFlags["DontSave"] = 52] = "DontSave";
            HideFlags[HideFlags["HideAndDontSave"] = 61] = "HideAndDontSave";
        })(HideFlags = framework.HideFlags || (framework.HideFlags = {}));
        var nodeComponent = (function () {
            function nodeComponent(comp, init) {
                if (init === void 0) { init = false; }
                this.comp = comp;
                this.init = init;
            }
            __decorate([
                gd3d.reflect.Field("INodeComponent"),
                __metadata("design:type", Object)
            ], nodeComponent.prototype, "comp", void 0);
            nodeComponent = __decorate([
                gd3d.reflect.SerializeType,
                __metadata("design:paramtypes", [Object, Boolean])
            ], nodeComponent);
            return nodeComponent;
        }());
        framework.nodeComponent = nodeComponent;
        var gameObject = (function () {
            function gameObject() {
                this.layer = 0;
                this.hideFlags = HideFlags.None;
                this.components = [];
                this.componentsInit = [];
                this._visible = true;
            }
            gameObject.prototype.getScene = function () {
                return this.transform.scene;
            };
            Object.defineProperty(gameObject.prototype, "visibleInScene", {
                get: function () {
                    var obj = this;
                    while (obj.visible && obj.transform.parent) {
                        obj = obj.transform.parent.gameObject;
                    }
                    return obj.visible;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(gameObject.prototype, "visible", {
                get: function () {
                    return this._visible;
                },
                set: function (val) {
                    if (val != this._visible) {
                        this._visible = val;
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.ChangeVisible);
                    }
                },
                enumerable: true,
                configurable: true
            });
            ;
            gameObject.prototype.getName = function () {
                return this.transform.name;
            };
            gameObject.prototype.init = function () {
                if (this.componentsInit.length > 0) {
                    for (var i = 0; i < this.componentsInit.length; i++) {
                        this.componentsInit[i].comp.start();
                        this.componentsInit[i].init = true;
                    }
                    this.componentsInit.length = 0;
                }
            };
            gameObject.prototype.update = function (delta) {
                if (this.components.length == 0)
                    return;
                for (var i = 0; i < this.components.length; i++) {
                    this.components[i].comp.update(delta);
                }
            };
            gameObject.prototype.addComponentDirect = function (comp) {
                this.transform.markHaveComponent();
                if (comp.gameObject != null) {
                    throw new Error("this components has added to a  gameObject");
                }
                comp.gameObject = this;
                var nodeObj = new nodeComponent(comp, false);
                var add = true;
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "effectbatcher") == "1") {
                    if (this.renderer == null) {
                        this.renderer = comp;
                        this.transform.markHaveRendererComp();
                    }
                    else {
                        add = false;
                        console.warn("已经有一个渲染器的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    if (this.camera == null) {
                        this.camera = comp;
                    }
                    else {
                        add = false;
                        console.warn("已经有一个摄像机的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "light") == "1") {
                    if (this.light == null) {
                        this.light = comp;
                        console.warn("add light:" + this.transform.name);
                    }
                    else {
                        add = false;
                        console.warn("已经有一个灯光的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1") {
                    if (this.collider == null) {
                        this.collider = comp;
                    }
                    else {
                        add = false;
                        console.warn("已经有一个碰撞盒的组件了，不能俩");
                    }
                }
                if (add) {
                    this.components.push(nodeObj);
                    this.componentsInit.push(nodeObj);
                    if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1")
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.AddCamera);
                    if (gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1")
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.AddCanvasRender);
                }
                return comp;
            };
            gameObject.prototype.getComponent = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return this.components[i].comp;
                    }
                }
                return null;
            };
            gameObject.prototype.getComponents = function () {
                var components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            };
            gameObject.prototype.getComponentsInChildren = function (type) {
                var components = [];
                this._getComponentsInChildren(type, this, components);
                return components;
            };
            gameObject.prototype._getComponentsInChildren = function (type, obj, array) {
                for (var i = 0; i < obj.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(obj.components[i].comp["__proto__"]);
                    if (cname == type) {
                        array.push(obj.components[i].comp);
                    }
                }
                for (var i_7 = 0; obj.transform.children != undefined && i_7 < obj.transform.children.length; i_7++) {
                    var _obj = obj.transform.children[i_7].gameObject;
                    this._getComponentsInChildren(type, _obj, array);
                }
            };
            gameObject.prototype.getComponentInParent = function (type) {
                var result = null;
                var _parent = this.transform.parent;
                while (result == null && _parent != null) {
                    result = _parent.gameObject.getComponent(type);
                    _parent = _parent.parent;
                }
                return result;
            };
            gameObject.prototype.addComponent = function (type) {
                for (var key in this.components) {
                    var st = this.components[key]["comp"]["constructor"]["name"];
                    if (st == type) {
                        throw new Error("已经有一个" + type + "的组件了，不能俩");
                    }
                }
                var pp = gd3d.reflect.getPrototype(type);
                var comp = gd3d.reflect.createInstance(pp, { "nodecomp": "1" });
                return this.addComponentDirect(comp);
            };
            gameObject.prototype.removeComponent = function (comp) {
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        if (this.components[i].init) {
                            this.components[i].comp.remove();
                        }
                        this.remove(this.components[i].comp);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            };
            gameObject.prototype.remove = function (comp) {
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1") {
                    this.renderer = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    this.camera = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "light") == "1") {
                    this.light = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1") {
                    this.collider = null;
                }
            };
            gameObject.prototype.removeComponentByTypeName = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    if (gd3d.reflect.getClassName(this.components[i].comp) == type) {
                        if (this.components[i].init) {
                            this.components[i].comp.remove();
                        }
                        this.remove(this.components[i].comp);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            };
            gameObject.prototype.removeAllComponents = function () {
                for (var i = 0; i < this.components.length; i++) {
                    {
                        this.components[i].comp.remove();
                    }
                    this.remove(this.components[i].comp);
                }
                this.components.length = 0;
            };
            gameObject.prototype.dispose = function () {
                this.removeAllComponents();
            };
            __decorate([
                gd3d.reflect.Field("number"),
                gd3d.reflect.UIStyle("enum"),
                __metadata("design:type", Number)
            ], gameObject.prototype, "layer", void 0);
            __decorate([
                gd3d.reflect.Field("number"),
                __metadata("design:type", Number)
            ], gameObject.prototype, "hideFlags", void 0);
            __decorate([
                gd3d.reflect.Field("nodeComponent[]"),
                __metadata("design:type", Array)
            ], gameObject.prototype, "components", void 0);
            __decorate([
                gd3d.reflect.Field("boolean"),
                __metadata("design:type", Object)
            ], gameObject.prototype, "_visible", void 0);
            gameObject = __decorate([
                gd3d.reflect.SerializeType
            ], gameObject);
            return gameObject;
        }());
        framework.gameObject = gameObject;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var renderContext = (function () {
            function renderContext(webgl) {
                this.viewPortPixel = new gd3d.math.rect(0, 0, 0, 0);
                this.eyePos = new gd3d.math.vector4();
                this.matrixView = new gd3d.math.matrix();
                this.matrixProject = new gd3d.math.matrix();
                this.matrixModel = new gd3d.math.matrix();
                this._matrixWorld2Object = new gd3d.math.matrix();
                this.matrixModelViewProject = new gd3d.math.matrix;
                this.matrixModelView = new gd3d.math.matrix;
                this.matrixViewProject = new gd3d.math.matrix;
                this.floatTimer = 0;
                this.intLightCount = 0;
                this.vec4LightPos = new Float32Array(32);
                this.vec4LightDir = new Float32Array(32);
                this.vec4LightColor = new Float32Array(32);
                this.floatLightRange = new Float32Array(8);
                this.floatLightSpotAngleCos = new Float32Array(8);
                this.lightmap = null;
                this.lightmapUV = 1;
                this.lightmapOffset = new gd3d.math.vector4(1, 1, 0, 0);
                this.webgl = webgl;
            }
            Object.defineProperty(renderContext.prototype, "matrixWorld2Object", {
                get: function () {
                    gd3d.math.matrixInverse(this.matrixModel, this._matrixWorld2Object);
                    return this._matrixWorld2Object;
                },
                enumerable: true,
                configurable: true
            });
            renderContext.prototype.updateCamera = function (app, camera) {
                camera.calcViewPortPixel(app, this.viewPortPixel);
                var asp = this.viewPortPixel.w / this.viewPortPixel.h;
                camera.calcViewMatrix(this.matrixView);
                camera.calcProjectMatrix(asp, this.matrixProject);
                gd3d.math.matrixMultiply(this.matrixProject, this.matrixView, this.matrixViewProject);
                this.floatTimer = app.getTotalTime();
                var pso = camera.gameObject.transform.getWorldTranslate();
                this.eyePos.x = pso.x;
                this.eyePos.y = pso.y;
                this.eyePos.z = pso.z;
            };
            renderContext.prototype.updateLights = function (lights) {
                this.intLightCount = lights.length;
                var dirt = gd3d.math.pool.new_vector3();
                for (var i = 0; i < lights.length; i++) {
                    {
                        var pos = lights[i].gameObject.transform.getWorldTranslate();
                        this.vec4LightPos[i * 4 + 0] = pos.x;
                        this.vec4LightPos[i * 4 + 1] = pos.y;
                        this.vec4LightPos[i * 4 + 2] = pos.z;
                        this.vec4LightPos[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Direction ? 0 : 1;
                        lights[i].gameObject.transform.getForwardInWorld(dirt);
                        this.vec4LightDir[i * 4 + 0] = dirt.x;
                        this.vec4LightDir[i * 4 + 1] = dirt.y;
                        this.vec4LightDir[i * 4 + 2] = dirt.z;
                        this.vec4LightDir[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Point ? 0 : 1;
                        this.floatLightSpotAngleCos[i] = lights[i].spotAngelCos;
                        this.vec4LightColor[i * 4 + 0] = lights[i].color.r;
                        this.vec4LightColor[i * 4 + 1] = lights[i].color.g;
                        this.vec4LightColor[i * 4 + 2] = lights[i].color.b;
                        this.vec4LightColor[i * 4 + 3] = lights[i].color.a;
                        this.floatLightRange[i] = lights[i].range;
                    }
                }
                gd3d.math.pool.delete_vector3(dirt);
            };
            renderContext.prototype.updateOverlay = function () {
                gd3d.math.matrixMakeIdentity(this.matrixModelViewProject);
            };
            renderContext.prototype.updateModel = function (model) {
                gd3d.math.matrixClone(model.getWorldMatrix(), this.matrixModel);
                gd3d.math.matrixMultiply(this.matrixViewProject, this.matrixModel, this.matrixModelViewProject);
            };
            renderContext.prototype.updateModeTrail = function () {
                gd3d.math.matrixClone(this.matrixView, this.matrixModelView);
                gd3d.math.matrixClone(this.matrixViewProject, this.matrixModelViewProject);
            };
            return renderContext;
        }());
        framework.renderContext = renderContext;
        var RenderLayerEnum;
        (function (RenderLayerEnum) {
            RenderLayerEnum[RenderLayerEnum["Common"] = 0] = "Common";
            RenderLayerEnum[RenderLayerEnum["Transparent"] = 1] = "Transparent";
            RenderLayerEnum[RenderLayerEnum["Overlay"] = 2] = "Overlay";
        })(RenderLayerEnum = framework.RenderLayerEnum || (framework.RenderLayerEnum = {}));
        var renderList = (function () {
            function renderList() {
                this.renderLayers = [];
                var common = new renderLayer();
                var transparent = new renderLayer(true);
                var overlay = new renderLayer(true);
                this.renderLayers.push(common);
                this.renderLayers.push(transparent);
                this.renderLayers.push(overlay);
            }
            renderList.prototype.clear = function () {
                for (var i = 0; i < this.renderLayers.length; i++) {
                    this.renderLayers[i].list.length = 0;
                }
            };
            renderList.prototype.addRenderer = function (renderer) {
                if (renderer.layer == RenderLayerEnum.Common) {
                    this.renderLayers[0].list.push(renderer);
                }
                else if (renderer.layer == RenderLayerEnum.Transparent) {
                    this.renderLayers[1].list.push(renderer);
                }
                else if (renderer.layer == RenderLayerEnum.Overlay) {
                    this.renderLayers[2].list.push(renderer);
                }
            };
            return renderList;
        }());
        framework.renderList = renderList;
        var renderLayer = (function () {
            function renderLayer(_sort) {
                if (_sort === void 0) { _sort = false; }
                this.needSort = false;
                this.list = [];
                this.needSort = _sort;
            }
            return renderLayer;
        }());
        framework.renderLayer = renderLayer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var scene = (function () {
            function scene(app) {
                this.renderCameras = [];
                this._mainCamera = null;
                this.renderContext = [];
                this.renderLights = [];
                this.lightmaps = [];
                this.RealCameraNumber = 0;
                this.app = app;
                this.webgl = app.webgl;
                this.assetmgr = app.getAssetMgr();
                this.rootNode = new framework.transform();
                this.rootNode.scene = this;
                this.renderList = new framework.renderList();
            }
            scene.prototype.addScreenSpaceOverlay = function (overlay) {
                if (!overlay)
                    return;
                if (!this._overlay2d)
                    this._overlay2d = [];
                if (this._overlay2d.indexOf(overlay) != -1)
                    return;
                this._overlay2d.push(overlay);
                this.sortOverLays(this._overlay2d);
            };
            Object.defineProperty(scene.prototype, "mainCamera", {
                get: function () {
                    if (this._mainCamera == null) {
                        this._mainCamera = this.renderCameras[0];
                    }
                    return this._mainCamera;
                },
                set: function (_camera) {
                    for (var i in this.renderCameras) {
                        if (this.renderCameras[i] == _camera) {
                            this._mainCamera = _camera;
                        }
                    }
                },
                enumerable: true,
                configurable: true
            });
            scene.prototype.update = function (delta) {
                this.rootNode.updateTran(false);
                this.rootNode.updateAABBChild();
                this.renderCameras.length = 0;
                this.renderLights.length = 0;
                this.renderList.clear();
                framework.aniplayer.playerCaches = [];
                this.updateScene(this.rootNode, delta);
                if (this.renderCameras.length > 1) {
                    this.renderCameras.sort(function (a, b) {
                        return a.order - b.order;
                    });
                }
                this.RealCameraNumber = 0;
                for (var i = 0; i < this.renderCameras.length; i++) {
                    gd3d.render.glDrawPass.resetLastState();
                    this._renderCamera(i);
                }
                this.updateSceneOverLay(delta);
                if (this.RealCameraNumber == 0) {
                    this.webgl.clearColor(0, 0, 0, 1);
                    this.webgl.clearDepth(1.0);
                    this.webgl.clear(this.webgl.COLOR_BUFFER_BIT | this.webgl.DEPTH_BUFFER_BIT);
                }
                this.webgl.flush();
            };
            scene.prototype.updateSceneOverLay = function (delta) {
                var _this = this;
                if (!this._overlay2d || this._overlay2d.length < 1)
                    return;
                var targetcamera = this.mainCamera;
                if (!this._overlay2d || !targetcamera)
                    return;
                var mainCamIdx = this.renderCameras.indexOf(targetcamera);
                if (mainCamIdx == -1) {
                    var cname = targetcamera.gameObject.getName();
                    var oktag = false;
                    for (var i = 0; i < this.renderCameras.length; i++) {
                        var cam = this.renderCameras[i];
                        if (cam && cam.gameObject.getName() == cname) {
                            targetcamera = this.mainCamera = cam;
                            oktag = true;
                            break;
                        }
                    }
                    if (!oktag) {
                        this._mainCamera = null;
                        targetcamera = this.mainCamera;
                    }
                }
                mainCamIdx = this.renderCameras.indexOf(targetcamera);
                if (!targetcamera)
                    return;
                if (this._overlay2d) {
                    this._overlay2d.forEach(function (overlay) {
                        if (overlay) {
                            overlay.start(targetcamera);
                            overlay.update(delta);
                            overlay.render(_this.renderContext[mainCamIdx], _this.assetmgr, targetcamera);
                        }
                    });
                }
            };
            scene.prototype._renderCamera = function (camindex) {
                var cam = this.renderCameras[camindex];
                var context = this.renderContext[camindex];
                if (this.app.bePlay && cam.gameObject.transform.name.toLowerCase().indexOf("editor") < 0) {
                    context.updateCamera(this.app, cam);
                    context.updateLights(this.renderLights);
                    cam.fillRenderer(this);
                    cam.renderScene(this, context);
                    this.RealCameraNumber++;
                    var overLays = cam.getOverLays();
                    this.sortOverLays(overLays);
                    for (var i = 0; i < overLays.length; i++) {
                        if (cam.CullingMask & framework.CullingMask.ui) {
                            overLays[i].render(context, this.assetmgr, cam);
                        }
                    }
                }
                else if (!this.app.bePlay && cam.gameObject.transform.name.toLowerCase().indexOf("editor") >= 0) {
                    context.updateCamera(this.app, cam);
                    context.updateLights(this.renderLights);
                    cam.fillRenderer(this);
                    cam.renderScene(this, context);
                    this.RealCameraNumber++;
                    if (this.app.be2dstate) {
                        var overLays = cam.getOverLays();
                        this.sortOverLays(overLays);
                        for (var i = 0; i < overLays.length; i++) {
                            if (cam.CullingMask & framework.CullingMask.ui) {
                                overLays[i].render(context, this.assetmgr, cam);
                            }
                        }
                    }
                }
                if (!this.app.bePlay && this.app.be2dstate) {
                    if (camindex == this.app.curcameraindex) {
                        var overLays = cam.getOverLays();
                        this.sortOverLays(overLays);
                        for (var i = 0; i < overLays.length; i++) {
                            if (cam.CullingMask & framework.CullingMask.ui) {
                                overLays[i].render(context, this.assetmgr, cam);
                            }
                        }
                    }
                }
            };
            scene.prototype.sortOverLays = function (lays) {
                if (!lays || lays.length < 1)
                    return;
                lays.sort(function (a, b) {
                    return a.sortOrder - b.sortOrder;
                });
            };
            scene.prototype.updateScene = function (node, delta) {
                if (this.app.bePlay) {
                    this.objupdate(node, delta);
                }
                else {
                    this.objupdateInEditor(node, delta);
                }
            };
            scene.prototype.objupdateInEditor = function (node, delta) {
                node.gameObject.init();
                if (node.gameObject.renderer != null) {
                    node.gameObject.renderer.update(delta);
                }
                var c = node.gameObject.camera;
                if (c != null) {
                    node.gameObject.camera.update(delta);
                }
                this.collectCameraAndLight(node);
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.objupdateInEditor(node.children[i], delta);
                    }
                }
            };
            scene.prototype.objupdate = function (node, delta) {
                if (node.hasComponent == false && node.hasComponentChild == false)
                    return;
                node.gameObject.init();
                if (node.gameObject.components.length > 0) {
                    node.gameObject.update(delta);
                    this.collectCameraAndLight(node);
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.objupdate(node.children[i], delta);
                    }
                }
            };
            scene.prototype.collectCameraAndLight = function (node) {
                var c = node.gameObject.camera;
                if (c != null && c.gameObject.visibleInScene) {
                    this.renderCameras.push(c);
                }
                while (this.renderContext.length < this.renderCameras.length) {
                    this.renderContext.push(new framework.renderContext(this.webgl));
                }
                var l = node.gameObject.light;
                if (l != null) {
                    this.renderLights.push(l);
                }
            };
            scene.prototype.addChild = function (node) {
                this.rootNode.addChild(node);
            };
            scene.prototype.removeChild = function (node) {
                this.rootNode.removeChild(node);
            };
            scene.prototype.getChildren = function () {
                return this.rootNode.children;
            };
            scene.prototype.getChildCount = function () {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            };
            scene.prototype.getChild = function (index) {
                return this.rootNode.children[index];
            };
            scene.prototype.getChildByName = function (name) {
                var res = this.rootNode.find(name);
                return res;
            };
            scene.prototype.getRoot = function () {
                return this.rootNode;
            };
            scene.prototype.pickAll = function (ray, isPickMesh, root, layer) {
                if (isPickMesh === void 0) { isPickMesh = false; }
                if (root === void 0) { root = this.getRoot(); }
                if (layer === void 0) { layer = NaN; }
                var picked = this.doPick(ray, true, isPickMesh, root, layer);
                if (picked == null)
                    return null;
                return picked;
            };
            scene.prototype.pick = function (ray, isPickMesh, root, layer) {
                if (isPickMesh === void 0) { isPickMesh = false; }
                if (root === void 0) { root = this.getRoot(); }
                if (layer === void 0) { layer = NaN; }
                var pickinfo = this.doPick(ray, false, isPickMesh, root, layer);
                if (pickinfo == null)
                    return null;
                return pickinfo;
            };
            scene.prototype.doPick = function (ray, pickall, isPickMesh, root, layer) {
                if (layer === void 0) { layer = NaN; }
                var pickedList = new Array();
                if (isPickMesh) {
                    this.pickMesh(ray, root, pickedList, layer);
                }
                else {
                    this.pickCollider(ray, root, pickedList, layer);
                }
                if (pickedList.length == 0)
                    return null;
                if (pickall) {
                    return pickedList;
                }
                else {
                    var index = 0;
                    for (var i = 1; i < pickedList.length; i++) {
                        if (pickedList[i].distance < pickedList[index].distance)
                            index = i;
                    }
                    return pickedList[index];
                }
            };
            scene.prototype.pickMesh = function (ray, tran, pickedList, layer) {
                if (layer === void 0) { layer = NaN; }
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return;
                    var canDo = true;
                    if (!isNaN(layer) && layer != tran.gameObject.layer)
                        canDo = false;
                    if (canDo) {
                        var meshFilter = tran.gameObject.getComponent("meshFilter");
                        if (meshFilter != null) {
                            var mesh = meshFilter.getMeshOutput();
                            var pickinfo = mesh.intersects(ray, tran.getWorldMatrix());
                            if (pickinfo) {
                                pickedList.push(pickinfo);
                                pickinfo.pickedtran = tran;
                            }
                        }
                        else {
                            var skinmesh = tran.gameObject.getComponent("skinnedMeshRenderer");
                            if (skinmesh != null) {
                                var pickinfo = skinmesh.intersects(ray);
                                if (pickinfo) {
                                    pickedList.push(pickinfo);
                                    pickinfo.pickedtran = tran;
                                }
                            }
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        this.pickMesh(ray, tran.children[i], pickedList, layer);
                    }
                }
            };
            scene.prototype.pickCollider = function (ray, tran, pickedList, layer) {
                if (layer === void 0) { layer = NaN; }
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return;
                    if (tran.gameObject.collider != null) {
                        var canDo = true;
                        if (!isNaN(layer) && layer != tran.gameObject.layer)
                            canDo = false;
                        console.error(tran.gameObject.layer + "  --  " + layer);
                        if (canDo) {
                            var pickinfo = ray.intersectCollider(tran);
                            if (pickinfo) {
                                pickedList.push(pickinfo);
                                pickinfo.pickedtran = tran;
                            }
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        this.pickCollider(ray, tran.children[i], pickedList, layer);
                    }
                }
            };
            return scene;
        }());
        framework.scene = scene;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var uniformSetter = (function () {
            function uniformSetter() {
            }
            uniformSetter.initAutouniform = function () {
                this.autoUniformDic["glstate_matrix_model"] = function (context) {
                    return context.matrixModel;
                };
                this.autoUniformDic["glstate_matrix_world2object"] = function (context) {
                    return context.matrixWorld2Object;
                };
                this.autoUniformDic["glstate_matrix_view"] = function (context) {
                    return context.matrixView;
                };
                this.autoUniformDic["glstate_matrix_project"] = function (context) {
                    return context.matrixProject;
                };
                this.autoUniformDic["glstate_matrix_modelview"] = function (context) {
                    return context.matrixModelView;
                };
                this.autoUniformDic["glstate_matrix_viewproject"] = function (context) {
                    return context.matrixViewProject;
                };
                this.autoUniformDic["glstate_matrix_mvp"] = function (context) {
                    return context.matrixModelViewProject;
                };
                this.autoUniformDic["glstate_timer"] = function (context) {
                    return context.floatTimer;
                };
                this.autoUniformDic["glstate_lightcount"] = function (context) {
                    return context.intLightCount;
                };
                this.autoUniformDic["glstate_vec4_lightposs"] = function (context) {
                    return context.vec4LightPos;
                };
                this.autoUniformDic["glstate_vec4_lightdirs"] = function (context) {
                    return context.vec4LightDir;
                };
                this.autoUniformDic["glstate_vec4_lightcolors"] = function (context) {
                    return context.vec4LightColor;
                };
                this.autoUniformDic["glstate_float_lightrange"] = function (context) {
                    return context.floatLightRange;
                };
                this.autoUniformDic["glstate_float_spotangelcoss"] = function (context) {
                    return context.floatLightSpotAngleCos;
                };
                this.autoUniformDic["glstate_eyepos"] = function (context) {
                    return context.eyePos;
                };
                this.autoUniformDic["_LightmapTex"] = function (context) {
                    return context.lightmap;
                };
                this.autoUniformDic["glstate_lightmapOffset"] = function (context) {
                    return context.lightmapOffset;
                };
                this.autoUniformDic["glstate_fog_start"] = function (context) {
                    return context.fog._Start;
                };
                this.autoUniformDic["glstate_fog_end"] = function (context) {
                    return context.fog._End;
                };
                this.autoUniformDic["glstate_fog_color"] = function (context) {
                    return context.fog._Color;
                };
                this.autoUniformDic["glstate_vec4_bones"] = function (context) {
                    return context.vec4_bones;
                };
                this.autoUniformDic["glstate_matrix_bones"] = function (context) {
                    return context.matrix_bones;
                };
            };
            uniformSetter.autoUniformDic = {};
            return uniformSetter;
        }());
        framework.uniformSetter = uniformSetter;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var taskstate = (function () {
            function taskstate() {
                this.finish = false;
                this.error = false;
                this.message = null;
                this.cancel = false;
                this.taskCall = null;
                this.taskInterface = null;
            }
            return taskstate;
        }());
        framework.taskstate = taskstate;
        var taskMgr = (function () {
            function taskMgr() {
                this.tasks = [];
                this.laststate = null;
            }
            taskMgr.prototype.addTaskCall = function (task) {
                var st = new taskstate();
                st.taskCall = task;
                this.tasks.push(st);
            };
            taskMgr.prototype.addTask = function (task) {
                var st = new taskstate();
                st.taskInterface = task;
                this.tasks.push(st);
            };
            taskMgr.prototype.move = function (delta) {
                if (this.laststate != null && this.laststate.cancel) {
                    return;
                }
                if (this.laststate != null && this.laststate.finish == false) {
                    return;
                }
                var task = this.tasks.shift();
                if (task == null) {
                    return;
                }
                var state = new taskstate();
                var laststate = this.laststate;
                this.laststate = state;
                if (task.taskInterface == null) {
                    task.taskCall(laststate, state);
                }
                else {
                    task.taskInterface.move(delta, laststate, state);
                }
            };
            taskMgr.prototype.cancel = function () {
                if (this.laststate != null) {
                    this.laststate.cancel = true;
                }
            };
            return taskMgr;
        }());
        framework.taskMgr = taskMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var aabb = (function () {
            function aabb(_minimum, _maximum) {
                this.opmin = new gd3d.math.vector3();
                this.opmax = new gd3d.math.vector3();
                this._center = new gd3d.math.vector3();
                this.srcmin = gd3d.math.pool.clone_vector3(_minimum);
                this.srcmax = gd3d.math.pool.clone_vector3(_maximum);
                this.minimum = gd3d.math.pool.clone_vector3(_minimum);
                this.maximum = gd3d.math.pool.clone_vector3(_maximum);
            }
            aabb.prototype.update = function (worldmatrix) {
                gd3d.math.matrixGetTranslation(worldmatrix, this.opmin);
                gd3d.math.matrixGetTranslation(worldmatrix, this.opmax);
                if (worldmatrix.rawData[0] > 0) {
                    this.opmin.x += worldmatrix.rawData[0] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[0] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[0] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[0] * this.srcmin.x;
                }
                if (worldmatrix.rawData[1] > 0) {
                    this.opmin.y += worldmatrix.rawData[1] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[1] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[1] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[1] * this.srcmin.y;
                }
                if (worldmatrix.rawData[2] > 0) {
                    this.opmin.z += worldmatrix.rawData[2] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[2] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[2] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[2] * this.srcmin.z;
                }
                if (worldmatrix.rawData[4] > 0) {
                    this.opmin.x += worldmatrix.rawData[4] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[4] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[4] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[4] * this.srcmin.x;
                }
                if (worldmatrix.rawData[5] > 0) {
                    this.opmin.y += worldmatrix.rawData[5] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[5] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[5] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[5] * this.srcmin.y;
                }
                if (worldmatrix.rawData[6] > 0) {
                    this.opmin.z += worldmatrix.rawData[6] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[6] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[6] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[6] * this.srcmin.z;
                }
                if (worldmatrix.rawData[8] > 0) {
                    this.opmin.x += worldmatrix.rawData[8] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[8] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[8] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[8] * this.srcmin.x;
                }
                if (worldmatrix.rawData[9] > 0) {
                    this.opmin.y += worldmatrix.rawData[9] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[9] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[9] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[9] * this.srcmin.y;
                }
                if (worldmatrix.rawData[10] > 0) {
                    this.opmin.z += worldmatrix.rawData[10] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[10] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[10] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[10] * this.srcmin.z;
                }
                this.minimum = gd3d.math.pool.clone_vector3(this.opmin);
                this.maximum = gd3d.math.pool.clone_vector3(this.opmax);
            };
            aabb.prototype.addVector3 = function (vec) {
                gd3d.math.vec3Max(this.maximum, vec, this.maximum);
                gd3d.math.vec3Max(this.minimum, vec, this.minimum);
            };
            aabb.prototype.containsVector3 = function (vec) {
                return (vec.x > this.minimum.x) && (vec.x < this.maximum.x) &&
                    (vec.y > this.minimum.y) && (vec.x < this.maximum.y) &&
                    (vec.z > this.minimum.z) && (vec.z < this.maximum.z);
            };
            aabb.prototype.intersectAABB = function (aabb) {
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                return true;
            };
            aabb.prototype.addAABB = function (aabb) {
                if (aabb != null) {
                    gd3d.math.vec3Max(this.maximum, aabb.maximum, this.maximum);
                    gd3d.math.vec3Min(this.minimum, aabb.minimum, this.minimum);
                }
            };
            Object.defineProperty(aabb.prototype, "center", {
                get: function () {
                    gd3d.math.vec3Add(this.maximum, this.minimum, this._center);
                    gd3d.math.vec3ScaleByNum(this._center, 0.5, this._center);
                    return this._center;
                },
                enumerable: true,
                configurable: true
            });
            aabb.prototype.clear = function () {
                gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimum);
                gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximum);
            };
            aabb.prototype.clone = function () {
                var _min = gd3d.math.pool.clone_vector3(this.minimum);
                var _max = gd3d.math.pool.clone_vector3(this.maximum);
                var aabb = new gd3d.framework.aabb(_min, _max);
                return aabb;
            };
            aabb.prototype.getVec3 = function (vecs) {
                vecs[0] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[1] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[1].z = this.maximum.z;
                vecs[2] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[2].x = this.maximum.x;
                vecs[3] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[3].y = this.minimum.y;
                vecs[4] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[4].y = this.maximum.y;
                vecs[5] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[5].x = this.minimum.x;
                vecs[6] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[6].z = this.minimum.z;
                vecs[7] = gd3d.math.pool.clone_vector3(this.maximum);
            };
            return aabb;
        }());
        framework.aabb = aabb;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var obb = (function () {
            function obb() {
                this.vectors = new Array();
            }
            obb.prototype.buildByMaxMin = function (minimum, maximum) {
                this.vectors[0] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[1] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[1].z = maximum.z;
                this.vectors[2] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[2].x = maximum.x;
                this.vectors[3] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[3].y = minimum.y;
                this.vectors[4] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[4].y = maximum.y;
                this.vectors[5] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[5].x = minimum.x;
                this.vectors[6] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[6].z = minimum.z;
                this.vectors[7] = gd3d.math.pool.clone_vector3(maximum);
                this.center = new gd3d.math.vector3();
                gd3d.math.vec3Add(maximum, minimum, this.center);
                gd3d.math.vec3ScaleByNum(this.center, 0.5, this.center);
                this.halfsize = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(maximum, minimum, this.halfsize);
                gd3d.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                this.directions = [new gd3d.math.vector3(), new gd3d.math.vector3(), new gd3d.math.vector3()];
            };
            obb.prototype.buildByCenterSize = function (center, size) {
                this.center = gd3d.math.pool.clone_vector3(center);
                this.halfsize = gd3d.math.pool.clone_vector3(size);
                gd3d.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                var hsx = this.halfsize.x;
                var hsy = this.halfsize.y;
                var hsz = this.halfsize.z;
                var cenx = this.center.x;
                var ceny = this.center.y;
                var cenz = this.center.z;
                this.vectors[0] = new gd3d.math.vector3(cenx - hsx, ceny - hsy, cenz - hsz);
                this.vectors[1] = new gd3d.math.vector3(cenx - hsx, ceny - hsy, cenz + hsz);
                this.vectors[2] = new gd3d.math.vector3(cenx + hsx, ceny - hsy, cenz - hsz);
                this.vectors[3] = new gd3d.math.vector3(cenx + hsx, ceny - hsy, cenz + hsz);
                this.vectors[4] = new gd3d.math.vector3(cenx - hsx, ceny + hsy, cenz - hsz);
                this.vectors[5] = new gd3d.math.vector3(cenx - hsx, ceny + hsy, cenz + hsz);
                this.vectors[6] = new gd3d.math.vector3(cenx + hsx, ceny + hsy, cenz - hsz);
                this.vectors[7] = new gd3d.math.vector3(cenx + hsx, ceny + hsy, cenz + hsz);
                this.directions = [new gd3d.math.vector3(), new gd3d.math.vector3(), new gd3d.math.vector3()];
            };
            obb.prototype.update = function (worldmatrix) {
                gd3d.math.matrixGetTranslation(worldmatrix, this.center);
                gd3d.math.matrixGetVector3ByOffset(worldmatrix, 0, this.directions[0]);
                gd3d.math.matrixGetVector3ByOffset(worldmatrix, 4, this.directions[1]);
                gd3d.math.matrixGetVector3ByOffset(worldmatrix, 8, this.directions[2]);
            };
            obb.prototype.caclWorldVecs = function (vecs, worldmatrix) {
                for (var index = 0; index < this.vectors.length; index++) {
                    vecs[index] = new gd3d.math.vector3();
                    gd3d.math.matrixTransformVector3(this.vectors[index], worldmatrix, vecs[index]);
                }
            };
            obb.prototype.intersects = function (_obb) {
                if (_obb == null)
                    return false;
                var box0 = this;
                var box1 = _obb;
                if (!this.axisOverlap(box0.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[2], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[2], box0, box1))
                    return false;
                var crossresult = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(box0.directions[0], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[0], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[0], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[1], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[1], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[1], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[2], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[2], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[2], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                return true;
            };
            obb.prototype.computeBoxExtents = function (axis, box) {
                var p = gd3d.math.vec3Dot(box.center, axis);
                var r0 = Math.abs(gd3d.math.vec3Dot(box.directions[0], axis)) * box.halfsize.x;
                var r1 = Math.abs(gd3d.math.vec3Dot(box.directions[1], axis)) * box.halfsize.y;
                var r2 = Math.abs(gd3d.math.vec3Dot(box.directions[2], axis)) * box.halfsize.z;
                var r = r0 + r1 + r2;
                var result = gd3d.math.pool.new_vector3();
                result.x = p - r;
                result.y = p + r;
                return result;
            };
            obb.prototype.axisOverlap = function (axis, box0, box1) {
                var result0 = this.computeBoxExtents(axis, box0);
                var result1 = this.computeBoxExtents(axis, box1);
                return this.extentsOverlap(result0.x, result0.y, result1.x, result1.y);
            };
            obb.prototype.extentsOverlap = function (min0, max0, min1, max1) {
                return !(min0 > max1 || min1 > max0);
            };
            obb.prototype.clone = function () {
                var _obb = new obb();
                _obb.center = gd3d.math.pool.clone_vector3(this.center);
                _obb.halfsize = this.halfsize;
                for (var key in this.directions) {
                    _obb.directions[key] = gd3d.math.pool.clone_vector3(this.directions[key]);
                }
                return _obb;
            };
            obb.prototype.dispose = function () {
                this.vectors.length = 0;
                this.directions.length = 0;
            };
            return obb;
        }());
        framework.obb = obb;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var pickinfo = (function () {
            function pickinfo(_bu, _bv, _distance) {
                this.hitposition = new gd3d.math.vector3();
                this.bu = 0;
                this.bv = 0;
                this.faceId = -1;
                this.subMeshId = 0;
                this.distance = _distance;
                this.bu = _bu;
                this.bv = _bv;
            }
            return pickinfo;
        }());
        framework.pickinfo = pickinfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var ray = (function () {
            function ray(_origin, _dir) {
                this.origin = gd3d.math.pool.clone_vector3(_origin);
                this.direction = gd3d.math.pool.clone_vector3(_dir);
            }
            ray.prototype.intersectAABB = function (_aabb) {
                return this.intersectBoxMinMax(_aabb.minimum, _aabb.maximum);
            };
            ray.prototype.intersectPlaneTransform = function (tran) {
                var pickinfo = null;
                var panelpoint = tran.getWorldTranslate();
                var forward = gd3d.math.pool.new_vector3();
                tran.getForwardInWorld(forward);
                var hitposition = this.intersectPlane(panelpoint, forward);
                if (hitposition) {
                    pickinfo = new gd3d.framework.pickinfo(0, 0, 0);
                    pickinfo.hitposition = hitposition;
                    pickinfo.distance = gd3d.math.vec3Distance(pickinfo.hitposition, this.origin);
                }
                gd3d.math.pool.delete_vector3(forward);
                return pickinfo;
            };
            ray.prototype.intersectPlane = function (planePoint, planeNormal) {
                var vp1 = planeNormal.x;
                var vp2 = planeNormal.y;
                var vp3 = planeNormal.z;
                var n1 = planePoint.x;
                var n2 = planePoint.y;
                var n3 = planePoint.z;
                var v1 = this.direction.x;
                var v2 = this.direction.y;
                var v3 = this.direction.z;
                var m1 = this.origin.x;
                var m2 = this.origin.y;
                var m3 = this.origin.z;
                var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
                if (vpt === 0) {
                    return null;
                }
                else {
                    var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                    return new gd3d.math.vector3(m1 + v1 * t, m2 + v2 * t, m3 + v3 * t);
                }
            };
            ray.prototype.intersectCollider = function (tran) {
                var _collider = tran.gameObject.collider;
                var pickinfo = null;
                if (_collider instanceof framework.boxcollider) {
                    var obb_1 = _collider.getBound();
                    if (!obb_1)
                        return null;
                    var vecs = [];
                    obb_1.caclWorldVecs(vecs, _collider.gameObject.transform.getWorldMatrix());
                    var data = gd3d.render.meshData.genBoxByArray(vecs);
                    for (var index = 0; index < data.trisindex.length; index += 3) {
                        var p0 = data.pos[data.trisindex[index]];
                        var p1 = data.pos[data.trisindex[index + 1]];
                        var p2 = data.pos[data.trisindex[index + 2]];
                        var result = this.intersectsTriangle(p0, p1, p2);
                        if (result) {
                            if (result.distance < 0)
                                continue;
                            if (!pickinfo || pickinfo.distance > result.distance) {
                                pickinfo = result;
                                var tdir = gd3d.math.pool.new_vector3();
                                gd3d.math.vec3ScaleByNum(this.direction, result.distance, tdir);
                                gd3d.math.vec3Add(this.origin, tdir, pickinfo.hitposition);
                                gd3d.math.pool.delete_vector3(tdir);
                            }
                        }
                    }
                }
                else if (_collider instanceof framework.meshcollider) {
                    var mesh_3 = _collider.getBound();
                    if (mesh_3 != null) {
                        pickinfo = mesh_3.intersects(this, tran.getWorldMatrix());
                    }
                }
                else if (_collider instanceof framework.canvasRenderer) {
                    pickinfo = this.intersectPlaneTransform(tran);
                }
                return pickinfo;
            };
            ray.prototype.intersectBoxMinMax = function (minimum, maximum) {
                var d = 0.0;
                var maxValue = Number.MAX_VALUE;
                var inv;
                var min;
                var max;
                var temp;
                if (Math.abs(this.direction.x) < 0.0000001) {
                    if (this.origin.x < minimum.x || this.origin.x > maximum.x) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.x;
                    min = (minimum.x - this.origin.x) * inv;
                    max = (maximum.x - this.origin.x) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.y) < 0.0000001) {
                    if (this.origin.y < minimum.y || this.origin.y > maximum.y) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.y;
                    min = (minimum.y - this.origin.y) * inv;
                    max = (maximum.y - this.origin.y) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.z) < 0.0000001) {
                    if (this.origin.z < minimum.z || this.origin.z > maximum.z) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.z;
                    min = (minimum.z - this.origin.z) * inv;
                    max = (maximum.z - this.origin.z) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                return true;
            };
            ray.prototype.intersectsSphere = function (center, radius) {
                var center_ori = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(center, this.origin, center_ori);
                var raydist = gd3d.math.vec3Dot(this.direction, center_ori);
                if (orilen2 < rad2)
                    return true;
                if (raydist < 0)
                    return false;
                var orilen2 = gd3d.math.vec3SqrLength(center_ori);
                gd3d.math.pool.delete_vector3(center_ori);
                var rad2 = radius * radius;
                var d = rad2 - (orilen2 - raydist * raydist);
                if (d < 0)
                    return false;
                return true;
            };
            ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {
                var _edge1 = gd3d.math.pool.new_vector3();
                var _edge2 = gd3d.math.pool.new_vector3();
                var _pvec = gd3d.math.pool.new_vector3();
                var _tvec = gd3d.math.pool.new_vector3();
                var _qvec = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(vertex1, vertex0, _edge1);
                gd3d.math.vec3Subtract(vertex2, vertex0, _edge2);
                gd3d.math.vec3Cross(this.direction, _edge2, _pvec);
                var det = gd3d.math.vec3Dot(_edge1, _pvec);
                if (det === 0) {
                    return null;
                }
                var invdet = 1 / det;
                gd3d.math.vec3Subtract(this.origin, vertex0, _tvec);
                var bu = gd3d.math.vec3Dot(_tvec, _pvec) * invdet;
                if (bu < 0 || bu > 1.0) {
                    return null;
                }
                gd3d.math.vec3Cross(_tvec, _edge1, _qvec);
                var bv = gd3d.math.vec3Dot(this.direction, _qvec) * invdet;
                if (bv < 0 || bu + bv > 1.0) {
                    return null;
                }
                var distance = gd3d.math.vec3Dot(_edge2, _qvec) * invdet;
                gd3d.math.pool.delete_vector3(_edge1);
                gd3d.math.pool.delete_vector3(_edge2);
                gd3d.math.pool.delete_vector3(_pvec);
                gd3d.math.pool.delete_vector3(_tvec);
                gd3d.math.pool.delete_vector3(_qvec);
                return new framework.pickinfo(bu, bv, distance);
            };
            return ray;
        }());
        framework.ray = ray;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var transform = (function () {
            function transform() {
                this.name = "noname";
                this.insId = new insID();
                this.prefab = null;
                this.aabbdirty = true;
                this.aabbchilddirty = true;
                this.dirty = true;
                this.dirtyChild = true;
                this.hasComponent = false;
                this.hasComponentChild = false;
                this.hasRendererComp = false;
                this.hasRendererCompChild = false;
                this.dirtyWorldDecompose = false;
                this.localRotate = new gd3d.math.quaternion();
                this.localTranslate = new gd3d.math.vector3(0, 0, 0);
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.localMatrix = new gd3d.math.matrix();
                this._localEulerAngles = new gd3d.math.vector3(0, 0, 0);
                this.worldMatrix = new gd3d.math.matrix();
                this.worldRotate = new gd3d.math.quaternion();
                this.worldTranslate = new gd3d.math.vector3(0, 0, 0);
                this.worldScale = new gd3d.math.vector3(1, 1, 1);
                this.tempWorldMatrix = new gd3d.math.matrix();
                this._beDispose = false;
            }
            Object.defineProperty(transform.prototype, "scene", {
                get: function () {
                    if (this._scene == null) {
                        if (this.parent == null)
                            return null;
                        this._scene = this.parent.scene;
                    }
                    return this._scene;
                },
                set: function (value) {
                    this._scene = value;
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.markAABBDirty = function () {
                this.aabbdirty = true;
                this.markAABBChildDirty();
                var p = this.parent;
                while (p != null) {
                    p.markAABBChildDirty();
                    p = p.parent;
                }
            };
            transform.prototype.markAABBChildDirty = function () {
                this.aabbchilddirty = true;
            };
            transform.prototype.caclAABB = function () {
                if (this.gameObject.components == null)
                    return;
                if (this.aabb == null) {
                    this.aabb = this.buildAABB();
                    this.aabbchild = this.aabb.clone();
                }
                this.aabb.update(this.worldMatrix);
            };
            transform.prototype.caclAABBChild = function () {
                if (this.aabb == null)
                    return;
                this.aabbchild = this.aabb.clone();
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.aabbchild.addAABB(this.children[i].aabbchild);
                    }
                }
            };
            transform.prototype.buildAABB = function () {
                var minimum = new gd3d.math.vector3();
                var maximum = new gd3d.math.vector3();
                var filter = this.gameObject.getComponent("meshFilter");
                if (filter != null && filter.mesh != null && filter.mesh.data != null && filter.mesh.data.pos != null) {
                    var meshdata = filter.mesh.data;
                    gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                    gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                    for (var i = 0; i < meshdata.pos.length; i++) {
                        gd3d.math.vec3Max(meshdata.pos[i], maximum, maximum);
                        gd3d.math.vec3Min(meshdata.pos[i], minimum, minimum);
                    }
                }
                else {
                    var skinmesh = this.gameObject.getComponent("skinnedMeshRenderer");
                    if (skinmesh != null && skinmesh.mesh != null && skinmesh.mesh.data != null && skinmesh.mesh.data.pos != null) {
                        var skinmeshdata = skinmesh.mesh.data;
                        gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                        gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                        for (var i = 0; i < skinmeshdata.pos.length; i++) {
                            gd3d.math.vec3Max(skinmeshdata.pos[i], maximum, maximum);
                            gd3d.math.vec3Min(skinmeshdata.pos[i], minimum, minimum);
                        }
                    }
                    else {
                        minimum.x = -1;
                        minimum.y = -1;
                        minimum.z = -1;
                        maximum.x = 1;
                        maximum.y = 1;
                        maximum.z = 1;
                    }
                }
                var _aabb = new framework.aabb(minimum, maximum);
                return _aabb;
            };
            transform.prototype.addChild = function (node) {
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.push(node);
                node.scene = this.scene;
                node.parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                if (node.hasComponent || node.hasComponentChild)
                    this.markHaveComponent();
                if (node.hasRendererComp || node.hasRendererCompChild)
                    this.markHaveRendererComp();
            };
            transform.prototype.addChildAt = function (node, index) {
                if (index < 0)
                    return;
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.splice(index, 0, node);
                node.scene = this.scene;
                node.parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                if (node.hasComponent || node.hasComponentChild)
                    this.markHaveComponent();
                if (node.hasRendererComp || node.hasRendererCompChild)
                    this.markHaveRendererComp();
            };
            transform.prototype.removeAllChild = function () {
                if (this.children == undefined)
                    return;
                while (this.children.length > 0) {
                    this.removeChild(this.children[0]);
                }
            };
            transform.prototype.removeChild = function (node) {
                if (node.parent != this || this.children == null) {
                    throw new Error("not my child.");
                }
                var i = this.children.indexOf(node);
                if (i >= 0) {
                    this.children.splice(i, 1);
                    framework.sceneMgr.app.markNotify(node, framework.NotifyType.RemoveChild);
                    node.parent = null;
                }
            };
            transform.prototype.find = function (name) {
                if (this.name == name)
                    return this;
                else {
                    if (this.children != undefined) {
                        for (var i in this.children) {
                            var res = this.children[i].find(name);
                            if (res != null)
                                return res;
                            else {
                                continue;
                            }
                        }
                    }
                }
                return null;
            };
            transform.prototype.checkImpactTran = function (tran) {
                if (this.gameObject.collider == null)
                    return false;
                return this.gameObject.collider.intersectsTransform(tran);
            };
            transform.prototype.checkImpact = function () {
                var trans = new Array();
                this.doImpact(this.scene.getRoot(), trans);
                return trans;
            };
            transform.prototype.doImpact = function (tran, impacted) {
                if (tran == this)
                    return;
                if (tran.gameObject != null && tran.gameObject.collider != null) {
                    if (this.checkImpactTran(tran)) {
                        impacted.push(tran);
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        this.doImpact(tran.children[i], impacted);
                    }
                }
            };
            transform.prototype.markDirty = function () {
                this.dirty = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p = p.parent;
                }
            };
            transform.prototype.markHaveComponent = function () {
                this.hasComponent = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p.hasComponentChild = true;
                    p = p.parent;
                }
            };
            transform.prototype.markHaveRendererComp = function () {
                this.hasRendererComp = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p.hasRendererCompChild = true;
                    p = p.parent;
                }
            };
            transform.prototype.updateTran = function (parentChange) {
                if (this.dirtyChild == false && this.dirty == false && parentChange == false)
                    return;
                if (this.dirty) {
                    gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                if (this.dirty || parentChange) {
                    if (this.parent == null) {
                        gd3d.math.matrixClone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        gd3d.math.matrixMultiply(this.parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    this.dirtyWorldDecompose = true;
                    this.markAABBDirty();
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].updateTran(parentChange || this.dirty);
                    }
                }
                this.dirty = false;
                this.dirtyChild = false;
                if (this.aabbdirty) {
                    this.caclAABB();
                    this.aabbdirty = false;
                }
            };
            transform.prototype.updateWorldTran = function () {
                var p = this.parent;
                var dirtylist = [];
                dirtylist.push(this);
                while (p != null) {
                    if (p.dirty)
                        dirtylist.push(p);
                    p = p.parent;
                }
                var top = dirtylist.pop();
                top.updateTran(false);
            };
            transform.prototype.updateAABBChild = function () {
                if (this.aabbchilddirty) {
                    if (this.children != null) {
                        for (var i = 0; i < this.children.length; i++) {
                            this.children[i].updateAABBChild();
                        }
                    }
                    this.caclAABBChild();
                    this.aabbchilddirty = false;
                }
            };
            Object.defineProperty(transform.prototype, "localPosition", {
                get: function () {
                    return this.localTranslate;
                },
                set: function (position) {
                    this.localTranslate = position;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "localEulerAngles", {
                get: function () {
                    gd3d.math.quatToEulerAngles(this.localRotate, this._localEulerAngles);
                    return this._localEulerAngles;
                },
                set: function (angle) {
                    gd3d.math.quatFromEulerAngles(angle.x, angle.y, angle.z, this.localRotate);
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.getWorldTranslate = function () {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrixDecompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldTranslate;
            };
            transform.prototype.getWorldScale = function () {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrixDecompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldScale;
            };
            transform.prototype.getWorldRotate = function () {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrixDecompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldRotate;
            };
            transform.prototype.getLocalMatrix = function () {
                if (this.dirty)
                    gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                return this.localMatrix;
            };
            transform.prototype.getWorldMatrix = function () {
                if (this.dirty) {
                    if (!this.parent)
                        gd3d.math.matrixMultiply(this.parent.worldMatrix, this.getLocalMatrix(), this.tempWorldMatrix);
                    else
                        gd3d.math.matrixClone(this.getLocalMatrix(), this.tempWorldMatrix);
                    return this.tempWorldMatrix;
                }
                else
                    return this.worldMatrix;
            };
            transform.prototype.getForwardInWorld = function (out) {
                var forward = gd3d.math.pool.new_vector3();
                forward.x = 0;
                forward.y = 0;
                forward.z = 1;
                gd3d.math.matrixTransformNormal(forward, this.getWorldMatrix(), out);
                gd3d.math.vec3Normalize(out, out);
                gd3d.math.pool.delete_vector3(forward);
            };
            transform.prototype.getRightInWorld = function (out) {
                var right = gd3d.math.pool.new_vector3();
                right.x = 1;
                right.y = 0;
                right.z = 0;
                gd3d.math.matrixTransformNormal(right, this.getWorldMatrix(), out);
                gd3d.math.vec3Normalize(out, out);
                gd3d.math.pool.delete_vector3(right);
            };
            transform.prototype.getUpInWorld = function (out) {
                var up = gd3d.math.pool.new_vector3();
                up.x = 0;
                up.y = 1;
                up.z = 0;
                gd3d.math.matrixTransformNormal(up, this.getWorldMatrix(), out);
                gd3d.math.vec3Normalize(out, out);
                gd3d.math.pool.delete_vector3(up);
            };
            transform.prototype.setWorldMatrix = function (mat) {
                this.dirty = true;
                this.updateWorldTran();
                var pworld = gd3d.math.pool.new_matrix();
                if (this.parent != null) {
                    gd3d.math.matrixClone(this.parent.worldMatrix, pworld);
                }
                else {
                    gd3d.math.matrixMakeIdentity(pworld);
                }
                var invparentworld = gd3d.math.pool.new_matrix();
                gd3d.math.matrixInverse(pworld, invparentworld);
                gd3d.math.matrixClone(mat, this.worldMatrix);
                this.dirtyWorldDecompose = true;
                gd3d.math.matrixMultiply(invparentworld, this.worldMatrix, this.localMatrix);
                gd3d.math.matrixDecompose(this.localMatrix, this.localScale, this.localRotate, this.localTranslate);
                this.markDirty();
                gd3d.math.pool.delete_matrix(pworld);
                gd3d.math.pool.delete_matrix(invparentworld);
            };
            transform.prototype.setWorldPosition = function (pos) {
                this.dirty = true;
                this.updateWorldTran();
                var pworld = gd3d.math.pool.new_matrix();
                if (this.parent != null) {
                    gd3d.math.matrixClone(this.parent.worldMatrix, pworld);
                }
                else {
                    gd3d.math.matrixMakeIdentity(pworld);
                }
                var invparentworld = gd3d.math.pool.new_matrix();
                gd3d.math.matrixInverse(pworld, invparentworld);
                this.worldMatrix.rawData[12] = pos.x;
                this.worldMatrix.rawData[13] = pos.y;
                this.worldMatrix.rawData[14] = pos.z;
                gd3d.math.matrixMultiply(invparentworld, this.worldMatrix, this.localMatrix);
                gd3d.math.matrixDecompose(this.localMatrix, this.localScale, this.localRotate, this.localTranslate);
                this.markDirty();
                gd3d.math.pool.delete_matrix(pworld);
                gd3d.math.pool.delete_matrix(invparentworld);
            };
            transform.prototype.lookat = function (trans) {
                this.dirty = true;
                trans.updateWorldTran();
                this.updateWorldTran();
                var p0 = this.getWorldTranslate();
                var p1 = trans.getWorldTranslate();
                var d = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(p1, p0, d);
                var quatworld = gd3d.math.pool.new_quaternion();
                var quat = gd3d.math.pool.new_quaternion();
                gd3d.math.quatLookat(p0, p1, quatworld);
                var quatworldCur = this.parent.getWorldRotate();
                gd3d.math.quatInverse(quatworldCur, quat);
                gd3d.math.quatMultiply(quat, quatworld, this.localRotate);
                gd3d.math.pool.delete_vector3(d);
                gd3d.math.pool.delete_quaternion(quatworld);
                gd3d.math.pool.delete_quaternion(quat);
            };
            transform.prototype.lookatPoint = function (point) {
                this.dirty = true;
                this.updateWorldTran();
                var p0 = this.getWorldTranslate();
                var p1 = point;
                var d = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(p1, p0, d);
                var quatworld = gd3d.math.pool.new_quaternion();
                var quat = gd3d.math.pool.new_quaternion();
                gd3d.math.quatLookat(p0, p1, quatworld);
                var quatworldCur = this.parent.getWorldRotate();
                gd3d.math.quatInverse(quatworldCur, quat);
                gd3d.math.quatMultiply(quat, quatworld, this.localRotate);
                this.markDirty();
                gd3d.math.pool.delete_vector3(d);
                gd3d.math.pool.delete_quaternion(quatworld);
                gd3d.math.pool.delete_quaternion(quat);
            };
            Object.defineProperty(transform.prototype, "gameObject", {
                get: function () {
                    if (this._gameObject == null) {
                        this._gameObject = new framework.gameObject();
                        this._gameObject.transform = this;
                    }
                    return this._gameObject;
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.clone = function () {
                return gd3d.io.cloneObj(this);
            };
            Object.defineProperty(transform.prototype, "beDispose", {
                get: function () {
                    return this._beDispose;
                },
                enumerable: true,
                configurable: true
            });
            transform.prototype.dispose = function () {
                if (this._beDispose)
                    return;
                if (this.children) {
                    for (var k in this.children) {
                        this.children[k].dispose();
                    }
                    this.removeAllChild();
                }
                this._gameObject.dispose();
                this._beDispose = true;
            };
            __decorate([
                gd3d.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform.prototype, "name", void 0);
            __decorate([
                gd3d.reflect.Field("transform[]"),
                __metadata("design:type", Array)
            ], transform.prototype, "children", void 0);
            __decorate([
                gd3d.reflect.Field("quaternion"),
                __metadata("design:type", gd3d.math.quaternion)
            ], transform.prototype, "localRotate", void 0);
            __decorate([
                gd3d.reflect.Field("vector3", new gd3d.math.vector3(0, 0, 0)),
                __metadata("design:type", gd3d.math.vector3)
            ], transform.prototype, "localTranslate", void 0);
            __decorate([
                gd3d.reflect.Field("vector3", new gd3d.math.vector3(1, 1, 1)),
                __metadata("design:type", gd3d.math.vector3)
            ], transform.prototype, "localScale", void 0);
            __decorate([
                gd3d.reflect.Field("gameObject"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [])
            ], transform.prototype, "gameObject", null);
            transform = __decorate([
                gd3d.reflect.SerializeType
            ], transform);
            return transform;
        }());
        framework.transform = transform;
        var insID = (function () {
            function insID() {
                this.id = insID.next();
            }
            insID.next = function () {
                var next = insID.idAll;
                insID.idAll++;
                return next;
            };
            insID.prototype.getInsID = function () {
                return this.id;
            };
            insID.idAll = 1;
            return insID;
        }());
        framework.insID = insID;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var EnumUtil = (function () {
            function EnumUtil() {
            }
            EnumUtil.getEnumObjByType = function (enumType) {
                var index = enumType.indexOf("gd3d.framework.");
                if (index == 0)
                    enumType = enumType.substr(15);
                return eval("{result:" + enumType + "}");
            };
            return EnumUtil;
        }());
        framework.EnumUtil = EnumUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var NumberUtil = (function () {
            function NumberUtil() {
            }
            NumberUtil.KEY_A = 65;
            NumberUtil.KEY_D = 68;
            NumberUtil.KEY_E = 69;
            NumberUtil.KEY_Q = 81;
            NumberUtil.KEY_R = 82;
            NumberUtil.KEY_S = 83;
            NumberUtil.KEY_W = 87;
            NumberUtil.KEY_a = 97;
            NumberUtil.KEY_d = 100;
            NumberUtil.KEY_e = 101;
            NumberUtil.KEY_q = 113;
            NumberUtil.KEY_r = 114;
            NumberUtil.KEY_s = 115;
            NumberUtil.KEY_w = 119;
            return NumberUtil;
        }());
        framework.NumberUtil = NumberUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var RegexpUtil = (function () {
            function RegexpUtil() {
            }
            RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
            RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
            RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
            RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
            RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
            RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
            return RegexpUtil;
        }());
        framework.RegexpUtil = RegexpUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var StringUtil = (function () {
            function StringUtil() {
            }
            StringUtil.replaceAll = function (srcStr, fromStr, toStr) {
                return srcStr.replace(new RegExp(fromStr, 'gm'), toStr);
            };
            StringUtil.trimAll = function (str) {
                str += "";
                var result = str.replace(/(^\s+)|(\s+$)/g, "");
                result = result.replace(/\s/g, "");
                return result;
            };
            StringUtil.firstCharToLowerCase = function (str) {
                var firstChar = str.substr(0, 1).toLowerCase();
                var other = str.substr(1);
                return firstChar + other;
            };
            StringUtil.isNullOrEmptyObject = function (obj) {
                if (!obj)
                    return true;
                for (var n in obj) {
                    return false;
                }
                return true;
            };
            StringUtil.COMPONENT_CAMERA = "camera";
            StringUtil.COMPONENT_BOXCOLLIDER = "boxcollider";
            StringUtil.COMPONENT_LIGHT = "light";
            StringUtil.COMPONENT_MESHFILTER = "meshFilter";
            StringUtil.COMPONENT_MESHRENDER = "meshRenderer";
            StringUtil.COMPONENT_EFFECTSYSTEM = "effectSystem";
            StringUtil.COMPONENT_LABEL = "label";
            StringUtil.COMPONENT_uirect = "uirect";
            StringUtil.COMPONENT_IMAGE = "image2D";
            StringUtil.COMPONENT_RAWIMAGE = "rawImage2D";
            StringUtil.COMPONENT_BUTTON = "button";
            StringUtil.COMPONENT_SKINMESHRENDER = "skinnedMeshRenderer";
            StringUtil.COMPONENT_AUDIOPLAYER = "AudioPlayer";
            StringUtil.COMPONENT_CAMERACONTROLLER = "cameraController";
            StringUtil.COMPONENT_CANVASRENDER = "canvasRenderer";
            StringUtil.UIStyle_RangeFloat = "rangeFloat";
            StringUtil.UIStyle_Enum = "enum";
            StringUtil.RESOURCES_MESH_CUBE = "cube";
            return StringUtil;
        }());
        framework.StringUtil = StringUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var textureutil = (function () {
            function textureutil() {
            }
            textureutil.webgl_util = " \n        var WebGLUtil = (function() {\n        \n          \"use strict\";\n        \n          var ShaderWrapper = function(gl, program) {\n            var i, attrib, uniform, count;\n        \n            this.program = program;\n            this.attribute = {};\n            this.uniform = {};\n        \n            count = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n            for (i = 0; i < count; i++) {\n              attrib = gl.getActiveAttrib(program, i);\n              this.attribute[attrib.name] = gl.getAttribLocation(program, attrib.name);\n            }\n        \n            count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n            for (i = 0; i < count; i++) {\n              uniform = gl.getActiveUniform(program, i);\n              this.uniform[uniform.name] = gl.getUniformLocation(program, uniform.name);\n            }\n          };\n        \n          function shaderStringFromScript(selector) {\n            var shaderScript = document.querySelector(selector);\n            if (!shaderScript) { return null; }\n        \n            var str = \"\";\n            var k = shaderScript.firstChild;\n            while (k) {\n              if (k.nodeType == 3) {\n                str += k.textContent;\n              }\n              k = k.nextSibling;\n            }\n            return str;\n          }\n        \n          var vendorPrefixes = [\"\", \"WEBKIT_\", \"MOZ_\"];\n        \n          return {\n            getContext: function(canvas, options) {\n              if (typeof canvas == \"string\") {\n                canvas = document.querySelector(canvas);\n              } \n        \n              var context;\n              if (canvas.getContext) {\n                try {\n                  context = canvas.getContext('webgl', options);\n                  if(context) { return context; }\n                } catch(ex) {}\n              \n                try {\n                  context = canvas.getContext('experimental-webgl', options);\n                  if(context) { return context; }\n                } catch(ex) {}\n              }\n            \n              return null;\n            },\n        \n            getExtension: function(gl, name) {\n              var i, ext;\n              for(i in vendorPrefixes) {\n                ext = gl.getExtension(vendorPrefixes[i] + name);\n                if (ext) { return ext; }\n              }\n              return null;\n            },\n        \n            compileShader: function(gl, source, type) {\n              var shaderHeader = \"\\n\";\n        \n              var shader = gl.createShader(type);\n        \n              gl.shaderSource(shader, shaderHeader + source);\n              gl.compileShader(shader);\n        \n              if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.error(gl.getShaderInfoLog(shader));\n                gl.deleteShader(shader);\n                return null;\n              }\n        \n              return shader;\n            },\n        \n            createProgram: function(gl, vertexShaderSource, fragmentShaderSource) {\n              var vs = this.compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);\n              if (!vs) {\n                return null;\n              }\n        \n              var fs = this.compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);\n              if (!fs) {\n                gl.deleteShader(vs);\n                return null;\n              }\n        \n              var shaderProgram = gl.createProgram();\n              gl.attachShader(shaderProgram, vs);\n              gl.attachShader(shaderProgram, fs);\n        \n              gl.linkProgram(shaderProgram);\n        \n              gl.deleteShader(vs);\n              gl.deleteShader(fs);\n        \n              if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n                console.error(\"Program Link error:\", gl.getProgramInfoLog(shaderProgram));\n                gl.deleteProgram(shaderProgram);\n                return null;\n              }\n        \n              return new ShaderWrapper(gl, shaderProgram);\n            },\n        \n            createProgramFromTags: function(gl, vertexSelector, fragmentSelector) {\n              var vs = shaderStringFromScript(vertexSelector),\n                  fs = shaderStringFromScript(fragmentSelector);\n              return this.createProgram(gl, vs, fs);\n            },\n        \n            createSolidTexture: function(gl, color) {\n              var data = new Uint8Array(color);\n              var texture = gl.createTexture();\n              gl.bindTexture(gl.TEXTURE_2D, texture);\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, data);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n              return texture;\n            },\n          };\n        })();\n        ";
            textureutil.webgl_texture_util = "\n        /*\n        Copyright (c) 2014, Brandon Jones. All rights reserved.\n    \n        Redistribution and use in source and binary forms, with or without modification,\n        are permitted provided that the following conditions are met:\n        \n          * Redistributions of source code must retain the above copyright notice, this\n          list of conditions and the following disclaimer.\n          * Redistributions in binary form must reproduce the above copyright notice,\n          this list of conditions and the following disclaimer in the documentation\n          and/or other materials provided with the distribution.\n        \n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n        ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n        WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n        ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n        (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n        LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n        ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n        SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n        \n        // Shim to provide workers a usable \"window\" object.\n        window = this;\n        \n        // Shim to make sure Firefox doesn't choke on console-less web workers.\n        if (typeof(console) == 'undefined') {\n          console = {\n            log: function() {},\n            error: function() {}\n          }\n        }\n        \n        // Emscripten-ified Crunch decoder in one massive block of Javascript!\n        function LoadCrunchDecoder() {\n          function e(a){throw a;}var j=void 0,l=!0,m=null,p=!1;function q(){return function(){}}var s;s||(s=eval(\"(function() { try { return Module || {} } catch(e) { return {} } })()\"));var aa={},v;for(v in s)s.hasOwnProperty(v)&&(aa[v]=s[v]);var w=\"object\"===typeof process&&\"function\"===typeof require,ba=\"object\"===typeof window,ca=\"function\"===typeof importScripts,da=!ba&&!w&&!ca;\n          if(w){s.print=function(a){process.stdout.write(a+\"\\n\")};s.printErr=function(a){process.stderr.write(a+\"\\n\")};var ea=require(\"fs\"),fa=require(\"path\");s.read=function(a,b){var a=fa.normalize(a),c=ea.readFileSync(a);!c&&a!=fa.resolve(a)&&(a=path.join(__dirname,\"..\",\"src\",a),c=ea.readFileSync(a));c&&!b&&(c=c.toString());return c};s.readBinary=function(a){return s.read(a,l)};s.load=function(a){ga(read(a))};s.arguments=process.argv.slice(2);module.exports=s}else da?(s.print=print,\"undefined\"!=typeof printErr&&\n          (s.printErr=printErr),s.read=\"undefined\"!=typeof read?read:function(){e(\"no read() available (jsc?)\")},s.readBinary=function(a){return read(a,\"binary\")},\"undefined\"!=typeof scriptArgs?s.arguments=scriptArgs:\"undefined\"!=typeof arguments&&(s.arguments=arguments),this.Module=s):ba||ca?(s.read=function(a){var b=new XMLHttpRequest;b.open(\"GET\",a,p);b.send(m);return b.responseText},\"undefined\"!=typeof arguments&&(s.arguments=arguments),\"undefined\"!==typeof console?(s.print=function(a){console.log(a)},\n          s.printErr=function(a){console.log(a)}):s.print=q(),ba?this.Module=s:s.load=importScripts):e(\"Unknown runtime environment. Where are we?\");function ga(a){eval.call(m,a)}\"undefined\"==!s.load&&s.read&&(s.load=function(a){ga(s.read(a))});s.print||(s.print=q());s.printErr||(s.printErr=s.print);s.arguments||(s.arguments=[]);s.print=s.print;s.P=s.printErr;s.preRun=[];s.postRun=[];for(v in aa)aa.hasOwnProperty(v)&&(s[v]=aa[v]);function ha(){return x}function ia(a){x=a}\n          function ja(a){switch(a){case \"i1\":case \"i8\":return 1;case \"i16\":return 2;case \"i32\":return 4;case \"i64\":return 8;case \"float\":return 4;case \"double\":return 8;default:if(\"*\"===a[a.length-1])return ka;if(\"i\"===a[0])return a=parseInt(a.substr(1)),A(0===a%8),a/8}}function la(a,b,c){c&&c.length?(c.splice||(c=Array.prototype.slice.call(c)),c.splice(0,0,b),s[\"dynCall_\"+a].apply(m,c)):s[\"dynCall_\"+a].call(m,b)}var ma;\n          function na(){var a=[],b=0;this.za=function(c){c&=255;if(0==a.length){if(0==(c&128))return String.fromCharCode(c);a.push(c);b=192==(c&224)?1:224==(c&240)?2:3;return\"\"}if(b&&(a.push(c),b--,0<b))return\"\";var c=a[0],d=a[1],f=a[2],h=a[3];2==a.length?c=String.fromCharCode((c&31)<<6|d&63):3==a.length?c=String.fromCharCode((c&15)<<12|(d&63)<<6|f&63):(c=(c&7)<<18|(d&63)<<12|(f&63)<<6|h&63,c=String.fromCharCode(Math.floor((c-65536)/1024)+55296,(c-65536)%1024+56320));a.length=0;return c};this.Cb=function(a){for(var a=\n          unescape(encodeURIComponent(a)),b=[],f=0;f<a.length;f++)b.push(a.charCodeAt(f));return b}}function oa(a){var b=x;x=x+a|0;x=x+7&-8;return b}function pa(a){var b=B;B=B+a|0;B=B+7&-8;return b}function qa(a){var b=D;D=D+a|0;D=D+7&-8;D>=ra&&E(\"Cannot enlarge memory arrays in asm.js. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value \"+ra+\", or (2) set Module.TOTAL_MEMORY before the program runs.\");return b}function sa(a,b){return Math.ceil(a/(b?b:8))*(b?b:8)}\n          var ka=4,ta={},ua=p,va;function A(a,b){a||E(\"Assertion failed: \"+b)}s.ccall=function(a,b,c,d){return wa(xa(a),b,c,d)};function xa(a){try{var b=s[\"_\"+a];b||(b=eval(\"_\"+a))}catch(c){}A(b,\"Cannot call unknown function \"+a+\" (perhaps LLVM optimizations or closure removed it?)\");return b}\n          function wa(a,b,c,d){function f(a,b){if(\"string\"==b){if(a===m||a===j||0===a)return 0;a=H(a);b=\"array\"}if(\"array\"==b){h||(h=ha());var c=oa(a.length);ya(a,c);return c}return a}var h=0,g=0,d=d?d.map(function(a){return f(a,c[g++])}):[];a=a.apply(m,d);\"string\"==b?b=za(a):(A(\"array\"!=b),b=a);h&&ia(h);return b}s.cwrap=function(a,b,c){var d=xa(a);return function(){return wa(d,b,c,Array.prototype.slice.call(arguments))}};\n          function Aa(a,b,c){c=c||\"i8\";\"*\"===c.charAt(c.length-1)&&(c=\"i32\");switch(c){case \"i1\":I[a]=b;break;case \"i8\":I[a]=b;break;case \"i16\":J[a>>1]=b;break;case \"i32\":K[a>>2]=b;break;case \"i64\":va=[b>>>0,(tempDouble=b,1<=+Ba(tempDouble)?0<tempDouble?(Ca(+Da(tempDouble/4294967296),4294967295)|0)>>>0:~~+Ea((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)];K[a>>2]=va[0];K[a+4>>2]=va[1];break;case \"float\":Fa[a>>2]=b;break;case \"double\":Ga[a>>3]=b;break;default:E(\"invalid type for setValue: \"+c)}}\n          s.setValue=Aa;s.getValue=function(a,b){b=b||\"i8\";\"*\"===b.charAt(b.length-1)&&(b=\"i32\");switch(b){case \"i1\":return I[a];case \"i8\":return I[a];case \"i16\":return J[a>>1];case \"i32\":return K[a>>2];case \"i64\":return K[a>>2];case \"float\":return Fa[a>>2];case \"double\":return Ga[a>>3];default:E(\"invalid type for setValue: \"+b)}return m};var Ha=1,Ia=2,Ja=4;s.ALLOC_NORMAL=0;s.ALLOC_STACK=Ha;s.ALLOC_STATIC=Ia;s.ALLOC_DYNAMIC=3;s.ALLOC_NONE=Ja;\n          function L(a,b,c,d){var f,h;\"number\"===typeof a?(f=l,h=a):(f=p,h=a.length);var g=\"string\"===typeof b?b:m,c=c==Ja?d:[Ka,oa,pa,qa][c===j?Ia:c](Math.max(h,g?1:b.length));if(f){d=c;A(0==(c&3));for(a=c+(h&-4);d<a;d+=4)K[d>>2]=0;for(a=c+h;d<a;)I[d++|0]=0;return c}if(\"i8\"===g)return a.subarray||a.slice?M.set(a,c):M.set(new Uint8Array(a),c),c;for(var d=0,i,r;d<h;){var t=a[d];\"function\"===typeof t&&(t=ta.Sd(t));f=g||b[d];0===f?d++:(\"i64\"==f&&(f=\"i32\"),Aa(c+d,t,f),r!==f&&(i=ja(f),r=f),d+=i)}return c}\n          s.allocate=L;function za(a,b){for(var c=p,d,f=0;;){d=M[a+f|0];if(128<=d)c=l;else if(0==d&&!b)break;f++;if(b&&f==b)break}b||(b=f);var h=\"\";if(!c){for(;0<b;)d=String.fromCharCode.apply(String,M.subarray(a,a+Math.min(b,1024))),h=h?h+d:d,a+=1024,b-=1024;return h}c=new na;for(f=0;f<b;f++)d=M[a+f|0],h+=c.za(d);return h}s.Pointer_stringify=za;s.UTF16ToString=function(a){for(var b=0,c=\"\";;){var d=J[a+2*b>>1];if(0==d)return c;++b;c+=String.fromCharCode(d)}};\n          s.stringToUTF16=function(a,b){for(var c=0;c<a.length;++c)J[b+2*c>>1]=a.charCodeAt(c);J[b+2*a.length>>1]=0};s.UTF32ToString=function(a){for(var b=0,c=\"\";;){var d=K[a+4*b>>2];if(0==d)return c;++b;65536<=d?(d-=65536,c+=String.fromCharCode(55296|d>>10,56320|d&1023)):c+=String.fromCharCode(d)}};s.stringToUTF32=function(a,b){for(var c=0,d=0;d<a.length;++d){var f=a.charCodeAt(d);if(55296<=f&&57343>=f)var h=a.charCodeAt(++d),f=65536+((f&1023)<<10)|h&1023;K[b+4*c>>2]=f;++c}K[b+4*c>>2]=0};\n          function La(a){try{\"number\"===typeof a&&(a=za(a));if(\"_\"!==a[0]||\"_\"!==a[1]||\"Z\"!==a[2])return a;var b=3,c={v:\"void\",b:\"bool\",c:\"char\",s:\"short\",i:\"int\",l:\"long\",f:\"float\",d:\"double\",w:\"wchar_t\",a:\"signed char\",h:\"unsigned char\",t:\"unsigned short\",j:\"unsigned int\",m:\"unsigned long\",x:\"long long\",y:\"unsigned long long\",z:\"...\"},d=[],f=function(h,i,r){var i=i||Infinity,t=\"\",y=[],u;if(\"N\"!==a[b]){\"K\"===a[b]&&b++;var n=parseInt(a.substr(b));if(n){var F=n.toString().length;u=a.substr(b+F,n);b+=F+n}}else{b++;\n          \"K\"===a[b]&&b++;for(u=[];\"E\"!==a[b];)if(\"S\"===a[b])b++,n=a.indexOf(\"_\",b),u.push(d[a.substring(b,n)||0]||\"?\"),b=n+1;else{n=parseInt(a.substr(b));F=n.toString().length;if(!n||!F){b--;break}var G=a.substr(b+F,n);u.push(G);d.push(G);b+=F+n}b++;u=u.join(\"::\");i--;if(0===i)return h?[u]:u}\"I\"===a[b]?(b++,n=f(l),F=f(l,1,l),t+=F[0]+\" \"+u+\"<\"+n.join(\", \")+\">\"):t=u;a:for(;b<a.length&&0<i--;)if(u=a[b++],u in c)y.push(c[u]);else switch(u){case \"P\":y.push(f(l,1,l)[0]+\"*\");break;case \"R\":y.push(f(l,1,l)[0]+\"&\");\n          break;case \"L\":b++;n=a.indexOf(\"E\",b)-b;y.push(a.substr(b,n));b+=n+2;break;case \"A\":n=parseInt(a.substr(b));b+=n.toString().length;\"_\"!==a[b]&&e(\"?\");b++;y.push(f(l,1,l)[0]+\" [\"+n+\"]\");break;case \"E\":break a;default:t+=\"?\"+u;break a}!r&&(1===y.length&&\"void\"===y[0])&&(y=[]);return h?y:t+(\"(\"+y.join(\", \")+\")\")};return f()}catch(h){return a}}function Ma(){var a=Error().stack;return a?a.replace(/__Z[\\w\\d_]+/g,function(a){var c=La(a);return a===c?a:a+\" [\"+c+\"]\"}):\"(no stack trace available)\"}\n          var I,M,J,Na,K,Oa,Fa,Ga,Qa=0,B=0,Ra=0,x=0,Sa=0,Ta=0,D=0,ra=s.TOTAL_MEMORY||16777216;A(\"undefined\"!==typeof Int32Array&&\"undefined\"!==typeof Float64Array&&!!(new Int32Array(1)).subarray&&!!(new Int32Array(1)).set,\"Cannot fallback to non-typed array case: Code is too specialized\");var N=new ArrayBuffer(ra);I=new Int8Array(N);J=new Int16Array(N);K=new Int32Array(N);M=new Uint8Array(N);Na=new Uint16Array(N);Oa=new Uint32Array(N);Fa=new Float32Array(N);Ga=new Float64Array(N);K[0]=255;\n          A(255===M[0]&&0===M[3],\"Typed arrays 2 must be run on a little-endian system\");s.HEAP=j;s.HEAP8=I;s.HEAP16=J;s.HEAP32=K;s.HEAPU8=M;s.HEAPU16=Na;s.HEAPU32=Oa;s.HEAPF32=Fa;s.HEAPF64=Ga;function Ua(a){for(;0<a.length;){var b=a.shift();if(\"function\"==typeof b)b();else{var c=b.M;\"number\"===typeof c?b.ta===j?la(\"v\",c):la(\"vi\",c,[b.ta]):c(b.ta===j?m:b.ta)}}}var Va=[],O=[],Wa=[],Xa=[],Ya=[],Za=p;function $a(a){Va.unshift(a)}s.addOnPreRun=s.Id=$a;s.addOnInit=s.Fd=function(a){O.unshift(a)};\n          s.addOnPreMain=s.Hd=function(a){Wa.unshift(a)};s.addOnExit=s.Ed=function(a){Xa.unshift(a)};function ab(a){Ya.unshift(a)}s.addOnPostRun=s.Gd=ab;function H(a,b,c){a=(new na).Cb(a);c&&(a.length=c);b||a.push(0);return a}s.intArrayFromString=H;s.intArrayToString=function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c];255<d&&(d&=255);b.push(String.fromCharCode(d))}return b.join(\"\")};s.writeStringToMemory=function(a,b,c){a=H(a,c);for(c=0;c<a.length;)I[b+c|0]=a[c],c+=1};\n          function ya(a,b){for(var c=0;c<a.length;c++)I[b+c|0]=a[c]}s.writeArrayToMemory=ya;s.writeAsciiToMemory=function(a,b,c){for(var d=0;d<a.length;d++)I[b+d|0]=a.charCodeAt(d);c||(I[b+a.length|0]=0)};function bb(a,b){return 0<=a?a:32>=b?2*Math.abs(1<<b-1)+a:Math.pow(2,b)+a}function cb(a,b){if(0>=a)return a;var c=32>=b?Math.abs(1<<b-1):Math.pow(2,b-1);if(a>=c&&(32>=b||a>c))a=-2*c+a;return a}Math.imul||(Math.imul=function(a,b){var c=a&65535,d=b&65535;return c*d+((a>>>16)*d+c*(b>>>16)<<16)|0});Math.Vd=Math.imul;\n          var Ba=Math.abs,Ea=Math.ceil,Da=Math.floor,Ca=Math.min,Q=0,db={},eb=m,fb=m;function gb(a){Q++;s.monitorRunDependencies&&s.monitorRunDependencies(Q);a?(A(!db[a]),db[a]=1):s.P(\"warning: run dependency added without ID\")}s.addRunDependency=gb;function hb(a){Q--;s.monitorRunDependencies&&s.monitorRunDependencies(Q);a?(A(db[a]),delete db[a]):s.P(\"warning: run dependency removed without ID\");0==Q&&(eb!==m&&(clearInterval(eb),eb=m),fb&&(a=fb,fb=m,a()))}s.removeRunDependency=hb;s.preloadedImages={};\n          s.preloadedAudios={};Qa=8;B=Qa+1376;O.push({M:function(){ib()}});\n          L([109,95,108,111,111,107,117,112,91,116,93,32,61,61,32,99,85,73,78,84,51,50,95,77,65,88,0,0,0,0,0,0,116,32,60,32,40,49,85,32,60,60,32,116,97,98,108,101,95,98,105,116,115,41,0,0,112,67,111,100,101,115,105,122,101,115,91,115,121,109,95,105,110,100,101,120,93,32,61,61,32,99,111,100,101,115,105,122,101,0,0,0,0,0,0,0,115,111,114,116,101,100,95,112,111,115,32,60,32,116,111,116,97,108,95,117,115,101,100,95,115,121,109,115,0,0,0,0,110,117,109,95,99,111,100,101,115,91,99,93,0,0,0,0,110,101,119,95,99,97,112,\n          97,99,105,116,121,32,38,38,32,40,110,101,119,95,99,97,112,97,99,105,116,121,32,62,32,109,95,99,97,112,97,99,105,116,121,41,0,0,0,0,0,40,108,101,110,32,62,61,32,49,41,32,38,38,32,40,108,101,110,32,60,61,32,99,77,97,120,69,120,112,101,99,116,101,100,67,111,100,101,83,105,122,101,41,0,0,0,0,0,110,101,120,116,95,108,101,118,101,108,95,111,102,115,32,62,32,99,117,114,95,108,101,118,101,108,95,111,102,115,0,0,110,117,109,32,38,38,32,40,110,117,109,32,61,61,32,126,110,117,109,95,99,104,101,99,107,41,0,0,\n          0,0,0,0,105,32,60,32,109,95,115,105,122,101,0,0,0,0,0,0,109,105,110,95,110,101,119,95,99,97,112,97,99,105,116,121,32,60,32,40,48,120,55,70,70,70,48,48,48,48,85,32,47,32,101,108,101,109,101,110,116,95,115,105,122,101,41,0,109,111,100,101,108,46,109,95,99,111,100,101,95,115,105,122,101,115,91,115,121,109,93,32,61,61,32,108,101,110,0,0,116,32,33,61,32,99,85,73,78,84,51,50,95,77,65,88,0,0,0,0,0,0,0,0,109,95,98,105,116,95,99,111,117,110,116,32,60,61,32,99,66,105,116,66,117,102,83,105,122,101,0,0,0,0,0,\n          0,48,0,0,0,0,0,0,0,46,46,47,105,110,99,47,99,114,110,95,100,101,99,111,109,112,46,104,0,0,0,0,0,40,116,111,116,97,108,95,115,121,109,115,32,62,61,32,49,41,32,38,38,32,40,116,111,116,97,108,95,115,121,109,115,32,60,61,32,112,114,101,102,105,120,95,99,111,100,105,110,103,58,58,99,77,97,120,83,117,112,112,111,114,116,101,100,83,121,109,115,41,0,0,0,102,97,108,115,101,0,0,0,99,114,110,100,95,102,114,101,101,58,32,98,97,100,32,112,116,114,0,0,0,0,0,0,99,114,110,100,95,114,101,97,108,108,111,99,58,32,98,\n          97,100,32,112,116,114,0,0,0,40,40,117,105,110,116,51,50,41,112,95,110,101,119,32,38,32,40,67,82,78,68,95,77,73,78,95,65,76,76,79,67,95,65,76,73,71,78,77,69,78,84,32,45,32,49,41,41,32,61,61,32,48,0,0,0,99,114,110,100,95,109,97,108,108,111,99,58,32,111,117,116,32,111,102,32,109,101,109,111,114,121,0,0,0,0,0,0,99,114,110,100,95,109,97,108,108,111,99,58,32,115,105,122,101,32,116,111,111,32,98,105,103,0,0,0,0,0,0,0,109,95,115,105,122,101,32,60,61,32,109,95,99,97,112,97,99,105,116,121,0,0,0,0,37,115,40,\n          37,117,41,58,32,65,115,115,101,114,116,105,111,110,32,102,97,105,108,117,114,101,58,32,34,37,115,34,10,0,0,0,0,0,0,0,0,17,18,19,20,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15,16,0,0,0,1,2,2,3,3,3,3,4,0,0,0,0,0,0,1,1,0,1,0,1,0,0,1,2,1,2,0,0,0,1,0,2,1,0,2,0,0,1,2,3,0,2,3,4,5,6,7,1,0,2,3,1,0,0,0,0],\"i8\",Ja,8);var jb=sa(L(12,\"i8\",Ia),8);A(0==jb%8);s._strlen=kb;function lb(a){return 0>a||0===a&&-Infinity===1/a}\n          function mb(a,b){function c(a){var c;\"double\"===a?c=Ga[b+f>>3]:\"i64\"==a?(c=[K[b+f>>2],K[b+(f+8)>>2]],f+=8):(a=\"i32\",c=K[b+f>>2]);f+=Math.max(Math.max(ja(a),ka),8);return c}for(var d=a,f=0,h=[],g,i;;){var r=d;g=I[d];if(0===g)break;i=I[d+1|0];if(37==g){var t=p,y=p,u=p,n=p,F=p;a:for(;;){switch(i){case 43:t=l;break;case 45:y=l;break;case 35:u=l;break;case 48:if(n)break a;else{n=l;break}case 32:F=l;break;default:break a}d++;i=I[d+1|0]}var G=0;if(42==i)G=c(\"i32\"),d++,i=I[d+1|0];else for(;48<=i&&57>=i;)G=\n          10*G+(i-48),d++,i=I[d+1|0];var P=p;if(46==i){var C=0,P=l;d++;i=I[d+1|0];if(42==i)C=c(\"i32\"),d++;else for(;;){i=I[d+1|0];if(48>i||57<i)break;C=10*C+(i-48);d++}i=I[d+1|0]}else C=6;var z;switch(String.fromCharCode(i)){case \"h\":i=I[d+2|0];104==i?(d++,z=1):z=2;break;case \"l\":i=I[d+2|0];108==i?(d++,z=8):z=4;break;case \"L\":case \"q\":case \"j\":z=8;break;case \"z\":case \"t\":case \"I\":z=4;break;default:z=m}z&&d++;i=I[d+1|0];switch(String.fromCharCode(i)){case \"d\":case \"i\":case \"u\":case \"o\":case \"x\":case \"X\":case \"p\":r=\n          100==i||105==i;z=z||4;g=c(\"i\"+8*z);var k;8==z&&(g=117==i?+(g[0]>>>0)+4294967296*+(g[1]>>>0):+(g[0]>>>0)+4294967296*+(g[1]|0));4>=z&&(g=(r?cb:bb)(g&Math.pow(256,z)-1,8*z));var T=Math.abs(g),r=\"\";if(100==i||105==i)k=cb(g,8*z).toString(10);else if(117==i)k=bb(g,8*z).toString(10),g=Math.abs(g);else if(111==i)k=(u?\"0\":\"\")+T.toString(8);else if(120==i||88==i){r=u&&0!=g?\"0x\":\"\";if(0>g){g=-g;k=(T-1).toString(16);T=[];for(u=0;u<k.length;u++)T.push((15-parseInt(k[u],16)).toString(16));for(k=T.join(\"\");k.length<\n          2*z;)k=\"f\"+k}else k=T.toString(16);88==i&&(r=r.toUpperCase(),k=k.toUpperCase())}else 112==i&&(0===T?k=\"(nil)\":(r=\"0x\",k=T.toString(16)));if(P)for(;k.length<C;)k=\"0\"+k;0<=g&&(t?r=\"+\"+r:F&&(r=\" \"+r));\"-\"==k.charAt(0)&&(r=\"-\"+r,k=k.substr(1));for(;r.length+k.length<G;)y?k+=\" \":n?k=\"0\"+k:r=\" \"+r;k=r+k;k.split(\"\").forEach(function(a){h.push(a.charCodeAt(0))});break;case \"f\":case \"F\":case \"e\":case \"E\":case \"g\":case \"G\":g=c(\"double\");if(isNaN(g))k=\"nan\",n=p;else if(isFinite(g)){P=p;z=Math.min(C,20);if(103==\n          i||71==i)P=l,C=C||1,z=parseInt(g.toExponential(z).split(\"e\")[1],10),C>z&&-4<=z?(i=(103==i?\"f\":\"F\").charCodeAt(0),C-=z+1):(i=(103==i?\"e\":\"E\").charCodeAt(0),C--),z=Math.min(C,20);if(101==i||69==i)k=g.toExponential(z),/[eE][-+]\\d$/.test(k)&&(k=k.slice(0,-1)+\"0\"+k.slice(-1));else if(102==i||70==i)k=g.toFixed(z),0===g&&lb(g)&&(k=\"-\"+k);r=k.split(\"e\");if(P&&!u)for(;1<r[0].length&&-1!=r[0].indexOf(\".\")&&(\"0\"==r[0].slice(-1)||\".\"==r[0].slice(-1));)r[0]=r[0].slice(0,-1);else for(u&&-1==k.indexOf(\".\")&&(r[0]+=\n          \".\");C>z++;)r[0]+=\"0\";k=r[0]+(1<r.length?\"e\"+r[1]:\"\");69==i&&(k=k.toUpperCase());0<=g&&(t?k=\"+\"+k:F&&(k=\" \"+k))}else k=(0>g?\"-\":\"\")+\"inf\",n=p;for(;k.length<G;)k=y?k+\" \":n&&(\"-\"==k[0]||\"+\"==k[0])?k[0]+\"0\"+k.slice(1):(n?\"0\":\" \")+k;97>i&&(k=k.toUpperCase());k.split(\"\").forEach(function(a){h.push(a.charCodeAt(0))});break;case \"s\":n=(t=c(\"i8*\"))?kb(t):6;P&&(n=Math.min(n,C));if(!y)for(;n<G--;)h.push(32);if(t)for(u=0;u<n;u++)h.push(M[t++|0]);else h=h.concat(H(\"(null)\".substr(0,n),l));if(y)for(;n<G--;)h.push(32);\n          break;case \"c\":for(y&&h.push(c(\"i8\"));0<--G;)h.push(32);y||h.push(c(\"i8\"));break;case \"n\":y=c(\"i32*\");K[y>>2]=h.length;break;case \"%\":h.push(g);break;default:for(u=r;u<d+2;u++)h.push(I[u])}d+=2}else h.push(g),d+=1}return h}function nb(a,b,c,d){c=mb(c,d);d=b===j?c.length:Math.min(c.length,Math.max(b-1,0));if(0>a)var a=-a,f=Ka(d+1),a=K[a>>2]=f;for(f=0;f<d;f++)I[a+f|0]=c[f];if(d<b||b===j)I[a+f|0]=0;return c.length}\n          var R={W:1,qa:2,qd:3,nc:4,L:5,Ga:6,Kb:7,Kc:8,ba:9,Yb:10,V:11,Ad:11,lb:12,eb:13,ic:14,Wc:15,Wb:16,Da:17,Bd:18,Ea:19,Xc:20,oa:21,u:22,Fc:23,kb:24,ad:25,xd:26,jc:27,Sc:28,sa:29,nd:30,yc:31,fd:32,fc:33,kd:34,Oc:42,lc:43,Zb:44,pc:45,qc:46,rc:47,xc:48,yd:49,Ic:50,oc:51,dc:35,Lc:37,Pb:52,Sb:53,Cd:54,Gc:55,Tb:56,Ub:57,ec:35,Vb:59,Uc:60,Jc:61,ud:62,Tc:63,Pc:64,Qc:65,md:66,Mc:67,Nb:68,rd:69,$b:70,gd:71,Ac:72,gc:73,Rb:74,bd:76,Qb:77,ld:78,sc:79,tc:80,wc:81,vc:82,uc:83,Vc:38,Fa:39,Bc:36,pa:40,ra:95,ed:96,cc:104,\n          Hc:105,Ob:97,jd:91,Zc:88,Rc:92,od:108,bc:111,Lb:98,ac:103,Ec:101,Cc:100,vd:110,kc:112,hb:113,ib:115,fb:114,gb:89,zc:90,hd:93,pd:94,Mb:99,Dc:102,jb:106,ca:107,wd:109,zd:87,hc:122,sd:116,$c:95,Nc:123,mc:84,cd:75,Xb:125,Yc:131,dd:130,td:86},ob={\"0\":\"Success\",1:\"Not super-user\",2:\"No such file or directory\",3:\"No such process\",4:\"Interrupted system call\",5:\"I/O error\",6:\"No such device or address\",7:\"Arg list too long\",8:\"Exec format error\",9:\"Bad file number\",10:\"No children\",11:\"No more processes\",\n          12:\"Not enough core\",13:\"Permission denied\",14:\"Bad address\",15:\"Block device required\",16:\"Mount device busy\",17:\"File exists\",18:\"Cross-device link\",19:\"No such device\",20:\"Not a directory\",21:\"Is a directory\",22:\"Invalid argument\",23:\"Too many open files in system\",24:\"Too many open files\",25:\"Not a typewriter\",26:\"Text file busy\",27:\"File too large\",28:\"No space left on device\",29:\"Illegal seek\",30:\"Read only file system\",31:\"Too many links\",32:\"Broken pipe\",33:\"Math arg out of domain of func\",\n          34:\"Math result not representable\",35:\"File locking deadlock error\",36:\"File or path name too long\",37:\"No record locks available\",38:\"Function not implemented\",39:\"Directory not empty\",40:\"Too many symbolic links\",42:\"No message of desired type\",43:\"Identifier removed\",44:\"Channel number out of range\",45:\"Level 2 not synchronized\",46:\"Level 3 halted\",47:\"Level 3 reset\",48:\"Link number out of range\",49:\"Protocol driver not attached\",50:\"No CSI structure available\",51:\"Level 2 halted\",52:\"Invalid exchange\",\n          53:\"Invalid request descriptor\",54:\"Exchange full\",55:\"No anode\",56:\"Invalid request code\",57:\"Invalid slot\",59:\"Bad font file fmt\",60:\"Device not a stream\",61:\"No data (for no delay io)\",62:\"Timer expired\",63:\"Out of streams resources\",64:\"Machine is not on the network\",65:\"Package not installed\",66:\"The object is remote\",67:\"The link has been severed\",68:\"Advertise error\",69:\"Srmount error\",70:\"Communication error on send\",71:\"Protocol error\",72:\"Multihop attempted\",73:\"Cross mount point (not really error)\",\n          74:\"Trying to read unreadable message\",75:\"Value too large for defined data type\",76:\"Given log. name not unique\",77:\"f.d. invalid for this operation\",78:\"Remote address changed\",79:\"Can   access a needed shared lib\",80:\"Accessing a corrupted shared lib\",81:\".lib section in a.out corrupted\",82:\"Attempting to link in too many libs\",83:\"Attempting to exec a shared library\",84:\"Illegal byte sequence\",86:\"Streams pipe error\",87:\"Too many users\",88:\"Socket operation on non-socket\",89:\"Destination address required\",\n          90:\"Message too long\",91:\"Protocol wrong type for socket\",92:\"Protocol not available\",93:\"Unknown protocol\",94:\"Socket type not supported\",95:\"Not supported\",96:\"Protocol family not supported\",97:\"Address family not supported by protocol family\",98:\"Address already in use\",99:\"Address not available\",100:\"Network interface is not configured\",101:\"Network is unreachable\",102:\"Connection reset by network\",103:\"Connection aborted\",104:\"Connection reset by peer\",105:\"No buffer space available\",106:\"Socket is already connected\",\n          107:\"Socket is not connected\",108:\"Can't send after socket shutdown\",109:\"Too many references\",110:\"Connection timed out\",111:\"Connection refused\",112:\"Host is down\",113:\"Host is unreachable\",114:\"Socket already connected\",115:\"Connection already in progress\",116:\"Stale file handle\",122:\"Quota exceeded\",123:\"No medium (in tape drive)\",125:\"Operation canceled\",130:\"Previous owner died\",131:\"State not recoverable\"},pb=0;function S(a){return K[pb>>2]=a}\n          function qb(a){return/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/.exec(a).slice(1)}function rb(a,b){for(var c=0,d=a.length-1;0<=d;d--){var f=a[d];\".\"===f?a.splice(d,1):\"..\"===f?(a.splice(d,1),c++):c&&(a.splice(d,1),c--)}if(b)for(;c--;c)a.unshift(\"..\");return a}function sb(a){var b=\"/\"===a.charAt(0),c=\"/\"===a.substr(-1),a=rb(a.split(\"/\").filter(function(a){return!!a}),!b).join(\"/\");!a&&!b&&(a=\".\");a&&c&&(a+=\"/\");return(b?\"/\":\"\")+a}\n          function U(){var a=Array.prototype.slice.call(arguments,0);return sb(a.filter(function(a){\"string\"!==typeof a&&e(new TypeError(\"Arguments to path.join must be strings\"));return a}).join(\"/\"))}function tb(){for(var a=\"\",b=p,c=arguments.length-1;-1<=c&&!b;c--){var d=0<=c?arguments[c]:\"/\";\"string\"!==typeof d&&e(new TypeError(\"Arguments to path.resolve must be strings\"));d&&(a=d+\"/\"+a,b=\"/\"===d.charAt(0))}a=rb(a.split(\"/\").filter(function(a){return!!a}),!b).join(\"/\");return(b?\"/\":\"\")+a||\".\"}var ub=[];\n          function vb(a,b){ub[a]={input:[],O:[],Z:b};wb[a]={k:xb}}\n          var xb={open:function(a){var b=ub[a.g.ka];b||e(new V(R.Ea));a.B=b;a.seekable=p},close:function(a){a.B.O.length&&a.B.Z.ja(a.B,10)},K:function(a,b,c,d){(!a.B||!a.B.Z.Qa)&&e(new V(R.Ga));for(var f=0,h=0;h<d;h++){var g;try{g=a.B.Z.Qa(a.B)}catch(i){e(new V(R.L))}g===j&&0===f&&e(new V(R.V));if(g===m||g===j)break;f++;b[c+h]=g}f&&(a.g.timestamp=Date.now());return f},write:function(a,b,c,d){(!a.B||!a.B.Z.ja)&&e(new V(R.Ga));for(var f=0;f<d;f++)try{a.B.Z.ja(a.B,b[c+f])}catch(h){e(new V(R.L))}d&&(a.g.timestamp=\n          Date.now());return f}},W={cb:1,na:2,bb:3,D:function(){return W.createNode(m,\"/\",16895,0)},createNode:function(a,b,c,d){(24576===(c&61440)||4096===(c&61440))&&e(new V(R.W));c=yb(a,b,c,d);16384===(c.mode&61440)?(c.n={J:W.n.J,A:W.n.A,wa:W.n.wa,Q:W.n.Q,Q:W.n.Q,rename:W.n.rename,ab:W.n.ab,Za:W.n.Za,Xa:W.n.Xa,ma:W.n.ma},c.k={N:W.k.N},c.o={}):32768===(c.mode&61440)?(c.n={J:W.n.J,A:W.n.A},c.k={N:W.k.N,K:W.k.K,write:W.k.write,Ja:W.k.Ja,Ta:W.k.Ta},c.o=[],c.ea=W.na):40960===(c.mode&61440)?(c.n={J:W.n.J,A:W.n.A,\n          la:W.n.la},c.k={}):8192===(c.mode&61440)&&(c.n={J:W.n.J,A:W.n.A},c.k=zb);c.timestamp=Date.now();a&&(a.o[b]=c);return c},ua:function(a){a.ea!==W.na&&(a.o=Array.prototype.slice.call(a.o),a.ea=W.na)},n:{J:function(a){var b={};b.Qd=8192===(a.mode&61440)?a.id:1;b.Wd=a.id;b.mode=a.mode;b.ae=1;b.uid=0;b.Ud=0;b.ka=a.ka;b.size=16384===(a.mode&61440)?4096:32768===(a.mode&61440)?a.o.length:40960===(a.mode&61440)?a.link.length:0;b.Kd=new Date(a.timestamp);b.$d=new Date(a.timestamp);b.Pd=new Date(a.timestamp);\n          b.pb=4096;b.Md=Math.ceil(b.size/b.pb);return b},A:function(a,b){b.mode!==j&&(a.mode=b.mode);b.timestamp!==j&&(a.timestamp=b.timestamp);if(b.size!==j){W.ua(a);var c=a.o;if(b.size<c.length)c.length=b.size;else for(;b.size>c.length;)c.push(0)}},wa:function(){e(new V(R.qa))},Q:function(a,b,c,d){return W.createNode(a,b,c,d)},rename:function(a,b,c){if(16384===(a.mode&61440)){var d;try{d=Ab(b,c)}catch(f){}if(d)for(var h in d.o)e(new V(R.Fa))}delete a.parent.o[a.name];a.name=c;b.o[c]=a;a.parent=b},ab:function(a,\n          b){delete a.o[b]},Za:function(a,b){var c=Ab(a,b),d;for(d in c.o)e(new V(R.Fa));delete a.o[b]},Xa:function(a){var b=[\".\",\"..\"],c;for(c in a.o)a.o.hasOwnProperty(c)&&b.push(c);return b},ma:function(a,b,c){a=W.createNode(a,b,41471,0);a.link=c;return a},la:function(a){40960!==(a.mode&61440)&&e(new V(R.u));return a.link}},k:{K:function(a,b,c,d,f){a=a.g.o;if(f>=a.length)return 0;d=Math.min(a.length-f,d);A(0<=d);if(8<d&&a.subarray)b.set(a.subarray(f,f+d),c);else for(var h=0;h<d;h++)b[c+h]=a[f+h];return d},\n          write:function(a,b,c,d,f,h){var g=a.g;g.timestamp=Date.now();a=g.o;if(d&&0===a.length&&0===f&&b.subarray)return A(b.length),h&&b.buffer===I.buffer&&0===c?(g.o=b,g.ea=W.cb):(g.o=new Uint8Array(b.subarray(c,c+d)),g.ea=W.bb),d;W.ua(g);for(a=g.o;a.length<f;)a.push(0);for(h=0;h<d;h++)a[f+h]=b[c+h];return d},N:function(a,b,c){1===c?b+=a.position:2===c&&32768===(a.g.mode&61440)&&(b+=a.g.o.length);0>b&&e(new V(R.u));a.Hb=[];return a.position=b},Ja:function(a,b,c){W.ua(a.g);a=a.g.o;for(b+=c;b>a.length;)a.push(0)},\n          Ta:function(a,b,c,d,f,h,g){32768!==(a.g.mode&61440)&&e(new V(R.Ea));a=a.g.o;if(!(g&2)&&(a.buffer===b||a.buffer===b.buffer))f=p,d=a.byteOffset;else{if(0<f||f+d<a.length)a=a.subarray?a.subarray(f,f+d):Array.prototype.slice.call(a,f,f+d);f=l;(d=Ka(d))||e(new V(R.lb));b.set(a,d)}return{de:d,Jd:f}}}},Bb=L(1,\"i32*\",Ia),Cb=L(1,\"i32*\",Ia),Db=L(1,\"i32*\",Ia),Eb=m,Fb=[],wb=[m],X=[m],Gb=1,Hb=m,Ib=l,V=m;function Jb(a){a instanceof V||e(a+\" : \"+Ma());S(a.Na)}\n          function Y(a,b){a=tb(\"/\",a);b=b||{Aa:0};8<b.Aa&&e(new V(R.pa));for(var c=rb(a.split(\"/\").filter(function(a){return!!a}),p),d=Eb,f=\"/\",h=0;h<c.length;h++){var g=h===c.length-1;if(g&&b.parent)break;d=Ab(d,c[h]);f=U(f,c[h]);d.Ab&&(d=d.D.root);if(!g||b.X)for(g=0;40960===(d.mode&61440);){d=Y(f,{X:p}).g;d.n.la||e(new V(R.u));var d=d.n.la(d),i=tb;var r=qb(f),f=r[0],r=r[1];!f&&!r?f=\".\":(r&&(r=r.substr(0,r.length-1)),f+=r);f=i(f,d);d=Y(f,{Aa:b.Aa}).g;40<g++&&e(new V(R.pa))}}return{path:f,g:d}}\n          function Kb(a){for(var b;;){if(a===a.parent)return b?U(a.D.Ua,b):a.D.Ua;b=b?U(a.name,b):a.name;a=a.parent}}function Lb(a,b){for(var c=0,d=0;d<b.length;d++)c=(c<<5)-c+b.charCodeAt(d)|0;return(a+c>>>0)%Hb.length}function Ab(a,b){var c=Mb(a,\"x\");c&&e(new V(c));for(c=Hb[Lb(a.id,b)];c;c=c.Bb){var d=c.name;if(c.parent.id===a.id&&d===b)return c}return a.n.wa(a,b)}\n          function yb(a,b,c,d){var f={id:Gb++,name:b,mode:c,n:{},k:{},ka:d,parent:m,D:m};a||(a=f);f.parent=a;f.D=a.D;Object.defineProperties(f,{K:{get:function(){return 365===(f.mode&365)},set:function(a){a?f.mode|=365:f.mode&=-366}},write:{get:function(){return 146===(f.mode&146)},set:function(a){a?f.mode|=146:f.mode&=-147}},yb:{get:function(){return 16384===(f.mode&61440)}},xb:{get:function(){return 8192===(f.mode&61440)}}});a=Lb(f.parent.id,f.name);f.Bb=Hb[a];return Hb[a]=f}\n          var Nb={r:0,rs:1052672,\"r+\":2,w:577,wx:705,xw:705,\"w+\":578,\"wx+\":706,\"xw+\":706,a:1089,ax:1217,xa:1217,\"a+\":1090,\"ax+\":1218,\"xa+\":1218};function Ob(a){var b=Nb[a];\"undefined\"===typeof b&&e(Error(\"Unknown file open mode: \"+a));return b}function Mb(a,b){return Ib?0:-1!==b.indexOf(\"r\")&&!(a.mode&292)||-1!==b.indexOf(\"w\")&&!(a.mode&146)||-1!==b.indexOf(\"x\")&&!(a.mode&73)?R.eb:0}function Pb(a,b){try{return Ab(a,b),R.Da}catch(c){}return Mb(a,\"wx\")}\n          function Qb(a,b,c){var d;a:{b=b||1;for(c=c||4096;b<=c;b++)if(!X[b]){d=b;break a}e(new V(R.kb))}a.C=d;Object.defineProperties(a,{object:{get:function(){return a.g},set:function(b){a.g=b}},Yd:{get:function(){return 1!==(a.I&2097155)}},Zd:{get:function(){return 0!==(a.I&2097155)}},Xd:{get:function(){return a.I&1024}}});return X[d]=a}var zb={open:function(a){a.k=wb[a.g.ka].k;a.k.open&&a.k.open(a)},N:function(){e(new V(R.sa))}};\n          function Rb(a,b){var c;b&&(c=Y(b,{X:p}),b=c.path);var d={type:a,ce:{},Ua:b,root:m},f=a.D(d);f.D=d;d.root=f;c&&(c.g.D=d,c.g.Ab=l,\"/\"===b&&(Eb=d.root));Fb.push(d);return f}function Sb(a,b,c){var d=Y(a,{parent:l}).g,a=\"/\"===a?\"/\":qb(a)[2],f=Pb(d,a);f&&e(new V(f));d.n.Q||e(new V(R.W));return d.n.Q(d,a,b,c)}function Tb(a,b){b=(b!==j?b:438)&4095;b|=32768;return Sb(a,b,0)}function Ub(a,b){b=(b!==j?b:511)&1023;b|=16384;return Sb(a,b,0)}\n          function Vb(a,b,c){\"undefined\"===typeof c&&(c=b,b=438);return Sb(a,b|8192,c)}function Wb(a,b){var c=Y(b,{parent:l}).g,d=\"/\"===b?\"/\":qb(b)[2],f=Pb(c,d);f&&e(new V(f));c.n.ma||e(new V(R.W));return c.n.ma(c,d,a)}function Xb(a,b){var c;c=\"string\"===typeof a?Y(a,{X:l}).g:a;c.n.A||e(new V(R.W));c.n.A(c,{mode:b&4095|c.mode&-4096,timestamp:Date.now()})}\n          function Yb(a,b){var c,a=sb(a),b=\"string\"===typeof b?Ob(b):b;c=b&64?(\"undefined\"===typeof c?438:c)&4095|32768:0;var d;try{d=Y(a,{X:!(b&131072)}).g}catch(f){}b&64&&(d?b&128&&e(new V(R.Da)):d=Sb(a,c,0));d||e(new V(R.qa));8192===(d.mode&61440)&&(b&=-513);d?40960===(d.mode&61440)?c=R.pa:16384===(d.mode&61440)&&(0!==(b&2097155)||b&512)?c=R.oa:(c=[\"r\",\"w\",\"rw\"][b&2097155],b&512&&(c+=\"w\"),c=Mb(d,c)):c=R.qa;c&&e(new V(c));if(b&512){c=d;c=\"string\"===typeof c?Y(c,{X:l}).g:c;c.n.A||e(new V(R.W));16384===(c.mode&\n          61440)&&e(new V(R.oa));32768!==(c.mode&61440)&&e(new V(R.u));var h=Mb(c,\"w\");h&&e(new V(h));c.n.A(c,{size:0,timestamp:Date.now()})}b&=-641;d=Qb({g:d,path:Kb(d),I:b,seekable:l,position:0,k:d.k,Hb:[],error:p},j,j);d.k.open&&d.k.open(d);s.logReadFiles&&!(b&1)&&(Zb||(Zb={}),a in Zb||(Zb[a]=1,s.printErr(\"read file: \"+a)));return d}function $b(a){try{a.k.close&&a.k.close(a)}catch(b){e(b)}finally{X[a.C]=m}}\n          function ac(a,b,c,d,f,h){(0>d||0>f)&&e(new V(R.u));0===(a.I&2097155)&&e(new V(R.ba));16384===(a.g.mode&61440)&&e(new V(R.oa));a.k.write||e(new V(R.u));var g=l;\"undefined\"===typeof f?(f=a.position,g=p):a.seekable||e(new V(R.sa));a.I&1024&&((!a.seekable||!a.k.N)&&e(new V(R.sa)),a.k.N(a,0,2));b=a.k.write(a,b,c,d,f,h);g||(a.position+=b);return b}function bc(){V||(V=function(a){this.Na=a;for(var b in R)if(R[b]===a){this.code=b;break}this.message=ob[a];this.stack=Ma()},V.prototype=Error())}var cc;\n          function dc(a,b){var c=0;a&&(c|=365);b&&(c|=146);return c}function ec(a,b,c,d,f,h){a=b?U(\"string\"===typeof a?a:Kb(a),b):a;d=dc(d,f);f=Tb(a,d);if(c){if(\"string\"===typeof c){for(var b=Array(c.length),g=0,i=c.length;g<i;++g)b[g]=c.charCodeAt(g);c=b}Xb(a,d|146);b=Yb(a,\"w\");ac(b,c,0,c.length,0,h);$b(b);Xb(a,d)}return f}\n          function fc(a,b,c,d){a=U(\"string\"===typeof a?a:Kb(a),b);b=dc(!!c,!!d);fc.Sa||(fc.Sa=64);var f;f=fc.Sa++<<8|0;wb[f]={k:{open:function(a){a.seekable=p},close:function(){d&&(d.buffer&&d.buffer.length)&&d(10)},K:function(a,b,d,f){for(var t=0,y=0;y<f;y++){var u;try{u=c()}catch(n){e(new V(R.L))}u===j&&0===t&&e(new V(R.V));if(u===m||u===j)break;t++;b[d+y]=u}t&&(a.g.timestamp=Date.now());return t},write:function(a,b,c,f){for(var t=0;t<f;t++)try{d(b[c+t])}catch(y){e(new V(R.L))}f&&(a.g.timestamp=Date.now());\n          return t}}};return Vb(a,b,f)}function gc(a){if(a.xb||a.yb||a.link||a.o)return l;var b=l;\"undefined\"!==typeof XMLHttpRequest&&e(Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\"));if(s.read)try{a.o=H(s.read(a.url),l)}catch(c){b=p}else e(Error(\"Cannot load without read() or XMLHttpRequest.\"));b||S(R.L);return b}\n          var Zb,Z={D:function(){return yb(m,\"/\",16895,0)},sb:function(a,b,c){c&&A(1==b==(6==c));a={tb:a,type:b,protocol:c,p:m,$:{},ya:[],R:[],T:Z.q};b=Z.ia();c=yb(Z.root,b,49152,0);c.S=a;b=Qb({path:b,g:c,I:Ob(\"r+\"),seekable:p,k:Z.k});a.$a=b;return a},ub:function(a){a=X[a];return!a||49152!==(a.g.mode&49152)?m:a.g.S},k:{Wa:function(a){a=a.g.S;return a.T.Wa(a)},Ra:function(a,b,c){a=a.g.S;return a.T.Ra(a,b,c)},K:function(a,b,c,d){a=a.g.S;d=a.T.Db(a,d);if(!d)return 0;b.set(d.buffer,c);return d.buffer.length},write:function(a,\n          b,c,d){a=a.g.S;return a.T.Fb(a,b,c,d)},close:function(a){a=a.g.S;a.T.close(a)}},ia:function(){Z.ia.Ma||(Z.ia.Ma=0);return\"socket[\"+Z.ia.Ma++ +\"]\"},q:{fa:function(a,b,c){var d;\"object\"===typeof b&&(d=b,c=b=m);if(d)d.Ha?(b=d.Ha.ee,c=d.Ha.fe):((c=/ws[s]?:\\/\\/([^:]+):(\\d+)/.exec(d.url))||e(Error(\"WebSocket URL must be in the format ws(s)://address:port\")),b=c[1],c=parseInt(c[2],10));else try{d=new WebSocket(\"ws://\"+b+\":\"+c,w?{}:[\"binary\"]),d.binaryType=\"arraybuffer\"}catch(f){e(new V(R.hb))}b={F:b,port:c,\n          e:d,ga:[]};Z.q.Ia(a,b);Z.q.wb(a,b);2===a.type&&\"undefined\"!==typeof a.U&&b.ga.push(new Uint8Array([255,255,255,255,112,111,114,116,(a.U&65280)>>8,a.U&255]));return b},ha:function(a,b,c){return a.$[b+\":\"+c]},Ia:function(a,b){a.$[b.F+\":\"+b.port]=b},Ya:function(a,b){delete a.$[b.F+\":\"+b.port]},wb:function(a,b){function c(c){A(\"string\"!==typeof c&&c.byteLength!==j);var c=new Uint8Array(c),d=f;f=p;d&&10===c.length&&255===c[0]&&255===c[1]&&255===c[2]&&255===c[3]&&112===c[4]&&111===c[5]&&114===c[6]&&116===\n          c[7]?(c=c[8]<<8|c[9],Z.q.Ya(a,b),b.port=c,Z.q.Ia(a,b)):a.R.push({F:b.F,port:b.port,data:c})}function d(){try{for(var a=b.ga.shift();a;)b.e.send(a),a=b.ga.shift()}catch(c){b.e.close()}}var f=l;w?(b.e.Y(\"open\",d),b.e.Y(\"message\",function(a,b){b.Ld&&c((new Uint8Array(a)).buffer)}),b.e.Y(\"error\",q())):(b.e.onopen=d,b.e.onmessage=function(a){c(a.data)})},Wa:function(a){if(1===a.type&&a.p)return a.ya.length?65:0;var b=0,c=1===a.type?Z.q.ha(a,a.G,a.H):m;if(a.R.length||!c||c&&c.e.readyState===c.e.aa||c&&\n          c.e.readyState===c.e.CLOSED)b|=65;if(!c||c&&c.e.readyState===c.e.OPEN)b|=4;if(c&&c.e.readyState===c.e.aa||c&&c.e.readyState===c.e.CLOSED)b|=16;return b},Ra:function(a,b,c){switch(b){case 21531:return b=0,a.R.length&&(b=a.R[0].data.length),K[c>>2]=b,0;default:return R.u}},close:function(a){if(a.p){try{a.p.close()}catch(b){}a.p=m}for(var c=Object.keys(a.$),d=0;d<c.length;d++){var f=a.$[c[d]];try{f.e.close()}catch(h){}Z.q.Ya(a,f)}return 0},bind:function(a,b,c){(\"undefined\"!==typeof a.Ca||\"undefined\"!==\n          typeof a.U)&&e(new V(R.u));a.Ca=b;a.U=c||_mkport();if(2===a.type){a.p&&(a.p.close(),a.p=m);try{a.T.zb(a,0)}catch(d){d instanceof V||e(d),d.Na!==R.ra&&e(d)}}},Od:function(a,b,c){a.p&&e(new V(ERRNO_CODS.ra));if(\"undefined\"!==typeof a.G&&\"undefined\"!==typeof a.H){var d=Z.q.ha(a,a.G,a.H);d&&(d.e.readyState===d.e.CONNECTING&&e(new V(R.fb)),e(new V(R.jb)))}b=Z.q.fa(a,b,c);a.G=b.F;a.H=b.port;e(new V(R.ib))},zb:function(a){w||e(new V(R.ra));a.p&&e(new V(R.u));var b=require(\"ws\").Dd;a.p=new b({host:a.Ca,port:a.U});\n          a.p.Y(\"connection\",function(b){if(1===a.type){var d=Z.sb(a.tb,a.type,a.protocol),b=Z.q.fa(d,b);d.G=b.F;d.H=b.port;a.ya.push(d)}else Z.q.fa(a,b)});a.p.Y(\"closed\",function(){a.p=m});a.p.Y(\"error\",q())},accept:function(a){a.p||e(new V(R.u));var b=a.ya.shift();b.$a.I=a.$a.I;return b},Td:function(a,b){var c,d;b?((a.G===j||a.H===j)&&e(new V(R.ca)),c=a.G,d=a.H):(c=a.Ca||0,d=a.U||0);return{F:c,port:d}},Fb:function(a,b,c,d,f,h){if(2===a.type){if(f===j||h===j)f=a.G,h=a.H;(f===j||h===j)&&e(new V(R.gb))}else f=\n          a.G,h=a.H;var g=Z.q.ha(a,f,h);1===a.type&&((!g||g.e.readyState===g.e.aa||g.e.readyState===g.e.CLOSED)&&e(new V(R.ca)),g.e.readyState===g.e.CONNECTING&&e(new V(R.V)));b=b instanceof Array||b instanceof ArrayBuffer?b.slice(c,c+d):b.buffer.slice(b.byteOffset+c,b.byteOffset+c+d);if(2===a.type&&(!g||g.e.readyState!==g.e.OPEN)){if(!g||g.e.readyState===g.e.aa||g.e.readyState===g.e.CLOSED)g=Z.q.fa(a,f,h);g.ga.push(b);return d}try{return g.e.send(b),d}catch(i){e(new V(R.u))}},Db:function(a,b){1===a.type&&\n          a.p&&e(new V(R.ca));var c=a.R.shift();if(!c){if(1===a.type){var d=Z.q.ha(a,a.G,a.H);if(d){if(d.e.readyState===d.e.aa||d.e.readyState===d.e.CLOSED)return m;e(new V(R.V))}e(new V(R.ca))}e(new V(R.V))}var d=c.data.byteLength||c.data.length,f=c.data.byteOffset||0,h=c.data.buffer||c.data,g=Math.min(b,d),i={buffer:new Uint8Array(h,f,g),F:c.F,port:c.port};1===a.type&&g<d&&(c.data=new Uint8Array(h,f+g,d-g),a.R.unshift(c));return i}}};\n          function hc(a,b,c){a=X[a];if(!a)return S(R.ba),-1;try{return ac(a,I,b,c)}catch(d){return Jb(d),-1}}function ic(a,b,c,d){c*=b;if(0==c)return 0;a=hc(d,a,c);if(-1==a){if(b=X[d])b.error=l;return 0}return Math.floor(a/b)}function jc(a,b,c){c=mb(b,c);b=ha();a=ic(L(c,\"i8\",Ha),1,c.length,a);ia(b);return a}s._memset=kc;s._memcpy=lc;function mc(a){s.print(\"exit(\"+a+\") called\");s.exit(a)}\n          function nc(a){nc.qb||(D=D+4095&-4096,nc.qb=l,A(qa),nc.ob=qa,qa=function(){E(\"cannot dynamically allocate, sbrk now has control\")});var b=D;0!=a&&nc.ob(a);return b}var oc=p,pc=p,qc=p,rc=p,sc=j,tc=j;function uc(a){return{jpg:\"image/jpeg\",jpeg:\"image/jpeg\",png:\"image/png\",bmp:\"image/bmp\",ogg:\"audio/ogg\",wav:\"audio/wav\",mp3:\"audio/mpeg\"}[a.substr(a.lastIndexOf(\".\")+1)]}var vc=[];function wc(){var a=s.canvas;vc.forEach(function(b){b(a.width,a.height)})}\n          function xc(){var a=s.canvas;this.Jb=a.width;this.Ib=a.height;a.width=screen.width;a.height=screen.height;\"undefined\"!=typeof SDL&&(a=Oa[SDL.screen+0*ka>>2],K[SDL.screen+0*ka>>2]=a|8388608);wc()}function yc(){var a=s.canvas;a.width=this.Jb;a.height=this.Ib;\"undefined\"!=typeof SDL&&(a=Oa[SDL.screen+0*ka>>2],K[SDL.screen+0*ka>>2]=a&-8388609);wc()}var zc,Ac,Bc,Cc;bc();Hb=Array(4096);Eb=yb(m,\"/\",16895,0);Rb(W,\"/\");Ub(\"/tmp\");Ub(\"/dev\");wb[259]={k:{K:function(){return 0},write:function(){return 0}}};\n          Vb(\"/dev/null\",259);vb(1280,{Qa:function(a){if(!a.input.length){var b=m;if(w){if(b=process.stdin.read(),!b){if(process.stdin._readableState&&process.stdin._readableState.ended)return m;return}}else\"undefined\"!=typeof window&&\"function\"==typeof window.prompt?(b=window.prompt(\"Input: \"),b!==m&&(b+=\"\\n\")):\"function\"==typeof readline&&(b=readline(),b!==m&&(b+=\"\\n\"));if(!b)return m;a.input=H(b,l)}return a.input.shift()},ja:function(a,b){b===m||10===b?(s.print(a.O.join(\"\")),a.O=[]):a.O.push(Dc.za(b))}});\n          vb(1536,{ja:function(a,b){b===m||10===b?(s.printErr(a.O.join(\"\")),a.O=[]):a.O.push(Dc.za(b))}});Vb(\"/dev/tty\",1280);Vb(\"/dev/tty1\",1536);Ub(\"/dev/shm\");Ub(\"/dev/shm/tmp\");\n          O.unshift({M:function(){if(!s.noFSInit&&!cc){A(!cc,\"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)\");cc=l;bc();s.stdin=s.stdin;s.stdout=s.stdout;s.stderr=s.stderr;s.stdin?fc(\"/dev\",\"stdin\",s.stdin):Wb(\"/dev/tty\",\"/dev/stdin\");s.stdout?fc(\"/dev\",\"stdout\",m,s.stdout):Wb(\"/dev/tty\",\"/dev/stdout\");s.stderr?fc(\"/dev\",\"stderr\",m,s.stderr):Wb(\"/dev/tty1\",\"/dev/stderr\");var a=Yb(\"/dev/stdin\",\n          \"r\");K[Bb>>2]=a.C;A(1===a.C,\"invalid handle for stdin (\"+a.C+\")\");a=Yb(\"/dev/stdout\",\"w\");K[Cb>>2]=a.C;A(2===a.C,\"invalid handle for stdout (\"+a.C+\")\");a=Yb(\"/dev/stderr\",\"w\");K[Db>>2]=a.C;A(3===a.C,\"invalid handle for stderr (\"+a.C+\")\")}}});Wa.push({M:function(){Ib=p}});Xa.push({M:function(){cc=p;for(var a=0;a<X.length;a++){var b=X[a];b&&$b(b)}}});s.FS_createFolder=function(a,b,c,d){a=U(\"string\"===typeof a?a:Kb(a),b);return Ub(a,dc(c,d))};\n          s.FS_createPath=function(a,b){for(var a=\"string\"===typeof a?a:Kb(a),c=b.split(\"/\").reverse();c.length;){var d=c.pop();if(d){var f=U(a,d);try{Ub(f)}catch(h){}a=f}}return f};s.FS_createDataFile=ec;\n          s.FS_createPreloadedFile=function(a,b,c,d,f,h,g,i,r){function t(){qc=document.pointerLockElement===n||document.mozPointerLockElement===n||document.webkitPointerLockElement===n}function y(c){function k(c){i||ec(a,b,c,d,f,r);h&&h();hb(\"cp \"+F)}var n=p;s.preloadPlugins.forEach(function(a){!n&&a.canHandle(F)&&(a.handle(c,F,k,function(){g&&g();hb(\"cp \"+F)}),n=l)});n||k(c)}s.preloadPlugins||(s.preloadPlugins=[]);if(!zc&&!ca){zc=l;try{new Blob,Ac=l}catch(u){Ac=p,console.log(\"warning: no blob constructor, cannot create blobs with mimetypes\")}Bc=\n          \"undefined\"!=typeof MozBlobBuilder?MozBlobBuilder:\"undefined\"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:!Ac?console.log(\"warning: no BlobBuilder\"):m;Cc=\"undefined\"!=typeof window?window.URL?window.URL:window.webkitURL:j;!s.Va&&\"undefined\"===typeof Cc&&(console.log(\"warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.\"),s.Va=l);s.preloadPlugins.push({canHandle:function(a){return!s.Va&&/\\.(jpg|jpeg|png|bmp)$/i.test(a)},handle:function(a,b,\n          c,d){var f=m;if(Ac)try{f=new Blob([a],{type:uc(b)}),f.size!==a.length&&(f=new Blob([(new Uint8Array(a)).buffer],{type:uc(b)}))}catch(g){var h=\"Blob constructor present but fails: \"+g+\"; falling back to blob builder\";ma||(ma={});ma[h]||(ma[h]=1,s.P(h))}f||(f=new Bc,f.append((new Uint8Array(a)).buffer),f=f.getBlob());var i=Cc.createObjectURL(f),n=new Image;n.onload=function(){A(n.complete,\"Image \"+b+\" could not be decoded\");var d=document.createElement(\"canvas\");d.width=n.width;d.height=n.height;d.getContext(\"2d\").drawImage(n,\n          0,0);s.preloadedImages[b]=d;Cc.revokeObjectURL(i);c&&c(a)};n.onerror=function(){console.log(\"Image \"+i+\" could not be decoded\");d&&d()};n.src=i}});s.preloadPlugins.push({canHandle:function(a){return!s.be&&a.substr(-4)in{\".ogg\":1,\".wav\":1,\".mp3\":1}},handle:function(a,b,c,d){function f(d){h||(h=l,s.preloadedAudios[b]=d,c&&c(a))}function g(){h||(h=l,s.preloadedAudios[b]=new Audio,d&&d())}var h=p;if(Ac){try{var i=new Blob([a],{type:uc(b)})}catch(n){return g()}var i=Cc.createObjectURL(i),t=new Audio;t.addEventListener(\"canplaythrough\",\n          function(){f(t)},p);t.onerror=function(){if(!h){console.log(\"warning: browser could not fully decode audio \"+b+\", trying slower base64 approach\");for(var c=\"\",d=0,g=0,i=0;i<a.length;i++){d=d<<8|a[i];for(g+=8;6<=g;)var n=d>>g-6&63,g=g-6,c=c+\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[n]}2==g?(c+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[(d&3)<<4],c+=\"==\"):4==g&&(c+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[(d&15)<<2],c+=\"=\");\n          t.src=\"data:audio/x-\"+b.substr(-3)+\";base64,\"+c;f(t)}};t.src=i;setTimeout(function(){ua||f(t)},1E4)}else return g()}});var n=s.canvas;n.Ba=n.requestPointerLock||n.mozRequestPointerLock||n.webkitRequestPointerLock;n.Oa=document.exitPointerLock||document.mozExitPointerLock||document.webkitExitPointerLock||q();n.Oa=n.Oa.bind(document);document.addEventListener(\"pointerlockchange\",t,p);document.addEventListener(\"mozpointerlockchange\",t,p);document.addEventListener(\"webkitpointerlockchange\",t,p);s.elementPointerLock&&\n          n.addEventListener(\"click\",function(a){!qc&&n.Ba&&(n.Ba(),a.preventDefault())},p)}var F=b?tb(U(a,b)):a;gb(\"cp \"+F);if(\"string\"==typeof c){var G=g,P=function(){G?G():e('Loading data file \"'+c+'\" failed.')},C=new XMLHttpRequest;C.open(\"GET\",c,l);C.responseType=\"arraybuffer\";C.onload=function(){if(200==C.status||0==C.status&&C.response){var a=C.response;A(a,'Loading data file \"'+c+'\" failed (no arrayBuffer).');a=new Uint8Array(a);y(a);hb(\"al \"+c)}else P()};C.onerror=P;C.send(m);gb(\"al \"+c)}else y(c)};\n          s.FS_createLazyFile=function(a,b,c,d,f){var h,g;\"undefined\"!==typeof XMLHttpRequest?(ca||e(\"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\"),h=function(){this.va=p;this.da=[]},h.prototype.get=function(a){if(!(a>this.length-1||0>a)){var b=a%this.rb;return this.vb(Math.floor(a/this.rb))[b]}},h.prototype.Gb=function(a){this.vb=a},h.prototype.Ka=function(){var a=new XMLHttpRequest;a.open(\"HEAD\",c,p);a.send(m);200<=a.status&&300>a.status||\n          304===a.status||e(Error(\"Couldn't load \"+c+\". Status: \"+a.status));var b=Number(a.getResponseHeader(\"Content-length\")),d,f=1048576;if(!((d=a.getResponseHeader(\"Accept-Ranges\"))&&\"bytes\"===d))f=b;var g=this;g.Gb(function(a){var d=a*f,h=(a+1)*f-1,h=Math.min(h,b-1);if(\"undefined\"===typeof g.da[a]){var i=g.da;d>h&&e(Error(\"invalid range (\"+d+\", \"+h+\") or no bytes requested!\"));h>b-1&&e(Error(\"only \"+b+\" bytes available! programmer error!\"));var k=new XMLHttpRequest;k.open(\"GET\",c,p);b!==f&&k.setRequestHeader(\"Range\",\n          \"bytes=\"+d+\"-\"+h);\"undefined\"!=typeof Uint8Array&&(k.responseType=\"arraybuffer\");k.overrideMimeType&&k.overrideMimeType(\"text/plain; charset=x-user-defined\");k.send(m);200<=k.status&&300>k.status||304===k.status||e(Error(\"Couldn't load \"+c+\". Status: \"+k.status));d=k.response!==j?new Uint8Array(k.response||[]):H(k.responseText||\"\",l);i[a]=d}\"undefined\"===typeof g.da[a]&&e(Error(\"doXHR failed!\"));return g.da[a]});this.nb=b;this.mb=f;this.va=l},h=new h,Object.defineProperty(h,\"length\",{get:function(){this.va||\n          this.Ka();return this.nb}}),Object.defineProperty(h,\"chunkSize\",{get:function(){this.va||this.Ka();return this.mb}}),g=j):(g=c,h=j);var i,a=U(\"string\"===typeof a?a:Kb(a),b);i=Tb(a,dc(d,f));h?i.o=h:g&&(i.o=m,i.url=g);var r={};Object.keys(i.k).forEach(function(a){var b=i.k[a];r[a]=function(){gc(i)||e(new V(R.L));return b.apply(m,arguments)}});r.K=function(a,b,c,d,f){gc(i)||e(new V(R.L));a=a.g.o;if(f>=a.length)return 0;d=Math.min(a.length-f,d);A(0<=d);if(a.slice)for(var g=0;g<d;g++)b[c+g]=a[f+g];else for(g=\n          0;g<d;g++)b[c+g]=a.get(f+g);return d};i.k=r;return i};s.FS_createLink=function(a,b,c){a=U(\"string\"===typeof a?a:Kb(a),b);return Wb(c,a)};s.FS_createDevice=fc;pb=pa(4);K[pb>>2]=0;O.unshift({M:q()});Xa.push({M:q()});var Dc=new na;w&&(require(\"fs\"),process.platform.match(/^win/));O.push({M:function(){Z.root=Rb(Z,m)}});\n          s.requestFullScreen=function(a,b){function c(){pc=p;(document.webkitFullScreenElement||document.webkitFullscreenElement||document.mozFullScreenElement||document.mozFullscreenElement||document.fullScreenElement||document.fullscreenElement)===d?(d.La=document.cancelFullScreen||document.mozCancelFullScreen||document.webkitCancelFullScreen,d.La=d.La.bind(document),sc&&d.Ba(),pc=l,tc&&xc()):tc&&yc();if(s.onFullScreen)s.onFullScreen(pc)}sc=a;tc=b;\"undefined\"===typeof sc&&(sc=l);\"undefined\"===typeof tc&&\n          (tc=p);var d=s.canvas;rc||(rc=l,document.addEventListener(\"fullscreenchange\",c,p),document.addEventListener(\"mozfullscreenchange\",c,p),document.addEventListener(\"webkitfullscreenchange\",c,p));d.Eb=d.requestFullScreen||d.mozRequestFullScreen||(d.webkitRequestFullScreen?function(){d.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)}:m);d.Eb()};\n          s.requestAnimationFrame=function(a){window.requestAnimationFrame||(window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||window.oRequestAnimationFrame||window.setTimeout);window.requestAnimationFrame(a)};s.setCanvasSize=function(a,b,c){var d=s.canvas;d.width=a;d.height=b;c||wc()};s.pauseMainLoop=q();s.resumeMainLoop=function(){oc&&(oc=p,m())};\n          s.getUserMedia=function(){window.Pa||(window.Pa=navigator.getUserMedia||navigator.mozGetUserMedia);window.Pa(j)};Ra=x=sa(B);Sa=Ra+5242880;Ta=D=sa(Sa);A(Ta<ra);Ca=Math.min;\n          var $=(function(global,env,buffer) {\n          // EMSCRIPTEN_START_ASM\n          \"use asm\";var a=new global.Int8Array(buffer);var b=new global.Int16Array(buffer);var c=new global.Int32Array(buffer);var d=new global.Uint8Array(buffer);var e=new global.Uint16Array(buffer);var f=new global.Uint32Array(buffer);var g=new global.Float32Array(buffer);var h=new global.Float64Array(buffer);var i=env.STACKTOP|0;var j=env.STACK_MAX|0;var k=env.tempDoublePtr|0;var l=env.ABORT|0;var m=+env.NaN;var n=+env.Infinity;var o=0;var p=0;var q=0;var r=0;var s=0,t=0,u=0,v=0,w=0.0,x=0,y=0,z=0,A=0.0;var B=0;var C=0;var D=0;var E=0;var F=0;var G=0;var H=0;var I=0;var J=0;var K=0;var L=global.Math.floor;var M=global.Math.abs;var N=global.Math.sqrt;var O=global.Math.pow;var P=global.Math.cos;var Q=global.Math.sin;var R=global.Math.tan;var S=global.Math.acos;var T=global.Math.asin;var U=global.Math.atan;var V=global.Math.atan2;var W=global.Math.exp;var X=global.Math.log;var Y=global.Math.ceil;var Z=global.Math.imul;var _=env.abort;var $=env.assert;var aa=env.asmPrintInt;var ab=env.asmPrintFloat;var ac=env.min;var ad=env.invoke_ii;var ae=env.invoke_v;var af=env.invoke_iii;var ag=env.invoke_vi;var ah=env._llvm_lifetime_end;var ai=env._snprintf;var aj=env._abort;var ak=env._fprintf;var al=env._printf;var am=env._fflush;var an=env.__reallyNegative;var ao=env._sysconf;var ap=env.___setErrNo;var aq=env._fwrite;var ar=env._send;var as=env._write;var at=env._exit;var au=env._sprintf;var av=env.__formatString;var aw=env.__ZSt9terminatev;var ax=env._pwrite;var ay=env._sbrk;var az=env.___errno_location;var aA=env.___gxx_personality_v0;var aB=env._llvm_lifetime_start;var aC=env._time;var aD=env.__exit;\n          // EMSCRIPTEN_START_FUNCS\n          function aI(a){a=a|0;var b=0;b=i;i=i+a|0;i=i+7&-8;return b|0}function aJ(){return i|0}function aK(a){a=a|0;i=a}function aL(a,b){a=a|0;b=b|0;if((o|0)==0){o=a;p=b}}function aM(b){b=b|0;a[k]=a[b];a[k+1|0]=a[b+1|0];a[k+2|0]=a[b+2|0];a[k+3|0]=a[b+3|0]}function aN(b){b=b|0;a[k]=a[b];a[k+1|0]=a[b+1|0];a[k+2|0]=a[b+2|0];a[k+3|0]=a[b+3|0];a[k+4|0]=a[b+4|0];a[k+5|0]=a[b+5|0];a[k+6|0]=a[b+6|0];a[k+7|0]=a[b+7|0]}function aO(a){a=a|0;B=a}function aP(a){a=a|0;C=a}function aQ(a){a=a|0;D=a}function aR(a){a=a|0;E=a}function aS(a){a=a|0;F=a}function aT(a){a=a|0;G=a}function aU(a){a=a|0;H=a}function aV(a){a=a|0;I=a}function aW(a){a=a|0;J=a}function aX(a){a=a|0;K=a}function aY(){}function aZ(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;f=i;i=i+1032|0;g=f|0;h=f+512|0;j=f+520|0;k=a+8|0;if((c[a+4>>2]|0)>>>0>(c[k>>2]|0)>>>0){l=j|0;au(l|0,768,(m=i,i=i+24|0,c[m>>2]=472,c[m+8>>2]=2121,c[m+16>>2]=744,m)|0)|0;i=m;al(l|0,(m=i,i=i+1|0,i=i+7&-8,c[m>>2]=0,m)|0)|0;i=m}if((2147418112/(e>>>0)|0)>>>0<=b>>>0){l=j|0;au(l|0,768,(m=i,i=i+24|0,c[m>>2]=472,c[m+8>>2]=2122,c[m+16>>2]=328,m)|0)|0;i=m;al(l|0,(m=i,i=i+1|0,i=i+7&-8,c[m>>2]=0,m)|0)|0;i=m}l=c[k>>2]|0;if(l>>>0>=b>>>0){n=1;i=f;return n|0}do{if(d){o=b-1|0;if((b|0)!=0){if((o&b|0)==0){p=b;break}}q=o>>>16|o;o=q>>>8|q;q=o>>>4|o;o=q>>>2|q;p=(o>>>1|o)+1|0}else{p=b}}while(0);if(!((p|0)!=0&p>>>0>l>>>0)){l=j|0;au(l|0,768,(m=i,i=i+24|0,c[m>>2]=472,c[m+8>>2]=2131,c[m+16>>2]=152,m)|0)|0;i=m;al(l|0,(m=i,i=i+1|0,i=i+7&-8,c[m>>2]=0,m)|0)|0;i=m}l=Z(p,e)|0;j=a|0;a=c[j>>2]|0;if((a&7|0)!=0){b=g|0;au(b|0,768,(m=i,i=i+24|0,c[m>>2]=472,c[m+8>>2]=2500,c[m+16>>2]=600,m)|0)|0;i=m;al(b|0,(m=i,i=i+1|0,i=i+7&-8,c[m>>2]=0,m)|0)|0;i=m;n=0;i=f;return n|0}if(l>>>0>2147418112){b=g|0;au(b|0,768,(m=i,i=i+24|0,c[m>>2]=472,c[m+8>>2]=2500,c[m+16>>2]=712,m)|0)|0;i=m;al(b|0,(m=i,i=i+1|0,i=i+7&-8,c[m>>2]=0,m)|0)|0;i=m;n=0;i=f;return n|0}c[h>>2]=l;b=a$(a,l,h,1)|0;a=c[h>>2]|0;if((b&7|0)!=0){h=g|0;au(h|0,768,(m=i,i=i+24|0,c[m>>2]=472,c[m+8>>2]=2552,c[m+16>>2]=624,m)|0)|0;i=m;al(h|0,(m=i,i=i+1|0,i=i+7&-8,c[m>>2]=0,m)|0)|0;i=m}if((b|0)==0){n=0;i=f;return n|0}c[j>>2]=b;if(a>>>0>l>>>0){r=(a>>>0)/(e>>>0)|0}else{r=p}c[k>>2]=r;n=1;i=f;return n|0}function a_(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0;b=i;i=i+512|0;d=b|0;e=a+3&-4;a=(e|0)==0?4:e;if(a>>>0>2147418112){e=d|0;au(e|0,768,(f=i,i=i+24|0,c[f>>2]=472,c[f+8>>2]=2500,c[f+16>>2]=712,f)|0)|0;i=f;al(e|0,(f=i,i=i+1|0,i=i+7&-8,c[f>>2]=0,f)|0)|0;i=f;g=0;i=b;return g|0}e=be(a)|0;do{if((e|0)!=0){h=c[e-4>>2]|0;j=h&3;if((j|0)==1){k=0}else{k=(h&-8)-((j|0)==0?8:4)|0}if(k>>>0<a>>>0){break}if((e&7|0)==0){g=e;i=b;return g|0}j=d|0;au(j|0,768,(f=i,i=i+24|0,c[f>>2]=472,c[f+8>>2]=2527,c[f+16>>2]=624,f)|0)|0;i=f;al(j|0,(f=i,i=i+1|0,i=i+7&-8,c[f>>2]=0,f)|0)|0;i=f;g=e;i=b;return g|0}}while(0);e=d|0;au(e|0,768,(f=i,i=i+24|0,c[f>>2]=472,c[f+8>>2]=2500,c[f+16>>2]=680,f)|0)|0;i=f;al(e|0,(f=i,i=i+1|0,i=i+7&-8,c[f>>2]=0,f)|0)|0;i=f;g=0;i=b;return g|0}function a$(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;if((a|0)==0){f=be(b)|0;if((d|0)==0){g=f;return g|0}do{if((f|0)==0){h=0}else{i=c[f-4>>2]|0;j=i&3;if((j|0)==1){h=0;break}h=(i&-8)-((j|0)==0?8:4)|0}}while(0);c[d>>2]=h;g=f;return g|0}if((b|0)==0){bf(a);if((d|0)==0){g=0;return g|0}c[d>>2]=0;g=0;return g|0}f=bg(a,b)|0;h=(f|0)!=0;if(h|e^1){k=h?f:a;l=f}else{f=bg(a,b)|0;k=(f|0)==0?a:f;l=f}if((d|0)==0){g=l;return g|0}do{if((k|0)==0){m=0}else{f=c[k-4>>2]|0;a=f&3;if((a|0)==1){m=0;break}m=(f&-8)-((a|0)==0?8:4)|0}}while(0);c[d>>2]=m;g=l;return g|0}function a0(b,e,f){b=b|0;e=e|0;f=f|0;var g=0,h=0;if((b|0)==0|e>>>0<74|(f|0)==0){return}if((c[f>>2]|0)!=40){return}if(((d[b]|0)<<8|(d[b+1|0]|0)|0)!=18552){return}if(((d[b+2|0]|0)<<8|(d[b+3|0]|0))>>>0<74){return}g=((d[b+7|0]|0)<<16|(d[b+6|0]|0)<<24|(d[b+8|0]|0)<<8|(d[b+9|0]|0))>>>0>e>>>0?0:b;if((g|0)==0){return}c[f+4>>2]=(d[g+12|0]|0)<<8|(d[g+13|0]|0);c[f+8>>2]=(d[g+14|0]|0)<<8|(d[g+15|0]|0);c[f+12>>2]=d[g+16|0]|0;c[f+16>>2]=d[g+17|0]|0;b=g+18|0;e=f+32|0;c[e>>2]=d[b]|0;c[e+4>>2]=0;e=a[b]|0;if(e<<24>>24==0){h=8}else{h=e<<24>>24==9?8:16}c[f+20>>2]=h;c[f+24>>2]=(d[g+26|0]|0)<<16|(d[g+25|0]|0)<<24|(d[g+27|0]|0)<<8|(d[g+28|0]|0);c[f+28>>2]=(d[g+30|0]|0)<<16|(d[g+29|0]|0)<<24|(d[g+31|0]|0)<<8|(d[g+32|0]|0);return}function a1(b){b=b|0;var d=0,e=0,f=0,g=0,h=0;d=i;i=i+512|0;e=c[b+20>>2]|0;if((e|0)!=0){a2(e)}e=b+4|0;f=c[e>>2]|0;if((f|0)==0){g=b+16|0;a[g]=0;i=d;return}if((f&7|0)==0){bf(f)}else{f=d|0;au(f|0,768,(h=i,i=i+24|0,c[h>>2]=472,c[h+8>>2]=2500,c[h+16>>2]=576,h)|0)|0;i=h;al(f|0,(h=i,i=i+1|0,i=i+7&-8,c[h>>2]=0,h)|0)|0;i=h}c[e>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;g=b+16|0;a[g]=0;i=d;return}function a2(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0;b=i;i=i+1536|0;d=b|0;e=b+512|0;f=b+1024|0;if((a|0)==0){i=b;return}g=c[a+168>>2]|0;do{if((g|0)!=0){h=c[g-4>>2]|0;j=g-8|0;if((h|0)==0){k=94}else{if((h|0)!=(~c[j>>2]|0)){k=94}}if((k|0)==94){h=d|0;au(h|0,768,(l=i,i=i+24|0,c[l>>2]=472,c[l+8>>2]=645,c[l+16>>2]=280,l)|0)|0;i=l;al(h|0,(l=i,i=i+1|0,i=i+7&-8,c[l>>2]=0,l)|0)|0;i=l;if((j|0)==0){break}}if((j&7|0)!=0){h=d|0;au(h|0,768,(l=i,i=i+24|0,c[l>>2]=472,c[l+8>>2]=2500,c[l+16>>2]=576,l)|0)|0;i=l;al(h|0,(l=i,i=i+1|0,i=i+7&-8,c[l>>2]=0,l)|0)|0;i=l;break}if((j|0)==0){be(0)|0;break}else{bf(j);break}}}while(0);d=c[a+176>>2]|0;do{if((d|0)!=0){g=c[d-4>>2]|0;j=d-8|0;if((g|0)==0){k=103}else{if((g|0)!=(~c[j>>2]|0)){k=103}}if((k|0)==103){g=f|0;au(g|0,768,(l=i,i=i+24|0,c[l>>2]=472,c[l+8>>2]=645,c[l+16>>2]=280,l)|0)|0;i=l;al(g|0,(l=i,i=i+1|0,i=i+7&-8,c[l>>2]=0,l)|0)|0;i=l;if((j|0)==0){break}}if((j&7|0)!=0){g=f|0;au(g|0,768,(l=i,i=i+24|0,c[l>>2]=472,c[l+8>>2]=2500,c[l+16>>2]=576,l)|0)|0;i=l;al(g|0,(l=i,i=i+1|0,i=i+7&-8,c[l>>2]=0,l)|0)|0;i=l;break}if((j|0)==0){be(0)|0;break}else{bf(j);break}}}while(0);if((a&7|0)==0){bf(a);i=b;return}else{a=e|0;au(a|0,768,(l=i,i=i+24|0,c[l>>2]=472,c[l+8>>2]=2500,c[l+16>>2]=576,l)|0)|0;i=l;al(a|0,(l=i,i=i+1|0,i=i+7&-8,c[l>>2]=0,l)|0)|0;i=l;i=b;return}}function a3(f){f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0;g=i;i=i+1232|0;h=g|0;j=g+512|0;k=g+576|0;l=g+648|0;m=g+720|0;n=f+8|0;o=c[n>>2]|0;if(!((o|0)!=0&o>>>0<8193)){p=m|0;au(p|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=2998,c[q+16>>2]=496,q)|0)|0;i=q;al(p|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q}p=f|0;c[p>>2]=o;r=f+20|0;s=c[r>>2]|0;if((s|0)==0){t=a_(180)|0;if((t|0)==0){u=0}else{bj(t+164|0,0,16);u=t}c[r>>2]=u;v=u;w=c[p>>2]|0}else{v=s;w=o}if((c[n>>2]|0)==0){n=m|0;au(n|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=904,c[q+16>>2]=312,q)|0)|0;i=q;al(n|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q;x=c[p>>2]|0}else{x=w}p=c[f+4>>2]|0;if(x>>>0>16){f=x;n=0;while(1){y=n+1|0;if(f>>>0>3){f=f>>>1;n=y}else{break}}f=n+2+((y|0)!=32&1<<y>>>0<x>>>0&1)|0;z=f>>>0<11?f&255:11}else{z=0}if((w|0)==0|z>>>0>11){A=0;i=g;return A|0}c[v>>2]=w;bj(k|0,0,68);f=0;while(1){x=a[p+f|0]|0;if(x<<24>>24!=0){y=k+((x&255)<<2)|0;c[y>>2]=(c[y>>2]|0)+1}y=f+1|0;if(y>>>0<w>>>0){f=y}else{B=1;C=-1;D=0;E=0;F=0;break}}while(1){f=c[k+(B<<2)>>2]|0;if((f|0)==0){c[v+28+(B-1<<2)>>2]=0;G=F;H=E;I=D;J=C}else{y=B-1|0;c[j+(y<<2)>>2]=F;x=f+F|0;n=16-B|0;c[v+28+(y<<2)>>2]=(x-1<<n|(1<<n)-1)+1;c[v+96+(y<<2)>>2]=E;c[l+(B<<2)>>2]=E;G=x;H=f+E|0;I=D>>>0>B>>>0?D:B;J=C>>>0<B>>>0?C:B}f=B+1|0;if(f>>>0<17){B=f;C=J;D=I;E=H;F=G<<1}else{break}}c[v+4>>2]=H;G=v+172|0;do{if(H>>>0>(c[G>>2]|0)>>>0){c[G>>2]=H;F=H-1|0;if((H|0)==0){K=140}else{if((F&H|0)!=0){K=140}}if((K|0)==140){E=F>>>16|F;F=E>>>8|E;E=F>>>4|F;F=E>>>2|E;E=(F>>>1|F)+1|0;c[G>>2]=E>>>0>w>>>0?w:E}E=v+176|0;F=c[E>>2]|0;do{if((F|0)!=0){D=c[F-4>>2]|0;C=F-8|0;if((D|0)==0){K=144}else{if((D|0)!=(~c[C>>2]|0)){K=144}}if((K|0)==144){D=h|0;au(D|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=645,c[q+16>>2]=280,q)|0)|0;i=q;al(D|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q;if((C|0)==0){break}}if((C&7|0)!=0){D=h|0;au(D|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=2500,c[q+16>>2]=576,q)|0)|0;i=q;al(D|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q;break}if((C|0)==0){be(0)|0;break}else{bf(C);break}}}while(0);F=c[G>>2]|0;C=(F|0)==0?1:F;F=a_((C<<1)+8|0)|0;if((F|0)==0){c[E>>2]=0;A=0;i=g;return A|0}else{D=F+8|0;c[F+4>>2]=C;c[F>>2]=~C;c[E>>2]=D;if((D|0)==0){A=0}else{L=E;break}i=g;return A|0}}else{L=v+176|0}}while(0);G=v+24|0;a[G]=J&255;a[v+25|0]=I&255;J=h|0;h=0;do{D=a[p+h|0]|0;C=D&255;if(D<<24>>24!=0){if((c[k+(C<<2)>>2]|0)==0){au(J|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=2274,c[q+16>>2]=136,q)|0)|0;i=q;al(J|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q}D=l+(C<<2)|0;C=c[D>>2]|0;c[D>>2]=C+1;if(C>>>0>=H>>>0){au(J|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=2278,c[q+16>>2]=104,q)|0)|0;i=q;al(J|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q}b[(c[L>>2]|0)+(C<<1)>>1]=h&65535}h=h+1|0;}while(h>>>0<w>>>0);w=a[G]|0;h=(w&255)>>>0<z>>>0?z:0;z=v+8|0;c[z>>2]=h;H=(h|0)!=0;if(H){l=1<<h;C=v+164|0;do{if(l>>>0>(c[C>>2]|0)>>>0){c[C>>2]=l;D=v+168|0;F=c[D>>2]|0;do{if((F|0)!=0){B=c[F-4>>2]|0;f=F-8|0;if((B|0)==0){K=169}else{if((B|0)!=(~c[f>>2]|0)){K=169}}if((K|0)==169){au(J|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=645,c[q+16>>2]=280,q)|0)|0;i=q;al(J|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q;if((f|0)==0){break}}if((f&7|0)!=0){au(J|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=2500,c[q+16>>2]=576,q)|0)|0;i=q;al(J|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q;break}if((f|0)==0){be(0)|0;break}else{bf(f);break}}}while(0);F=l<<2;E=a_(F+8|0)|0;if((E|0)==0){c[D>>2]=0;A=0;i=g;return A|0}else{f=E+8|0;B=f;c[E+4>>2]=l;c[E>>2]=~l;c[D>>2]=B;if((f|0)==0){A=0}else{M=B;N=F;break}i=g;return A|0}}else{M=c[v+168>>2]|0;N=l<<2}}while(0);K=v+168|0;bj(M|0,-1|0,N|0);N=1;do{do{if((c[k+(N<<2)>>2]|0)!=0){M=h-N|0;C=1<<M;F=N-1|0;B=c[j+(F<<2)>>2]|0;if(!((N|0)!=0&N>>>0<17)){au(J|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=1954,c[q+16>>2]=200,q)|0)|0;i=q;al(J|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q}f=c[v+28+(F<<2)>>2]|0;if((f|0)==0){O=-1}else{O=(f-1|0)>>>((16-N|0)>>>0)}if(B>>>0>O>>>0){break}f=(c[v+96+(F<<2)>>2]|0)-B|0;F=N<<16;E=B;do{B=e[(c[L>>2]|0)+(f+E<<1)>>1]|0;if((d[p+B|0]|0|0)!=(N|0)){au(J|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=2320,c[q+16>>2]=64,q)|0)|0;i=q;al(J|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q}x=E<<M;y=B|F;B=0;do{n=B+x|0;if(n>>>0>=l>>>0){au(J|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=2326,c[q+16>>2]=40,q)|0)|0;i=q;al(J|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q}m=c[K>>2]|0;if((c[m+(n<<2)>>2]|0)==-1){P=m}else{au(J|0,768,(q=i,i=i+24|0,c[q>>2]=472,c[q+8>>2]=2328,c[q+16>>2]=8,q)|0)|0;i=q;al(J|0,(q=i,i=i+1|0,i=i+7&-8,c[q>>2]=0,q)|0)|0;i=q;P=c[K>>2]|0}c[P+(n<<2)>>2]=y;B=B+1|0;}while(B>>>0<C>>>0);E=E+1|0;}while(E>>>0<=O>>>0)}}while(0);N=N+1|0;}while(N>>>0<=h>>>0);Q=a[G]|0}else{Q=w}w=v+96|0;c[w>>2]=(c[w>>2]|0)-(c[j>>2]|0);w=v+100|0;c[w>>2]=(c[w>>2]|0)-(c[j+4>>2]|0);w=v+104|0;c[w>>2]=(c[w>>2]|0)-(c[j+8>>2]|0);w=v+108|0;c[w>>2]=(c[w>>2]|0)-(c[j+12>>2]|0);w=v+112|0;c[w>>2]=(c[w>>2]|0)-(c[j+16>>2]|0);w=v+116|0;c[w>>2]=(c[w>>2]|0)-(c[j+20>>2]|0);w=v+120|0;c[w>>2]=(c[w>>2]|0)-(c[j+24>>2]|0);w=v+124|0;c[w>>2]=(c[w>>2]|0)-(c[j+28>>2]|0);w=v+128|0;c[w>>2]=(c[w>>2]|0)-(c[j+32>>2]|0);w=v+132|0;c[w>>2]=(c[w>>2]|0)-(c[j+36>>2]|0);w=v+136|0;c[w>>2]=(c[w>>2]|0)-(c[j+40>>2]|0);w=v+140|0;c[w>>2]=(c[w>>2]|0)-(c[j+44>>2]|0);w=v+144|0;c[w>>2]=(c[w>>2]|0)-(c[j+48>>2]|0);w=v+148|0;c[w>>2]=(c[w>>2]|0)-(c[j+52>>2]|0);w=v+152|0;c[w>>2]=(c[w>>2]|0)-(c[j+56>>2]|0);w=v+156|0;c[w>>2]=(c[w>>2]|0)-(c[j+60>>2]|0);j=v+16|0;c[j>>2]=0;w=v+20|0;c[w>>2]=Q&255;L279:do{if(H){Q=h;while(1){if((Q|0)==0){break L279}R=Q-1|0;if((c[k+(Q<<2)>>2]|0)==0){Q=R}else{break}}c[j>>2]=c[v+28+(R<<2)>>2];Q=h+1|0;c[w>>2]=Q;G=Q;while(1){if(G>>>0>I>>>0){break L279}if((c[k+(G<<2)>>2]|0)==0){G=G+1|0}else{break}}c[w>>2]=G}}while(0);c[v+92>>2]=-1;c[v+160>>2]=1048575;c[v+12>>2]=32-(c[z>>2]|0);A=1;i=g;return A|0}function a4(b,e){b=b|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ab=0,ac=0,ad=0,ae=0,af=0,ag=0,ah=0,ai=0,aj=0;f=i;i=i+4120|0;g=f+512|0;h=f+1024|0;j=f+1536|0;k=f+2048|0;l=f+2560|0;m=f+3072|0;n=f+3584|0;o=f+4096|0;p=b+20|0;q=c[p>>2]|0;if((q|0)<14){r=b+4|0;s=b+8|0;t=b+16|0;u=f|0;v=q;while(1){w=c[r>>2]|0;if((w|0)==(c[s>>2]|0)){x=0}else{c[r>>2]=w+1;x=d[w]|0}w=v+8|0;c[p>>2]=w;if((w|0)<33){y=w}else{au(u|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=3200,c[z+16>>2]=432,z)|0)|0;i=z;al(u|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z;y=c[p>>2]|0}w=x<<32-y|c[t>>2];c[t>>2]=w;if((y|0)<14){v=y}else{A=y;B=w;break}}}else{A=q;B=c[b+16>>2]|0}q=b+16|0;y=B>>>18;c[q>>2]=B<<14;c[p>>2]=A-14;if((y|0)==0){c[e>>2]=0;A=e+4|0;B=c[A>>2]|0;if((B|0)!=0){if((B&7|0)==0){bf(B)}else{B=n|0;au(B|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=2500,c[z+16>>2]=576,z)|0)|0;i=z;al(B|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z}c[A>>2]=0;c[e+8>>2]=0;c[e+12>>2]=0}a[e+16|0]=0;A=e+20|0;B=c[A>>2]|0;if((B|0)==0){C=1;i=f;return C|0}a2(B);c[A>>2]=0;C=1;i=f;return C|0}A=e+4|0;B=e+8|0;v=c[B>>2]|0;if((v|0)!=(y|0)){if(v>>>0<=y>>>0){do{if((c[e+12>>2]|0)>>>0<y>>>0){if(aZ(A,y,(v+1|0)==(y|0),1)|0){D=c[B>>2]|0;break}a[e+16|0]=1;C=0;i=f;return C|0}else{D=v}}while(0);bj((c[A>>2]|0)+D|0,0,y-D|0)}c[B>>2]=y}D=A|0;bj(c[D>>2]|0,0,y|0);A=c[p>>2]|0;if((A|0)<5){v=b+4|0;t=b+8|0;x=m|0;m=A;while(1){u=c[v>>2]|0;if((u|0)==(c[t>>2]|0)){E=0}else{c[v>>2]=u+1;E=d[u]|0}u=m+8|0;c[p>>2]=u;if((u|0)<33){F=u}else{au(x|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=3200,c[z+16>>2]=432,z)|0)|0;i=z;al(x|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z;F=c[p>>2]|0}u=E<<32-F|c[q>>2];c[q>>2]=u;if((F|0)<5){m=F}else{G=F;H=u;break}}}else{G=A;H=c[q>>2]|0}A=H>>>27;c[q>>2]=H<<5;c[p>>2]=G-5;if((A|0)==0|H>>>0>2952790015){C=0;i=f;return C|0}c[o+20>>2]=0;bj(o|0,0,17);H=o+4|0;G=o+8|0;L345:do{if(aZ(H,21,0,1)|0){F=c[G>>2]|0;m=c[H>>2]|0;bj(m+F|0,0,21-F|0);c[G>>2]=21;F=b+4|0;E=b+8|0;x=l|0;v=0;do{t=c[p>>2]|0;if((t|0)<3){u=t;while(1){r=c[F>>2]|0;if((r|0)==(c[E>>2]|0)){I=0}else{c[F>>2]=r+1;I=d[r]|0}r=u+8|0;c[p>>2]=r;if((r|0)<33){J=r}else{au(x|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=3200,c[z+16>>2]=432,z)|0)|0;i=z;al(x|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z;J=c[p>>2]|0}r=I<<32-J|c[q>>2];c[q>>2]=r;if((J|0)<3){u=J}else{K=J;L=r;break}}}else{K=t;L=c[q>>2]|0}c[q>>2]=L<<3;c[p>>2]=K-3;a[m+(d[808+v|0]|0)|0]=L>>>29&255;v=v+1|0;}while(v>>>0<A>>>0);if(!(a3(o)|0)){M=0;break}v=n|0;m=h|0;x=g|0;u=k|0;r=j|0;s=0;L362:while(1){w=y-s|0;N=a5(b,o)|0;do{if(N>>>0<17){if((c[B>>2]|0)>>>0<=s>>>0){au(v|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=904,c[z+16>>2]=312,z)|0)|0;i=z;al(v|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z}a[(c[D>>2]|0)+s|0]=N&255;O=s+1|0}else{if((N|0)==18){P=c[p>>2]|0;if((P|0)<7){Q=P;while(1){R=c[F>>2]|0;if((R|0)==(c[E>>2]|0)){S=0}else{c[F>>2]=R+1;S=d[R]|0}R=Q+8|0;c[p>>2]=R;if((R|0)<33){T=R}else{au(r|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=3200,c[z+16>>2]=432,z)|0)|0;i=z;al(r|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z;T=c[p>>2]|0}R=S<<32-T|c[q>>2];c[q>>2]=R;if((T|0)<7){Q=T}else{U=T;V=R;break}}}else{U=P;V=c[q>>2]|0}c[q>>2]=V<<7;c[p>>2]=U-7;Q=(V>>>25)+11|0;if(Q>>>0>w>>>0){M=0;break L345}O=Q+s|0;break}else if((N|0)==17){Q=c[p>>2]|0;if((Q|0)<3){R=Q;while(1){W=c[F>>2]|0;if((W|0)==(c[E>>2]|0)){X=0}else{c[F>>2]=W+1;X=d[W]|0}W=R+8|0;c[p>>2]=W;if((W|0)<33){Y=W}else{au(u|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=3200,c[z+16>>2]=432,z)|0)|0;i=z;al(u|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z;Y=c[p>>2]|0}W=X<<32-Y|c[q>>2];c[q>>2]=W;if((Y|0)<3){R=Y}else{Z=Y;_=W;break}}}else{Z=Q;_=c[q>>2]|0}c[q>>2]=_<<3;c[p>>2]=Z-3;R=(_>>>29)+3|0;if(R>>>0>w>>>0){M=0;break L345}O=R+s|0;break}else{if((N-19|0)>>>0>=2){$=306;break L362}R=c[p>>2]|0;if((N|0)==19){if((R|0)<2){P=R;while(1){W=c[F>>2]|0;if((W|0)==(c[E>>2]|0)){aa=0}else{c[F>>2]=W+1;aa=d[W]|0}W=P+8|0;c[p>>2]=W;if((W|0)<33){ab=W}else{au(m|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=3200,c[z+16>>2]=432,z)|0)|0;i=z;al(m|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z;ab=c[p>>2]|0}W=aa<<32-ab|c[q>>2];c[q>>2]=W;if((ab|0)<2){P=ab}else{ac=ab;ad=W;break}}}else{ac=R;ad=c[q>>2]|0}c[q>>2]=ad<<2;c[p>>2]=ac-2;ae=(ad>>>30)+3|0}else{if((R|0)<6){P=R;while(1){Q=c[F>>2]|0;if((Q|0)==(c[E>>2]|0)){af=0}else{c[F>>2]=Q+1;af=d[Q]|0}Q=P+8|0;c[p>>2]=Q;if((Q|0)<33){ag=Q}else{au(x|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=3200,c[z+16>>2]=432,z)|0)|0;i=z;al(x|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z;ag=c[p>>2]|0}Q=af<<32-ag|c[q>>2];c[q>>2]=Q;if((ag|0)<6){P=ag}else{ah=ag;ai=Q;break}}}else{ah=R;ai=c[q>>2]|0}c[q>>2]=ai<<6;c[p>>2]=ah-6;ae=(ai>>>26)+7|0}if((s|0)==0|ae>>>0>w>>>0){M=0;break L345}P=s-1|0;if((c[B>>2]|0)>>>0<=P>>>0){au(v|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=904,c[z+16>>2]=312,z)|0)|0;i=z;al(v|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z}Q=a[(c[D>>2]|0)+P|0]|0;if(Q<<24>>24==0){M=0;break L345}P=ae+s|0;if(s>>>0<P>>>0){aj=s}else{O=s;break}while(1){if((c[B>>2]|0)>>>0<=aj>>>0){au(v|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=904,c[z+16>>2]=312,z)|0)|0;i=z;al(v|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z}W=aj+1|0;a[(c[D>>2]|0)+aj|0]=Q;if(W>>>0<P>>>0){aj=W}else{O=P;break}}}}}while(0);if(O>>>0<y>>>0){s=O}else{break}}if(($|0)==306){au(v|0,768,(z=i,i=i+24|0,c[z>>2]=472,c[z+8>>2]=3141,c[z+16>>2]=464,z)|0)|0;i=z;al(v|0,(z=i,i=i+1|0,i=i+7&-8,c[z>>2]=0,z)|0)|0;i=z;M=0;break}if((O|0)!=(y|0)){M=0;break}M=a3(e)|0}else{a[o+16|0]=1;M=0}}while(0);a1(o);C=M;i=f;return C|0}function a5(a,b){a=a|0;b=b|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;f=i;i=i+512|0;g=f|0;h=c[b+20>>2]|0;j=a+20|0;k=c[j>>2]|0;do{if((k|0)<24){l=a+4|0;m=c[l>>2]|0;n=c[a+8>>2]|0;o=m>>>0<n>>>0;if((k|0)>=16){if(o){c[l>>2]=m+1;p=d[m]|0}else{p=0}c[j>>2]=k+8;q=a+16|0;r=p<<24-k|c[q>>2];c[q>>2]=r;s=r;break}if(o){t=(d[m]|0)<<8;u=m+1|0}else{t=0;u=m}if(u>>>0<n>>>0){v=d[u]|0;w=u+1|0}else{v=0;w=u}c[l>>2]=w;c[j>>2]=k+16;l=a+16|0;n=(v|t)<<16-k|c[l>>2];c[l>>2]=n;s=n}else{s=c[a+16>>2]|0}}while(0);k=a+16|0;a=(s>>>16)+1|0;do{if(a>>>0>(c[h+16>>2]|0)>>>0){t=c[h+20>>2]|0;while(1){x=t-1|0;if(a>>>0>(c[h+28+(x<<2)>>2]|0)>>>0){t=t+1|0}else{break}}v=(c[h+96+(x<<2)>>2]|0)+(s>>>((32-t|0)>>>0))|0;if(v>>>0<(c[b>>2]|0)>>>0){y=t;z=e[(c[h+176>>2]|0)+(v<<1)>>1]|0;break}v=g|0;au(v|0,768,(A=i,i=i+24|0,c[A>>2]=472,c[A+8>>2]=3267,c[A+16>>2]=464,A)|0)|0;i=A;al(v|0,(A=i,i=i+1|0,i=i+7&-8,c[A>>2]=0,A)|0)|0;i=A;B=0;i=f;return B|0}else{v=c[(c[h+168>>2]|0)+(s>>>((32-(c[h+8>>2]|0)|0)>>>0)<<2)>>2]|0;if((v|0)==-1){w=g|0;au(w|0,768,(A=i,i=i+24|0,c[A>>2]=472,c[A+8>>2]=3245,c[A+16>>2]=408,A)|0)|0;i=A;al(w|0,(A=i,i=i+1|0,i=i+7&-8,c[A>>2]=0,A)|0)|0;i=A}w=v&65535;u=v>>>16;if((c[b+8>>2]|0)>>>0<=w>>>0){v=g|0;au(v|0,768,(A=i,i=i+24|0,c[A>>2]=472,c[A+8>>2]=903,c[A+16>>2]=312,A)|0)|0;i=A;al(v|0,(A=i,i=i+1|0,i=i+7&-8,c[A>>2]=0,A)|0)|0;i=A}if((d[(c[b+4>>2]|0)+w|0]|0|0)==(u|0)){y=u;z=w;break}v=g|0;au(v|0,768,(A=i,i=i+24|0,c[A>>2]=472,c[A+8>>2]=3249,c[A+16>>2]=376,A)|0)|0;i=A;al(v|0,(A=i,i=i+1|0,i=i+7&-8,c[A>>2]=0,A)|0)|0;i=A;y=u;z=w}}while(0);c[k>>2]=c[k>>2]<<y;c[j>>2]=(c[j>>2]|0)-y;B=z;i=f;return B|0}function a6(a,b){a=a|0;b=b|0;var d=0,e=0;d=i;i=i+40|0;e=d|0;c[e>>2]=40;a0(a,b,e);i=d;return c[e+4>>2]|0}function a7(a,b){a=a|0;b=b|0;var d=0,e=0;d=i;i=i+40|0;e=d|0;c[e>>2]=40;a0(a,b,e);i=d;return c[e+8>>2]|0}function a8(a,b){a=a|0;b=b|0;var d=0,e=0;d=i;i=i+40|0;e=d|0;c[e>>2]=40;a0(a,b,e);i=d;return c[e+12>>2]|0}function a9(a,b){a=a|0;b=b|0;var d=0,e=0;d=i;i=i+40|0;e=d|0;c[e>>2]=40;a0(a,b,e);i=d;return c[e+32>>2]|0}function ba(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0;d=i;i=i+552|0;e=d|0;f=d+512|0;c[f>>2]=40;a0(a,b,f);b=f+32|0;f=c[b>>2]|0;a=c[b+4>>2]|0;b=9;g=0;h=0;j=0;if((f|0)==1&(a|0)==0|(f|0)==2&(a|0)==0|(f|0)==7&(a|0)==0|(f|0)==8&(a|0)==0|(f|0)==3&(a|0)==0|(f|0)==4&(a|0)==0|(f|0)==5&(a|0)==0|(f|0)==6&(a|0)==0){k=16;i=d;return k|0}else if((f|0)==(h|0)&(a|0)==(j|0)|(f|0)==(b|0)&(a|0)==(g|0)){k=8;i=d;return k|0}else{g=e|0;au(g|0,768,(e=i,i=i+24|0,c[e>>2]=472,c[e+8>>2]=2664,c[e+16>>2]=568,e)|0)|0;i=e;al(g|0,(e=i,i=i+1|0,i=i+7&-8,c[e>>2]=0,e)|0)|0;i=e;k=0;i=d;return k|0}return 0}function bb(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;e=i;i=i+552|0;f=e|0;g=e+512|0;c[g>>2]=40;a0(a,b,g);b=(((c[g+4>>2]|0)>>>(d>>>0))+3|0)>>>2;a=(((c[g+8>>2]|0)>>>(d>>>0))+3|0)>>>2;d=g+32|0;g=c[d>>2]|0;h=c[d+4>>2]|0;d=9;j=0;k=0;l=0;if((g|0)==1&(h|0)==0|(g|0)==2&(h|0)==0|(g|0)==7&(h|0)==0|(g|0)==8&(h|0)==0|(g|0)==3&(h|0)==0|(g|0)==4&(h|0)==0|(g|0)==5&(h|0)==0|(g|0)==6&(h|0)==0){m=16;n=Z(a,b)|0;o=Z(n,m)|0;i=e;return o|0}else if((g|0)==(k|0)&(h|0)==(l|0)|(g|0)==(d|0)&(h|0)==(j|0)){m=8;n=Z(a,b)|0;o=Z(n,m)|0;i=e;return o|0}else{j=f|0;au(j|0,768,(f=i,i=i+24|0,c[f>>2]=472,c[f+8>>2]=2664,c[f+16>>2]=568,f)|0)|0;i=f;al(j|0,(f=i,i=i+1|0,i=i+7&-8,c[f>>2]=0,f)|0)|0;i=f;m=0;n=Z(a,b)|0;o=Z(n,m)|0;i=e;return o|0}return 0}function bc(f,g,h,j,k,l){f=f|0;g=g|0;h=h|0;j=j|0;k=k|0;l=l|0;var m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,_=0,$=0,aa=0,ab=0,ac=0,ad=0,ae=0,af=0,ag=0,ah=0,ai=0,aj=0,ak=0,am=0,an=0,ao=0,ap=0,aq=0,ar=0,as=0,at=0,av=0,aw=0,ax=0,ay=0,az=0,aA=0,aB=0,aC=0,aD=0,aE=0,aF=0,aG=0,aH=0,aI=0,aJ=0,aK=0,aL=0,aM=0,aN=0,aO=0,aP=0,aQ=0,aR=0,aS=0,aT=0,aU=0,aV=0,aW=0,aX=0,aY=0,a$=0,a2=0,a3=0,a6=0,a7=0,a8=0,a9=0,ba=0,bb=0,bc=0,be=0,bg=0,bh=0,bi=0,bk=0,bl=0,bm=0,bn=0,bo=0,bp=0,bq=0,br=0,bs=0,bt=0,bu=0,bv=0,bw=0,bx=0,by=0,bz=0,bA=0,bB=0,bC=0,bD=0,bE=0,bF=0,bG=0,bH=0,bI=0,bJ=0,bK=0,bL=0,bM=0,bN=0,bO=0,bP=0,bQ=0,bR=0,bS=0,bT=0,bU=0,bV=0,bW=0,bX=0,bY=0,bZ=0,b_=0,b$=0,b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0,b7=0,b8=0,b9=0,ca=0,cb=0,cc=0,cd=0,ce=0,cf=0,cg=0,ch=0,ci=0,cj=0,ck=0,cl=0,cm=0,cn=0,co=0,cp=0,cq=0,cr=0,cs=0;j=i;i=i+4008|0;m=j|0;n=j+16|0;o=j+32|0;p=j+56|0;q=j+960|0;r=j+1864|0;s=j+1888|0;t=j+1912|0;u=j+2112|0;v=j+2312|0;w=j+2376|0;x=j+2888|0;y=j+2936|0;z=j+3448|0;A=j+3960|0;B=j+4e3|0;c[A>>2]=40;a0(f,g,A);C=(c[A+4>>2]|0)>>>(k>>>0);D=(c[A+8>>2]|0)>>>(k>>>0);E=A+32|0;A=c[E>>2]|0;F=c[E+4>>2]|0;E=9;G=0;H=0;I=0;if((A|0)==1&(F|0)==0|(A|0)==2&(F|0)==0|(A|0)==7&(F|0)==0|(A|0)==8&(F|0)==0|(A|0)==3&(F|0)==0|(A|0)==4&(F|0)==0|(A|0)==5&(F|0)==0|(A|0)==6&(F|0)==0){J=16}else if((A|0)==(H|0)&(F|0)==(I|0)|(A|0)==(E|0)&(F|0)==(G|0)){J=8}else{G=z|0;au(G|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=2664,c[K+16>>2]=568,K)|0)|0;i=K;al(G|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K;J=0}G=B|0;c[G>>2]=h;L502:do{if((f|0)==0|g>>>0<62){L=0}else{F=a_(300)|0;if((F|0)==0){L=0;break}E=F;c[F>>2]=519686845;A=F+4|0;c[A>>2]=0;I=F+8|0;c[I>>2]=0;H=F+88|0;bj(H|0,0,45);M=F+252|0;bj(M|0,0,13);N=F+268|0;bj(N|0,0,13);O=F+284|0;bj(O|0,0,13);bj(F+136|0,0,21);bj(F+160|0,0,21);bj(F+184|0,0,21);bj(F+208|0,0,21);bj(F+232|0,0,17);L505:do{if(g>>>0<74){P=369}else{if(((d[f]|0)<<8|(d[f+1|0]|0)|0)!=18552){P=369;break}if(((d[f+2|0]|0)<<8|(d[f+3|0]|0))>>>0<74){P=369;break}Q=((d[f+7|0]|0)<<16|(d[f+6|0]|0)<<24|(d[f+8|0]|0)<<8|(d[f+9|0]|0))>>>0>g>>>0?0:f;R=H;c[R>>2]=Q;if((Q|0)==0){break}c[A>>2]=f;c[I>>2]=g;S=F+92|0;T=S;U=(d[Q+68|0]|0)<<8|(d[Q+67|0]|0)<<16|(d[Q+69|0]|0);V=f+U|0;W=(d[Q+65|0]|0)<<8|(d[Q+66|0]|0);if((W|0)==0){break}Q=S;c[Q>>2]=V;S=F+96|0;c[S>>2]=V;V=F+104|0;c[V>>2]=W;X=F+100|0;c[X>>2]=f+(W+U);U=F+108|0;c[U>>2]=0;W=F+112|0;c[W>>2]=0;if(!(a4(T,F+116|0)|0)){break}Y=c[R>>2]|0;if(((d[Y+39|0]|0)<<8|(d[Y+40|0]|0)|0)==0){_=a[Y+55|0]|0;$=a[Y+56|0]|0;if(((_&255)<<8|$&255|0)==0){break}else{aa=_;ab=$;ac=Y}}else{if(!(a4(T,F+140|0)|0)){break}if(!(a4(T,F+188|0)|0)){break}Y=c[R>>2]|0;aa=a[Y+55|0]|0;ab=a[Y+56|0]|0;ac=Y}if(((aa&255)<<8|ab&255|0)==0){ad=ac}else{if(!(a4(T,F+164|0)|0)){break}if(!(a4(T,F+212|0)|0)){break}ad=c[R>>2]|0}Y=(d[ad+39|0]|0)<<8|(d[ad+40|0]|0);if((Y|0)==0){ae=ad}else{$=x;_=F+236|0;af=F+240|0;ag=c[af>>2]|0;if((ag|0)==(Y|0)){ah=ad}else{if(ag>>>0>Y>>>0){ai=ad}else{do{if((c[F+244>>2]|0)>>>0<Y>>>0){if(aZ(_,Y,(ag+1|0)==(Y|0),4)|0){aj=c[af>>2]|0;break}else{a[F+248|0]=1;break L505}}else{aj=ag}}while(0);bj((c[_>>2]|0)+(aj<<2)|0,0,Y-aj<<2|0);ai=c[R>>2]|0}c[af>>2]=Y;ah=ai}ag=c[A>>2]|0;ak=(d[ah+34|0]|0)<<8|(d[ah+33|0]|0)<<16|(d[ah+35|0]|0);am=ag+ak|0;an=(d[ah+37|0]|0)<<8|(d[ah+36|0]|0)<<16|(d[ah+38|0]|0);if((an|0)==0){break}c[Q>>2]=am;c[S>>2]=am;c[V>>2]=an;c[X>>2]=ag+(an+ak);c[U>>2]=0;c[W>>2]=0;ak=x|0;bj($|0,0,17);an=x+24|0;c[x+44>>2]=0;bj(x+20|0,0,21);ag=0;while(1){if(ag>>>0>=2){P=397;break}if(a4(T,x+(ag*24|0)|0)|0){ag=ag+1|0}else{ao=0;break}}if((P|0)==397){if((c[af>>2]|0)==0){ag=w|0;au(ag|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(ag|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}ag=0;$=0;am=0;ap=0;aq=0;ar=c[_>>2]|0;as=0;at=0;while(1){av=(a5(T,ak)|0)+at&31;aw=(a5(T,an)|0)+ag&63;ax=(a5(T,ak)|0)+$&31;ay=(a5(T,ak)|0)+am|0;az=(a5(T,an)|0)+ap&63;aA=(a5(T,ak)|0)+aq&31;c[ar>>2]=aw<<5|av<<11|ax|ay<<27|az<<21|aA<<16;aB=as+1|0;if(aB>>>0<Y>>>0){ag=aw;$=ax;am=ay&31;ap=az;aq=aA;ar=ar+4|0;as=aB;at=av}else{ao=1;break}}}a1(an);a1(ak);if(!ao){break}at=v;as=c[R>>2]|0;ar=(d[as+47|0]|0)<<8|(d[as+48|0]|0);aq=c[A>>2]|0;ap=(d[as+42|0]|0)<<8|(d[as+41|0]|0)<<16|(d[as+43|0]|0);am=aq+ap|0;$=(d[as+45|0]|0)<<8|(d[as+44|0]|0)<<16|(d[as+46|0]|0);if(($|0)==0){break}c[Q>>2]=am;c[S>>2]=am;c[V>>2]=$;c[X>>2]=aq+($+ap);c[U>>2]=0;c[W>>2]=0;c[s+20>>2]=0;bj(s|0,0,17);if(a4(T,s)|0){aC=-3;aD=-3;aE=0}else{a1(s);break}while(1){c[t+(aE<<2)>>2]=aC;c[u+(aE<<2)>>2]=aD;ap=aC+1|0;$=(ap|0)>3;aq=aE+1|0;if(aq>>>0<49){aC=$?-3:ap;aD=($&1)+aD|0;aE=aq}else{break}}bj(at|0,0,64);ak=F+256|0;an=c[ak>>2]|0;if((an|0)!=(ar|0)){if(an>>>0<=ar>>>0){do{if((c[F+260>>2]|0)>>>0<ar>>>0){if(aZ(M,ar,(an+1|0)==(ar|0),4)|0){aF=c[ak>>2]|0;break}else{a[F+264|0]=1;a1(s);break L505}}else{aF=an}}while(0);bj((c[M>>2]|0)+(aF<<2)|0,0,ar-aF<<2|0)}c[ak>>2]=ar}if((ar|0)==0){an=w|0;au(an|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(an|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}else{an=v|0;at=v+4|0;aq=v+8|0;$=v+12|0;ap=v+16|0;am=v+20|0;as=v+24|0;ag=v+28|0;Y=v+32|0;_=v+36|0;af=v+40|0;av=v+44|0;aB=v+48|0;aA=v+52|0;az=v+56|0;ay=v+60|0;ax=c[M>>2]|0;aw=0;while(1){aG=0;do{aH=a5(T,s)|0;aI=aG<<1;aJ=v+(aI<<2)|0;c[aJ>>2]=(c[aJ>>2]|0)+(c[t+(aH<<2)>>2]|0)&3;aJ=v+((aI|1)<<2)|0;c[aJ>>2]=(c[aJ>>2]|0)+(c[u+(aH<<2)>>2]|0)&3;aG=aG+1|0;}while(aG>>>0<8);c[ax>>2]=(d[880+(c[at>>2]|0)|0]|0)<<2|(d[880+(c[an>>2]|0)|0]|0)|(d[880+(c[aq>>2]|0)|0]|0)<<4|(d[880+(c[$>>2]|0)|0]|0)<<6|(d[880+(c[ap>>2]|0)|0]|0)<<8|(d[880+(c[am>>2]|0)|0]|0)<<10|(d[880+(c[as>>2]|0)|0]|0)<<12|(d[880+(c[ag>>2]|0)|0]|0)<<14|(d[880+(c[Y>>2]|0)|0]|0)<<16|(d[880+(c[_>>2]|0)|0]|0)<<18|(d[880+(c[af>>2]|0)|0]|0)<<20|(d[880+(c[av>>2]|0)|0]|0)<<22|(d[880+(c[aB>>2]|0)|0]|0)<<24|(d[880+(c[aA>>2]|0)|0]|0)<<26|(d[880+(c[az>>2]|0)|0]|0)<<28|(d[880+(c[ay>>2]|0)|0]|0)<<30;aG=aw+1|0;if(aG>>>0<ar>>>0){ax=ax+4|0;aw=aG}else{break}}}a1(s);ae=c[R>>2]|0}aw=(d[ae+55|0]|0)<<8|(d[ae+56|0]|0);if((aw|0)==0){L=F;break L502}ax=c[A>>2]|0;ar=(d[ae+50|0]|0)<<8|(d[ae+49|0]|0)<<16|(d[ae+51|0]|0);ay=ax+ar|0;az=(d[ae+53|0]|0)<<8|(d[ae+52|0]|0)<<16|(d[ae+54|0]|0);if((az|0)==0){break}c[Q>>2]=ay;c[S>>2]=ay;c[V>>2]=az;c[X>>2]=ax+(az+ar);c[U>>2]=0;c[W>>2]=0;c[r+20>>2]=0;bj(r|0,0,17);L585:do{if(a4(T,r)|0){ar=F+272|0;az=c[ar>>2]|0;if((az|0)!=(aw|0)){if(az>>>0<=aw>>>0){do{if((c[F+276>>2]|0)>>>0<aw>>>0){if(aZ(N,aw,(az+1|0)==(aw|0),2)|0){aK=c[ar>>2]|0;break}else{a[F+280|0]=1;break L585}}else{aK=az}}while(0);bj((c[N>>2]|0)+(aK<<1)|0,0,aw-aK<<1|0)}c[ar>>2]=aw}az=c[N>>2]|0;ax=0;ay=0;aA=0;while(1){aB=a5(T,r)|0;av=aB+ax&255;aB=(a5(T,r)|0)+ay&255;b[az>>1]=(aB<<8|av)&65535;af=aA+1|0;if(af>>>0<aw>>>0){az=az+2|0;ax=av;ay=aB;aA=af}else{break}}a1(r);aA=v;ay=c[R>>2]|0;ax=(d[ay+63|0]|0)<<8|(d[ay+64|0]|0);az=c[A>>2]|0;ar=(d[ay+58|0]|0)<<8|(d[ay+57|0]|0)<<16|(d[ay+59|0]|0);af=az+ar|0;aB=(d[ay+61|0]|0)<<8|(d[ay+60|0]|0)<<16|(d[ay+62|0]|0);if((aB|0)==0){aL=0}else{c[Q>>2]=af;c[S>>2]=af;c[V>>2]=aB;c[X>>2]=az+(aB+ar);c[U>>2]=0;c[W>>2]=0;c[o+20>>2]=0;bj(o|0,0,17);L605:do{if(a4(T,o)|0){ar=-7;aB=-7;az=0;while(1){c[p+(az<<2)>>2]=ar;c[q+(az<<2)>>2]=aB;af=ar+1|0;ay=(af|0)>7;av=az+1|0;if(av>>>0<225){ar=ay?-7:af;aB=(ay&1)+aB|0;az=av}else{break}}bj(aA|0,0,64);az=ax*3|0;aB=F+288|0;ar=c[aB>>2]|0;if((ar|0)!=(az|0)){if(ar>>>0<=az>>>0){do{if((c[F+292>>2]|0)>>>0<az>>>0){if(aZ(O,az,(ar+1|0)==(az|0),2)|0){aM=c[aB>>2]|0;break}else{a[F+296|0]=1;aN=0;break L605}}else{aM=ar}}while(0);bj((c[O>>2]|0)+(aM<<1)|0,0,az-aM<<1|0)}c[aB>>2]=az}if((az|0)==0){ar=w|0;au(ar|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(ar|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}if((ax|0)==0){aN=1;break}ar=v|0;av=v+4|0;ay=v+8|0;af=v+12|0;_=v+16|0;Y=v+20|0;ag=v+24|0;as=v+28|0;am=v+32|0;ap=v+36|0;$=v+40|0;aq=v+44|0;an=v+48|0;at=v+52|0;ak=v+56|0;aG=v+60|0;aH=c[O>>2]|0;aJ=0;while(1){aI=0;do{aO=a5(T,o)|0;aP=aI<<1;aQ=v+(aP<<2)|0;c[aQ>>2]=(c[aQ>>2]|0)+(c[p+(aO<<2)>>2]|0)&7;aQ=v+((aP|1)<<2)|0;c[aQ>>2]=(c[aQ>>2]|0)+(c[q+(aO<<2)>>2]|0)&7;aI=aI+1|0;}while(aI>>>0<8);b[aH>>1]=(d[872+(c[av>>2]|0)|0]|0)<<3|(d[872+(c[ar>>2]|0)|0]|0)|(d[872+(c[ay>>2]|0)|0]|0)<<6|(d[872+(c[af>>2]|0)|0]|0)<<9|(d[872+(c[_>>2]|0)|0]|0)<<12|(d[872+(c[Y>>2]|0)|0]|0)<<15;b[aH+2>>1]=(d[872+(c[ag>>2]|0)|0]|0)<<2|(a[872+(c[Y>>2]|0)|0]&255)>>>1|(d[872+(c[as>>2]|0)|0]|0)<<5|(d[872+(c[am>>2]|0)|0]|0)<<8|(d[872+(c[ap>>2]|0)|0]|0)<<11|(d[872+(c[$>>2]|0)|0]|0)<<14;b[aH+4>>1]=(d[872+(c[aq>>2]|0)|0]|0)<<1|(a[872+(c[$>>2]|0)|0]&255)>>>2|(d[872+(c[an>>2]|0)|0]|0)<<4|(d[872+(c[at>>2]|0)|0]|0)<<7|(d[872+(c[ak>>2]|0)|0]|0)<<10|(d[872+(c[aG>>2]|0)|0]|0)<<13;aI=aJ+1|0;if(aI>>>0<ax>>>0){aH=aH+6|0;aJ=aI}else{aN=1;break}}}else{aN=0}}while(0);a1(o);aL=aN}if(aL){L=aL?F:0;break L502}else{break L505}}}while(0);a1(r)}}while(0);if((P|0)==369){c[H>>2]=0}bd(E);if((F&7|0)==0){bf(F);L=0;break}else{O=y|0;au(O|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=2500,c[K+16>>2]=576,K)|0)|0;i=K;al(O|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K;L=0;break}}}while(0);r=l+k|0;do{if(r>>>0>k>>>0){l=L;if((L|0)==0){aL=k;aN=D;o=C;q=h;while(1){aR=q+(Z(Z((o+3|0)>>>2,J)|0,(aN+3|0)>>>2)|0)|0;v=aL+1|0;if(v>>>0<r>>>0){aL=v;aN=aN>>>1;o=o>>>1;q=aR}else{break}}c[G>>2]=aR;break}q=L+88|0;o=L+8|0;aN=L+4|0;aL=L+92|0;F=aL;E=L+96|0;H=L+104|0;v=L+100|0;p=L+108|0;aM=L+112|0;aK=L+240|0;ae=L+256|0;s=aL;aL=L+116|0;u=L+140|0;t=L+236|0;aF=w|0;aE=L+188|0;aD=L+252|0;aC=L+272|0;ao=L+212|0;x=L+288|0;ah=L+284|0;ai=L+164|0;aj=L+268|0;ad=y|0;ac=k;ab=D;aa=C;f=h;while(1){g=Z((aa+3|0)>>>2,J)|0;O=Z(g,(ab+3|0)>>>2)|0;do{if(O>>>0<8|ac>>>0>15){aS=f}else{if((c[l>>2]|0)!=519686845){aS=f;break}A=c[q>>2]|0;N=(d[A+70+(ac<<2)+1|0]|0)<<16|(d[A+70+(ac<<2)|0]|0)<<24|(d[A+70+(ac<<2)+2|0]|0)<<8|(d[A+70+(ac<<2)+3|0]|0);M=ac+1|0;if(M>>>0<(d[A+16|0]|0)>>>0){aT=(d[A+70+(M<<2)+1|0]|0)<<16|(d[A+70+(M<<2)|0]|0)<<24|(d[A+70+(M<<2)+2|0]|0)<<8|(d[A+70+(M<<2)+3|0]|0)}else{aT=c[o>>2]|0}if(aT>>>0>N>>>0){aU=A}else{au(ad|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=3705,c[K+16>>2]=248,K)|0)|0;i=K;al(ad|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K;aU=c[q>>2]|0}A=c[aN>>2]|0;M=A+N|0;I=aT-N|0;T=((d[aU+12|0]|0)<<8|(d[aU+13|0]|0))>>>(ac>>>0);W=((d[aU+14|0]|0)<<8|(d[aU+15|0]|0))>>>(ac>>>0);U=T>>>0>1?(T+3|0)>>>2:1;T=W>>>0>1?(W+3|0)>>>2:1;W=aU+18|0;X=a[W]|0;if(X<<24>>24==0){aV=8}else{aV=X<<24>>24==9?8:16}X=Z(aV,U)|0;if((g|0)==0){aW=X;P=494}else{if(X>>>0<=g>>>0){aW=g;P=494}}L663:do{if((P|0)==494){P=0;if((Z(aW,T)|0)>>>0>O>>>0){break}X=(U+1|0)>>>1;V=(T+1|0)>>>1;if((aT|0)==(N|0)){break}c[F>>2]=M;c[E>>2]=M;c[H>>2]=I;c[v>>2]=A+aT;c[p>>2]=0;c[aM>>2]=0;switch(d[W]|0|0){case 0:{S=c[aK>>2]|0;Q=c[ae>>2]|0;R=a[aU+17|0]|0;aw=R&255;ax=aW>>>2;if(R<<24>>24==0){break L663}R=(V|0)==0;aA=V-1|0;aJ=(T&1|0)!=0;aH=aW<<1;aG=ax+1|0;ak=ax+2|0;at=ax+3|0;an=X-1|0;$=an<<4;aq=(U&1|0)!=0;ap=aW+4|0;am=0;as=0;Y=0;ag=1;while(1){if(R){aX=am;aY=as;a$=ag}else{_=am;af=as;ay=0;ar=c[B+(Y<<2)>>2]|0;av=ag;while(1){if((ay&1|0)==0){a2=0;a3=X;a6=1;a7=16;a8=ar}else{a2=an;a3=-1;a6=-1;a7=-16;a8=ar+$|0}az=(ay|0)==(aA|0);aB=az&aJ;if((a2|0)==(a3|0)){a9=_;ba=af;bb=av}else{aI=az&aJ^1;az=_;aO=af;aQ=a2;aP=a8;bc=av;while(1){if((bc|0)==1){be=a5(s,aL)|0|512}else{be=bc}bg=be&7;bh=d[832+bg|0]|0;bi=az;bk=0;do{bl=(a5(s,u)|0)+bi|0;bm=bl-S|0;bn=bm>>31;bi=bn&bl|bm&~bn;if((c[aK>>2]|0)>>>0<=bi>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[n+(bk<<2)>>2]=c[(c[t>>2]|0)+(bi<<2)>>2];bk=bk+1|0;}while(bk>>>0<bh>>>0);bh=be>>>3;bk=(aQ|0)==(an|0)&aq;bn=aP;do{if(aB|bk){if(bk){bm=(a5(s,aE)|0)+aO|0;bl=bm-Q|0;bo=bl>>31;bp=bo&bm|bl&~bo;c[bn>>2]=c[n+((d[840+(bg<<2)|0]|0)<<2)>>2];if((c[ae>>2]|0)>>>0<=bp>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[aP+4>>2]=c[(c[aD>>2]|0)+(bp<<2)>>2];bo=(a5(s,aE)|0)+bp|0;bp=bo-Q|0;bl=bp>>31;bm=(a5(s,aE)|0)+(bl&bo|bp&~bl)|0;bl=bm-Q|0;bp=bl>>31;bo=bp&bm|bl&~bp;if(aB){bp=(a5(s,aE)|0)+bo|0;bl=bp-Q|0;bm=bl>>31;bq=bm&bp|bl&~bm;break}c[aP+aW>>2]=c[n+((d[842+(bg<<2)|0]|0)<<2)>>2];if((c[ae>>2]|0)>>>0<=bo>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[aP+ap>>2]=c[(c[aD>>2]|0)+(bo<<2)>>2];bm=(a5(s,aE)|0)+bo|0;bo=bm-Q|0;bl=bo>>31;bq=bl&bm|bo&~bl;break}else{br=aO;bs=0}while(1){bl=Z(bs,aW)|0;bo=bs<<1;bm=(a5(s,aE)|0)+br|0;bp=bm-Q|0;bt=bp>>31;bu=bt&bm|bp&~bt;if((bs|0)==0|aI){c[aP+bl>>2]=c[n+((d[840+(bg<<2)+bo|0]|0)<<2)>>2];if((c[ae>>2]|0)>>>0<=bu>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[aP+(bl+4)>>2]=c[(c[aD>>2]|0)+(bu<<2)>>2];bt=(a5(s,aE)|0)+bu|0;bp=bt-Q|0;bm=bp>>31;bv=bm&bt|bp&~bm;c[aP+(bl+8)>>2]=c[n+((d[(bo|1)+(840+(bg<<2))|0]|0)<<2)>>2];if((c[ae>>2]|0)>>>0<=bv>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[aP+(bl+12)>>2]=c[(c[aD>>2]|0)+(bv<<2)>>2];bw=bv}else{bv=(a5(s,aE)|0)+bu|0;bu=bv-Q|0;bl=bu>>31;bw=bl&bv|bu&~bl}bl=bs+1|0;if(bl>>>0<2){br=bw;bs=bl}else{bq=bw;break}}}else{c[bn>>2]=c[n+((d[840+(bg<<2)|0]|0)<<2)>>2];bl=(a5(s,aE)|0)+aO|0;bu=bl-Q|0;bv=bu>>31;bo=bv&bl|bu&~bv;if((c[ae>>2]|0)>>>0<=bo>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[aP+4>>2]=c[(c[aD>>2]|0)+(bo<<2)>>2];c[aP+8>>2]=c[n+((d[841+(bg<<2)|0]|0)<<2)>>2];bv=(a5(s,aE)|0)+bo|0;bo=bv-Q|0;bu=bo>>31;bl=bu&bv|bo&~bu;if((c[ae>>2]|0)>>>0<=bl>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[aP+12>>2]=c[(c[aD>>2]|0)+(bl<<2)>>2];c[bn+(ax<<2)>>2]=c[n+((d[842+(bg<<2)|0]|0)<<2)>>2];bu=(a5(s,aE)|0)+bl|0;bl=bu-Q|0;bo=bl>>31;bv=bo&bu|bl&~bo;if((c[ae>>2]|0)>>>0<=bv>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[bn+(aG<<2)>>2]=c[(c[aD>>2]|0)+(bv<<2)>>2];c[bn+(ak<<2)>>2]=c[n+((d[843+(bg<<2)|0]|0)<<2)>>2];bo=(a5(s,aE)|0)+bv|0;bv=bo-Q|0;bl=bv>>31;bu=bl&bo|bv&~bl;if((c[ae>>2]|0)>>>0<=bu>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[bn+(at<<2)>>2]=c[(c[aD>>2]|0)+(bu<<2)>>2];bq=bu}}while(0);bn=aQ+a6|0;if((bn|0)==(a3|0)){a9=bi;ba=bq;bb=bh;break}else{az=bi;aO=bq;aQ=bn;aP=aP+a7|0;bc=bh}}}bc=ay+1|0;if(bc>>>0<V>>>0){_=a9;af=ba;ay=bc;ar=ar+aH|0;av=bb}else{aX=a9;aY=ba;a$=bb;break}}}av=Y+1|0;if(av>>>0<aw>>>0){am=aX;as=aY;Y=av;ag=a$}else{break}}break};case 2:case 3:case 5:case 6:case 4:{ag=c[aK>>2]|0;Y=c[ae>>2]|0;as=c[aC>>2]|0;am=(d[aU+63|0]|0)<<8|(d[aU+64|0]|0);aw=a[aU+17|0]|0;aH=aw&255;if(aw<<24>>24==0){break L663}aw=(V|0)==0;at=V-1|0;Q=(T&1|0)==0;ak=aW<<1;aG=(U&1|0)==0;ax=X-1|0;ap=ax<<5;aq=0;an=0;S=0;aJ=0;aA=0;$=1;while(1){if(aw){bx=aq;by=an;bz=S;bA=aJ;bB=$}else{R=aq;av=an;ar=S;ay=aJ;af=0;_=c[B+(aA<<2)>>2]|0;bc=$;while(1){if((af&1|0)==0){bC=0;bD=X;bE=1;bF=32;bG=_}else{bC=ax;bD=-1;bE=-1;bF=-32;bG=_+ap|0}aP=Q|(af|0)!=(at|0);if((bC|0)==(bD|0)){bH=R;bI=av;bJ=ar;bK=ay;bL=bc}else{aQ=R;aO=av;az=ar;aI=ay;aB=bC;bn=bG;bg=bc;while(1){if((bg|0)==1){bM=a5(s,aL)|0|512}else{bM=bg}bk=bM&7;bu=d[832+bk|0]|0;bl=(aB|0)!=(ax|0);bv=az;bo=0;do{bm=(a5(s,ai)|0)+bv|0;bp=bm-as|0;bt=bp>>31;bv=bt&bm|bp&~bt;if((c[aC>>2]|0)>>>0<=bv>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[m+(bo<<2)>>2]=e[(c[aj>>2]|0)+(bv<<1)>>1]|0;bo=bo+1|0;}while(bo>>>0<bu>>>0);bo=bM>>>3;bh=aQ;bi=0;do{bt=(a5(s,u)|0)+bh|0;bp=bt-ag|0;bm=bp>>31;bh=bm&bt|bp&~bm;if((c[aK>>2]|0)>>>0<=bh>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[n+(bi<<2)>>2]=c[(c[t>>2]|0)+(bh<<2)>>2];bi=bi+1|0;}while(bi>>>0<bu>>>0);bu=aG|bl;bi=aO;bm=aI;bp=bn;bt=0;while(1){bN=(bt|0)==0|aP;bO=bt<<1;bP=bi;bQ=bm;bR=bp;bS=0;while(1){bT=(a5(s,ao)|0)+bQ|0;bU=bT-am|0;bV=bU>>31;bW=bV&bT|bU&~bV;bV=(a5(s,aE)|0)+bP|0;bU=bV-Y|0;bT=bU>>31;bX=bT&bV|bU&~bT;if(((bS|0)==0|bu)&bN){bT=d[bS+bO+(840+(bk<<2))|0]|0;bU=bW*3|0;if((c[x>>2]|0)>>>0<=bU>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}bV=c[ah>>2]|0;c[bR>>2]=(e[bV+(bU<<1)>>1]|0)<<16|c[m+(bT<<2)>>2];c[bR+4>>2]=(e[bV+(bU+2<<1)>>1]|0)<<16|(e[bV+(bU+1<<1)>>1]|0);c[bR+8>>2]=c[n+(bT<<2)>>2];if((c[ae>>2]|0)>>>0<=bX>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[bR+12>>2]=c[(c[aD>>2]|0)+(bX<<2)>>2]}bT=bS+1|0;if(bT>>>0<2){bP=bX;bQ=bW;bR=bR+16|0;bS=bT}else{break}}bS=bt+1|0;if(bS>>>0<2){bi=bX;bm=bW;bp=bp+aW|0;bt=bS}else{break}}bt=aB+bE|0;if((bt|0)==(bD|0)){bH=bh;bI=bX;bJ=bv;bK=bW;bL=bo;break}else{aQ=bh;aO=bX;az=bv;aI=bW;aB=bt;bn=bn+bF|0;bg=bo}}}bg=af+1|0;if(bg>>>0<V>>>0){R=bH;av=bI;ar=bJ;ay=bK;af=bg;_=_+ak|0;bc=bL}else{bx=bH;by=bI;bz=bJ;bA=bK;bB=bL;break}}}bc=aA+1|0;if(bc>>>0<aH>>>0){aq=bx;an=by;S=bz;aJ=bA;aA=bc;$=bB}else{break}}break};case 9:{$=c[aC>>2]|0;aA=(d[aU+63|0]|0)<<8|(d[aU+64|0]|0);aJ=a[aU+17|0]|0;S=aJ&255;if(aJ<<24>>24==0){break L663}aJ=(V|0)==0;an=V-1|0;aq=(T&1|0)==0;aH=aW<<1;ak=X-1|0;Y=ak<<4;am=(U&1|0)!=0;aG=0;ag=0;as=0;ax=1;while(1){if(aJ){bY=aG;bZ=ag;b_=ax}else{at=aG;Q=ag;ap=0;aw=c[B+(as<<2)>>2]|0;bc=ax;while(1){if((ap&1|0)==0){b$=0;b0=X;b1=1;b2=16;b3=aw}else{b$=ak;b0=-1;b1=-1;b2=-16;b3=aw+Y|0}_=aq|(ap|0)!=(an|0);if((b$|0)==(b0|0)){b4=at;b5=Q;b6=bc}else{af=at;ay=Q;ar=b3;av=b$;R=bc;while(1){if((R|0)==1){b7=a5(s,aL)|0|512}else{b7=R}bg=b7&7;bn=d[832+bg|0]|0;aB=af;aI=0;do{az=(a5(s,ai)|0)+aB|0;aO=az-$|0;aQ=aO>>31;aB=aQ&az|aO&~aQ;if((c[aC>>2]|0)>>>0<=aB>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[n+(aI<<2)>>2]=e[(c[aj>>2]|0)+(aB<<1)>>1]|0;aI=aI+1|0;}while(aI>>>0<bn>>>0);bn=(av|0)==(ak|0)&am;aI=ay;bo=ar;bv=0;while(1){bh=bo;aQ=(bv|0)==0|_;aO=bv<<1;az=(a5(s,ao)|0)+aI|0;aP=az-aA|0;bt=aP>>31;bp=bt&az|aP&~bt;if(aQ){bt=d[840+(bg<<2)+aO|0]|0;aP=bp*3|0;if((c[x>>2]|0)>>>0<=aP>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}az=c[ah>>2]|0;c[bh>>2]=(e[az+(aP<<1)>>1]|0)<<16|c[n+(bt<<2)>>2];c[bo+4>>2]=(e[az+(aP+2<<1)>>1]|0)<<16|(e[az+(aP+1<<1)>>1]|0)}aP=bo+8|0;az=(a5(s,ao)|0)+bp|0;bp=az-aA|0;bt=bp>>31;b8=bt&az|bp&~bt;if(!(bn|aQ^1)){aQ=d[(aO|1)+(840+(bg<<2))|0]|0;aO=b8*3|0;if((c[x>>2]|0)>>>0<=aO>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}bt=c[ah>>2]|0;c[aP>>2]=(e[bt+(aO<<1)>>1]|0)<<16|c[n+(aQ<<2)>>2];c[bo+12>>2]=(e[bt+(aO+2<<1)>>1]|0)<<16|(e[bt+(aO+1<<1)>>1]|0)}aO=bv+1|0;if(aO>>>0<2){aI=b8;bo=bo+aW|0;bv=aO}else{break}}bv=b7>>>3;bo=av+b1|0;if((bo|0)==(b0|0)){b4=aB;b5=b8;b6=bv;break}else{af=aB;ay=b8;ar=ar+b2|0;av=bo;R=bv}}}R=ap+1|0;if(R>>>0<V>>>0){at=b4;Q=b5;ap=R;aw=aw+aH|0;bc=b6}else{bY=b4;bZ=b5;b_=b6;break}}}bc=as+1|0;if(bc>>>0<S>>>0){aG=bY;ag=bZ;as=bc;ax=b_}else{break}}break};case 7:case 8:{ax=c[aC>>2]|0;as=(d[aU+63|0]|0)<<8|(d[aU+64|0]|0);ag=a[aU+17|0]|0;aG=ag&255;if(ag<<24>>24==0){break L663}ag=(V|0)==0;S=V-1|0;aH=(T&1|0)==0;aA=aW<<1;am=(U&1|0)==0;ak=X-1|0;$=ak<<5;an=0;aq=0;Y=0;aJ=0;bc=0;aw=1;while(1){if(ag){b9=an;ca=aq;cb=Y;cc=aJ;cd=aw}else{ap=an;Q=aq;at=Y;R=aJ;av=0;ar=c[B+(bc<<2)>>2]|0;ay=aw;while(1){if((av&1|0)==0){ce=0;cf=X;cg=1;ch=32;ci=ar}else{ce=ak;cf=-1;cg=-1;ch=-32;ci=ar+$|0}af=aH|(av|0)!=(S|0);if((ce|0)==(cf|0)){cj=ap;ck=Q;cl=at;cm=R;cn=ay}else{_=ap;bv=Q;bo=at;aI=R;bg=ce;bn=ci;aO=ay;while(1){if((aO|0)==1){co=a5(s,aL)|0|512}else{co=aO}bt=co&7;aQ=d[832+bt|0]|0;aP=(bg|0)!=(ak|0);bp=_;az=0;do{bh=(a5(s,ai)|0)+bp|0;bm=bh-ax|0;bi=bm>>31;bp=bi&bh|bm&~bi;if((c[aC>>2]|0)>>>0<=bp>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[n+(az<<2)>>2]=e[(c[aj>>2]|0)+(bp<<1)>>1]|0;az=az+1|0;}while(az>>>0<aQ>>>0);az=co>>>3;aB=bo;bi=0;do{bm=(a5(s,ai)|0)+aB|0;bh=bm-ax|0;bk=bh>>31;aB=bk&bm|bh&~bk;if((c[aC>>2]|0)>>>0<=aB>>>0){au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K}c[m+(bi<<2)>>2]=e[(c[aj>>2]|0)+(aB<<1)>>1]|0;bi=bi+1|0;}while(bi>>>0<aQ>>>0);aQ=am|aP;bi=bv;bk=aI;bh=bn;bm=0;while(1){bu=(bm|0)==0|af;bl=bm<<1;bS=bi;bR=bk;bQ=bh;bP=0;while(1){bO=(a5(s,ao)|0)+bS|0;bN=bO-as|0;bT=bN>>31;cp=bT&bO|bN&~bT;bT=(a5(s,ao)|0)+bR|0;bN=bT-as|0;bO=bN>>31;cq=bO&bT|bN&~bO;if(((bP|0)==0|aQ)&bu){bO=d[bP+bl+(840+(bt<<2))|0]|0;bN=cp*3|0;bT=c[x>>2]|0;if(bT>>>0>bN>>>0){cr=bT}else{au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K;cr=c[x>>2]|0}bT=c[ah>>2]|0;bU=cq*3|0;if(cr>>>0>bU>>>0){cs=bT}else{au(aF|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=904,c[K+16>>2]=312,K)|0)|0;i=K;al(aF|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K;cs=c[ah>>2]|0}c[bQ>>2]=(e[bT+(bN<<1)>>1]|0)<<16|c[n+(bO<<2)>>2];c[bQ+4>>2]=(e[bT+(bN+2<<1)>>1]|0)<<16|(e[bT+(bN+1<<1)>>1]|0);c[bQ+8>>2]=(e[cs+(bU<<1)>>1]|0)<<16|c[m+(bO<<2)>>2];c[bQ+12>>2]=(e[cs+(bU+2<<1)>>1]|0)<<16|(e[cs+(bU+1<<1)>>1]|0)}bU=bP+1|0;if(bU>>>0<2){bS=cp;bR=cq;bQ=bQ+16|0;bP=bU}else{break}}bP=bm+1|0;if(bP>>>0<2){bi=cp;bk=cq;bh=bh+aW|0;bm=bP}else{break}}bm=bg+cg|0;if((bm|0)==(cf|0)){cj=bp;ck=cp;cl=aB;cm=cq;cn=az;break}else{_=bp;bv=cp;bo=aB;aI=cq;bg=bm;bn=bn+ch|0;aO=az}}}aO=av+1|0;if(aO>>>0<V>>>0){ap=cj;Q=ck;at=cl;R=cm;av=aO;ar=ar+aA|0;ay=cn}else{b9=cj;ca=ck;cb=cl;cc=cm;cd=cn;break}}}ay=bc+1|0;if(ay>>>0<aG>>>0){an=b9;aq=ca;Y=cb;aJ=cc;bc=ay;aw=cd}else{break}}break};default:{break L663}}}}while(0);aS=c[G>>2]|0}}while(0);g=aS+O|0;c[G>>2]=g;U=ac+1|0;if(U>>>0<r>>>0){ac=U;ab=ab>>>1;aa=aa>>>1;f=g}else{break}}}}while(0);if((L|0)==0){i=j;return}if((c[L>>2]|0)!=519686845){i=j;return}bd(L);if((L&7|0)==0){bf(L);i=j;return}else{L=z|0;au(L|0,768,(K=i,i=i+24|0,c[K>>2]=472,c[K+8>>2]=2500,c[K+16>>2]=576,K)|0)|0;i=K;al(L|0,(K=i,i=i+1|0,i=i+7&-8,c[K>>2]=0,K)|0)|0;i=K;i=j;return}}function bd(b){b=b|0;var d=0,e=0,f=0,g=0,h=0;d=i;i=i+512|0;e=d|0;c[b>>2]=0;f=b+284|0;g=c[f>>2]|0;if((g|0)!=0){if((g&7|0)==0){bf(g)}else{g=e|0;au(g|0,768,(h=i,i=i+24|0,c[h>>2]=472,c[h+8>>2]=2500,c[h+16>>2]=576,h)|0)|0;i=h;al(g|0,(h=i,i=i+1|0,i=i+7&-8,c[h>>2]=0,h)|0)|0;i=h}c[f>>2]=0;c[b+288>>2]=0;c[b+292>>2]=0}a[b+296|0]=0;f=b+268|0;g=c[f>>2]|0;if((g|0)!=0){if((g&7|0)==0){bf(g)}else{g=e|0;au(g|0,768,(h=i,i=i+24|0,c[h>>2]=472,c[h+8>>2]=2500,c[h+16>>2]=576,h)|0)|0;i=h;al(g|0,(h=i,i=i+1|0,i=i+7&-8,c[h>>2]=0,h)|0)|0;i=h}c[f>>2]=0;c[b+272>>2]=0;c[b+276>>2]=0}a[b+280|0]=0;f=b+252|0;g=c[f>>2]|0;if((g|0)!=0){if((g&7|0)==0){bf(g)}else{g=e|0;au(g|0,768,(h=i,i=i+24|0,c[h>>2]=472,c[h+8>>2]=2500,c[h+16>>2]=576,h)|0)|0;i=h;al(g|0,(h=i,i=i+1|0,i=i+7&-8,c[h>>2]=0,h)|0)|0;i=h}c[f>>2]=0;c[b+256>>2]=0;c[b+260>>2]=0}a[b+264|0]=0;f=b+236|0;g=c[f>>2]|0;if((g|0)!=0){if((g&7|0)==0){bf(g)}else{g=e|0;au(g|0,768,(h=i,i=i+24|0,c[h>>2]=472,c[h+8>>2]=2500,c[h+16>>2]=576,h)|0)|0;i=h;al(g|0,(h=i,i=i+1|0,i=i+7&-8,c[h>>2]=0,h)|0)|0;i=h}c[f>>2]=0;c[b+240>>2]=0;c[b+244>>2]=0}a[b+248|0]=0;a1(b+212|0);a1(b+188|0);a1(b+164|0);a1(b+140|0);a1(b+116|0);i=d;return}function be(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ab=0,ac=0,ad=0,ae=0,af=0,ag=0,ah=0,ai=0,ak=0,al=0,am=0,an=0,ap=0,aq=0,ar=0,as=0,at=0,au=0,av=0,aw=0,ax=0,aA=0,aB=0,aD=0,aE=0,aF=0,aG=0,aH=0,aI=0,aJ=0,aK=0,aL=0;do{if(a>>>0<245){if(a>>>0<11){b=16}else{b=a+11&-8}d=b>>>3;e=c[228]|0;f=e>>>(d>>>0);if((f&3|0)!=0){g=(f&1^1)+d|0;h=g<<1;i=952+(h<<2)|0;j=952+(h+2<<2)|0;h=c[j>>2]|0;k=h+8|0;l=c[k>>2]|0;do{if((i|0)==(l|0)){c[228]=e&~(1<<g)}else{if(l>>>0<(c[232]|0)>>>0){aj();return 0}m=l+12|0;if((c[m>>2]|0)==(h|0)){c[m>>2]=i;c[j>>2]=l;break}else{aj();return 0}}}while(0);l=g<<3;c[h+4>>2]=l|3;j=h+(l|4)|0;c[j>>2]=c[j>>2]|1;n=k;return n|0}if(b>>>0<=(c[230]|0)>>>0){o=b;break}if((f|0)!=0){j=2<<d;l=f<<d&(j|-j);j=(l&-l)-1|0;l=j>>>12&16;i=j>>>(l>>>0);j=i>>>5&8;m=i>>>(j>>>0);i=m>>>2&4;p=m>>>(i>>>0);m=p>>>1&2;q=p>>>(m>>>0);p=q>>>1&1;r=(j|l|i|m|p)+(q>>>(p>>>0))|0;p=r<<1;q=952+(p<<2)|0;m=952+(p+2<<2)|0;p=c[m>>2]|0;i=p+8|0;l=c[i>>2]|0;do{if((q|0)==(l|0)){c[228]=e&~(1<<r)}else{if(l>>>0<(c[232]|0)>>>0){aj();return 0}j=l+12|0;if((c[j>>2]|0)==(p|0)){c[j>>2]=q;c[m>>2]=l;break}else{aj();return 0}}}while(0);l=r<<3;m=l-b|0;c[p+4>>2]=b|3;q=p;e=q+b|0;c[q+(b|4)>>2]=m|1;c[q+l>>2]=m;l=c[230]|0;if((l|0)!=0){q=c[233]|0;d=l>>>3;l=d<<1;f=952+(l<<2)|0;k=c[228]|0;h=1<<d;do{if((k&h|0)==0){c[228]=k|h;s=f;t=952+(l+2<<2)|0}else{d=952+(l+2<<2)|0;g=c[d>>2]|0;if(g>>>0>=(c[232]|0)>>>0){s=g;t=d;break}aj();return 0}}while(0);c[t>>2]=q;c[s+12>>2]=q;c[q+8>>2]=s;c[q+12>>2]=f}c[230]=m;c[233]=e;n=i;return n|0}l=c[229]|0;if((l|0)==0){o=b;break}h=(l&-l)-1|0;l=h>>>12&16;k=h>>>(l>>>0);h=k>>>5&8;p=k>>>(h>>>0);k=p>>>2&4;r=p>>>(k>>>0);p=r>>>1&2;d=r>>>(p>>>0);r=d>>>1&1;g=c[1216+((h|l|k|p|r)+(d>>>(r>>>0))<<2)>>2]|0;r=g;d=g;p=(c[g+4>>2]&-8)-b|0;while(1){g=c[r+16>>2]|0;if((g|0)==0){k=c[r+20>>2]|0;if((k|0)==0){break}else{u=k}}else{u=g}g=(c[u+4>>2]&-8)-b|0;k=g>>>0<p>>>0;r=u;d=k?u:d;p=k?g:p}r=d;i=c[232]|0;if(r>>>0<i>>>0){aj();return 0}e=r+b|0;m=e;if(r>>>0>=e>>>0){aj();return 0}e=c[d+24>>2]|0;f=c[d+12>>2]|0;do{if((f|0)==(d|0)){q=d+20|0;g=c[q>>2]|0;if((g|0)==0){k=d+16|0;l=c[k>>2]|0;if((l|0)==0){v=0;break}else{w=l;x=k}}else{w=g;x=q}while(1){q=w+20|0;g=c[q>>2]|0;if((g|0)!=0){w=g;x=q;continue}q=w+16|0;g=c[q>>2]|0;if((g|0)==0){break}else{w=g;x=q}}if(x>>>0<i>>>0){aj();return 0}else{c[x>>2]=0;v=w;break}}else{q=c[d+8>>2]|0;if(q>>>0<i>>>0){aj();return 0}g=q+12|0;if((c[g>>2]|0)!=(d|0)){aj();return 0}k=f+8|0;if((c[k>>2]|0)==(d|0)){c[g>>2]=f;c[k>>2]=q;v=f;break}else{aj();return 0}}}while(0);L990:do{if((e|0)!=0){f=d+28|0;i=1216+(c[f>>2]<<2)|0;do{if((d|0)==(c[i>>2]|0)){c[i>>2]=v;if((v|0)!=0){break}c[229]=c[229]&~(1<<c[f>>2]);break L990}else{if(e>>>0<(c[232]|0)>>>0){aj();return 0}q=e+16|0;if((c[q>>2]|0)==(d|0)){c[q>>2]=v}else{c[e+20>>2]=v}if((v|0)==0){break L990}}}while(0);if(v>>>0<(c[232]|0)>>>0){aj();return 0}c[v+24>>2]=e;f=c[d+16>>2]|0;do{if((f|0)!=0){if(f>>>0<(c[232]|0)>>>0){aj();return 0}else{c[v+16>>2]=f;c[f+24>>2]=v;break}}}while(0);f=c[d+20>>2]|0;if((f|0)==0){break}if(f>>>0<(c[232]|0)>>>0){aj();return 0}else{c[v+20>>2]=f;c[f+24>>2]=v;break}}}while(0);if(p>>>0<16){e=p+b|0;c[d+4>>2]=e|3;f=r+(e+4)|0;c[f>>2]=c[f>>2]|1}else{c[d+4>>2]=b|3;c[r+(b|4)>>2]=p|1;c[r+(p+b)>>2]=p;f=c[230]|0;if((f|0)!=0){e=c[233]|0;i=f>>>3;f=i<<1;q=952+(f<<2)|0;k=c[228]|0;g=1<<i;do{if((k&g|0)==0){c[228]=k|g;y=q;z=952+(f+2<<2)|0}else{i=952+(f+2<<2)|0;l=c[i>>2]|0;if(l>>>0>=(c[232]|0)>>>0){y=l;z=i;break}aj();return 0}}while(0);c[z>>2]=e;c[y+12>>2]=e;c[e+8>>2]=y;c[e+12>>2]=q}c[230]=p;c[233]=m}f=d+8|0;if((f|0)==0){o=b;break}else{n=f}return n|0}else{if(a>>>0>4294967231){o=-1;break}f=a+11|0;g=f&-8;k=c[229]|0;if((k|0)==0){o=g;break}r=-g|0;i=f>>>8;do{if((i|0)==0){A=0}else{if(g>>>0>16777215){A=31;break}f=(i+1048320|0)>>>16&8;l=i<<f;h=(l+520192|0)>>>16&4;j=l<<h;l=(j+245760|0)>>>16&2;B=14-(h|f|l)+(j<<l>>>15)|0;A=g>>>((B+7|0)>>>0)&1|B<<1}}while(0);i=c[1216+(A<<2)>>2]|0;L1038:do{if((i|0)==0){C=0;D=r;E=0}else{if((A|0)==31){F=0}else{F=25-(A>>>1)|0}d=0;m=r;p=i;q=g<<F;e=0;while(1){B=c[p+4>>2]&-8;l=B-g|0;if(l>>>0<m>>>0){if((B|0)==(g|0)){C=p;D=l;E=p;break L1038}else{G=p;H=l}}else{G=d;H=m}l=c[p+20>>2]|0;B=c[p+16+(q>>>31<<2)>>2]|0;j=(l|0)==0|(l|0)==(B|0)?e:l;if((B|0)==0){C=G;D=H;E=j;break}else{d=G;m=H;p=B;q=q<<1;e=j}}}}while(0);if((E|0)==0&(C|0)==0){i=2<<A;r=(i|-i)&k;if((r|0)==0){o=g;break}i=(r&-r)-1|0;r=i>>>12&16;e=i>>>(r>>>0);i=e>>>5&8;q=e>>>(i>>>0);e=q>>>2&4;p=q>>>(e>>>0);q=p>>>1&2;m=p>>>(q>>>0);p=m>>>1&1;I=c[1216+((i|r|e|q|p)+(m>>>(p>>>0))<<2)>>2]|0}else{I=E}if((I|0)==0){J=D;K=C}else{p=I;m=D;q=C;while(1){e=(c[p+4>>2]&-8)-g|0;r=e>>>0<m>>>0;i=r?e:m;e=r?p:q;r=c[p+16>>2]|0;if((r|0)!=0){p=r;m=i;q=e;continue}r=c[p+20>>2]|0;if((r|0)==0){J=i;K=e;break}else{p=r;m=i;q=e}}}if((K|0)==0){o=g;break}if(J>>>0>=((c[230]|0)-g|0)>>>0){o=g;break}q=K;m=c[232]|0;if(q>>>0<m>>>0){aj();return 0}p=q+g|0;k=p;if(q>>>0>=p>>>0){aj();return 0}e=c[K+24>>2]|0;i=c[K+12>>2]|0;do{if((i|0)==(K|0)){r=K+20|0;d=c[r>>2]|0;if((d|0)==0){j=K+16|0;B=c[j>>2]|0;if((B|0)==0){L=0;break}else{M=B;N=j}}else{M=d;N=r}while(1){r=M+20|0;d=c[r>>2]|0;if((d|0)!=0){M=d;N=r;continue}r=M+16|0;d=c[r>>2]|0;if((d|0)==0){break}else{M=d;N=r}}if(N>>>0<m>>>0){aj();return 0}else{c[N>>2]=0;L=M;break}}else{r=c[K+8>>2]|0;if(r>>>0<m>>>0){aj();return 0}d=r+12|0;if((c[d>>2]|0)!=(K|0)){aj();return 0}j=i+8|0;if((c[j>>2]|0)==(K|0)){c[d>>2]=i;c[j>>2]=r;L=i;break}else{aj();return 0}}}while(0);L1088:do{if((e|0)!=0){i=K+28|0;m=1216+(c[i>>2]<<2)|0;do{if((K|0)==(c[m>>2]|0)){c[m>>2]=L;if((L|0)!=0){break}c[229]=c[229]&~(1<<c[i>>2]);break L1088}else{if(e>>>0<(c[232]|0)>>>0){aj();return 0}r=e+16|0;if((c[r>>2]|0)==(K|0)){c[r>>2]=L}else{c[e+20>>2]=L}if((L|0)==0){break L1088}}}while(0);if(L>>>0<(c[232]|0)>>>0){aj();return 0}c[L+24>>2]=e;i=c[K+16>>2]|0;do{if((i|0)!=0){if(i>>>0<(c[232]|0)>>>0){aj();return 0}else{c[L+16>>2]=i;c[i+24>>2]=L;break}}}while(0);i=c[K+20>>2]|0;if((i|0)==0){break}if(i>>>0<(c[232]|0)>>>0){aj();return 0}else{c[L+20>>2]=i;c[i+24>>2]=L;break}}}while(0);do{if(J>>>0<16){e=J+g|0;c[K+4>>2]=e|3;i=q+(e+4)|0;c[i>>2]=c[i>>2]|1}else{c[K+4>>2]=g|3;c[q+(g|4)>>2]=J|1;c[q+(J+g)>>2]=J;i=J>>>3;if(J>>>0<256){e=i<<1;m=952+(e<<2)|0;r=c[228]|0;j=1<<i;do{if((r&j|0)==0){c[228]=r|j;O=m;P=952+(e+2<<2)|0}else{i=952+(e+2<<2)|0;d=c[i>>2]|0;if(d>>>0>=(c[232]|0)>>>0){O=d;P=i;break}aj();return 0}}while(0);c[P>>2]=k;c[O+12>>2]=k;c[q+(g+8)>>2]=O;c[q+(g+12)>>2]=m;break}e=p;j=J>>>8;do{if((j|0)==0){Q=0}else{if(J>>>0>16777215){Q=31;break}r=(j+1048320|0)>>>16&8;i=j<<r;d=(i+520192|0)>>>16&4;B=i<<d;i=(B+245760|0)>>>16&2;l=14-(d|r|i)+(B<<i>>>15)|0;Q=J>>>((l+7|0)>>>0)&1|l<<1}}while(0);j=1216+(Q<<2)|0;c[q+(g+28)>>2]=Q;c[q+(g+20)>>2]=0;c[q+(g+16)>>2]=0;m=c[229]|0;l=1<<Q;if((m&l|0)==0){c[229]=m|l;c[j>>2]=e;c[q+(g+24)>>2]=j;c[q+(g+12)>>2]=e;c[q+(g+8)>>2]=e;break}if((Q|0)==31){R=0}else{R=25-(Q>>>1)|0}l=J<<R;m=c[j>>2]|0;while(1){if((c[m+4>>2]&-8|0)==(J|0)){break}S=m+16+(l>>>31<<2)|0;j=c[S>>2]|0;if((j|0)==0){T=829;break}else{l=l<<1;m=j}}if((T|0)==829){if(S>>>0<(c[232]|0)>>>0){aj();return 0}else{c[S>>2]=e;c[q+(g+24)>>2]=m;c[q+(g+12)>>2]=e;c[q+(g+8)>>2]=e;break}}l=m+8|0;j=c[l>>2]|0;i=c[232]|0;if(m>>>0<i>>>0){aj();return 0}if(j>>>0<i>>>0){aj();return 0}else{c[j+12>>2]=e;c[l>>2]=e;c[q+(g+8)>>2]=j;c[q+(g+12)>>2]=m;c[q+(g+24)>>2]=0;break}}}while(0);q=K+8|0;if((q|0)==0){o=g;break}else{n=q}return n|0}}while(0);K=c[230]|0;if(o>>>0<=K>>>0){S=K-o|0;J=c[233]|0;if(S>>>0>15){R=J;c[233]=R+o;c[230]=S;c[R+(o+4)>>2]=S|1;c[R+K>>2]=S;c[J+4>>2]=o|3}else{c[230]=0;c[233]=0;c[J+4>>2]=K|3;S=J+(K+4)|0;c[S>>2]=c[S>>2]|1}n=J+8|0;return n|0}J=c[231]|0;if(o>>>0<J>>>0){S=J-o|0;c[231]=S;J=c[234]|0;K=J;c[234]=K+o;c[K+(o+4)>>2]=S|1;c[J+4>>2]=o|3;n=J+8|0;return n|0}do{if((c[222]|0)==0){J=ao(30)|0;if((J-1&J|0)==0){c[224]=J;c[223]=J;c[225]=-1;c[226]=-1;c[227]=0;c[339]=0;c[222]=(aC(0)|0)&-16^1431655768;break}else{aj();return 0}}}while(0);J=o+48|0;S=c[224]|0;K=o+47|0;R=S+K|0;Q=-S|0;S=R&Q;if(S>>>0<=o>>>0){n=0;return n|0}O=c[338]|0;do{if((O|0)!=0){P=c[336]|0;L=P+S|0;if(L>>>0<=P>>>0|L>>>0>O>>>0){n=0}else{break}return n|0}}while(0);L1180:do{if((c[339]&4|0)==0){O=c[234]|0;L1182:do{if((O|0)==0){T=859}else{L=O;P=1360;while(1){U=P|0;M=c[U>>2]|0;if(M>>>0<=L>>>0){V=P+4|0;if((M+(c[V>>2]|0)|0)>>>0>L>>>0){break}}M=c[P+8>>2]|0;if((M|0)==0){T=859;break L1182}else{P=M}}if((P|0)==0){T=859;break}L=R-(c[231]|0)&Q;if(L>>>0>=2147483647){W=0;break}m=ay(L|0)|0;e=(m|0)==((c[U>>2]|0)+(c[V>>2]|0)|0);X=e?m:-1;Y=e?L:0;Z=m;_=L;T=868}}while(0);do{if((T|0)==859){O=ay(0)|0;if((O|0)==-1){W=0;break}g=O;L=c[223]|0;m=L-1|0;if((m&g|0)==0){$=S}else{$=S-g+(m+g&-L)|0}L=c[336]|0;g=L+$|0;if(!($>>>0>o>>>0&$>>>0<2147483647)){W=0;break}m=c[338]|0;if((m|0)!=0){if(g>>>0<=L>>>0|g>>>0>m>>>0){W=0;break}}m=ay($|0)|0;g=(m|0)==(O|0);X=g?O:-1;Y=g?$:0;Z=m;_=$;T=868}}while(0);L1202:do{if((T|0)==868){m=-_|0;if((X|0)!=-1){aa=Y;ab=X;T=879;break L1180}do{if((Z|0)!=-1&_>>>0<2147483647&_>>>0<J>>>0){g=c[224]|0;O=K-_+g&-g;if(O>>>0>=2147483647){ac=_;break}if((ay(O|0)|0)==-1){ay(m|0)|0;W=Y;break L1202}else{ac=O+_|0;break}}else{ac=_}}while(0);if((Z|0)==-1){W=Y}else{aa=ac;ab=Z;T=879;break L1180}}}while(0);c[339]=c[339]|4;ad=W;T=876}else{ad=0;T=876}}while(0);do{if((T|0)==876){if(S>>>0>=2147483647){break}W=ay(S|0)|0;Z=ay(0)|0;if(!((Z|0)!=-1&(W|0)!=-1&W>>>0<Z>>>0)){break}ac=Z-W|0;Z=ac>>>0>(o+40|0)>>>0;Y=Z?W:-1;if((Y|0)!=-1){aa=Z?ac:ad;ab=Y;T=879}}}while(0);do{if((T|0)==879){ad=(c[336]|0)+aa|0;c[336]=ad;if(ad>>>0>(c[337]|0)>>>0){c[337]=ad}ad=c[234]|0;L1222:do{if((ad|0)==0){S=c[232]|0;if((S|0)==0|ab>>>0<S>>>0){c[232]=ab}c[340]=ab;c[341]=aa;c[343]=0;c[237]=c[222];c[236]=-1;S=0;do{Y=S<<1;ac=952+(Y<<2)|0;c[952+(Y+3<<2)>>2]=ac;c[952+(Y+2<<2)>>2]=ac;S=S+1|0;}while(S>>>0<32);S=ab+8|0;if((S&7|0)==0){ae=0}else{ae=-S&7}S=aa-40-ae|0;c[234]=ab+ae;c[231]=S;c[ab+(ae+4)>>2]=S|1;c[ab+(aa-36)>>2]=40;c[235]=c[226]}else{S=1360;while(1){af=c[S>>2]|0;ag=S+4|0;ah=c[ag>>2]|0;if((ab|0)==(af+ah|0)){T=891;break}ac=c[S+8>>2]|0;if((ac|0)==0){break}else{S=ac}}do{if((T|0)==891){if((c[S+12>>2]&8|0)!=0){break}ac=ad;if(!(ac>>>0>=af>>>0&ac>>>0<ab>>>0)){break}c[ag>>2]=ah+aa;ac=c[234]|0;Y=(c[231]|0)+aa|0;Z=ac;W=ac+8|0;if((W&7|0)==0){ai=0}else{ai=-W&7}W=Y-ai|0;c[234]=Z+ai;c[231]=W;c[Z+(ai+4)>>2]=W|1;c[Z+(Y+4)>>2]=40;c[235]=c[226];break L1222}}while(0);if(ab>>>0<(c[232]|0)>>>0){c[232]=ab}S=ab+aa|0;Y=1360;while(1){ak=Y|0;if((c[ak>>2]|0)==(S|0)){T=901;break}Z=c[Y+8>>2]|0;if((Z|0)==0){break}else{Y=Z}}do{if((T|0)==901){if((c[Y+12>>2]&8|0)!=0){break}c[ak>>2]=ab;S=Y+4|0;c[S>>2]=(c[S>>2]|0)+aa;S=ab+8|0;if((S&7|0)==0){al=0}else{al=-S&7}S=ab+(aa+8)|0;if((S&7|0)==0){am=0}else{am=-S&7}S=ab+(am+aa)|0;Z=S;W=al+o|0;ac=ab+W|0;_=ac;K=S-(ab+al)-o|0;c[ab+(al+4)>>2]=o|3;do{if((Z|0)==(c[234]|0)){J=(c[231]|0)+K|0;c[231]=J;c[234]=_;c[ab+(W+4)>>2]=J|1}else{if((Z|0)==(c[233]|0)){J=(c[230]|0)+K|0;c[230]=J;c[233]=_;c[ab+(W+4)>>2]=J|1;c[ab+(J+W)>>2]=J;break}J=aa+4|0;X=c[ab+(am+J)>>2]|0;if((X&3|0)==1){$=X&-8;V=X>>>3;L1267:do{if(X>>>0<256){U=c[ab+((am|8)+aa)>>2]|0;Q=c[ab+(aa+12+am)>>2]|0;R=952+(V<<1<<2)|0;do{if((U|0)!=(R|0)){if(U>>>0<(c[232]|0)>>>0){aj();return 0}if((c[U+12>>2]|0)==(Z|0)){break}aj();return 0}}while(0);if((Q|0)==(U|0)){c[228]=c[228]&~(1<<V);break}do{if((Q|0)==(R|0)){an=Q+8|0}else{if(Q>>>0<(c[232]|0)>>>0){aj();return 0}m=Q+8|0;if((c[m>>2]|0)==(Z|0)){an=m;break}aj();return 0}}while(0);c[U+12>>2]=Q;c[an>>2]=U}else{R=S;m=c[ab+((am|24)+aa)>>2]|0;P=c[ab+(aa+12+am)>>2]|0;do{if((P|0)==(R|0)){O=am|16;g=ab+(O+J)|0;L=c[g>>2]|0;if((L|0)==0){e=ab+(O+aa)|0;O=c[e>>2]|0;if((O|0)==0){ap=0;break}else{aq=O;ar=e}}else{aq=L;ar=g}while(1){g=aq+20|0;L=c[g>>2]|0;if((L|0)!=0){aq=L;ar=g;continue}g=aq+16|0;L=c[g>>2]|0;if((L|0)==0){break}else{aq=L;ar=g}}if(ar>>>0<(c[232]|0)>>>0){aj();return 0}else{c[ar>>2]=0;ap=aq;break}}else{g=c[ab+((am|8)+aa)>>2]|0;if(g>>>0<(c[232]|0)>>>0){aj();return 0}L=g+12|0;if((c[L>>2]|0)!=(R|0)){aj();return 0}e=P+8|0;if((c[e>>2]|0)==(R|0)){c[L>>2]=P;c[e>>2]=g;ap=P;break}else{aj();return 0}}}while(0);if((m|0)==0){break}P=ab+(aa+28+am)|0;U=1216+(c[P>>2]<<2)|0;do{if((R|0)==(c[U>>2]|0)){c[U>>2]=ap;if((ap|0)!=0){break}c[229]=c[229]&~(1<<c[P>>2]);break L1267}else{if(m>>>0<(c[232]|0)>>>0){aj();return 0}Q=m+16|0;if((c[Q>>2]|0)==(R|0)){c[Q>>2]=ap}else{c[m+20>>2]=ap}if((ap|0)==0){break L1267}}}while(0);if(ap>>>0<(c[232]|0)>>>0){aj();return 0}c[ap+24>>2]=m;R=am|16;P=c[ab+(R+aa)>>2]|0;do{if((P|0)!=0){if(P>>>0<(c[232]|0)>>>0){aj();return 0}else{c[ap+16>>2]=P;c[P+24>>2]=ap;break}}}while(0);P=c[ab+(R+J)>>2]|0;if((P|0)==0){break}if(P>>>0<(c[232]|0)>>>0){aj();return 0}else{c[ap+20>>2]=P;c[P+24>>2]=ap;break}}}while(0);as=ab+(($|am)+aa)|0;at=$+K|0}else{as=Z;at=K}J=as+4|0;c[J>>2]=c[J>>2]&-2;c[ab+(W+4)>>2]=at|1;c[ab+(at+W)>>2]=at;J=at>>>3;if(at>>>0<256){V=J<<1;X=952+(V<<2)|0;P=c[228]|0;m=1<<J;do{if((P&m|0)==0){c[228]=P|m;au=X;av=952+(V+2<<2)|0}else{J=952+(V+2<<2)|0;U=c[J>>2]|0;if(U>>>0>=(c[232]|0)>>>0){au=U;av=J;break}aj();return 0}}while(0);c[av>>2]=_;c[au+12>>2]=_;c[ab+(W+8)>>2]=au;c[ab+(W+12)>>2]=X;break}V=ac;m=at>>>8;do{if((m|0)==0){aw=0}else{if(at>>>0>16777215){aw=31;break}P=(m+1048320|0)>>>16&8;$=m<<P;J=($+520192|0)>>>16&4;U=$<<J;$=(U+245760|0)>>>16&2;Q=14-(J|P|$)+(U<<$>>>15)|0;aw=at>>>((Q+7|0)>>>0)&1|Q<<1}}while(0);m=1216+(aw<<2)|0;c[ab+(W+28)>>2]=aw;c[ab+(W+20)>>2]=0;c[ab+(W+16)>>2]=0;X=c[229]|0;Q=1<<aw;if((X&Q|0)==0){c[229]=X|Q;c[m>>2]=V;c[ab+(W+24)>>2]=m;c[ab+(W+12)>>2]=V;c[ab+(W+8)>>2]=V;break}if((aw|0)==31){ax=0}else{ax=25-(aw>>>1)|0}Q=at<<ax;X=c[m>>2]|0;while(1){if((c[X+4>>2]&-8|0)==(at|0)){break}aA=X+16+(Q>>>31<<2)|0;m=c[aA>>2]|0;if((m|0)==0){T=974;break}else{Q=Q<<1;X=m}}if((T|0)==974){if(aA>>>0<(c[232]|0)>>>0){aj();return 0}else{c[aA>>2]=V;c[ab+(W+24)>>2]=X;c[ab+(W+12)>>2]=V;c[ab+(W+8)>>2]=V;break}}Q=X+8|0;m=c[Q>>2]|0;$=c[232]|0;if(X>>>0<$>>>0){aj();return 0}if(m>>>0<$>>>0){aj();return 0}else{c[m+12>>2]=V;c[Q>>2]=V;c[ab+(W+8)>>2]=m;c[ab+(W+12)>>2]=X;c[ab+(W+24)>>2]=0;break}}}while(0);n=ab+(al|8)|0;return n|0}}while(0);Y=ad;W=1360;while(1){aB=c[W>>2]|0;if(aB>>>0<=Y>>>0){aD=c[W+4>>2]|0;aE=aB+aD|0;if(aE>>>0>Y>>>0){break}}W=c[W+8>>2]|0}W=aB+(aD-39)|0;if((W&7|0)==0){aF=0}else{aF=-W&7}W=aB+(aD-47+aF)|0;ac=W>>>0<(ad+16|0)>>>0?Y:W;W=ac+8|0;_=ab+8|0;if((_&7|0)==0){aG=0}else{aG=-_&7}_=aa-40-aG|0;c[234]=ab+aG;c[231]=_;c[ab+(aG+4)>>2]=_|1;c[ab+(aa-36)>>2]=40;c[235]=c[226];c[ac+4>>2]=27;c[W>>2]=c[340];c[W+4>>2]=c[341];c[W+8>>2]=c[342];c[W+12>>2]=c[343];c[340]=ab;c[341]=aa;c[343]=0;c[342]=W;W=ac+28|0;c[W>>2]=7;if((ac+32|0)>>>0<aE>>>0){_=W;while(1){W=_+4|0;c[W>>2]=7;if((_+8|0)>>>0<aE>>>0){_=W}else{break}}}if((ac|0)==(Y|0)){break}_=ac-ad|0;W=Y+(_+4)|0;c[W>>2]=c[W>>2]&-2;c[ad+4>>2]=_|1;c[Y+_>>2]=_;W=_>>>3;if(_>>>0<256){K=W<<1;Z=952+(K<<2)|0;S=c[228]|0;m=1<<W;do{if((S&m|0)==0){c[228]=S|m;aH=Z;aI=952+(K+2<<2)|0}else{W=952+(K+2<<2)|0;Q=c[W>>2]|0;if(Q>>>0>=(c[232]|0)>>>0){aH=Q;aI=W;break}aj();return 0}}while(0);c[aI>>2]=ad;c[aH+12>>2]=ad;c[ad+8>>2]=aH;c[ad+12>>2]=Z;break}K=ad;m=_>>>8;do{if((m|0)==0){aJ=0}else{if(_>>>0>16777215){aJ=31;break}S=(m+1048320|0)>>>16&8;Y=m<<S;ac=(Y+520192|0)>>>16&4;W=Y<<ac;Y=(W+245760|0)>>>16&2;Q=14-(ac|S|Y)+(W<<Y>>>15)|0;aJ=_>>>((Q+7|0)>>>0)&1|Q<<1}}while(0);m=1216+(aJ<<2)|0;c[ad+28>>2]=aJ;c[ad+20>>2]=0;c[ad+16>>2]=0;Z=c[229]|0;Q=1<<aJ;if((Z&Q|0)==0){c[229]=Z|Q;c[m>>2]=K;c[ad+24>>2]=m;c[ad+12>>2]=ad;c[ad+8>>2]=ad;break}if((aJ|0)==31){aK=0}else{aK=25-(aJ>>>1)|0}Q=_<<aK;Z=c[m>>2]|0;while(1){if((c[Z+4>>2]&-8|0)==(_|0)){break}aL=Z+16+(Q>>>31<<2)|0;m=c[aL>>2]|0;if((m|0)==0){T=1009;break}else{Q=Q<<1;Z=m}}if((T|0)==1009){if(aL>>>0<(c[232]|0)>>>0){aj();return 0}else{c[aL>>2]=K;c[ad+24>>2]=Z;c[ad+12>>2]=ad;c[ad+8>>2]=ad;break}}Q=Z+8|0;_=c[Q>>2]|0;m=c[232]|0;if(Z>>>0<m>>>0){aj();return 0}if(_>>>0<m>>>0){aj();return 0}else{c[_+12>>2]=K;c[Q>>2]=K;c[ad+8>>2]=_;c[ad+12>>2]=Z;c[ad+24>>2]=0;break}}}while(0);ad=c[231]|0;if(ad>>>0<=o>>>0){break}_=ad-o|0;c[231]=_;ad=c[234]|0;Q=ad;c[234]=Q+o;c[Q+(o+4)>>2]=_|1;c[ad+4>>2]=o|3;n=ad+8|0;return n|0}}while(0);c[(az()|0)>>2]=12;n=0;return n|0}function bf(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0;if((a|0)==0){return}b=a-8|0;d=b;e=c[232]|0;if(b>>>0<e>>>0){aj()}f=c[a-4>>2]|0;g=f&3;if((g|0)==1){aj()}h=f&-8;i=a+(h-8)|0;j=i;L1439:do{if((f&1|0)==0){k=c[b>>2]|0;if((g|0)==0){return}l=-8-k|0;m=a+l|0;n=m;o=k+h|0;if(m>>>0<e>>>0){aj()}if((n|0)==(c[233]|0)){p=a+(h-4)|0;if((c[p>>2]&3|0)!=3){q=n;r=o;break}c[230]=o;c[p>>2]=c[p>>2]&-2;c[a+(l+4)>>2]=o|1;c[i>>2]=o;return}p=k>>>3;if(k>>>0<256){k=c[a+(l+8)>>2]|0;s=c[a+(l+12)>>2]|0;t=952+(p<<1<<2)|0;do{if((k|0)!=(t|0)){if(k>>>0<e>>>0){aj()}if((c[k+12>>2]|0)==(n|0)){break}aj()}}while(0);if((s|0)==(k|0)){c[228]=c[228]&~(1<<p);q=n;r=o;break}do{if((s|0)==(t|0)){u=s+8|0}else{if(s>>>0<e>>>0){aj()}v=s+8|0;if((c[v>>2]|0)==(n|0)){u=v;break}aj()}}while(0);c[k+12>>2]=s;c[u>>2]=k;q=n;r=o;break}t=m;p=c[a+(l+24)>>2]|0;v=c[a+(l+12)>>2]|0;do{if((v|0)==(t|0)){w=a+(l+20)|0;x=c[w>>2]|0;if((x|0)==0){y=a+(l+16)|0;z=c[y>>2]|0;if((z|0)==0){A=0;break}else{B=z;C=y}}else{B=x;C=w}while(1){w=B+20|0;x=c[w>>2]|0;if((x|0)!=0){B=x;C=w;continue}w=B+16|0;x=c[w>>2]|0;if((x|0)==0){break}else{B=x;C=w}}if(C>>>0<e>>>0){aj()}else{c[C>>2]=0;A=B;break}}else{w=c[a+(l+8)>>2]|0;if(w>>>0<e>>>0){aj()}x=w+12|0;if((c[x>>2]|0)!=(t|0)){aj()}y=v+8|0;if((c[y>>2]|0)==(t|0)){c[x>>2]=v;c[y>>2]=w;A=v;break}else{aj()}}}while(0);if((p|0)==0){q=n;r=o;break}v=a+(l+28)|0;m=1216+(c[v>>2]<<2)|0;do{if((t|0)==(c[m>>2]|0)){c[m>>2]=A;if((A|0)!=0){break}c[229]=c[229]&~(1<<c[v>>2]);q=n;r=o;break L1439}else{if(p>>>0<(c[232]|0)>>>0){aj()}k=p+16|0;if((c[k>>2]|0)==(t|0)){c[k>>2]=A}else{c[p+20>>2]=A}if((A|0)==0){q=n;r=o;break L1439}}}while(0);if(A>>>0<(c[232]|0)>>>0){aj()}c[A+24>>2]=p;t=c[a+(l+16)>>2]|0;do{if((t|0)!=0){if(t>>>0<(c[232]|0)>>>0){aj()}else{c[A+16>>2]=t;c[t+24>>2]=A;break}}}while(0);t=c[a+(l+20)>>2]|0;if((t|0)==0){q=n;r=o;break}if(t>>>0<(c[232]|0)>>>0){aj()}else{c[A+20>>2]=t;c[t+24>>2]=A;q=n;r=o;break}}else{q=d;r=h}}while(0);d=q;if(d>>>0>=i>>>0){aj()}A=a+(h-4)|0;e=c[A>>2]|0;if((e&1|0)==0){aj()}do{if((e&2|0)==0){if((j|0)==(c[234]|0)){B=(c[231]|0)+r|0;c[231]=B;c[234]=q;c[q+4>>2]=B|1;if((q|0)!=(c[233]|0)){return}c[233]=0;c[230]=0;return}if((j|0)==(c[233]|0)){B=(c[230]|0)+r|0;c[230]=B;c[233]=q;c[q+4>>2]=B|1;c[d+B>>2]=B;return}B=(e&-8)+r|0;C=e>>>3;L1542:do{if(e>>>0<256){u=c[a+h>>2]|0;g=c[a+(h|4)>>2]|0;b=952+(C<<1<<2)|0;do{if((u|0)!=(b|0)){if(u>>>0<(c[232]|0)>>>0){aj()}if((c[u+12>>2]|0)==(j|0)){break}aj()}}while(0);if((g|0)==(u|0)){c[228]=c[228]&~(1<<C);break}do{if((g|0)==(b|0)){D=g+8|0}else{if(g>>>0<(c[232]|0)>>>0){aj()}f=g+8|0;if((c[f>>2]|0)==(j|0)){D=f;break}aj()}}while(0);c[u+12>>2]=g;c[D>>2]=u}else{b=i;f=c[a+(h+16)>>2]|0;t=c[a+(h|4)>>2]|0;do{if((t|0)==(b|0)){p=a+(h+12)|0;v=c[p>>2]|0;if((v|0)==0){m=a+(h+8)|0;k=c[m>>2]|0;if((k|0)==0){E=0;break}else{F=k;G=m}}else{F=v;G=p}while(1){p=F+20|0;v=c[p>>2]|0;if((v|0)!=0){F=v;G=p;continue}p=F+16|0;v=c[p>>2]|0;if((v|0)==0){break}else{F=v;G=p}}if(G>>>0<(c[232]|0)>>>0){aj()}else{c[G>>2]=0;E=F;break}}else{p=c[a+h>>2]|0;if(p>>>0<(c[232]|0)>>>0){aj()}v=p+12|0;if((c[v>>2]|0)!=(b|0)){aj()}m=t+8|0;if((c[m>>2]|0)==(b|0)){c[v>>2]=t;c[m>>2]=p;E=t;break}else{aj()}}}while(0);if((f|0)==0){break}t=a+(h+20)|0;u=1216+(c[t>>2]<<2)|0;do{if((b|0)==(c[u>>2]|0)){c[u>>2]=E;if((E|0)!=0){break}c[229]=c[229]&~(1<<c[t>>2]);break L1542}else{if(f>>>0<(c[232]|0)>>>0){aj()}g=f+16|0;if((c[g>>2]|0)==(b|0)){c[g>>2]=E}else{c[f+20>>2]=E}if((E|0)==0){break L1542}}}while(0);if(E>>>0<(c[232]|0)>>>0){aj()}c[E+24>>2]=f;b=c[a+(h+8)>>2]|0;do{if((b|0)!=0){if(b>>>0<(c[232]|0)>>>0){aj()}else{c[E+16>>2]=b;c[b+24>>2]=E;break}}}while(0);b=c[a+(h+12)>>2]|0;if((b|0)==0){break}if(b>>>0<(c[232]|0)>>>0){aj()}else{c[E+20>>2]=b;c[b+24>>2]=E;break}}}while(0);c[q+4>>2]=B|1;c[d+B>>2]=B;if((q|0)!=(c[233]|0)){H=B;break}c[230]=B;return}else{c[A>>2]=e&-2;c[q+4>>2]=r|1;c[d+r>>2]=r;H=r}}while(0);r=H>>>3;if(H>>>0<256){d=r<<1;e=952+(d<<2)|0;A=c[228]|0;E=1<<r;do{if((A&E|0)==0){c[228]=A|E;I=e;J=952+(d+2<<2)|0}else{r=952+(d+2<<2)|0;h=c[r>>2]|0;if(h>>>0>=(c[232]|0)>>>0){I=h;J=r;break}aj()}}while(0);c[J>>2]=q;c[I+12>>2]=q;c[q+8>>2]=I;c[q+12>>2]=e;return}e=q;I=H>>>8;do{if((I|0)==0){K=0}else{if(H>>>0>16777215){K=31;break}J=(I+1048320|0)>>>16&8;d=I<<J;E=(d+520192|0)>>>16&4;A=d<<E;d=(A+245760|0)>>>16&2;r=14-(E|J|d)+(A<<d>>>15)|0;K=H>>>((r+7|0)>>>0)&1|r<<1}}while(0);I=1216+(K<<2)|0;c[q+28>>2]=K;c[q+20>>2]=0;c[q+16>>2]=0;r=c[229]|0;d=1<<K;do{if((r&d|0)==0){c[229]=r|d;c[I>>2]=e;c[q+24>>2]=I;c[q+12>>2]=q;c[q+8>>2]=q}else{if((K|0)==31){L=0}else{L=25-(K>>>1)|0}A=H<<L;J=c[I>>2]|0;while(1){if((c[J+4>>2]&-8|0)==(H|0)){break}M=J+16+(A>>>31<<2)|0;E=c[M>>2]|0;if((E|0)==0){N=1186;break}else{A=A<<1;J=E}}if((N|0)==1186){if(M>>>0<(c[232]|0)>>>0){aj()}else{c[M>>2]=e;c[q+24>>2]=J;c[q+12>>2]=q;c[q+8>>2]=q;break}}A=J+8|0;B=c[A>>2]|0;E=c[232]|0;if(J>>>0<E>>>0){aj()}if(B>>>0<E>>>0){aj()}else{c[B+12>>2]=e;c[A>>2]=e;c[q+8>>2]=B;c[q+12>>2]=J;c[q+24>>2]=0;break}}}while(0);q=(c[236]|0)-1|0;c[236]=q;if((q|0)==0){O=1368}else{return}while(1){q=c[O>>2]|0;if((q|0)==0){break}else{O=q+8|0}}c[236]=-1;return}function bg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;if((a|0)==0){d=be(b)|0;return d|0}if(b>>>0>4294967231){c[(az()|0)>>2]=12;d=0;return d|0}if(b>>>0<11){e=16}else{e=b+11&-8}f=a-8|0;g=a-4|0;h=c[g>>2]|0;i=h&-8;j=i-8|0;k=a+j|0;l=k;m=c[232]|0;if(f>>>0<m>>>0){aj();return 0}n=h&3;if(!((n|0)!=1&(j|0)>-8)){aj();return 0}j=i|4;o=a+(j-8)|0;p=c[o>>2]|0;if((p&1|0)==0){aj();return 0}L1677:do{if((n|0)==0){if(e>>>0<256|i>>>0<(e|4)>>>0){break}if((i-e|0)>>>0>c[224]<<1>>>0|(f|0)==0){break}else{d=a}return d|0}else{do{if(i>>>0<e>>>0){if((l|0)==(c[234]|0)){q=(c[231]|0)+i|0;if(q>>>0<=e>>>0){break L1677}r=q-e|0;c[g>>2]=h&1|e|2;c[a+((e|4)-8)>>2]=r|1;c[234]=a+(e-8);c[231]=r;break}if((l|0)==(c[233]|0)){r=(c[230]|0)+i|0;if(r>>>0<e>>>0){break L1677}q=r-e|0;if(q>>>0>15){c[g>>2]=h&1|e|2;c[a+((e|4)-8)>>2]=q|1;c[a+(r-8)>>2]=q;s=a+(r-4)|0;c[s>>2]=c[s>>2]&-2;t=a+(e-8)|0;u=q}else{c[g>>2]=h&1|r|2;q=a+(r-4)|0;c[q>>2]=c[q>>2]|1;t=0;u=0}c[230]=u;c[233]=t;break}if((p&2|0)!=0){break L1677}q=(p&-8)+i|0;if(q>>>0<e>>>0){break L1677}r=q-e|0;s=p>>>3;L1695:do{if(p>>>0<256){v=c[a+i>>2]|0;w=c[a+j>>2]|0;x=952+(s<<1<<2)|0;do{if((v|0)!=(x|0)){if(v>>>0<m>>>0){aj();return 0}if((c[v+12>>2]|0)==(l|0)){break}aj();return 0}}while(0);if((w|0)==(v|0)){c[228]=c[228]&~(1<<s);break}do{if((w|0)==(x|0)){y=w+8|0}else{if(w>>>0<m>>>0){aj();return 0}z=w+8|0;if((c[z>>2]|0)==(l|0)){y=z;break}aj();return 0}}while(0);c[v+12>>2]=w;c[y>>2]=v}else{x=k;z=c[a+(i+16)>>2]|0;A=c[a+j>>2]|0;do{if((A|0)==(x|0)){B=a+(i+12)|0;C=c[B>>2]|0;if((C|0)==0){D=a+(i+8)|0;E=c[D>>2]|0;if((E|0)==0){F=0;break}else{G=E;H=D}}else{G=C;H=B}while(1){B=G+20|0;C=c[B>>2]|0;if((C|0)!=0){G=C;H=B;continue}B=G+16|0;C=c[B>>2]|0;if((C|0)==0){break}else{G=C;H=B}}if(H>>>0<m>>>0){aj();return 0}else{c[H>>2]=0;F=G;break}}else{B=c[a+i>>2]|0;if(B>>>0<m>>>0){aj();return 0}C=B+12|0;if((c[C>>2]|0)!=(x|0)){aj();return 0}D=A+8|0;if((c[D>>2]|0)==(x|0)){c[C>>2]=A;c[D>>2]=B;F=A;break}else{aj();return 0}}}while(0);if((z|0)==0){break}A=a+(i+20)|0;v=1216+(c[A>>2]<<2)|0;do{if((x|0)==(c[v>>2]|0)){c[v>>2]=F;if((F|0)!=0){break}c[229]=c[229]&~(1<<c[A>>2]);break L1695}else{if(z>>>0<(c[232]|0)>>>0){aj();return 0}w=z+16|0;if((c[w>>2]|0)==(x|0)){c[w>>2]=F}else{c[z+20>>2]=F}if((F|0)==0){break L1695}}}while(0);if(F>>>0<(c[232]|0)>>>0){aj();return 0}c[F+24>>2]=z;x=c[a+(i+8)>>2]|0;do{if((x|0)!=0){if(x>>>0<(c[232]|0)>>>0){aj();return 0}else{c[F+16>>2]=x;c[x+24>>2]=F;break}}}while(0);x=c[a+(i+12)>>2]|0;if((x|0)==0){break}if(x>>>0<(c[232]|0)>>>0){aj();return 0}else{c[F+20>>2]=x;c[x+24>>2]=F;break}}}while(0);if(r>>>0>=16){c[g>>2]=c[g>>2]&1|e|2;c[a+((e|4)-8)>>2]=r|3;s=a+((q|4)-8)|0;c[s>>2]=c[s>>2]|1;bh(a+(e-8)|0,r);break}c[g>>2]=q|c[g>>2]&1|2;s=a+((q|4)-8)|0;c[s>>2]=c[s>>2]|1;d=a;return d|0}else{s=i-e|0;if(s>>>0<=15){break}c[g>>2]=h&1|e|2;c[a+((e|4)-8)>>2]=s|3;c[o>>2]=c[o>>2]|1;bh(a+(e-8)|0,s);d=a;return d|0}}while(0);if((f|0)==0){break}else{d=a}return d|0}}while(0);f=be(b)|0;if((f|0)==0){d=0;return d|0}e=c[g>>2]|0;g=(e&-8)-((e&3|0)==0?8:4)|0;e=g>>>0<b>>>0?g:b;bk(f|0,a|0,e)|0;bf(a);d=f;return d|0}function bh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;d=a;e=d+b|0;f=e;g=c[a+4>>2]|0;L1783:do{if((g&1|0)==0){h=c[a>>2]|0;if((g&3|0)==0){return}i=d+(-h|0)|0;j=i;k=h+b|0;l=c[232]|0;if(i>>>0<l>>>0){aj()}if((j|0)==(c[233]|0)){m=d+(b+4)|0;if((c[m>>2]&3|0)!=3){n=j;o=k;break}c[230]=k;c[m>>2]=c[m>>2]&-2;c[d+(4-h)>>2]=k|1;c[e>>2]=k;return}m=h>>>3;if(h>>>0<256){p=c[d+(8-h)>>2]|0;q=c[d+(12-h)>>2]|0;r=952+(m<<1<<2)|0;do{if((p|0)!=(r|0)){if(p>>>0<l>>>0){aj()}if((c[p+12>>2]|0)==(j|0)){break}aj()}}while(0);if((q|0)==(p|0)){c[228]=c[228]&~(1<<m);n=j;o=k;break}do{if((q|0)==(r|0)){s=q+8|0}else{if(q>>>0<l>>>0){aj()}t=q+8|0;if((c[t>>2]|0)==(j|0)){s=t;break}aj()}}while(0);c[p+12>>2]=q;c[s>>2]=p;n=j;o=k;break}r=i;m=c[d+(24-h)>>2]|0;t=c[d+(12-h)>>2]|0;do{if((t|0)==(r|0)){u=16-h|0;v=d+(u+4)|0;w=c[v>>2]|0;if((w|0)==0){x=d+u|0;u=c[x>>2]|0;if((u|0)==0){y=0;break}else{z=u;A=x}}else{z=w;A=v}while(1){v=z+20|0;w=c[v>>2]|0;if((w|0)!=0){z=w;A=v;continue}v=z+16|0;w=c[v>>2]|0;if((w|0)==0){break}else{z=w;A=v}}if(A>>>0<l>>>0){aj()}else{c[A>>2]=0;y=z;break}}else{v=c[d+(8-h)>>2]|0;if(v>>>0<l>>>0){aj()}w=v+12|0;if((c[w>>2]|0)!=(r|0)){aj()}x=t+8|0;if((c[x>>2]|0)==(r|0)){c[w>>2]=t;c[x>>2]=v;y=t;break}else{aj()}}}while(0);if((m|0)==0){n=j;o=k;break}t=d+(28-h)|0;l=1216+(c[t>>2]<<2)|0;do{if((r|0)==(c[l>>2]|0)){c[l>>2]=y;if((y|0)!=0){break}c[229]=c[229]&~(1<<c[t>>2]);n=j;o=k;break L1783}else{if(m>>>0<(c[232]|0)>>>0){aj()}i=m+16|0;if((c[i>>2]|0)==(r|0)){c[i>>2]=y}else{c[m+20>>2]=y}if((y|0)==0){n=j;o=k;break L1783}}}while(0);if(y>>>0<(c[232]|0)>>>0){aj()}c[y+24>>2]=m;r=16-h|0;t=c[d+r>>2]|0;do{if((t|0)!=0){if(t>>>0<(c[232]|0)>>>0){aj()}else{c[y+16>>2]=t;c[t+24>>2]=y;break}}}while(0);t=c[d+(r+4)>>2]|0;if((t|0)==0){n=j;o=k;break}if(t>>>0<(c[232]|0)>>>0){aj()}else{c[y+20>>2]=t;c[t+24>>2]=y;n=j;o=k;break}}else{n=a;o=b}}while(0);a=c[232]|0;if(e>>>0<a>>>0){aj()}y=d+(b+4)|0;z=c[y>>2]|0;do{if((z&2|0)==0){if((f|0)==(c[234]|0)){A=(c[231]|0)+o|0;c[231]=A;c[234]=n;c[n+4>>2]=A|1;if((n|0)!=(c[233]|0)){return}c[233]=0;c[230]=0;return}if((f|0)==(c[233]|0)){A=(c[230]|0)+o|0;c[230]=A;c[233]=n;c[n+4>>2]=A|1;c[n+A>>2]=A;return}A=(z&-8)+o|0;s=z>>>3;L1883:do{if(z>>>0<256){g=c[d+(b+8)>>2]|0;t=c[d+(b+12)>>2]|0;h=952+(s<<1<<2)|0;do{if((g|0)!=(h|0)){if(g>>>0<a>>>0){aj()}if((c[g+12>>2]|0)==(f|0)){break}aj()}}while(0);if((t|0)==(g|0)){c[228]=c[228]&~(1<<s);break}do{if((t|0)==(h|0)){B=t+8|0}else{if(t>>>0<a>>>0){aj()}m=t+8|0;if((c[m>>2]|0)==(f|0)){B=m;break}aj()}}while(0);c[g+12>>2]=t;c[B>>2]=g}else{h=e;m=c[d+(b+24)>>2]|0;l=c[d+(b+12)>>2]|0;do{if((l|0)==(h|0)){i=d+(b+20)|0;p=c[i>>2]|0;if((p|0)==0){q=d+(b+16)|0;v=c[q>>2]|0;if((v|0)==0){C=0;break}else{D=v;E=q}}else{D=p;E=i}while(1){i=D+20|0;p=c[i>>2]|0;if((p|0)!=0){D=p;E=i;continue}i=D+16|0;p=c[i>>2]|0;if((p|0)==0){break}else{D=p;E=i}}if(E>>>0<a>>>0){aj()}else{c[E>>2]=0;C=D;break}}else{i=c[d+(b+8)>>2]|0;if(i>>>0<a>>>0){aj()}p=i+12|0;if((c[p>>2]|0)!=(h|0)){aj()}q=l+8|0;if((c[q>>2]|0)==(h|0)){c[p>>2]=l;c[q>>2]=i;C=l;break}else{aj()}}}while(0);if((m|0)==0){break}l=d+(b+28)|0;g=1216+(c[l>>2]<<2)|0;do{if((h|0)==(c[g>>2]|0)){c[g>>2]=C;if((C|0)!=0){break}c[229]=c[229]&~(1<<c[l>>2]);break L1883}else{if(m>>>0<(c[232]|0)>>>0){aj()}t=m+16|0;if((c[t>>2]|0)==(h|0)){c[t>>2]=C}else{c[m+20>>2]=C}if((C|0)==0){break L1883}}}while(0);if(C>>>0<(c[232]|0)>>>0){aj()}c[C+24>>2]=m;h=c[d+(b+16)>>2]|0;do{if((h|0)!=0){if(h>>>0<(c[232]|0)>>>0){aj()}else{c[C+16>>2]=h;c[h+24>>2]=C;break}}}while(0);h=c[d+(b+20)>>2]|0;if((h|0)==0){break}if(h>>>0<(c[232]|0)>>>0){aj()}else{c[C+20>>2]=h;c[h+24>>2]=C;break}}}while(0);c[n+4>>2]=A|1;c[n+A>>2]=A;if((n|0)!=(c[233]|0)){F=A;break}c[230]=A;return}else{c[y>>2]=z&-2;c[n+4>>2]=o|1;c[n+o>>2]=o;F=o}}while(0);o=F>>>3;if(F>>>0<256){z=o<<1;y=952+(z<<2)|0;C=c[228]|0;b=1<<o;do{if((C&b|0)==0){c[228]=C|b;G=y;H=952+(z+2<<2)|0}else{o=952+(z+2<<2)|0;d=c[o>>2]|0;if(d>>>0>=(c[232]|0)>>>0){G=d;H=o;break}aj()}}while(0);c[H>>2]=n;c[G+12>>2]=n;c[n+8>>2]=G;c[n+12>>2]=y;return}y=n;G=F>>>8;do{if((G|0)==0){I=0}else{if(F>>>0>16777215){I=31;break}H=(G+1048320|0)>>>16&8;z=G<<H;b=(z+520192|0)>>>16&4;C=z<<b;z=(C+245760|0)>>>16&2;o=14-(b|H|z)+(C<<z>>>15)|0;I=F>>>((o+7|0)>>>0)&1|o<<1}}while(0);G=1216+(I<<2)|0;c[n+28>>2]=I;c[n+20>>2]=0;c[n+16>>2]=0;o=c[229]|0;z=1<<I;if((o&z|0)==0){c[229]=o|z;c[G>>2]=y;c[n+24>>2]=G;c[n+12>>2]=n;c[n+8>>2]=n;return}if((I|0)==31){J=0}else{J=25-(I>>>1)|0}I=F<<J;J=c[G>>2]|0;while(1){if((c[J+4>>2]&-8|0)==(F|0)){break}K=J+16+(I>>>31<<2)|0;G=c[K>>2]|0;if((G|0)==0){L=1452;break}else{I=I<<1;J=G}}if((L|0)==1452){if(K>>>0<(c[232]|0)>>>0){aj()}c[K>>2]=y;c[n+24>>2]=J;c[n+12>>2]=n;c[n+8>>2]=n;return}K=J+8|0;L=c[K>>2]|0;I=c[232]|0;if(J>>>0<I>>>0){aj()}if(L>>>0<I>>>0){aj()}c[L+12>>2]=y;c[K>>2]=y;c[n+8>>2]=L;c[n+12>>2]=J;c[n+24>>2]=0;return}function bi(b){b=b|0;var c=0;c=b;while(a[c]|0){c=c+1|0}return c-b|0}function bj(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=b+e|0;if((e|0)>=20){d=d&255;e=b&3;g=d|d<<8|d<<16|d<<24;h=f&~3;if(e){e=b+4-e|0;while((b|0)<(e|0)){a[b]=d;b=b+1|0}}while((b|0)<(h|0)){c[b>>2]=g;b=b+4|0}}while((b|0)<(f|0)){a[b]=d;b=b+1|0}}function bk(b,d,e){b=b|0;d=d|0;e=e|0;var f=0;f=b|0;if((b&3)==(d&3)){while(b&3){if((e|0)==0)return f|0;a[b]=a[d]|0;b=b+1|0;d=d+1|0;e=e-1|0}while((e|0)>=4){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;e=e-4|0}}while((e|0)>0){a[b]=a[d]|0;b=b+1|0;d=d+1|0;e=e-1|0}return f|0}function bl(a,b){a=a|0;b=b|0;return aE[a&1](b|0)|0}function bm(a){a=a|0;aF[a&1]()}function bn(a,b,c){a=a|0;b=b|0;c=c|0;return aG[a&1](b|0,c|0)|0}function bo(a,b){a=a|0;b=b|0;aH[a&1](b|0)}function bp(a){a=a|0;_(0);return 0}function bq(){_(1)}function br(a,b){a=a|0;b=b|0;_(2);return 0}function bs(a){a=a|0;_(3)}\n          // EMSCRIPTEN_END_FUNCS\n          var aE=[bp,bp];var aF=[bq,bq];var aG=[br,br];var aH=[bs,bs];return{_strlen:bi,_crn_get_levels:a8,_crn_get_uncompressed_size:bb,_crn_decompress:bc,_crn_get_width:a6,_realloc:bg,_crn_get_bytes_per_block:ba,_memset:bj,_malloc:be,_memcpy:bk,_free:bf,_crn_get_height:a7,_crn_get_dxt_format:a9,runPostSets:aY,stackAlloc:aI,stackSave:aJ,stackRestore:aK,setThrew:aL,setTempRet0:aO,setTempRet1:aP,setTempRet2:aQ,setTempRet3:aR,setTempRet4:aS,setTempRet5:aT,setTempRet6:aU,setTempRet7:aV,setTempRet8:aW,setTempRet9:aX,dynCall_ii:bl,dynCall_v:bm,dynCall_iii:bn,dynCall_vi:bo}\n          // EMSCRIPTEN_END_ASM\n          })({Math:Math,Int8Array:Int8Array,Int16Array:Int16Array,Int32Array:Int32Array,Uint8Array:Uint8Array,Uint16Array:Uint16Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array},{abort:E,assert:A,asmPrintInt:function(a,b){s.print(\"int \"+a+\",\"+b)},asmPrintFloat:function(a,b){s.print(\"float \"+a+\",\"+b)},min:Ca,invoke_ii:function(a,b){try{return s.dynCall_ii(a,b)}catch(c){\"number\"!==typeof c&&\"longjmp\"!==c&&e(c),$.setThrew(1,0)}},invoke_v:function(a){try{s.dynCall_v(a)}catch(b){\"number\"!==\n          typeof b&&\"longjmp\"!==b&&e(b),$.setThrew(1,0)}},invoke_iii:function(a,b,c){try{return s.dynCall_iii(a,b,c)}catch(d){\"number\"!==typeof d&&\"longjmp\"!==d&&e(d),$.setThrew(1,0)}},invoke_vi:function(a,b){try{s.dynCall_vi(a,b)}catch(c){\"number\"!==typeof c&&\"longjmp\"!==c&&e(c),$.setThrew(1,0)}},_llvm_lifetime_end:q(),_snprintf:nb,_abort:function(){s.abort()},_fprintf:jc,_printf:function(a,b){return jc(K[Cb>>2],a,b)},_fflush:q(),__reallyNegative:lb,_sysconf:function(a){switch(a){case 30:return 4096;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 79:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;\n          case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;\n          case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1E3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return 1}S(R.u);return-1},___setErrNo:S,_fwrite:ic,_send:function(a,b,c){return!Z.ub(a)?\n          (S(R.ba),-1):hc(a,b,c)},_write:hc,_exit:function(a){mc(a)},_sprintf:function(a,b,c){return nb(a,j,b,c)},__formatString:mb,__ZSt9terminatev:function(){mc(-1234)},_pwrite:function(a,b,c,d){a=X[a];if(!a)return S(R.ba),-1;try{return ac(a,I,b,c,d)}catch(f){return Jb(f),-1}},_sbrk:nc,___errno_location:function(){return pb},___gxx_personality_v0:q(),_llvm_lifetime_start:q(),_time:function(a){var b=Math.floor(Date.now()/1E3);a&&(K[a>>2]=b);return b},__exit:mc,STACKTOP:x,STACK_MAX:Sa,tempDoublePtr:jb,ABORT:ua,\n          NaN:NaN,Infinity:Infinity},N),kb=s._strlen=$._strlen;s._crn_get_levels=$._crn_get_levels;s._crn_get_uncompressed_size=$._crn_get_uncompressed_size;s._crn_decompress=$._crn_decompress;s._crn_get_width=$._crn_get_width;s._realloc=$._realloc;s._crn_get_bytes_per_block=$._crn_get_bytes_per_block;var kc=s._memset=$._memset,Ka=s._malloc=$._malloc,lc=s._memcpy=$._memcpy;s._free=$._free;s._crn_get_height=$._crn_get_height;s._crn_get_dxt_format=$._crn_get_dxt_format;var ib=s.runPostSets=$.runPostSets;\n          s.dynCall_ii=$.dynCall_ii;s.dynCall_v=$.dynCall_v;s.dynCall_iii=$.dynCall_iii;s.dynCall_vi=$.dynCall_vi;oa=function(a){return $.stackAlloc(a)};ha=function(){return $.stackSave()};ia=function(a){$.stackRestore(a)};function Ec(a){this.name=\"ExitStatus\";this.message=\"Program terminated with exit(\"+a+\")\";this.status=a}Ec.prototype=Error();var Fc,Gc=m,fb=function Hc(){!s.calledRun&&Ic&&Jc();s.calledRun||(fb=Hc)};\n          s.callMain=s.Nd=function(a){function b(){for(var a=0;3>a;a++)d.push(0)}A(0==Q,\"cannot call main when async dependencies remain! (listen on __ATMAIN__)\");A(0==Va.length,\"cannot call main when preRun functions remain to be called\");a=a||[];ba&&Gc!==m&&s.P(\"preload time: \"+(Date.now()-Gc)+\" ms\");Za||(Za=l,Ua(O));var c=a.length+1,d=[L(H(\"/bin/this.program\"),\"i8\",0)];b();for(var f=0;f<c-1;f+=1)d.push(L(H(a[f]),\"i8\",0)),b();d.push(0);d=L(d,\"i32\",0);Fc=x;try{var h=s._main(c,d,0);s.noExitRuntime||Kc(h)}catch(g){g instanceof\n          Ec||(\"SimulateInfiniteLoop\"==g?s.noExitRuntime=l:(g&&(\"object\"===typeof g&&g.stack)&&s.P(\"exception thrown: \"+[g,g.stack]),e(g)))}finally{}};\n          function Jc(a){function b(){Za||(Za=l,Ua(O));Ua(Wa);s.calledRun=l;s._main&&Ic&&s.callMain(a);if(s.postRun)for(\"function\"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;)ab(s.postRun.shift());Ua(Ya)}a=a||s.arguments;Gc===m&&(Gc=Date.now());if(0<Q)s.P(\"run() called, but dependencies remain, so not running\");else{if(s.preRun)for(\"function\"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)$a(s.preRun.shift());Ua(Va);0<Q||(s.setStatus?(s.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){s.setStatus(\"\")},\n          1);ua||b()},1)):b())}}s.run=s.ge=Jc;function Kc(a){ua=l;x=Fc;Ua(Xa);e(new Ec(a))}s.exit=s.Rd=Kc;function E(a){a&&(s.print(a),s.P(a));ua=l;e(\"abort() at \"+Ma())}s.abort=s.abort=E;if(s.preInit)for(\"function\"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();var Ic=l;s.noInitialRun&&(Ic=p);Jc();\n        \n          return Module;\n        }\n        \n        // Using this \"namespace\" keeps our global scope clutter free and prevents other scripts from stomping on our variables.\n        var WebGLTextureUtil = (function() {\n        \n          \"use strict\";\n        \n          //============================//\n          // DXT constants and utilites //\n          //============================//\n        \n          // Utility functions\n          // Builds a numeric code for a given fourCC string\n          function fourCCToInt32(value) {\n            return value.charCodeAt(0) +\n              (value.charCodeAt(1) << 8) +\n              (value.charCodeAt(2) << 16) +\n              (value.charCodeAt(3) << 24);\n          }\n        \n          // Turns a fourCC numeric code into a string\n          function int32ToFourCC(value) {\n            return String.fromCharCode(\n              value & 0xff,\n              (value >> 8) & 0xff,\n              (value >> 16) & 0xff,\n              (value >> 24) & 0xff\n            );\n          }\n        \n          // Calcualates the size of a compressed texture level in bytes\n          function textureLevelSize(format, width, height) {\n            switch (format) {\n              case COMPRESSED_RGB_S3TC_DXT1_EXT:\n              case COMPRESSED_RGB_ATC_WEBGL:\n              case COMPRESSED_RGB_ETC1_WEBGL:\n                return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\n        \n              case COMPRESSED_RGBA_S3TC_DXT3_EXT:\n              case COMPRESSED_RGBA_S3TC_DXT5_EXT:\n              case COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:\n              case COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:\n                return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\n        \n              case COMPRESSED_RGB_PVRTC_4BPPV1_IMG:\n              case COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:\n                return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);\n        \n              case COMPRESSED_RGB_PVRTC_2BPPV1_IMG:\n              case COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:\n                return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);\n        \n              default:\n                return 0;\n            }\n          }\n        \n          // DXT formats, from:\n          // http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\n          var COMPRESSED_RGB_S3TC_DXT1_EXT  = 0x83F0;\n          var COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\n          var COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\n          var COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\n        \n          // ATC formats, from:\n          // http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_atc/\n          var COMPRESSED_RGB_ATC_WEBGL                     = 0x8C92;\n          var COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL     = 0x8C93;\n          var COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;\n        \n          // DXT values and structures referenced from:\n          // http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n          var DDS_MAGIC = 0x20534444;\n          var DDSD_MIPMAPCOUNT = 0x20000;\n          var DDPF_FOURCC = 0x4;\n        \n          var DDS_HEADER_LENGTH = 31; // The header length in 32 bit ints.\n        \n          // Offsets into the header array.\n          var DDS_HEADER_MAGIC = 0;\n        \n          var DDS_HEADER_SIZE = 1;\n          var DDS_HEADER_FLAGS = 2;\n          var DDS_HEADER_HEIGHT = 3;\n          var DDS_HEADER_WIDTH = 4;\n        \n          var DDS_HEADER_MIPMAPCOUNT = 7;\n        \n          var DDS_HEADER_PF_FLAGS = 20;\n          var DDS_HEADER_PF_FOURCC = 21;\n        \n          // FourCC format identifiers.\n          var FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n          var FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n          var FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n        \n          var FOURCC_ATC = fourCCToInt32(\"ATC \");\n          var FOURCC_ATCA = fourCCToInt32(\"ATCA\");\n          var FOURCC_ATCI = fourCCToInt32(\"ATCI\");\n        \n          //==================//\n          // Crunch constants //\n          //==================//\n        \n          // Taken from crnlib.h\n          var CRN_FORMAT = {\n            cCRNFmtInvalid: -1,\n        \n            cCRNFmtDXT1: 0,\n            // cCRNFmtDXT3 is not currently supported when writing to CRN - only DDS.\n            cCRNFmtDXT3: 1,\n            cCRNFmtDXT5: 2\n        \n            // Crunch supports more formats than this, but we can't use them here.\n          };\n        \n          // Mapping of Crunch formats to DXT formats.\n          var DXT_FORMAT_MAP = {};\n          DXT_FORMAT_MAP[CRN_FORMAT.cCRNFmtDXT1] = COMPRESSED_RGB_S3TC_DXT1_EXT;\n          DXT_FORMAT_MAP[CRN_FORMAT.cCRNFmtDXT3] = COMPRESSED_RGBA_S3TC_DXT3_EXT;\n          DXT_FORMAT_MAP[CRN_FORMAT.cCRNFmtDXT5] = COMPRESSED_RGBA_S3TC_DXT5_EXT;\n        \n          //===============//\n          // PVR constants //\n          //===============//\n        \n          // PVR formats, from:\n          // http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\n          var COMPRESSED_RGB_PVRTC_4BPPV1_IMG  = 0x8C00;\n          var COMPRESSED_RGB_PVRTC_2BPPV1_IMG  = 0x8C01;\n          var COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\n          var COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\n        \n          // ETC1 format, from:\n          // http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/\n          var COMPRESSED_RGB_ETC1_WEBGL = 0x8D64;\n        \n          var PVR_FORMAT_2BPP_RGB  = 0;\n          var PVR_FORMAT_2BPP_RGBA = 1;\n          var PVR_FORMAT_4BPP_RGB  = 2;\n          var PVR_FORMAT_4BPP_RGBA = 3;\n          var PVR_FORMAT_ETC1      = 6;\n          var PVR_FORMAT_DXT1      = 7;\n          var PVR_FORMAT_DXT3      = 9;\n          var PVR_FORMAT_DXT5      = 5;\n        \n          var PVR_HEADER_LENGTH = 13; // The header length in 32 bit ints.\n          var PVR_MAGIC = 0x03525650; //0x50565203;\n        \n          // Offsets into the header array.\n          var PVR_HEADER_MAGIC = 0;\n          var PVR_HEADER_FORMAT = 2;\n          var PVR_HEADER_HEIGHT = 6;\n          var PVR_HEADER_WIDTH = 7;\n          var PVR_HEADER_MIPMAPCOUNT = 11;\n          var PVR_HEADER_METADATA = 12;\n        \n          //============//\n          // Misc Utils //\n          //============//\n        \n          // When an error occurs set the texture to a 1x1 black pixel\n          // This prevents WebGL errors from attempting to use unrenderable textures\n          // and clears out stale data if we're re-using a texture.\n          function clearOnError(gl, error, texture, callback) {\n            console.error(error);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0]));\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        \n            // Notify the user that an error occurred and the texture is ready.\n            if (callback) { callback(texture, error, null); }\n          }\n        \n          function isPowerOfTwo(n) {\n            return (n & (n - 1)) === 0;\n          }\n        \n          function getExtension(gl, name) {\n            var vendorPrefixes = [\"\", \"WEBKIT_\", \"MOZ_\"];\n            var ext = null;\n            for (var i in vendorPrefixes) {\n              ext = gl.getExtension(vendorPrefixes[i] + name);\n              if (ext) { break; }\n            }\n            return ext;\n          }\n        \n          //==================//\n          // DDS File Reading //\n          //==================//\n        \n          // Parse a DDS file and provide information about the raw DXT data it contains to the given callback.\n          function parseDDS(arrayBuffer, callback, errorCallback) {\n            // Callbacks must be provided.\n            if (!callback || !errorCallback) { return; }\n        \n            // Get a view of the arrayBuffer that represents the DDS header.\n            var header = new Int32Array(arrayBuffer, 0, DDS_HEADER_LENGTH);\n        \n            // Do some sanity checks to make sure this is a valid DDS file.\n            if(header[DDS_HEADER_MAGIC] != DDS_MAGIC) {\n              errorCallback(\"Invalid magic number in DDS header\");\n              return 0;\n            }\n        \n            if(!header[DDS_HEADER_PF_FLAGS] & DDPF_FOURCC) {\n              errorCallback(\"Unsupported format, must contain a FourCC code\");\n              return 0;\n            }\n        \n            // Determine what type of compressed data the file contains.\n            var fourCC = header[DDS_HEADER_PF_FOURCC];\n            var internalFormat;\n            switch(fourCC) {\n              case FOURCC_DXT1:\n                internalFormat = COMPRESSED_RGB_S3TC_DXT1_EXT;\n                break;\n        \n              case FOURCC_DXT3:\n                internalFormat = COMPRESSED_RGBA_S3TC_DXT3_EXT;\n                break;\n        \n              case FOURCC_DXT5:\n                internalFormat = COMPRESSED_RGBA_S3TC_DXT5_EXT;\n                break;\n        \n              case FOURCC_ATC:\n                internalFormat = COMPRESSED_RGB_ATC_WEBGL;\n                break;\n        \n              case FOURCC_ATCA:\n                internalFormat = COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL;\n                break;\n        \n              case FOURCC_ATCI:\n                internalFormat = COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;\n                break;\n        \n        \n              default:\n                errorCallback(\"Unsupported FourCC code: \" + int32ToFourCC(fourCC));\n                return;\n            }\n        \n            // Determine how many mipmap levels the file contains.\n            var levels = 1;\n            if(header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) {\n              levels = Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]);\n            }\n        \n            // Gather other basic metrics and a view of the raw the DXT data.\n            var width = header[DDS_HEADER_WIDTH];\n            var height = header[DDS_HEADER_HEIGHT];\n            var dataOffset = header[DDS_HEADER_SIZE] + 4;\n            var dxtData = new Uint8Array(arrayBuffer, dataOffset);\n        \n            // Pass the DXT information to the callback for uploading.\n            callback(dxtData, width, height, levels, internalFormat);\n          }\n        \n          //==================//\n          // PVR File Reading //\n          //==================//\n        \n          // Parse a PVR file and provide information about the raw texture data it contains to the given callback.\n          function parsePVR(arrayBuffer, callback, errorCallback) {\n            // Callbacks must be provided.\n            if (!callback || !errorCallback) { return; }\n        \n            // Get a view of the arrayBuffer that represents the DDS header.\n            var header = new Int32Array(arrayBuffer, 0, PVR_HEADER_LENGTH);\n        \n            // Do some sanity checks to make sure this is a valid DDS file.\n            if(header[PVR_HEADER_MAGIC] != PVR_MAGIC) {\n              errorCallback(\"Invalid magic number in PVR header\");\n              return 0;\n            }\n        \n            // Determine what type of compressed data the file contains.\n            var format = header[PVR_HEADER_FORMAT];\n            var internalFormat;\n            switch(format) {\n              case PVR_FORMAT_2BPP_RGB:\n                internalFormat = COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n                break;\n        \n              case PVR_FORMAT_2BPP_RGBA:\n                internalFormat = COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n                break;\n        \n              case PVR_FORMAT_4BPP_RGB:\n                internalFormat = COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n                break;\n        \n              case PVR_FORMAT_4BPP_RGBA:\n                internalFormat = COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n                break;\n        \n              case PVR_FORMAT_ETC1:\n                internalFormat = COMPRESSED_RGB_ETC1_WEBGL;\n                break;\n        \n              case PVR_FORMAT_DXT1:\n                internalFormat = COMPRESSED_RGB_S3TC_DXT1_EXT;\n                break;\n        \n              case PVR_FORMAT_DXT3:\n                internalFormat = COMPRESSED_RGBA_S3TC_DXT3_EXT;\n                break;\n        \n              case PVR_FORMAT_DXT5:\n                internalFormat = COMPRESSED_RGBA_S3TC_DXT5_EXT;\n                break;\n        \n              default:\n                errorCallback(\"Unsupported PVR format: \" + format);\n                return;\n            }\n        \n            // Gather other basic metrics and a view of the raw the DXT data.\n            var width = header[PVR_HEADER_WIDTH];\n            var height = header[PVR_HEADER_HEIGHT];\n            var levels = header[PVR_HEADER_MIPMAPCOUNT];\n            var dataOffset = header[PVR_HEADER_METADATA] + 52;\n            var pvrtcData = new Uint8Array(arrayBuffer, dataOffset);\n        \n            // Pass the PVRTC information to the callback for uploading.\n            callback(pvrtcData, width, height, levels, internalFormat);\n          }\n        \n          //=====================//\n          // Crunch file reading //\n          //=====================//\n        \n          // Parse a crunch file and decompress the contained texture into raw DXT data, which is then passed to the callback.\n          var decompressCRN = (function() {\n            // Variables which are cached between calls to the function, hidden here with some function scoping tricks.\n            var dst = null;\n            var dxtData = null;\n            var cachedDstSize = 0;\n        \n            // The emscripten module.\n            var Module = null;\n        \n            // Copy an array of bytes into or out of the emscripten heap.\n            function arrayBufferCopy(src, dst, dstByteOffset, numBytes) {\n              var i;\n              var dst32Offset = dstByteOffset / 4;\n              var tail = (numBytes % 4);\n              var src32 = new Uint32Array(src.buffer, 0, (numBytes - tail) / 4);\n              var dst32 = new Uint32Array(dst.buffer);\n              for (i = 0; i < src32.length; i++) {\n                dst32[dst32Offset + i] = src32[i];\n              }\n              for (i = numBytes - tail; i < numBytes; i++) {\n                dst[dstByteOffset + i] = src[i];\n              }\n            }\n        \n            // This is the actual function that is executed when you call decompressCRN.\n            return function(arrayBuffer, callback, errorCallback) {\n              // Callbacks must be provided.\n              if (!callback || !errorCallback) { return; }\n        \n              // If the emscripten module has not been loaded yet do so now.\n              // Executes the massive code blob at the top of the file.\n              if (!Module) {\n                Module = LoadCrunchDecoder();\n              }\n        \n              // Copy the contents of the arrayBuffer into emscriptens heap.\n              var srcSize = arrayBuffer.byteLength;\n              var bytes = new Uint8Array(arrayBuffer);\n              var src = Module._malloc(srcSize);\n              arrayBufferCopy(bytes, Module.HEAPU8, src, srcSize);\n        \n              // Determine what type of compressed data the file contains.\n              var format = Module._crn_get_dxt_format(src, srcSize);\n              if (!DXT_FORMAT_MAP[format]) {\n                errorCallback(\"Unsupported DXT format\");\n                return;\n              }\n        \n              // Gather basic metrics about the DXT data.\n              var levels = Module._crn_get_levels(src, srcSize);\n              var width = Module._crn_get_width(src, srcSize);\n              var height = Module._crn_get_height(src, srcSize);\n              //var bytesPerBlock = Module._crn_get_bytes_per_block(src, srcSize);\n        \n              // Determine the size of the decoded DXT data.\n              var dstSize = 0;\n              var i;\n              for (i = 0; i < levels; ++i) {\n                dstSize += textureLevelSize(DXT_FORMAT_MAP[format], width >> i, height >> i);\n              }\n        \n              // Allocate enough space on the emscripten heap to hold the decoded DXT data\n              // or reuse the existing allocation if a previous call to this function has\n              // already acquired a large enough buffer.\n              if(cachedDstSize < dstSize) {\n                if(dst) { Module._free(dst); }\n                dst = Module._malloc(dstSize);\n                dxtData = new Uint8Array(Module.HEAPU8.buffer, dst, dstSize);\n                cachedDstSize = dstSize;\n              }\n        \n              // Decompress the DXT data from the Crunch file into the allocated space.\n              Module._crn_decompress(src, srcSize, dst, dstSize, 0, levels);\n        \n              // Release the crunch file data from the emscripten heap.\n              Module._free(src);\n        \n              // Pass the DXT information to the callback for uploading.\n              callback(dxtData, width, height, levels, DXT_FORMAT_MAP[format]);\n            };\n          })();\n        \n          //=============//\n          // IMG loading //\n          //=============//\n        \n          /*\n          This function provides a method for loading webgl textures using a pool of\n          image elements, which has very low memory overhead. For more details see:\n          http://blog.tojicode.com/2012/03/javascript-memory-optimization-and.html\n          */\n          var loadImgTexture = (function createTextureLoader() {\n            var MAX_CACHE_IMAGES = 16;\n        \n            var textureImageCache = new Array(MAX_CACHE_IMAGES);\n            var cacheTop = 0;\n            var remainingCacheImages = MAX_CACHE_IMAGES;\n            var pendingTextureRequests = [];\n        \n            var TextureImageLoader = function(loadedCallback) {\n              var self = this;\n              var blackPixel = new Uint8Array([0, 0, 0]);\n        \n              this.gl = null;\n              this.texture = null;\n              this.callback = null;\n        \n              this.image = new Image();\n              this.image.addEventListener('load', function() {\n                var gl = self.gl;\n                gl.bindTexture(gl.TEXTURE_2D, self.texture);\n        \n                var startTime = Date.now();\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, self.image);\n        \n                if (isPowerOfTwo(self.image.width) && isPowerOfTwo(self.image.height)) {\n                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n                  gl.generateMipmap(gl.TEXTURE_2D);\n                } else {\n                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                }\n                var uploadTime = Date.now() - startTime;\n        \n                if(self.callback) {\n                  var stats = {\n                    width: self.image.width,\n                    height: self.image.height,\n                    internalFormat: gl.RGBA,\n                    levelZeroSize: self.image.width * self.image.height * 4,\n                    uploadTime: uploadTime\n                  };\n                  self.callback(self.texture, null, stats);\n                }\n                loadedCallback(self);\n              }, false);\n              this.image.addEventListener('error', function(ev) {\n                clearOnError(self.gl, 'Image could not be loaded', self.texture, self.callback);\n                loadedCallback(self);\n              }, false);\n            };\n        \n            TextureImageLoader.prototype.loadTexture = function(gl, src, texture, callback) {\n              this.gl = gl;\n              this.texture = texture;\n              this.callback = callback;\n              this.image.src = src;\n            };\n        \n            var PendingTextureRequest = function(gl, src, texture, callback) {\n              this.gl = gl;\n              this.src = src;\n              this.texture = texture;\n              this.callback = callback;\n            };\n        \n            function releaseTextureImageLoader(til) {\n              var req;\n              if(pendingTextureRequests.length) {\n                req = pendingTextureRequests.shift();\n                til.loadTexture(req.gl, req.src, req.texture, req.callback);\n              } else {\n                textureImageCache[cacheTop++] = til;\n              }\n            }\n        \n            return function(gl, src, texture, callback) {\n              var til;\n        \n              if(cacheTop) {\n                til = textureImageCache[--cacheTop];\n                til.loadTexture(gl, src, texture, callback);\n              } else if (remainingCacheImages) {\n                til = new TextureImageLoader(releaseTextureImageLoader);\n                til.loadTexture(gl, src, texture, callback);\n                --remainingCacheImages;\n              } else {\n                pendingTextureRequests.push(new PendingTextureRequest(gl, src, texture, callback));\n              }\n        \n              return texture;\n            };\n          })();\n        \n          // Detect if we are executing in a worker process.\n          if (window.document === undefined) {\n        \n            //===============//\n            // Crunch Worker //\n            //===============//\n        \n            // Worker message handler\n            onmessage = function(msg) {\n              // Calls to the worker contain a URL to load and the associated pending texture ID.\n              var src = msg.data.src;\n              var id = msg.data.id;\n        \n              // Notifies the main thread that DXT data is ready.\n              function uploadCallback(dxtData, width, height, levels, internalFormat) {\n                postMessage({\n                  id: id,\n                  dxtData: dxtData,\n                  width: width,\n                  height: height,\n                  levels: levels,\n                  internalFormat: internalFormat\n                });\n              }\n        \n              // Notifies the main thread that an error has occured.\n              function errorCallback(error) {\n                postMessage({\n                  id: id,\n                  error: error\n                });\n              }\n        \n              // Load the file via XHR\n              var xhr = new XMLHttpRequest();\n              xhr.addEventListener('load', function (ev) {\n                if (xhr.status == 200) {\n                  // If the file loaded successfully parse and decompress it.\n                  decompressCRN(xhr.response, uploadCallback, errorCallback);\n                } else {\n                  errorCallback(xhr.statusText);\n                }\n              }, false);\n              xhr.open('GET', \"../\" + src, true);\n              xhr.responseType = 'arraybuffer';\n              xhr.send(null);\n            };\n          } else {\n        \n            //=====================//\n            // TextureLoader Class //\n            //=====================//\n        \n            var nextPendingTextureId = 0;\n            var CrunchPendingTexture = function(texture, callback) {\n              this.id = nextPendingTextureId++;\n              this.texture = texture;\n              this.callback = callback;\n            }\n        \n            var useWorker = true;\n        \n            // This class is our public interface.\n            var TextureLoader = function(gl) {\n              this.gl = gl;\n              this.worker = null;\n        \n              // Load the compression format extensions, if available\n              this.dxtExt = getExtension(gl, \"WEBGL_compressed_texture_s3tc\");\n              this.pvrtcExt = getExtension(gl, \"WEBGL_compressed_texture_pvrtc\");\n              this.atcExt = getExtension(gl, \"WEBGL_compressed_texture_atc\");\n              this.etc1Ext = getExtension(gl, \"WEBGL_compressed_texture_etc1\");\n        \n              if (!!useWorker && this.supportsDXT()) {\n                var self = this;\n        \n                // When using a worker process we must keep track of the pending texture\n                // loads so that we can correctly correlate the DXT data to the desired\n                // texture when the worker completes.\n                this.pendingTextures = {};\n        \n                // Reload this file as a worker.\n                this.worker = new Worker(\"lib/webgl-texture-util.js\");\n        \n                // The worker's message handler.\n                this.worker.onmessage = function(msg) {\n                  // Find the pending texture associated with the data we just received\n                  // from the worker.\n                  var id = msg.data.id;\n                  var pt = self.pendingTextures[id];\n                  if (!pt) { return; }\n        \n                  // Remove the pending texture from the waiting list.\n                  delete self.pendingTextures[id];\n        \n                  // If the worker indicated an error has occured handle it now.\n                  if (msg.data.error) {\n                    clearOnError(self.gl, msg.data.error, pt.texture, pt.callback);\n                    return;\n                  }\n        \n                  if (!self._formatSupported(msg.data.internalFormat)) {\n                    clearOnError(self.gl, \"Texture format not supported\", pt.texture, pt.callback);\n                    return;\n                  }\n        \n                  // Upload the DXT data returned by the worker.\n                  self._uploadCompressedData(\n                      new Uint8Array(msg.data.dxtData),\n                      msg.data.width,\n                      msg.data.height,\n                      msg.data.levels,\n                      msg.data.internalFormat,\n                      pt.texture,\n                      pt.callback);\n                };\n              }\n            }\n        \n            // Returns whether or not the compressed format is supported by the WebGL implementation\n            TextureLoader.prototype._formatSupported = function(format) {\n              switch (format) {\n                case COMPRESSED_RGB_S3TC_DXT1_EXT:\n                case COMPRESSED_RGBA_S3TC_DXT3_EXT:\n                case COMPRESSED_RGBA_S3TC_DXT5_EXT:\n                  return !!this.dxtExt;\n        \n                case COMPRESSED_RGB_PVRTC_4BPPV1_IMG:\n                case COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:\n                case COMPRESSED_RGB_PVRTC_2BPPV1_IMG:\n                case COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:\n                  return !!this.pvrtcExt;\n        \n                case COMPRESSED_RGB_ATC_WEBGL:\n                case COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:\n                case COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:\n                  return !!this.atcExt;\n        \n                case COMPRESSED_RGB_ETC1_WEBGL:\n                  return !!this.etc1Ext;\n        \n                default:\n                  return false;\n              }\n            }\n        \n            // Uploads compressed texture data to the GPU.\n            TextureLoader.prototype._uploadCompressedData = function(data, width, height, levels, internalFormat, texture, callback) {\n              var gl = this.gl;\n              gl.bindTexture(gl.TEXTURE_2D, texture);\n        \n              var offset = 0;\n        \n              var stats = {\n                width: width,\n                height: height,\n                internalFormat: internalFormat,\n                levelZeroSize: textureLevelSize(internalFormat, width, height),\n                uploadTime: 0\n              };\n        \n              var startTime = Date.now();\n              // Loop through each mip level of compressed texture data provided and upload it to the given texture.\n              for (var i = 0; i < levels; ++i) {\n                \n                \n        \n                // Determine how big this level of compressed texture data is in bytes.\n                var levelSize = textureLevelSize(internalFormat, width, height);\n                // Get a view of the bytes for this level of DXT data.\n                var dxtLevel = new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);\n                // Upload!\n                gl.compressedTexImage2D(gl.TEXTURE_2D, i, internalFormat, width, height, 0, dxtLevel);\n                // The next mip level will be half the height and width of this one.\n                width = width >> 1;\n                height = height >> 1;\n                // Advance the offset into the compressed texture data past the current mip level's data.\n                offset += levelSize;\n              }\n              stats.uploadTime = Date.now() - startTime;\n        \n              // We can't use gl.generateMipmaps with compressed textures, so only use\n              // mipmapped filtering if the compressed texture data contained mip levels.\n              if (levels > 1) {\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n              } else {\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n              }\n        \n              // Notify the user that the texture is ready.\n              if (callback) { callback(texture, null, stats); }\n            }\n        \n            TextureLoader.prototype.supportsDXT = function() {\n              return !!this.dxtExt;\n            }\n        \n            TextureLoader.prototype.supportsPVRTC = function() {\n              return !!this.pvrtcExt;\n            }\n        \n            TextureLoader.prototype.supportsATC = function() {\n              return !!this.atcExt;\n            }\n        \n            TextureLoader.prototype.supportsETC1 = function() {\n              return !!this.etc1Ext;\n            }\n        \n            // Loads a image file into the given texture.\n            // Supports any format that can be loaded into an img tag\n            // If no texture is provided one is created and returned.\n            TextureLoader.prototype.loadIMG = function(src, texture, callback) {\n              if(!texture) {\n                texture = this.gl.createTexture();\n              }\n        \n              loadImgTexture(gl, src, texture, callback);\n        \n              return texture;\n            }\n        \n            // Loads a DDS file into the given texture.\n            // If no texture is provided one is created and returned.\n            TextureLoader.prototype.loadDDS = function(src, texture, callback) {\n              console.log(src);\n              var self = this;\n              if (!texture) {\n                texture = this.gl.createTexture();\n              }\n        \n              // Load the file via XHR.\n              var xhr = new XMLHttpRequest();\n              xhr.addEventListener('load', function (ev) {\n                if (xhr.status == 200) {\n                  // If the file loaded successfully parse it.\n                  parseDDS(xhr.response, function(dxtData, width, height, levels, internalFormat) {\n                    if (!self._formatSupported(internalFormat)) {\n                      clearOnError(self.gl, \"Texture format not supported\", texture, callback);\n                      return;\n                    }\n                    // Upload the parsed DXT data to the texture.\n                    self._uploadCompressedData(dxtData, width, height, levels, internalFormat, texture, callback);\n                  }, function(error) {\n                    clearOnError(self.gl, error, texture, callback);\n                  });\n                } else {\n                  clearOnError(self.gl, xhr.statusText, texture, callback);\n                }\n              }, false);\n              xhr.open('GET', src, true);\n              xhr.responseType = 'arraybuffer';\n              xhr.send(null);\n        \n              return texture;\n            }\n        \n            // Loads a CRN (Crunch) file into the given texture.\n            // If no texture is provided one is created and returned.\n            TextureLoader.prototype.loadCRN = function(src, texture, callback) {\n              var self = this;\n              if (!texture) {\n                texture = this.gl.createTexture();\n              }\n        \n              if (!this.supportsDXT()) {\n                clearOnError(this.gl, \"Texture format not supported\", texture, callback);\n                return texture;\n              }\n        \n              if(this.worker) {\n                // If we're using a worker to handle the decoding create a pending texture\n                // and put it on the waiting list.\n                var pending = new CrunchPendingTexture(texture, callback);\n                this.pendingTextures[pending.id] = pending;\n                // Then tell the worker to load the CRN file.\n                this.worker.postMessage({id: pending.id, src: src});\n              } else {\n                // Load the file via XHR.\n                var xhr = new XMLHttpRequest();\n                xhr.addEventListener('load', function (ev) {\n                  if (xhr.status == 200) {\n                    // If the file loaded successfully parse and decompress it.\n                    decompressCRN(xhr.response, function(dxtData, width, height, levels, internalFormat) {\n                      if (!self._formatSupported(internalFormat)) {\n                        clearOnError(self.gl, \"Texture format not supported\", texture, callback);\n                        return;\n                      }\n                      // Upload the parsed and decompressed DXT data to the texture.\n                      self._uploadCompressedData(dxtData, width, height, levels, internalFormat, texture, callback);\n                    }, function(error) {\n                      clearOnError(self.gl, error, texture, callback);\n                    });\n                  } else {\n                    clearOnError(self.gl, xhr.statusText, texture, callback);\n                  }\n                }, false);\n                xhr.open('GET', src, true);\n                xhr.responseType = 'arraybuffer';\n                xhr.send(null);\n              }\n        \n              return texture;\n            }\n        \n            // Loads a PVR file into the given texture.\n            // If no texture is provided one is created and returned.\n            TextureLoader.prototype.loadPVR = function(src, texture, callback) {\n              var self = this;\n              if(!texture) {\n                texture = this.gl.createTexture();\n              }\n        \n              // Load the file via XHR.\n              var xhr = new XMLHttpRequest();\n              xhr.addEventListener('load', function (ev) {\n                if (xhr.status == 200) {\n                  // If the file loaded successfully parse it.\n                  parsePVR(xhr.response, function(dxtData, width, height, levels, internalFormat) {\n                    if (!self._formatSupported(internalFormat)) {\n                      clearOnError(self.gl, \"Texture format not supported\", texture, callback);\n                      return;\n                    }\n                    // Upload the parsed PVR data to the texture.\n                    self._uploadCompressedData(dxtData, width, height, levels, internalFormat, texture, callback);\n                  }, function(error) {\n                    clearOnError(self.gl, error, texture, callback);\n                  });\n                } else {\n                  clearOnError(self.gl, xhr.statusText, texture, callback);\n                }\n              }, false);\n              xhr.open('GET', src, true);\n              xhr.responseType = 'arraybuffer';\n              xhr.send(null);\n        \n              return texture;\n            }\n        \n            // Loads a texture from a file. Guesses the type based on extension.\n            // If no texture is provided one is created and returned.\n            TextureLoader.prototype.loadTexture = function(src, texture, callback) {\n              // Shamelessly lifted from StackOverflow :)\n              // http://stackoverflow.com/questions/680929\n              var re = /(?:\\.([^.]+))?$/;\n              var ext = re.exec(src)[1] || '';\n              ext = ext.toLowerCase();\n        \n              switch(ext) {\n                case 'crn':\n                  return this.loadCRN(src, texture, callback);\n                case 'dds':\n                  return this.loadDDS(src, texture, callback);\n                case 'pvr':\n                  return this.loadPVR(src, texture, callback);\n                default:\n                  return this.loadIMG(src, texture, callback);\n              }\n            }\n        \n            // Sets a texture to a solid RGBA color\n            // If no texture is provided one is created and returned.\n            TextureLoader.prototype.makeSolidColor = function(r, g, b, a, texture) {\n              var gl = this.gl;\n              var data = new Uint8Array([r, g, b, a]);\n              if(!texture) {\n                texture = gl.createTexture();\n              }\n              gl.bindTexture(gl.TEXTURE_2D, texture);\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n              return texture;\n            }\n        \n            return TextureLoader;\n          }\n        })();\n        \n        ";
            return textureutil;
        }());
        framework.textureutil = textureutil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var PrimitiveType;
        (function (PrimitiveType) {
            PrimitiveType[PrimitiveType["Sphere"] = 0] = "Sphere";
            PrimitiveType[PrimitiveType["Capsule"] = 1] = "Capsule";
            PrimitiveType[PrimitiveType["Cylinder"] = 2] = "Cylinder";
            PrimitiveType[PrimitiveType["Cube"] = 3] = "Cube";
            PrimitiveType[PrimitiveType["Plane"] = 4] = "Plane";
            PrimitiveType[PrimitiveType["Quad"] = 5] = "Quad";
            PrimitiveType[PrimitiveType["Pyramid"] = 6] = "Pyramid";
        })(PrimitiveType = framework.PrimitiveType || (framework.PrimitiveType = {}));
        var Primitive2DType;
        (function (Primitive2DType) {
            Primitive2DType[Primitive2DType["RawImage2D"] = 0] = "RawImage2D";
            Primitive2DType[Primitive2DType["Image2D"] = 1] = "Image2D";
            Primitive2DType[Primitive2DType["Label"] = 2] = "Label";
            Primitive2DType[Primitive2DType["Button"] = 3] = "Button";
        })(Primitive2DType = framework.Primitive2DType || (framework.Primitive2DType = {}));
        var TransformUtil = (function () {
            function TransformUtil() {
            }
            TransformUtil.CreatePrimitive = function (type, app) {
                var objName = PrimitiveType[type];
                var trans = new framework.transform();
                trans.name = objName;
                var mesh = trans.gameObject.addComponent("meshFilter");
                var smesh = app.getAssetMgr().getDefaultMesh(objName.toLowerCase());
                mesh.mesh = smesh;
                var renderer = trans.gameObject.addComponent("meshRenderer");
                renderer.materials = [];
                renderer.materials.push(new framework.material());
                renderer.materials[0].setShader(app.getAssetMgr().getShader("shader/def"));
                return trans;
            };
            TransformUtil.Create2DPrimitive = function (type, app) {
                var objName = Primitive2DType[type];
                var componentName = framework.StringUtil.firstCharToLowerCase(objName);
                var t2d = new framework.transform2D();
                t2d.name = objName;
                var i2dComp = t2d.addComponent(componentName);
                t2d.pivot.x = 0;
                t2d.pivot.y = 0;
                switch (type) {
                    case Primitive2DType.RawImage2D:
                        TransformUtil.create2D_rawImage(i2dComp, app);
                        break;
                    case Primitive2DType.Image2D:
                        TransformUtil.create2D_image2D(i2dComp, app);
                        break;
                    case Primitive2DType.Label:
                        TransformUtil.create2D_label(i2dComp, app);
                        break;
                    case Primitive2DType.Button:
                        TransformUtil.create2D_button(i2dComp, app);
                        break;
                }
                return t2d;
            };
            TransformUtil.create2D_rawImage = function (img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.image = app.getAssetMgr().getDefaultTexture("white");
            };
            TransformUtil.create2D_image2D = function (img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
            };
            TransformUtil.create2D_label = function (label, app) {
                label.transform.width = 150;
                label.transform.height = 50;
                label.text = "label";
                label.fontsize = 25;
                label.color = new gd3d.math.color(1, 0, 0, 1);
                var _font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                if (_font == null) {
                    app.getAssetMgr().load("res/STXINGKA.TTF.png", gd3d.framework.AssetTypeEnum.Auto, function (s) {
                        if (s.isfinish) {
                            app.getAssetMgr().load("res/resources/STXINGKA.font.json", gd3d.framework.AssetTypeEnum.Auto, function (s1) {
                                label.font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                                label.transform.markDirty();
                            });
                        }
                    });
                }
                else {
                    label.font = _font;
                    ;
                    label.transform.markDirty();
                }
            };
            TransformUtil.create2D_button = function (btn, app) {
                btn.transform.width = 150;
                btn.transform.height = 50;
                var img = btn.transform.addComponent("image2D");
                img.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
                img.imageType = gd3d.framework.ImageType.Sliced;
                btn.targetImage = img;
                btn.transition = gd3d.framework.TransitionType.ColorTint;
                var lab = new gd3d.framework.transform2D();
                lab.name = "label";
                lab.width = 150;
                lab.height = 50;
                lab.pivot.x = 0;
                lab.pivot.y = 0;
                lab.localTranslate.y = -10;
                var label = lab.addComponent("label");
                label.text = "button";
                label.fontsize = 25;
                label.color = new gd3d.math.color(1, 0, 0, 1);
                btn.transform.addChild(lab);
                var _font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                if (_font == null) {
                    app.getAssetMgr().load("res/STXINGKA.TTF.png", gd3d.framework.AssetTypeEnum.Auto, function (s) {
                        if (s.isfinish) {
                            app.getAssetMgr().load("res/resources/STXINGKA.font.json", gd3d.framework.AssetTypeEnum.Auto, function (s1) {
                                label.font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                                btn.transform.markDirty();
                            });
                        }
                    });
                }
                else {
                    label.font = _font;
                    ;
                    btn.transform.markDirty();
                }
            };
            return TransformUtil;
        }());
        framework.TransformUtil = TransformUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var WebGLDebugUtils = (function () {
            function WebGLDebugUtils() {
                this.glEnums = null;
            }
            WebGLDebugUtils.prototype.log = function (msg) {
                if (window.console && window.console.log) {
                    window.console.log(msg);
                }
            };
            WebGLDebugUtils.prototype.init = function (ctx) {
                if (this.glEnums == null) {
                    this.glEnums = {};
                    for (var propertyName in ctx) {
                        if (typeof ctx[propertyName] == 'number') {
                            this.glEnums[ctx[propertyName]] = propertyName;
                        }
                    }
                }
            };
            WebGLDebugUtils.prototype.checkInit = function () {
                if (this.glEnums == null) {
                    throw 'WebGLDebugUtils.init(ctx) not called';
                }
            };
            WebGLDebugUtils.prototype.mightBeEnum = function (value) {
                this.checkInit();
                return (this.glEnums[value] !== undefined);
            };
            WebGLDebugUtils.prototype.glEnumToString = function (value) {
                this.checkInit();
                var name = this.glEnums[value];
                return (name !== undefined) ? name :
                    ("*UNKNOWN WebGL ENUM (0x" + value.toString(16) + ")");
            };
            WebGLDebugUtils.prototype.glFunctionArgToString = function (functionName, argumentIndex, value) {
                var funcInfo = WebGLDebugUtils.glValidEnumContexts[functionName];
                if (funcInfo !== undefined) {
                    if (funcInfo[argumentIndex]) {
                        return this.glEnumToString(value);
                    }
                }
                return value.toString();
            };
            WebGLDebugUtils.prototype.makeDebugContext = function (ctx, opt_onErrorFunc) {
                var _this = this;
                if (opt_onErrorFunc === void 0) { opt_onErrorFunc = null; }
                this.init(ctx);
                opt_onErrorFunc = opt_onErrorFunc ||
                    (function (err, functionName, args) {
                        var argStr = "";
                        for (var ii = 0; ii < args.length; ++ii) {
                            argStr += ((ii == 0) ? '' : ', ') +
                                _this.glFunctionArgToString(functionName, ii, args[ii]);
                        }
                        console.error("WebGL error " + _this.glEnumToString(err) + " in " + functionName +
                            "(" + argStr + ")");
                    });
                var glErrorShadow = {};
                function makeErrorWrapper(ctx, functionName) {
                    return function () {
                        var result = ctx[functionName].apply(ctx, arguments);
                        var err = ctx.getError();
                        if (err != 0) {
                            glErrorShadow[err] = true;
                            opt_onErrorFunc(err, functionName, arguments);
                        }
                        return result;
                    };
                }
                var wrapper = {};
                for (var propertyName in ctx) {
                    if (typeof ctx[propertyName] == 'function') {
                        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
                    }
                    else {
                        wrapper[propertyName] = ctx[propertyName];
                    }
                }
                wrapper["getError"] = function () {
                    for (var err in glErrorShadow) {
                        if (glErrorShadow[err]) {
                            glErrorShadow[err] = false;
                            return err;
                        }
                    }
                    return ctx.NO_ERROR;
                };
                console.error(" i am ---makeDebugContext-");
                return wrapper;
            };
            WebGLDebugUtils.prototype.resetToInitialState = function (ctx) {
                var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
                var tmp = ctx.createBuffer();
                ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
                for (var ii = 0; ii < numAttribs; ++ii) {
                    ctx.disableVertexAttribArray(ii);
                    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
                    ctx.vertexAttrib1f(ii, 0);
                }
                ctx.deleteBuffer(tmp);
                var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
                for (var ii = 0; ii < numTextureUnits; ++ii) {
                    ctx.activeTexture(ctx.TEXTURE0 + ii);
                    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
                    ctx.bindTexture(ctx.TEXTURE_2D, null);
                }
                ctx.activeTexture(ctx.TEXTURE0);
                ctx.useProgram(null);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
                ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
                ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
                ctx.disable(ctx.BLEND);
                ctx.disable(ctx.CULL_FACE);
                ctx.disable(ctx.DEPTH_TEST);
                ctx.disable(ctx.DITHER);
                ctx.disable(ctx.SCISSOR_TEST);
                ctx.blendColor(0, 0, 0, 0);
                ctx.blendEquation(ctx.FUNC_ADD);
                ctx.blendFunc(ctx.ONE, ctx.ZERO);
                ctx.clearColor(0, 0, 0, 0);
                ctx.clearDepth(1);
                ctx.clearStencil(-1);
                ctx.colorMask(true, true, true, true);
                ctx.cullFace(ctx.BACK);
                ctx.depthFunc(ctx.LESS);
                ctx.depthMask(true);
                ctx.depthRange(0, 1);
                ctx.frontFace(ctx.CCW);
                ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
                ctx.lineWidth(1);
                ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
                ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
                    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
                }
                ctx.polygonOffset(0, 0);
                ctx.sampleCoverage(1, false);
                ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
                ctx.stencilMask(0xFFFFFFFF);
                ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
                ctx.viewport(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);
                ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);
                while (ctx.getError())
                    ;
            };
            WebGLDebugUtils.prototype.makeLostContextSimulatingContext = function (ctx) {
                var wrapper_ = {};
                var contextId_ = 1;
                var contextLost_ = false;
                var resourceId_ = 0;
                var resourceDb_ = [];
                var onLost_ = undefined;
                var onRestored_ = undefined;
                var nextOnRestored_ = undefined;
                var glErrorShadow_ = {};
                function isWebGLObject(obj) {
                    return (obj instanceof WebGLBuffer ||
                        obj instanceof WebGLFramebuffer ||
                        obj instanceof WebGLProgram ||
                        obj instanceof WebGLRenderbuffer ||
                        obj instanceof WebGLShader ||
                        obj instanceof WebGLTexture);
                }
                function checkResources(args) {
                    for (var ii = 0; ii < args.length; ++ii) {
                        var arg = args[ii];
                        if (isWebGLObject(arg)) {
                            return arg.__webglDebugContextLostId__ == contextId_;
                        }
                    }
                    return true;
                }
                function clearErrors() {
                    var k = Object.keys(glErrorShadow_);
                    for (var ii = 0; ii < k.length; ++ii) {
                        delete glErrorShadow_[k[ii]];
                    }
                }
                function makeLostContextWrapper(ctx, functionName) {
                    var f = ctx[functionName];
                    return function () {
                        if (!contextLost_) {
                            if (!checkResources(arguments)) {
                                glErrorShadow_[ctx.INVALID_OPERATION] = true;
                                return;
                            }
                            var result = f.apply(ctx, arguments);
                            return result;
                        }
                    };
                }
                for (var propertyName in ctx) {
                    if (typeof ctx[propertyName] == 'function') {
                        wrapper_[propertyName] = makeLostContextWrapper(ctx, propertyName);
                    }
                    else {
                        wrapper_[propertyName] = ctx[propertyName];
                    }
                }
                function makeWebGLContextEvent(statusMessage) {
                    return { statusMessage: statusMessage };
                }
                function freeResources() {
                    for (var ii = 0; ii < resourceDb_.length; ++ii) {
                        var resource = resourceDb_[ii];
                        if (resource instanceof WebGLBuffer) {
                            ctx.deleteBuffer(resource);
                        }
                    }
                }
                wrapper_["loseContext"] = function () {
                    if (!contextLost_) {
                        contextLost_ = true;
                        ++contextId_;
                        while (ctx.getError())
                            ;
                        clearErrors();
                        glErrorShadow_[ctx.CONTEXT_LOST_WEBGL] = true;
                        setTimeout(function () {
                            if (onLost_) {
                                onLost_(makeWebGLContextEvent("context lost"));
                            }
                        }, 0);
                    }
                };
                wrapper_["restoreContext"] = function () {
                    if (contextLost_) {
                        if (onRestored_) {
                            setTimeout(function () {
                                freeResources();
                                this.resetToInitialState(ctx);
                                contextLost_ = false;
                                if (onRestored_) {
                                    var callback = onRestored_;
                                    onRestored_ = nextOnRestored_;
                                    nextOnRestored_ = undefined;
                                    callback(makeWebGLContextEvent("context restored"));
                                }
                            }, 0);
                        }
                        else {
                            throw "You can not restore the context without a listener";
                        }
                    }
                };
                wrapper_["getError"] = function () {
                    if (!contextLost_) {
                        var err;
                        while (err = ctx.getError()) {
                            glErrorShadow_[err] = true;
                        }
                    }
                    for (var key in glErrorShadow_) {
                        if (glErrorShadow_[key]) {
                            delete glErrorShadow_[key];
                            return key;
                        }
                    }
                    return ctx.NO_ERROR;
                };
                var creationFunctions = [
                    "createBuffer",
                    "createFramebuffer",
                    "createProgram",
                    "createRenderbuffer",
                    "createShader",
                    "createTexture"
                ];
                for (var ii = 0; ii < creationFunctions.length; ++ii) {
                    var functionName = creationFunctions[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return null;
                            }
                            var obj = f.apply(ctx, arguments);
                            obj.__webglDebugContextLostId__ = contextId_;
                            resourceDb_.push(obj);
                            return obj;
                        };
                    }(ctx[functionName]);
                }
                var functionsThatShouldReturnNull = [
                    "getActiveAttrib",
                    "getActiveUniform",
                    "getBufferParameter",
                    "getContextAttributes",
                    "getAttachedShaders",
                    "getFramebufferAttachmentParameter",
                    "getParameter",
                    "getProgramParameter",
                    "getProgramInfoLog",
                    "getRenderbufferParameter",
                    "getShaderParameter",
                    "getShaderInfoLog",
                    "getShaderSource",
                    "getTexParameter",
                    "getUniform",
                    "getUniformLocation",
                    "getVertexAttrib"
                ];
                for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
                    var functionName = functionsThatShouldReturnNull[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return null;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrapper_[functionName]);
                }
                var isFunctions = [
                    "isBuffer",
                    "isEnabled",
                    "isFramebuffer",
                    "isProgram",
                    "isRenderbuffer",
                    "isShader",
                    "isTexture"
                ];
                for (var ii = 0; ii < isFunctions.length; ++ii) {
                    var functionName = isFunctions[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return false;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrapper_[functionName]);
                }
                wrapper_["checkFramebufferStatus"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return ctx.FRAMEBUFFER_UNSUPPORTED;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["checkFramebufferStatus"]);
                wrapper_["getAttribLocation"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return -1;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["getAttribLocation"]);
                wrapper_["getVertexAttribOffset"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return 0;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["getVertexAttribOffset"]);
                wrapper_["isContextLost"] = function () {
                    return contextLost_;
                };
                function wrapEvent(listener) {
                    if (typeof (listener) == "function") {
                        return listener;
                    }
                    else {
                        return function (info) {
                            listener.handleEvent(info);
                        };
                    }
                }
                wrapper_["registerOnContextLostListener"] = function (listener) {
                    onLost_ = wrapEvent(listener);
                };
                wrapper_["registerOnContextRestoredListener"] = function (listener) {
                    if (contextLost_) {
                        nextOnRestored_ = wrapEvent(listener);
                    }
                    else {
                        onRestored_ = wrapEvent(listener);
                    }
                };
                return wrapper_;
            };
            WebGLDebugUtils.glValidEnumContexts = {
                'enable': { 0: true },
                'disable': { 0: true },
                'getParameter': { 0: true },
                'drawArrays': { 0: true },
                'drawElements': { 0: true, 2: true },
                'createShader': { 0: true },
                'getShaderParameter': { 1: true },
                'getProgramParameter': { 1: true },
                'getVertexAttrib': { 1: true },
                'vertexAttribPointer': { 2: true },
                'bindTexture': { 0: true },
                'activeTexture': { 0: true },
                'getTexParameter': { 0: true, 1: true },
                'texParameterf': { 0: true, 1: true },
                'texParameteri': { 0: true, 1: true, 2: true },
                'texImage2D': { 0: true, 2: true, 6: true, 7: true },
                'texSubImage2D': { 0: true, 6: true, 7: true },
                'copyTexImage2D': { 0: true, 2: true },
                'copyTexSubImage2D': { 0: true },
                'generateMipmap': { 0: true },
                'bindBuffer': { 0: true },
                'bufferData': { 0: true, 2: true },
                'bufferSubData': { 0: true },
                'getBufferParameter': { 0: true, 1: true },
                'pixelStorei': { 0: true, 1: true },
                'readPixels': { 4: true, 5: true },
                'bindRenderbuffer': { 0: true },
                'bindFramebuffer': { 0: true },
                'checkFramebufferStatus': { 0: true },
                'framebufferRenderbuffer': { 0: true, 1: true, 2: true },
                'framebufferTexture2D': { 0: true, 1: true, 2: true },
                'getFramebufferAttachmentParameter': { 0: true, 1: true, 2: true },
                'getRenderbufferParameter': { 0: true, 1: true },
                'renderbufferStorage': { 0: true, 1: true },
                'clear': { 0: true },
                'depthFunc': { 0: true },
                'blendFunc': { 0: true, 1: true },
                'blendFuncSeparate': { 0: true, 1: true, 2: true, 3: true },
                'blendEquation': { 0: true },
                'blendEquationSeparate': { 0: true, 1: true },
                'stencilFunc': { 0: true },
                'stencilFuncSeparate': { 0: true, 1: true },
                'stencilMaskSeparate': { 0: true },
                'stencilOp': { 0: true, 1: true, 2: true },
                'stencilOpSeparate': { 0: true, 1: true, 2: true, 3: true },
                'cullFace': { 0: true },
                'frontFace': { 0: true },
            };
            return WebGLDebugUtils;
        }());
        framework.WebGLDebugUtils = WebGLDebugUtils;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        var WebGLUtils = (function () {
            function WebGLUtils() {
                this.makeFailHTML = function (msg) {
                    return '' +
                        '<div style="margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;">' + msg + '</div>';
                };
                this.GET_A_WEBGL_BROWSER = '' +
                    'This page requires a browser that supports WebGL.<br/>' +
                    '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';
                this.OTHER_PROBLEM = '' +
                    "It doesn't appear your computer can support WebGL.<br/>" +
                    '<a href="http://get.webgl.org">Click here for more information.</a>';
                if (!window.requestAnimationFrame) {
                    var tempwin = window;
                    window.requestAnimationFrame =
                        tempwin.requestAnimationFrame ||
                            tempwin.webkitRequestAnimationFrame ||
                            tempwin.mozRequestAnimationFrame ||
                            tempwin.oRequestAnimationFrame ||
                            tempwin.msRequestAnimationFrame ||
                            function (callback, element) {
                                window.setTimeout(callback, 1000 / 60);
                            };
                }
                if (!window.cancelAnimationFrame) {
                    var tempwin = window;
                    window.cancelAnimationFrame = (tempwin.cancelRequestAnimationFrame ||
                        window.webkitCancelAnimationFrame || tempwin.webkitCancelRequestAnimationFrame ||
                        tempwin.mozCancelAnimationFrame || tempwin.mozCancelRequestAnimationFrame ||
                        tempwin.msCancelAnimationFrame || tempwin.msCancelRequestAnimationFrame ||
                        tempwin.oCancelAnimationFrame || tempwin.oCancelRequestAnimationFrame ||
                        window.clearTimeout);
                }
            }
            WebGLUtils.prototype.setupWebGL = function (canvas, opt_attribs, opt_onError) {
                if (opt_attribs === void 0) { opt_attribs = null; }
                if (opt_onError === void 0) { opt_onError = null; }
                function handleCreationError(msg) {
                    var container = document.getElementsByTagName("body")[0];
                    if (container) {
                        var str = WebGLRenderingContext ?
                            this.OTHER_PROBLEM :
                            this.GET_A_WEBGL_BROWSER;
                        if (msg) {
                            str += "<br/><br/>Status: " + msg;
                        }
                        container.innerHTML = this.makeFailHTML(str);
                    }
                }
                ;
                opt_onError = opt_onError || handleCreationError;
                if (canvas.addEventListener) {
                    canvas.addEventListener("webglcontextcreationerror", function (event) {
                        opt_onError(event.statusMessage);
                    }, false);
                }
                var context = this.create3DContext(canvas, opt_attribs);
                if (!context) {
                    if (!WebGLRenderingContext) {
                        opt_onError("");
                    }
                    else {
                        opt_onError("");
                    }
                }
                return context;
            };
            WebGLUtils.prototype.create3DContext = function (canvas, opt_attribs) {
                var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
                var context = null;
                for (var ii = 0; ii < names.length; ++ii) {
                    try {
                        context = canvas.getContext(names[ii], opt_attribs);
                    }
                    catch (e) { }
                    if (context) {
                        break;
                    }
                }
                return context;
            };
            return WebGLUtils;
        }());
        framework.WebGLUtils = WebGLUtils;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        var loadRetryMgr = (function () {
            function loadRetryMgr() {
            }
            return loadRetryMgr;
        }());
        function xhrLoad(url, fun, onprocess, responseType, loadedFun) {
            if (onprocess === void 0) { onprocess = null; }
            var req = new XMLHttpRequest();
            var isLoaded = false;
            req.open("GET", url);
            req.responseType = responseType;
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 200) {
                        loadedFun(req);
                        isLoaded = true;
                    }
                    else {
                        switch (req.status) {
                            case 404:
                                fun(null, new Error("got a 404:" + url));
                                break;
                        }
                    }
                }
            };
            req.onprogress = function (ev) {
                if (onprocess)
                    onprocess(ev.loaded, ev.total);
            };
            req.onerror = function () {
                fun(null, new Error("onerr in req:"));
            };
            req.onloadend = function () {
                if (!isLoaded) {
                    if (!loadRetryMgr.urlCaseDic)
                        loadRetryMgr.urlCaseDic = {};
                    var dic = loadRetryMgr.urlCaseDic;
                    dic[url] = isNaN(dic[url]) || dic[url] < 0 ? 0 : dic[url];
                    if (dic[url] >= 2) {
                        dic[url] = 0;
                        fun(null, new Error("load this url fail  ：" + url), true);
                    }
                    else {
                        xhrLoad(url, fun, onprocess, responseType, loadedFun);
                        dic[url]++;
                    }
                }
            };
            try {
                req.send();
            }
            catch (err) {
                fun(null, err);
            }
        }
        function loadText(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            xhrLoad(url, fun, onprocess, "text", function (req) {
                fun(req.responseText, null);
            });
        }
        io.loadText = loadText;
        function loadArrayBuffer(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            xhrLoad(url, fun, onprocess, "arraybuffer", function (req) {
                fun(req.response, null);
            });
        }
        io.loadArrayBuffer = loadArrayBuffer;
        function loadBlob(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            xhrLoad(url, fun, onprocess, "blob", function (req) {
                fun(req.response, null);
            });
        }
        io.loadBlob = loadBlob;
        function loadImg(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            xhrLoad(url, fun, onprocess, "blob", function (req) {
                var blob = req.response;
                var img = document.createElement("img");
                img.onload = function (e) {
                    window.URL.revokeObjectURL(img.src);
                    fun(img, null);
                };
                img.onerror = function (e) {
                    fun(null, new Error("error when blob to img:" + url));
                };
                try {
                    img.src = window.URL.createObjectURL(blob);
                }
                catch (e) {
                    fun(null, e);
                }
            });
        }
        io.loadImg = loadImg;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        var pool = (function () {
            function pool() {
            }
            pool.collect_all = function () {
                pool.collect_vector4();
                pool.collect_vector3();
                pool.collect_vector2();
                pool.collect_matrix();
                pool.collect_quaternion();
                pool.collect_color();
            };
            Object.defineProperty(pool, "vector4_one", {
                get: function () {
                    if (pool._vector4_one == null) {
                        pool._vector4_one = new math.vector4(1, 1, 1, 1);
                    }
                    return pool._vector4_one;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_vector4 = function () {
                if (pool.unused_vector4.length > 0)
                    return pool.unused_vector4.pop();
                else
                    return new math.vector4();
            };
            pool.clone_vector4 = function (src) {
                if (pool.unused_vector4.length > 0) {
                    var v = pool.unused_vector4.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    v.w = src.w;
                    return v;
                }
                else
                    return new math.vector4(src.x, src.y, src.z);
            };
            pool.delete_vector4 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector4) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    pool.unused_vector4.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector4吗？");
            };
            pool.collect_vector4 = function () {
                pool.unused_vector4.length = 0;
            };
            Object.defineProperty(pool, "color_one", {
                get: function () {
                    if (pool._color_one == null) {
                        pool._color_one = new math.color(1, 1, 1, 1);
                    }
                    return pool._color_one;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_color = function () {
                if (pool.unused_color.length > 0)
                    return pool.unused_color.pop();
                else
                    return new math.color();
            };
            pool.delete_color = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.color) {
                    v.r = v.g = v.b = 0;
                    v.a = 1;
                    pool.unused_color.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是color吗？");
            };
            pool.collect_color = function () {
                pool.unused_color.length = 0;
            };
            Object.defineProperty(pool, "vector3_up", {
                get: function () {
                    if (pool._vector3_up == null) {
                        pool._vector3_up = new math.vector3(0, 1, 0);
                    }
                    return pool._vector3_up;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_right", {
                get: function () {
                    if (pool._vector3_right == null) {
                        pool._vector3_right = new math.vector3(1, 0, 0);
                    }
                    return pool._vector3_right;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_forward", {
                get: function () {
                    if (pool._vector3_forward == null) {
                        pool._vector3_forward = new math.vector3(0, 0, 1);
                    }
                    return pool._vector3_forward;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_zero", {
                get: function () {
                    if (pool._vector3_zero == null) {
                        pool._vector3_zero = new math.vector3(0, 0, 0);
                    }
                    return pool._vector3_zero;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_one", {
                get: function () {
                    if (pool._vector3_one == null) {
                        pool._vector3_one = new math.vector3(1, 1, 1);
                    }
                    return pool._vector3_one;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_vector3 = function () {
                if (pool.unused_vector3.length > 0) {
                    var v = pool.unused_vector3.pop();
                    return v;
                }
                else
                    return new math.vector3();
            };
            pool.clone_vector3 = function (src) {
                if (pool.unused_vector3.length > 0) {
                    var v = pool.unused_vector3.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    return v;
                }
                else
                    return new math.vector3(src.x, src.y, src.z);
            };
            pool.delete_vector3 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector3) {
                    v.x = v.y = v.z = 0;
                    pool.unused_vector3.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector3吗？");
            };
            pool.collect_vector3 = function () {
                pool.unused_vector3.length = 0;
            };
            Object.defineProperty(pool, "vector2_up", {
                get: function () {
                    if (pool._vector2_up == null) {
                        pool._vector2_up = new math.vector2(0, 1);
                    }
                    return pool._vector2_up;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(pool, "vector2_right", {
                get: function () {
                    if (pool._vector2_right == null) {
                        pool._vector2_right = new math.vector2(1, 0);
                    }
                    return pool._vector2_right;
                },
                enumerable: true,
                configurable: true
            });
            pool.new_vector2 = function () {
                if (pool.unused_vector2.length > 0)
                    return pool.unused_vector2.pop();
                else
                    return new math.vector2();
            };
            pool.clone_vector2 = function (src) {
                if (pool.unused_vector2.length > 0) {
                    var v = pool.unused_vector2.pop();
                    v.x = src.x;
                    v.y = src.y;
                    return v;
                }
                else
                    return new math.vector2(src.x, src.y);
            };
            pool.delete_vector2 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector2) {
                    v.x = v.y = 0;
                    pool.unused_vector2.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector2吗？");
            };
            pool.delete_vector2Array = function (vs) {
                for (var i = 0; i < vs.length; i++) {
                    if (vs[i] != undefined) {
                        vs[i].x = vs[i].y = 0;
                        pool.unused_vector2.push(vs[i]);
                    }
                }
                vs.length = 0;
            };
            pool.collect_vector2 = function () {
                pool.unused_vector2.length = 0;
            };
            pool.new_matrix3x2 = function () {
                if (pool.unused_matrix3x2.length > 0)
                    return pool.unused_matrix3x2.pop();
                else
                    return new math.matrix3x2();
            };
            pool.clone_matrix3x2 = function (src) {
                var v = pool.new_matrix();
                for (var i = 0; i < 6; i++)
                    v.rawData[i] = src.rawData[i];
                return v;
            };
            pool.delete_matrix3x2 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.matrix3x2) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 1;
                    v.rawData[4] = 0;
                    v.rawData[5] = 0;
                    pool.unused_matrix3x2.push(v);
                }
                else {
                    console.error("kindding me?确定你要回收的是matrix3x2吗？");
                }
            };
            pool.collect_matrix3x2 = function () {
                pool.unused_matrix3x2.length = 0;
            };
            pool.new_matrix = function () {
                if (pool.unused_matrix.length > 0)
                    return pool.unused_matrix.pop();
                else
                    return new math.matrix();
            };
            pool.clone_matrix = function (src) {
                var v = pool.new_matrix();
                for (var i = 0; i < 16; i++)
                    v.rawData[i] = src.rawData[i];
                return v;
            };
            pool.delete_matrix = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.matrix) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 0;
                    v.rawData[4] = 0;
                    v.rawData[5] = 1;
                    v.rawData[6] = 0;
                    v.rawData[7] = 0;
                    v.rawData[8] = 0;
                    v.rawData[9] = 0;
                    v.rawData[10] = 1;
                    v.rawData[11] = 0;
                    v.rawData[12] = 0;
                    v.rawData[13] = 0;
                    v.rawData[14] = 0;
                    v.rawData[15] = 1;
                    pool.unused_matrix.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是matrix吗？");
            };
            pool.collect_matrix = function () {
                pool.unused_matrix.length = 0;
            };
            pool.new_quaternion = function () {
                if (pool.unused_quaternion.length > 0)
                    return pool.unused_quaternion.pop();
                else
                    return new math.quaternion();
            };
            pool.clone_quaternion = function (src) {
                if (pool.unused_quaternion.length > 0) {
                    var v = pool.unused_quaternion.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    v.w = src.w;
                    return v;
                }
                else
                    return new math.quaternion(src.x, src.y, src.z, src.w);
            };
            pool.delete_quaternion = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.quaternion) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    pool.unused_quaternion.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是quaternion吗？");
            };
            pool.collect_quaternion = function () {
                pool.unused_quaternion.length = 0;
            };
            pool.unused_vector4 = [];
            pool.unused_color = [];
            pool.unused_vector3 = [];
            pool.unused_vector2 = [];
            pool.unused_matrix3x2 = [];
            pool.unused_matrix = [];
            pool.identityMat = new math.matrix();
            pool.unused_quaternion = [];
            return pool;
        }());
        math.pool = pool;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var caps = (function () {
            function caps() {
            }
            return caps;
        }());
        render.caps = caps;
        var webglkit = (function () {
            function webglkit() {
            }
            webglkit.SetMaxVertexAttribArray = function (webgl, count) {
                for (var i = count; i < webglkit._maxVertexAttribArray; i++) {
                    webgl.disableVertexAttribArray(i);
                }
                webglkit._maxVertexAttribArray = count;
            };
            webglkit.GetTextureNumber = function (webgl, index) {
                webglkit.initConst(webgl);
                return webglkit._texNumber[index];
            };
            webglkit.initConst = function (webgl) {
                if (webglkit._texNumber == null) {
                    webglkit._texNumber = [];
                    webglkit._texNumber.push(webgl.TEXTURE0);
                    webglkit._texNumber.push(webgl.TEXTURE1);
                    webglkit._texNumber.push(webgl.TEXTURE2);
                    webglkit._texNumber.push(webgl.TEXTURE3);
                    webglkit._texNumber.push(webgl.TEXTURE4);
                    webglkit._texNumber.push(webgl.TEXTURE5);
                    webglkit._texNumber.push(webgl.TEXTURE6);
                    webglkit._texNumber.push(webgl.TEXTURE7);
                    webglkit._texNumber.push(webgl.TEXTURE8);
                    webglkit._texNumber.push(webgl.TEXTURE9);
                    webglkit._texNumber.push(webgl.TEXTURE10);
                    webglkit._texNumber.push(webgl.TEXTURE11);
                    webglkit._texNumber.push(webgl.TEXTURE12);
                    webglkit._texNumber.push(webgl.TEXTURE13);
                    webglkit._texNumber.push(webgl.TEXTURE14);
                    webglkit._texNumber.push(webgl.TEXTURE15);
                    webglkit.LEQUAL = webgl.LEQUAL;
                    webglkit.NEVER = webgl.NEVER;
                    webglkit.EQUAL = webgl.EQUAL;
                    webglkit.GEQUAL = webgl.GEQUAL;
                    webglkit.NOTEQUAL = webgl.NOTEQUAL;
                    webglkit.LESS = webgl.LESS;
                    webglkit.GREATER = webgl.GREATER;
                    webglkit.ALWAYS = webgl.ALWAYS;
                    webglkit.FUNC_ADD = webgl.FUNC_ADD;
                    webglkit.FUNC_SUBTRACT = webgl.FUNC_SUBTRACT;
                    webglkit.FUNC_REVERSE_SUBTRACT = webgl.FUNC_REVERSE_SUBTRACT;
                    webglkit.ONE = webgl.ONE;
                    webglkit.ZERO = webgl.ZERO;
                    webglkit.SRC_ALPHA = webgl.SRC_ALPHA;
                    webglkit.SRC_COLOR = webgl.SRC_COLOR;
                    webglkit.ONE_MINUS_SRC_ALPHA = webgl.ONE_MINUS_SRC_ALPHA;
                    webglkit.ONE_MINUS_SRC_COLOR = webgl.ONE_MINUS_SRC_COLOR;
                    webglkit.ONE_MINUS_DST_ALPHA = webgl.ONE_MINUS_DST_ALPHA;
                    webglkit.ONE_MINUS_DST_COLOR = webgl.ONE_MINUS_DST_COLOR;
                    webglkit.caps.standardDerivatives = (webgl.getExtension('OES_standard_derivatives') !== null);
                    webglkit.caps.pvrtcExtension = webgl.getExtension('WEBGL_compressed_texture_pvrtc');
                    webglkit.caps.atcExtension = webgl.getExtension('WEBGL_compressed_texture_atc');
                }
            };
            webglkit._maxVertexAttribArray = 0;
            webglkit._texNumber = null;
            webglkit.caps = new caps();
            return webglkit;
        }());
        render.webglkit = webglkit;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var ShowFaceStateEnum;
        (function (ShowFaceStateEnum) {
            ShowFaceStateEnum[ShowFaceStateEnum["ALL"] = 0] = "ALL";
            ShowFaceStateEnum[ShowFaceStateEnum["CCW"] = 1] = "CCW";
            ShowFaceStateEnum[ShowFaceStateEnum["CW"] = 2] = "CW";
        })(ShowFaceStateEnum = render.ShowFaceStateEnum || (render.ShowFaceStateEnum = {}));
        var DrawModeEnum;
        (function (DrawModeEnum) {
            DrawModeEnum[DrawModeEnum["VboTri"] = 0] = "VboTri";
            DrawModeEnum[DrawModeEnum["VboLine"] = 1] = "VboLine";
            DrawModeEnum[DrawModeEnum["EboTri"] = 2] = "EboTri";
            DrawModeEnum[DrawModeEnum["EboLine"] = 3] = "EboLine";
        })(DrawModeEnum = render.DrawModeEnum || (render.DrawModeEnum = {}));
        var BlendModeEnum;
        (function (BlendModeEnum) {
            BlendModeEnum[BlendModeEnum["Close"] = 0] = "Close";
            BlendModeEnum[BlendModeEnum["Blend"] = 1] = "Blend";
            BlendModeEnum[BlendModeEnum["Blend_PreMultiply"] = 2] = "Blend_PreMultiply";
            BlendModeEnum[BlendModeEnum["Add"] = 3] = "Add";
            BlendModeEnum[BlendModeEnum["Add_PreMultiply"] = 4] = "Add_PreMultiply";
        })(BlendModeEnum = render.BlendModeEnum || (render.BlendModeEnum = {}));
        var glDrawPass = (function () {
            function glDrawPass() {
                this.state_showface = ShowFaceStateEnum.CCW;
                this.state_zwrite = false;
                this.state_ztest = false;
                this.state_ztest_method = render.webglkit.LEQUAL;
                this.state_blend = false;
                this.state_blendEquation = 0;
                this.state_blendSrcRGB = 0;
                this.state_blendDestRGB = 0;
                this.state_blendSrcAlpha = 0;
                this.state_blendDestALpha = 0;
            }
            glDrawPass.prototype.setProgram = function (program, uniformDefault) {
                if (uniformDefault === void 0) { uniformDefault = false; }
                this.program = program;
                this.mapuniforms = program.mapUniform;
            };
            glDrawPass.prototype.setAlphaBlend = function (mode) {
                this.state_blendMode = mode;
                if (mode == BlendModeEnum.Add) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.webglkit.ONE;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Add_PreMultiply) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.ONE;
                    this.state_blendDestRGB = render.webglkit.ONE;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend) {
                    this.state_blend = true;
                    this.state_zwrite = false;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend_PreMultiply) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.ONE;
                    this.state_blendDestRGB = render.webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Close) {
                    this.state_blend = false;
                }
            };
            glDrawPass.resetLastState = function () {
                this.lastShowFace = -1;
                this.lastZWrite = null;
                this.lastZTest = null;
                this.lastZTestMethod = -1;
                this.lastBlend = null;
                this.lastBlendMode = null;
            };
            glDrawPass.prototype.use = function (webgl, applyUniForm) {
                if (applyUniForm === void 0) { applyUniForm = true; }
                if (this.state_showface != glDrawPass.lastShowFace) {
                    glDrawPass.lastShowFace = this.state_showface;
                    if (this.state_showface == ShowFaceStateEnum.ALL) {
                        webgl.disable(webgl.CULL_FACE);
                    }
                    else {
                        if (this.state_showface == ShowFaceStateEnum.CCW) {
                            webgl.frontFace(webgl.CCW);
                        }
                        else {
                            webgl.frontFace(webgl.CW);
                        }
                        webgl.cullFace(webgl.BACK);
                        webgl.enable(webgl.CULL_FACE);
                    }
                }
                if (this.state_zwrite != glDrawPass.lastZWrite) {
                    glDrawPass.lastZWrite = this.state_zwrite;
                    if (this.state_zwrite) {
                        webgl.depthMask(true);
                    }
                    else {
                        webgl.depthMask(false);
                    }
                }
                if (this.state_ztest != glDrawPass.lastZTest) {
                    glDrawPass.lastZTest = this.state_ztest;
                    if (this.state_ztest) {
                        webgl.enable(webgl.DEPTH_TEST);
                    }
                    else {
                        webgl.disable(webgl.DEPTH_TEST);
                    }
                }
                if (this.state_ztest && glDrawPass.lastZTestMethod != this.state_ztest_method) {
                    glDrawPass.lastZTestMethod = this.state_ztest_method;
                    webgl.depthFunc(this.state_ztest_method);
                }
                if (this.state_blend != glDrawPass.lastBlend) {
                    glDrawPass.lastBlend = this.state_blend;
                    if (this.state_blend) {
                        webgl.enable(webgl.BLEND);
                    }
                    else {
                        webgl.disable(webgl.BLEND);
                    }
                }
                if (this.state_blend && glDrawPass.lastBlendMode != this.state_blendMode) {
                    glDrawPass.lastBlendMode = this.state_blendMode;
                    webgl.blendEquation(this.state_blendEquation);
                    webgl.blendFuncSeparate(this.state_blendSrcRGB, this.state_blendDestRGB, this.state_blendSrcAlpha, this.state_blendDestALpha);
                }
                this.program.use(webgl);
            };
            glDrawPass.prototype.draw = function (webgl, mesh, drawmode, drawindexindex, drawbegin, drawcount) {
                if (drawmode === void 0) { drawmode = DrawModeEnum.EboTri; }
                if (drawindexindex === void 0) { drawindexindex = 0; }
                if (drawbegin === void 0) { drawbegin = 0; }
                if (drawcount === void 0) { drawcount = -1; }
                this.use(webgl);
                mesh.bind(webgl, this.program, drawindexindex);
                if (drawmode == DrawModeEnum.VboTri) {
                    mesh.drawArrayTris(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.VboLine) {
                    mesh.drawArrayLines(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.EboTri) {
                    mesh.drawElementTris(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.EboLine) {
                    mesh.drawElementLines(webgl, drawbegin, drawcount);
                }
            };
            glDrawPass.prototype.getCurDrawState = function () {
                var res = "";
                res = this.formate(this.state_showface.toString(), res);
                res = this.formate(this.state_zwrite.toString(), res);
                res = this.formate(this.state_ztest.toString(), res);
                if (this.state_ztest) {
                    res = this.formate(this.state_ztest_method.toString(), res);
                }
                else {
                    res = this.formate("ztestnone", res);
                }
                res = this.formate(this.state_blend.toString(), res);
                if (this.state_blend) {
                    res = this.formate(this.state_blendEquation.toString(), res);
                }
                else {
                    res = this.formate("blendnone", res);
                }
                return res;
            };
            glDrawPass.prototype.getCurBlendVal = function () {
                var res = "";
                res = this.formate(this.state_blendSrcRGB.toString(), res);
                res = this.formate(this.state_blendDestRGB.toString(), res);
                res = this.formate(this.state_blendSrcAlpha.toString(), res);
                res = this.formate(this.state_blendDestALpha.toString(), res);
                return res;
            };
            glDrawPass.prototype.formate = function (str, out) {
                return out += str + "_";
            };
            glDrawPass.lastShowFace = -1;
            glDrawPass.lastZWrite = null;
            glDrawPass.lastZTest = null;
            glDrawPass.lastZTestMethod = -1;
            glDrawPass.lastBlend = null;
            glDrawPass.lastBlendMode = null;
            return glDrawPass;
        }());
        render.glDrawPass = glDrawPass;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var VertexFormatMask;
        (function (VertexFormatMask) {
            VertexFormatMask[VertexFormatMask["Position"] = 1] = "Position";
            VertexFormatMask[VertexFormatMask["Normal"] = 2] = "Normal";
            VertexFormatMask[VertexFormatMask["Tangent"] = 4] = "Tangent";
            VertexFormatMask[VertexFormatMask["Color"] = 8] = "Color";
            VertexFormatMask[VertexFormatMask["UV0"] = 16] = "UV0";
            VertexFormatMask[VertexFormatMask["UV1"] = 32] = "UV1";
            VertexFormatMask[VertexFormatMask["BlendIndex4"] = 64] = "BlendIndex4";
            VertexFormatMask[VertexFormatMask["BlendWeight4"] = 128] = "BlendWeight4";
            VertexFormatMask[VertexFormatMask["ColorEX"] = 256] = "ColorEX";
        })(VertexFormatMask = render.VertexFormatMask || (render.VertexFormatMask = {}));
        var number4 = (function () {
            function number4() {
            }
            return number4;
        }());
        render.number4 = number4;
        var MeshTypeEnum;
        (function (MeshTypeEnum) {
            MeshTypeEnum[MeshTypeEnum["Static"] = 0] = "Static";
            MeshTypeEnum[MeshTypeEnum["Dynamic"] = 1] = "Dynamic";
            MeshTypeEnum[MeshTypeEnum["Stream"] = 2] = "Stream";
        })(MeshTypeEnum = render.MeshTypeEnum || (render.MeshTypeEnum = {}));
        var drawInfo = (function () {
            function drawInfo() {
            }
            Object.defineProperty(drawInfo, "ins", {
                get: function () {
                    if (drawInfo._ins == null)
                        drawInfo._ins = new drawInfo();
                    return drawInfo._ins;
                },
                enumerable: true,
                configurable: true
            });
            return drawInfo;
        }());
        render.drawInfo = drawInfo;
        var glMesh = (function () {
            function glMesh() {
                this.lineMode = WebGLRenderingContext.LINES;
                this.bindIndex = -1;
                this.vertexFormat = VertexFormatMask.Position;
            }
            glMesh.prototype.initBuffer = function (webgl, vf, vertexCount, mode) {
                if (mode === void 0) { mode = MeshTypeEnum.Static; }
                if (this.vbo != null)
                    throw new Error("you can only initbuffer once.");
                if (mode == MeshTypeEnum.Static)
                    this.mode = webgl.STATIC_DRAW;
                else if (mode == MeshTypeEnum.Dynamic)
                    this.mode = webgl.DYNAMIC_DRAW;
                else if (mode == MeshTypeEnum.Stream)
                    this.mode = webgl.STREAM_DRAW;
                this.vertexFormat = vf;
                this.vertexCount = vertexCount;
                if (vertexCount > 0) {
                    this.vertexByteSize = render.meshData.calcByteSize(vf);
                    this.vbo = webgl.createBuffer();
                    webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                    webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
                }
                this.indexCounts = [];
                this.ebos = [];
            };
            glMesh.prototype.addIndex = function (webgl, indexcount) {
                var index = this.ebos.length;
                var _ebo = webgl.createBuffer();
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, _ebo);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
                this.ebos.push(_ebo);
                this.indexCounts.push(indexcount);
                return index;
            };
            glMesh.prototype.resetVboSize = function (webgl, vertexCount) {
                this.vertexCount = vertexCount;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
            };
            glMesh.prototype.resetEboSize = function (webgl, eboindex, indexcount) {
                this.indexCounts[eboindex] = indexcount;
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
            };
            glMesh.prototype.dispose = function (webgl) {
                webgl.deleteBuffer(this.vbo);
                this.vbo = null;
                if (this.ebos) {
                    for (var i = 0; i < this.ebos.length; i++)
                        webgl.deleteBuffer(this.ebos[i]);
                    this.ebos.length = 0;
                }
            };
            glMesh.prototype.caclByteLength = function () {
                var total = 0;
                total += this.vertexByteSize * this.vertexCount;
                for (var k in this.indexCounts) {
                    total += this.indexCounts[k] * 2;
                }
                return total;
            };
            glMesh.prototype.bindVboBuffer = function (webgl) {
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
            };
            glMesh.prototype.bind = function (webgl, shadercode, bindEbo) {
                if (bindEbo === void 0) { bindEbo = 0; }
                this.bindIndex = bindEbo;
                if (bindEbo >= 0) {
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[bindEbo]);
                }
                var total = this.vertexByteSize;
                var seek = 0;
                var channel = 0;
                {
                    if (shadercode.posPos >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posPos);
                        webgl.vertexAttribPointer(shadercode.posPos, 3, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                if (this.vertexFormat & VertexFormatMask.Normal) {
                    if (shadercode.posNormal >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posNormal);
                        webgl.vertexAttribPointer(shadercode.posNormal, 3, webgl.FLOAT, true, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                else if (shadercode.posNormal >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posNormal);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.Tangent) {
                    if (shadercode.posTangent >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posTangent);
                        webgl.vertexAttribPointer(shadercode.posTangent, 3, webgl.FLOAT, true, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                else if (shadercode.posTangent >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posTangent);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.Color) {
                    if (shadercode.posColor >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posColor);
                        webgl.vertexAttribPointer(shadercode.posColor, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posColor >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posColor);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.UV0) {
                    if (shadercode.posUV0 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posUV0);
                        webgl.vertexAttribPointer(shadercode.posUV0, 2, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 8;
                }
                else if (shadercode.posUV0 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posUV0);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.UV1) {
                    if (shadercode.posUV2 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posUV2);
                        webgl.vertexAttribPointer(shadercode.posUV2, 2, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 8;
                }
                else if (shadercode.posUV2 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posUV2);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.BlendIndex4) {
                    if (shadercode.posBlendIndex4 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posBlendIndex4);
                        webgl.vertexAttribPointer(shadercode.posBlendIndex4, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posBlendIndex4 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posBlendIndex4);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.BlendWeight4) {
                    if (shadercode.posBlendWeight4 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posBlendWeight4);
                        webgl.vertexAttribPointer(shadercode.posBlendWeight4, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posBlendWeight4 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posBlendWeight4);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.ColorEX) {
                    if (shadercode.posColorEx >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posColorEx);
                        webgl.vertexAttribPointer(shadercode.posColorEx, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posColorEx >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posColorEx);
                    channel++;
                }
                render.webglkit.SetMaxVertexAttribArray(webgl, channel);
            };
            glMesh.prototype.uploadVertexSubData = function (webgl, varray, offset) {
                if (offset === void 0) { offset = 0; }
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferSubData(webgl.ARRAY_BUFFER, offset, varray);
            };
            glMesh.prototype.uploadVertexData = function (webgl, varray) {
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, varray, this.mode);
            };
            glMesh.prototype.uploadIndexSubData = function (webgl, eboindex, data, offset) {
                if (offset === void 0) { offset = 0; }
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, offset, data);
            };
            glMesh.prototype.uploadIndexData = function (webgl, eboindex, data) {
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, data, this.mode);
            };
            glMesh.prototype.drawArrayTris = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.vertexCount / 3) | 0) * 3;
                drawInfo.ins.triCount += count / 3;
                drawInfo.ins.renderCount++;
                webgl.drawArrays(webgl.TRIANGLES, start, count);
            };
            glMesh.prototype.drawArrayLines = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.vertexCount / 2) | 0) * 2;
                drawInfo.ins.renderCount++;
                webgl.drawArrays(this.lineMode, start, count);
            };
            glMesh.prototype.drawElementTris = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.indexCounts[this.bindIndex] / 3) | 0) * 3;
                drawInfo.ins.triCount += count / 3;
                drawInfo.ins.renderCount++;
                webgl.drawElements(webgl.TRIANGLES, count, webgl.UNSIGNED_SHORT, start * 2);
            };
            glMesh.prototype.drawElementLines = function (webgl, start, count) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (count < 0)
                    count = ((this.indexCounts[this.bindIndex] / 2) | 0) * 2;
                drawInfo.ins.renderCount++;
                webgl.drawElements(this.lineMode, count, webgl.UNSIGNED_SHORT, start * 2);
            };
            return glMesh;
        }());
        render.glMesh = glMesh;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var meshData = (function () {
            function meshData() {
            }
            meshData.addQuadPos = function (data, quad) {
                var istart = data.pos.length;
                meshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
            };
            meshData.addQuadPos_Quad = function (data, quad) {
                var istart = data.pos.length;
                meshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
                data.trisindex.push(istart + 2);
            };
            meshData.addQuadVec3ByValue = function (array, value) {
                for (var i = 0; i < 4; i++) {
                    var v = gd3d.math.pool.clone_vector3(value);
                    array.push(v);
                }
            };
            meshData.addQuadVec3 = function (array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            };
            meshData.addQuadVec2 = function (array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            };
            meshData.genQuad = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, 0),
                    new gd3d.math.vector3(-half, -half, 0),
                    new gd3d.math.vector3(half, half, 0),
                    new gd3d.math.vector3(half, -half, 0)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(1, 0)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genQuad_forparticle = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(0, half, 0),
                    new gd3d.math.vector3(0, -half, 0),
                    new gd3d.math.vector3(2 * half, half, 0),
                    new gd3d.math.vector3(2 * half, -half, 0)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genPlaneCCW = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, 0, half),
                    new gd3d.math.vector3(-half, 0, -half),
                    new gd3d.math.vector3(half, 0, half),
                    new gd3d.math.vector3(half, 0, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genCylinderCCW = function (height, radius, segment) {
                if (segment === void 0) { segment = 20; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var normal = new gd3d.math.vector3(0, 1, 0);
                for (var s = 0; s < 4; s++) {
                    var y = (s < 2 ? 0.5 : -0.5) * height;
                    if (s == 0)
                        normal = new gd3d.math.vector3(0, 1, 0);
                    else if (s == 3)
                        normal = new gd3d.math.vector3(0, -1, 0);
                    for (var i = 0; i < segment; i++) {
                        var r = i / segment * Math.PI * 2;
                        var x = Math.sin(r);
                        var z = Math.cos(r);
                        if (s == 1 || s == 2)
                            normal = new gd3d.math.vector3(x, 0, z);
                        data.pos.push(new gd3d.math.vector3(x * radius, y, z * radius));
                        var vn = gd3d.math.pool.clone_vector3(normal);
                        data.normal.push(vn);
                        if (s == 0 || s == 3) {
                            data.uv.push(new gd3d.math.vector2(x / 2 + 0.5, z / 2 + 0.5));
                        }
                        else {
                            data.uv.push(new gd3d.math.vector2(i / segment, y < 0 ? 0 : 1));
                        }
                    }
                }
                var itop = data.pos.length;
                data.pos.push(new gd3d.math.vector3(0, 0.5 * height, 0));
                data.normal.push(new gd3d.math.vector3(0, 1, 0));
                data.uv.push(new gd3d.math.vector2(0.5, 0.5));
                var ibottom = data.pos.length;
                data.pos.push(new gd3d.math.vector3(0, -0.5 * height, 0));
                data.normal.push(new gd3d.math.vector3(0, -1, 0));
                data.uv.push(new gd3d.math.vector2(0.5, 0.5));
                for (var i = 0; i < segment; i++) {
                    data.trisindex.push(itop);
                    data.trisindex.push(i == segment - 1 ? segment * 0 + 0 : segment * 0 + i + 1);
                    data.trisindex.push(segment * 0 + i + 0);
                    data.trisindex.push(ibottom);
                    data.trisindex.push(segment * 3 + i + 0);
                    data.trisindex.push(i == segment - 1 ? segment * 3 + 0 : segment * 3 + i + 1);
                    var t = segment * 1 + i;
                    var t2 = i == segment - 1 ? segment * 1 + 0 : segment * 1 + i + 1;
                    var b = segment * 2 + i;
                    var b2 = i == segment - 1 ? segment * 2 + 0 : segment * 2 + i + 1;
                    data.trisindex.push(t);
                    data.trisindex.push(t2);
                    data.trisindex.push(b);
                    data.trisindex.push(t2);
                    data.trisindex.push(b2);
                    data.trisindex.push(b);
                }
                return data;
            };
            meshData.genPyramid = function (height, halfsize) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var vec1 = new gd3d.math.vector3();
                var vec2 = new gd3d.math.vector3();
                var vec3 = new gd3d.math.vector3();
                var vec4 = new gd3d.math.vector3();
                var vec5 = new gd3d.math.vector3(0, -1, 0);
                var uvxx = new gd3d.math.vector2(0.5, 0.5);
                var uv00 = new gd3d.math.vector2(0, 0);
                var uv01 = new gd3d.math.vector2(0, 1);
                var uv10 = new gd3d.math.vector2(1, 0);
                var uv11 = new gd3d.math.vector2(1, 1);
                var ipos = 0;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(halfsize, height, halfsize), new gd3d.math.vector3(halfsize, -height, -halfsize), vec1);
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.uv.push(uv00);
                data.uv.push(uvxx);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(-halfsize, height, halfsize), new gd3d.math.vector3(halfsize, -height, halfsize), vec2);
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.uv.push(uv01);
                data.uv.push(uvxx);
                data.uv.push(uv11);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(-halfsize, height, -halfsize), new gd3d.math.vector3(-halfsize, -height, halfsize), vec3);
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.uv.push(uv11);
                data.uv.push(uvxx);
                data.uv.push(uv10);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(halfsize, height, -halfsize), new gd3d.math.vector3(-halfsize, -height, -halfsize), vec4);
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.uv.push(uv10);
                data.uv.push(uvxx);
                data.uv.push(uv00);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.uv.push(uv00);
                data.uv.push(uv10);
                data.uv.push(uv11);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                data.trisindex.push(ipos + 3);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos);
                ipos += 4;
                return data;
            };
            meshData.genSphereCCW = function (radius, widthSegments, heightSegments) {
                if (radius === void 0) { radius = 1; }
                if (widthSegments === void 0) { widthSegments = 24; }
                if (heightSegments === void 0) { heightSegments = 12; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                widthSegments = Math.max(3, Math.floor(widthSegments));
                heightSegments = Math.max(2, Math.floor(heightSegments));
                var ix, iy;
                var index = 0;
                var grid = [];
                var vertex = new gd3d.math.vector3();
                var normal = new gd3d.math.vector3();
                for (iy = 0; iy <= heightSegments; iy++) {
                    var verticesRow = [];
                    var v = iy / heightSegments;
                    for (ix = 0; ix <= widthSegments; ix++) {
                        var u = ix / widthSegments;
                        vertex.x = -radius * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        vertex.y = radius * Math.cos(v * Math.PI);
                        vertex.z = radius * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        data.pos.push(gd3d.math.pool.clone_vector3(vertex));
                        normal = gd3d.math.pool.clone_vector3(vertex);
                        var num = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                        if (num > Number.MIN_VALUE) {
                            normal.x = normal.x / num;
                            normal.y = normal.y / num;
                            normal.z = normal.z / num;
                        }
                        else {
                            normal.x = 0;
                            normal.y = 0;
                            normal.z = 0;
                        }
                        data.normal.push(normal);
                        var uv = new gd3d.math.vector2(1 - u, v);
                        data.uv.push(uv);
                        verticesRow.push(index++);
                    }
                    grid.push(verticesRow);
                }
                for (iy = 0; iy < heightSegments; iy++) {
                    for (ix = 0; ix < widthSegments; ix++) {
                        var a = grid[iy][ix + 1];
                        var b = grid[iy][ix];
                        var c = grid[iy + 1][ix];
                        var d = grid[iy + 1][ix + 1];
                        if (iy !== 0)
                            data.trisindex.push(a, d, b);
                        if (iy !== heightSegments - 1)
                            data.trisindex.push(b, d, c);
                    }
                }
                return data;
            };
            meshData.genBoxCCW = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(half, -half, -half),
                    new gd3d.math.vector3(half, -half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(-half, half, -half),
                    new gd3d.math.vector3(half, half, half),
                    new gd3d.math.vector3(half, half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(half, -half, half),
                    new gd3d.math.vector3(half, half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(0, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, -half),
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(half, half, -half),
                    new gd3d.math.vector3(half, -half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(half, -half, -half),
                    new gd3d.math.vector3(half, -half, half),
                    new gd3d.math.vector3(half, half, -half),
                    new gd3d.math.vector3(half, half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(-half, half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                return data;
            };
            meshData.genBoxByArray = function (array) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos(data, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos(data, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos(data, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos(data, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                return data;
            };
            meshData.genBoxByArray_Quad = function (array) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos_Quad(data, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos_Quad(data, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos_Quad(data, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                return data;
            };
            meshData.genCircleLineCCW = function (radius, segment, wide) {
                if (segment === void 0) { segment = 64; }
                if (wide === void 0) { wide = 0.05; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                for (var i = 0; i < segment; i++) {
                    var r1 = Math.PI * 2 * i / segment;
                    var x1 = Math.sin(r1) * radius;
                    var z1 = Math.cos(r1) * radius;
                    var r2 = Math.PI * 2 * (i + 1) / segment;
                    var x2 = Math.sin(r2) * radius;
                    var z2 = Math.cos(r2) * radius;
                    meshData.addQuadPos(data, [
                        new gd3d.math.vector3(x2, wide, z2),
                        new gd3d.math.vector3(x1, wide, z1),
                        new gd3d.math.vector3(x2, -wide, z2),
                        new gd3d.math.vector3(x1, -wide, z1)
                    ]);
                }
                return data;
            };
            meshData.prototype.caclByteLength = function () {
                var len = 0;
                if (this.pos != undefined)
                    len += 12;
                if (this.color != undefined)
                    len += 16;
                if (this.normal != undefined)
                    len += 12;
                if (this.tangent != undefined)
                    len += 12;
                if (this.uv != undefined)
                    len += 8;
                if (this.uv2 != undefined)
                    len += 8;
                if (this.blendIndex != undefined)
                    len += 16;
                if (this.blendWeight != undefined)
                    len += 16;
                if (this.colorex != undefined)
                    len += 16;
                if (this.trisindex != undefined)
                    len += 12;
                len *= this.pos.length;
                return len;
            };
            meshData.calcByteSize = function (vf) {
                var total = 0;
                if (vf & render.VertexFormatMask.Position)
                    total += 12;
                if (vf & render.VertexFormatMask.Normal)
                    total += 12;
                if (vf & render.VertexFormatMask.Tangent)
                    total += 12;
                if (vf & render.VertexFormatMask.Color)
                    total += 16;
                if (vf & render.VertexFormatMask.UV0)
                    total += 8;
                if (vf & render.VertexFormatMask.UV1)
                    total += 8;
                if (vf & render.VertexFormatMask.BlendIndex4)
                    total += 16;
                if (vf & render.VertexFormatMask.BlendWeight4)
                    total += 16;
                if (vf & render.VertexFormatMask.ColorEX)
                    total += 16;
                return total;
            };
            meshData.prototype.genVertexDataArray = function (vf) {
                var vertexCount = this.pos.length;
                var total = meshData.calcByteSize(vf) / 4;
                var varray = new Float32Array(total * vertexCount);
                for (var i = 0; i < vertexCount; i++) {
                    var nseek = 0;
                    varray[i * total + nseek] = this.pos[i].x;
                    nseek++;
                    varray[i * total + nseek] = this.pos[i].y;
                    nseek++;
                    varray[i * total + nseek] = this.pos[i].z;
                    nseek++;
                    if (vf & render.VertexFormatMask.Normal) {
                        if (this.normal == undefined || this.normal.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.normal[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.normal[i].y;
                            nseek++;
                            varray[i * total + nseek] = this.normal[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Tangent) {
                        if (this.tangent == undefined || this.tangent.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.tangent[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.tangent[i].y;
                            nseek++;
                            varray[i * total + nseek] = this.tangent[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Color) {
                        if (this.color == undefined || this.color.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.color[i].r;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].g;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].b;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].a;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV0) {
                        if (this.uv == undefined || this.uv.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.uv[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.uv[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV1) {
                        if (this.uv2 == undefined || this.uv2.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.uv2[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.uv2[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendIndex4) {
                        if (this.blendIndex == undefined || this.blendIndex.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.blendIndex[i].v0;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v1;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v2;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendWeight4) {
                        if (this.blendWeight == undefined || this.blendWeight.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.blendWeight[i].v0;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v1;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v2;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.ColorEX) {
                        if (this.colorex == undefined || this.colorex.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.colorex[i].r;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].g;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].b;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].a;
                            nseek++;
                        }
                    }
                }
                return varray;
            };
            meshData.prototype.genIndexDataArray = function () {
                return new Uint16Array(this.trisindex);
            };
            meshData.prototype.genIndexDataArrayTri2Line = function () {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 3) | 0); i++) {
                    line.push(this.trisindex[i * 3 + 0]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 0]);
                }
                return new Uint16Array(line);
            };
            meshData.prototype.genIndexDataArrayQuad2Line = function () {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 4) | 0); i++) {
                    line.push(this.trisindex[i * 4 + 0]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 3]);
                }
                return new Uint16Array(line);
            };
            return meshData;
        }());
        render.meshData = meshData;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var staticMeshRenderer = (function () {
            function staticMeshRenderer() {
                this.eboIndex = 0;
                this.drawMode = render.DrawModeEnum.EboTri;
                this.drawbegin = 0;
                this.drawcount = -1;
            }
            staticMeshRenderer.prototype.draw = function (webgl) {
                this.material.use(webgl);
                this.mesh.bind(webgl, this.material.program, this.eboIndex);
                if (this.drawMode == render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, this.drawbegin, this.drawcount);
                }
            };
            return staticMeshRenderer;
        }());
        render.staticMeshRenderer = staticMeshRenderer;
        var batchRenderer = (function () {
            function batchRenderer() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            batchRenderer.prototype.initBuffer = function (webgl, vf, drawMode) {
                this.mesh = new render.glMesh();
                this.mesh.initBuffer(webgl, vf, 128, render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == render.DrawModeEnum.EboLine || drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
            };
            batchRenderer.prototype.begin = function (webgl, mat) {
                if (this.vboCount > 0)
                    this.end(webgl);
                this.curmaterial = mat;
            };
            batchRenderer.prototype.push = function (webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > 2048
                    ||
                        (ebodata != null && this.eboCount + ebodata.length > 2048)) {
                    this.end(webgl);
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    var narr = new Float32Array(this.dataForVbo.length * 2);
                    for (var i = 0; i < this.dataForVbo.length; i++) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (var i = 0; i < vbodata.length; i++) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == render.DrawModeEnum.VboLine || this.drawMode == render.DrawModeEnum.VboTri)
                    return;
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        var narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (var i = 0; i < this.dataForEbo.length; i++) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (var i = 0; i < ebodata.length; i++) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            };
            batchRenderer.prototype.end = function (webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexData(webgl, this.dataForVbo.slice(0, this.vboCount));
                if (this.eboCount > 0)
                    this.mesh.uploadIndexData(webgl, 0, this.dataForEbo.slice(0, this.eboCount));
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                this.curmaterial.use(webgl);
                this.mesh.bind(webgl, this.curmaterial.program, (this.drawMode == render.DrawModeEnum.EboLine || this.drawMode == render.DrawModeEnum.EboTri) ? 0 : -1);
                if (this.drawMode == render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
            };
            return batchRenderer;
        }());
        render.batchRenderer = batchRenderer;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var shaderUniform = (function () {
            function shaderUniform() {
            }
            shaderUniform.initApplyUnifmFunc = function () {
                var _this = this;
                this.applyuniformFunc[render.UniformTypeEnum.Float] = function (location, value) {
                    _this.webgl.uniform1f(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Floatv] = function (location, value) {
                    _this.webgl.uniform1fv(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4] = function (location, value) {
                    _this.webgl.uniform4f(location, value.x, value.y, value.z, value.w);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4v] = function (location, value) {
                    _this.webgl.uniform4fv(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4x4] = function (location, value) {
                    _this.webgl.uniformMatrix4fv(location, false, value.rawData);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4x4v] = function (location, value) {
                    _this.webgl.uniformMatrix4fv(location, false, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Texture] = function (location, value) {
                    var tex = value.glTexture.texture;
                    _this.webgl.activeTexture(render.webglkit.GetTextureNumber(_this.webgl, _this.texindex));
                    _this.webgl.bindTexture(_this.webgl.TEXTURE_2D, tex);
                    _this.webgl.uniform1i(location, _this.texindex);
                    _this.texindex++;
                };
                this.applyuniformFunc[render.UniformTypeEnum.CubeTexture] = function (location, value) {
                    var tex = value.glTexture.texture;
                    _this.webgl.activeTexture(render.webglkit.GetTextureNumber(_this.webgl, _this.texindex));
                    _this.webgl.bindTexture(_this.webgl.TEXTURE_CUBE_MAP, tex);
                    _this.webgl.uniform1i(location, _this.texindex);
                    _this.texindex++;
                };
            };
            shaderUniform.texindex = 0;
            shaderUniform.applyuniformFunc = {};
            return shaderUniform;
        }());
        render.shaderUniform = shaderUniform;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var glWindow = (function () {
            function glWindow() {
                this.clearop_Color = false;
                this.backColor = new gd3d.math.color(1, 0, 1, 1);
                this.clearop_Depth = false;
                this.clearop_Stencil = false;
                this.viewport = new gd3d.math.rect(0, 0, 1, 1);
            }
            glWindow.prototype.use = function (webgl) {
                if (this.renderTarget != null) {
                    this.renderTarget.use(webgl);
                }
                else {
                    gd3d.render.glRenderTarget.useNull(webgl);
                }
                if (this.backColor != null)
                    webgl.clearColor(this.backColor.r, this.backColor.g, this.backColor.b, this.backColor.a);
                var n = 0;
                if (this.clearop_Color)
                    n |= webgl.COLOR_BUFFER_BIT;
                if (this.clearop_Depth)
                    n |= webgl.DEPTH_BUFFER_BIT;
                if (this.clearop_Stencil)
                    n |= webgl.STENCIL_BUFFER_BIT;
                webgl.clear(n);
                if (this.renderTarget != null) {
                    webgl.viewport(this.renderTarget.width * this.viewport.x, this.renderTarget.height * this.viewport.y, this.renderTarget.width * this.viewport.w, this.renderTarget.height * this.viewport.h);
                }
                else {
                    webgl.viewport(webgl.canvas.width * this.viewport.x, webgl.canvas.height * this.viewport.y, webgl.canvas.width * this.viewport.w, webgl.canvas.height * this.viewport.h);
                }
            };
            return glWindow;
        }());
        render.glWindow = glWindow;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var UniformTypeEnum;
        (function (UniformTypeEnum) {
            UniformTypeEnum[UniformTypeEnum["Texture"] = 0] = "Texture";
            UniformTypeEnum[UniformTypeEnum["Float"] = 1] = "Float";
            UniformTypeEnum[UniformTypeEnum["Floatv"] = 2] = "Floatv";
            UniformTypeEnum[UniformTypeEnum["Float4"] = 3] = "Float4";
            UniformTypeEnum[UniformTypeEnum["Float4v"] = 4] = "Float4v";
            UniformTypeEnum[UniformTypeEnum["Float4x4"] = 5] = "Float4x4";
            UniformTypeEnum[UniformTypeEnum["Float4x4v"] = 6] = "Float4x4v";
            UniformTypeEnum[UniformTypeEnum["CubeTexture"] = 7] = "CubeTexture";
        })(UniformTypeEnum = render.UniformTypeEnum || (render.UniformTypeEnum = {}));
        var uniform = (function () {
            function uniform() {
            }
            return uniform;
        }());
        render.uniform = uniform;
        var ShaderTypeEnum;
        (function (ShaderTypeEnum) {
            ShaderTypeEnum[ShaderTypeEnum["VS"] = 0] = "VS";
            ShaderTypeEnum[ShaderTypeEnum["FS"] = 1] = "FS";
        })(ShaderTypeEnum = render.ShaderTypeEnum || (render.ShaderTypeEnum = {}));
        var glShader = (function () {
            function glShader(name, type, shader, code) {
                this.name = name;
                this.type = type;
                this.shader = shader;
            }
            return glShader;
        }());
        render.glShader = glShader;
        var glProgram = (function () {
            function glProgram(vs, fs, program) {
                this.posPos = -1;
                this.posNormal = -1;
                this.posTangent = -1;
                this.posColor = -1;
                this.posUV0 = -1;
                this.posUV2 = -1;
                this.posBlendIndex4 = -1;
                this.posBlendWeight4 = -1;
                this.posColorEx = -1;
                this.mapUniform = {};
                this.vs = vs;
                this.fs = fs;
                this.program = program;
            }
            glProgram.prototype.initAttribute = function (webgl) {
                this.posPos = webgl.getAttribLocation(this.program, "_glesVertex");
                this.posColor = webgl.getAttribLocation(this.program, "_glesColor");
                this.posUV0 = webgl.getAttribLocation(this.program, "_glesMultiTexCoord0");
                this.posUV2 = webgl.getAttribLocation(this.program, "_glesMultiTexCoord1");
                this.posNormal = webgl.getAttribLocation(this.program, "_glesNormal");
                this.posTangent = webgl.getAttribLocation(this.program, "_glesTangent");
                this.posBlendIndex4 = webgl.getAttribLocation(this.program, "_glesBlendIndex4");
                this.posBlendWeight4 = webgl.getAttribLocation(this.program, "_glesBlendWeight4");
                this.posColorEx = webgl.getAttribLocation(this.program, "_glesColorEx");
            };
            glProgram.prototype.use = function (webgl) {
                webgl.useProgram(this.program);
            };
            glProgram.prototype.initUniforms = function (webgl) {
                var numUniforms = webgl.getProgramParameter(this.program, webgl.ACTIVE_UNIFORMS);
                for (var i = 0; i < numUniforms; i++) {
                    var uniformInfo = webgl.getActiveUniform(this.program, i);
                    if (!uniformInfo)
                        break;
                    var name = uniformInfo.name;
                    if (name.substr(-3) === "[0]") {
                        name = name.substr(0, name.length - 3);
                    }
                    var location = webgl.getUniformLocation(this.program, uniformInfo.name);
                    var type = uniformInfo.type;
                    var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]");
                    var _uniform = new uniform();
                    _uniform.name = name;
                    _uniform.location = location;
                    this.mapUniform[name] = _uniform;
                    if (type === webgl.FLOAT && isArray) {
                        _uniform.type = UniformTypeEnum.Floatv;
                    }
                    else if (type === webgl.FLOAT) {
                        _uniform.type = UniformTypeEnum.Float;
                    }
                    else if (type === webgl.FLOAT_VEC4 && isArray) {
                        _uniform.type = UniformTypeEnum.Float4v;
                    }
                    else if (type === webgl.FLOAT_VEC4) {
                        _uniform.type = UniformTypeEnum.Float4;
                    }
                    else if (type === webgl.FLOAT_MAT4 && isArray) {
                        _uniform.type = UniformTypeEnum.Float4x4v;
                    }
                    else if (type === webgl.FLOAT_MAT4) {
                        _uniform.type = UniformTypeEnum.Float4x4;
                    }
                    else if (type === webgl.SAMPLER_2D) {
                        _uniform.type = UniformTypeEnum.Texture;
                    }
                    else if (type === webgl.SAMPLER_CUBE) {
                        _uniform.type = UniformTypeEnum.CubeTexture;
                    }
                    else {
                        console.log("Unifrom parse Erorr : not have this type!");
                    }
                }
            };
            return glProgram;
        }());
        render.glProgram = glProgram;
        var shaderPool = (function () {
            function shaderPool() {
                this.mapVS = {};
                this.mapFS = {};
                this.mapProgram = {};
                this.mapVSString = {};
                this.mapFSString = {};
            }
            shaderPool.prototype.disposeVS = function (webgl, id) {
                webgl.deleteShader(this.mapVS[id].shader);
            };
            shaderPool.prototype.disposeFS = function (webgl, id) {
                webgl.deleteShader(this.mapFS[id].shader);
            };
            shaderPool.prototype.disposeProgram = function (webgl, id) {
                webgl.deleteProgram(this.mapProgram[id].program);
            };
            shaderPool.prototype.disposeAll = function (webgl) {
                for (var key in this.mapVS) {
                    this.disposeVS(webgl, key);
                }
                for (var key in this.mapFS) {
                    this.disposeFS(webgl, key);
                }
                for (var key in this.mapProgram) {
                    this.disposeProgram(webgl, key);
                }
                this.mapVS = {};
                this.mapFS = {};
                this.mapProgram = {};
            };
            shaderPool.prototype.compileVS = function (webgl, name, code) {
                var vs = webgl.createShader(webgl.VERTEX_SHADER);
                webgl.shaderSource(vs, code);
                webgl.compileShader(vs);
                var r1 = webgl.getShaderParameter(vs, webgl.COMPILE_STATUS);
                if (r1 == false) {
                    if (confirm("a vs:" + name + " error!!!" + webgl.getShaderInfoLog(vs) + "\n" + "did you want see the code?")) {
                        webgl.deleteShader(vs);
                        alert(code);
                    }
                    return null;
                }
                var s = new glShader(name, ShaderTypeEnum.VS, vs, code);
                this.mapVS[name] = s;
                return s;
            };
            shaderPool.prototype.compileFS = function (webgl, name, code) {
                var fs = webgl.createShader(webgl.FRAGMENT_SHADER);
                webgl.shaderSource(fs, code);
                webgl.compileShader(fs);
                var r1 = webgl.getShaderParameter(fs, webgl.COMPILE_STATUS);
                if (r1 == false) {
                    if (confirm("a fs:" + name + " error!!!" + webgl.getShaderInfoLog(fs) + "\n" + "did you want see the code?")) {
                        webgl.deleteShader(fs);
                        alert(code);
                    }
                    return null;
                }
                var s = new glShader(name, ShaderTypeEnum.FS, fs, code);
                this.mapFS[name] = s;
                return s;
            };
            shaderPool.prototype.linkProgram = function (webgl, nameVS, nameFS) {
                var program = webgl.createProgram();
                webgl.attachShader(program, this.mapVS[nameVS].shader);
                webgl.attachShader(program, this.mapFS[nameFS].shader);
                webgl.linkProgram(program);
                var r3 = webgl.getProgramParameter(program, webgl.LINK_STATUS);
                if (r3 == false) {
                    alert("vs:" + nameVS + "   fs:" + nameFS + "a webgl program error:" + webgl.getProgramInfoLog(program));
                    webgl.deleteProgram(program);
                    return null;
                }
                var name = nameVS + "_" + nameFS;
                var glp = new glProgram(this.mapVS[nameVS], this.mapFS[nameFS], program);
                glp.initUniforms(webgl);
                glp.initAttribute(webgl);
                this.mapProgram[name] = glp;
                return glp;
            };
            shaderPool.prototype.linkProgrambyPassType = function (webgl, type, nameVS, nameFS) {
                var vsStr = this.mapVSString[nameVS];
                var fsStr = this.mapFSString[nameFS];
                if (type == "base") {
                }
                else if (type == "base_fog" || type == "fog") {
                    vsStr = "#define FOG \n" + vsStr;
                    fsStr = "#define FOG \n" + fsStr;
                }
                else if (type == "skin") {
                    vsStr = "#define SKIN \n" + vsStr;
                    fsStr = "#define SKIN \n" + fsStr;
                }
                else if (type == "skin_fog") {
                    vsStr = "#define SKIN \n" + "#define FOG \n" + vsStr;
                    fsStr = "#define SKIN \n" + "#define FOG \n" + fsStr;
                }
                else if (type == "lightmap") {
                    vsStr = "#define LIGHTMAP \n" + vsStr;
                    fsStr = "#define LIGHTMAP \n" + fsStr;
                }
                else if (type == "lightmap_fog") {
                    vsStr = "#define LIGHTMAP \n" + "#define FOG \n" + vsStr;
                    fsStr = "#define LIGHTMAP \n" + "#define FOG \n" + fsStr;
                }
                else if (type == "quad") {
                    vsStr = "#define QUAD \n" + vsStr;
                    fsStr = "#define QUAD \n" + fsStr;
                }
                this.compileVS(webgl, nameVS + type, vsStr);
                this.compileFS(webgl, nameFS + type, fsStr);
                var pro = this.linkProgram(webgl, nameVS + type, nameFS + type);
                return pro;
            };
            return shaderPool;
        }());
        render.shaderPool = shaderPool;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        var TextureFormatEnum;
        (function (TextureFormatEnum) {
            TextureFormatEnum[TextureFormatEnum["RGBA"] = 1] = "RGBA";
            TextureFormatEnum[TextureFormatEnum["RGB"] = 2] = "RGB";
            TextureFormatEnum[TextureFormatEnum["Gray"] = 3] = "Gray";
            TextureFormatEnum[TextureFormatEnum["PVRTC4_RGB"] = 4] = "PVRTC4_RGB";
            TextureFormatEnum[TextureFormatEnum["PVRTC4_RGBA"] = 4] = "PVRTC4_RGBA";
            TextureFormatEnum[TextureFormatEnum["PVRTC2_RGB"] = 4] = "PVRTC2_RGB";
            TextureFormatEnum[TextureFormatEnum["PVRTC2_RGBA"] = 4] = "PVRTC2_RGBA";
        })(TextureFormatEnum = render.TextureFormatEnum || (render.TextureFormatEnum = {}));
        var textureReader = (function () {
            function textureReader(webgl, texRGBA, width, height, gray) {
                if (gray === void 0) { gray = true; }
                this.gray = gray;
                this.width = width;
                this.height = height;
                var fbo = webgl.createFramebuffer();
                var fbold = webgl.getParameter(webgl.FRAMEBUFFER_BINDING);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbo);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, texRGBA, 0);
                var readData = new Uint8Array(this.width * this.height * 4);
                readData[0] = 2;
                webgl.readPixels(0, 0, this.width, this.height, webgl.RGBA, webgl.UNSIGNED_BYTE, readData);
                webgl.deleteFramebuffer(fbo);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbold);
                if (gray) {
                    this.data = new Uint8Array(this.width * this.height);
                    for (var i = 0; i < width * height; i++) {
                        this.data[i] = readData[i * 4];
                    }
                }
                else {
                    this.data = readData;
                }
            }
            textureReader.prototype.getPixel = function (u, v) {
                var x = (u * this.width) | 0;
                var y = (v * this.height) | 0;
                if (x < 0 || x >= this.width || y < 0 || y >= this.height)
                    return 0;
                if (this.gray) {
                    return this.data[y * this.width + x];
                }
                else {
                    var i = (y * this.width + x) * 4;
                    return new gd3d.math.color(this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]);
                }
            };
            return textureReader;
        }());
        render.textureReader = textureReader;
        var glRenderTarget = (function () {
            function glRenderTarget(webgl, width, height, depth, stencil) {
                if (depth === void 0) { depth = false; }
                if (stencil === void 0) { stencil = false; }
                this.width = width;
                this.height = height;
                this.fbo = webgl.createFramebuffer();
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                if (depth || stencil) {
                    this.renderbuffer = webgl.createRenderbuffer();
                    webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                    if (depth && stencil) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else if (depth) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                }
                this.texture = webgl.createTexture();
                this.fbo["width"] = width;
                this.fbo["height"] = height;
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
            }
            glRenderTarget.prototype.use = function (webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            };
            glRenderTarget.useNull = function (webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            };
            glRenderTarget.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteFramebuffer(this.renderbuffer);
                    this.renderbuffer = null;
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glRenderTarget.prototype.caclByteLength = function () {
                return this.width * this.height * 4;
            };
            glRenderTarget.prototype.isFrameBuffer = function () {
                return true;
            };
            return glRenderTarget;
        }());
        render.glRenderTarget = glRenderTarget;
        var glTexture2D = (function () {
            function glTexture2D(webgl, format, mipmap, linear) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (mipmap === void 0) { mipmap = false; }
                if (linear === void 0) { linear = true; }
                this.linear = true;
                this.premultiply = true;
                this.repeat = true;
                this.mirroredU = true;
                this.mirroredV = true;
                this.loaded = false;
                this.width = 0;
                this.height = 0;
                this.mipmap = false;
                this.webgl = webgl;
                this.format = format;
                this.linear = linear;
                this.mipmap = mipmap;
                this.texture = webgl.createTexture();
                var extname = "WEBGL_compressed_texture_pvrtc";
                this.ext = this.getExt("WEBGL_compressed_texture_pvrtc");
            }
            glTexture2D.prototype.getExt = function (name) {
                var browserPrefixes = [
                    "",
                    "MOZ_",
                    "OP_",
                    "WEBKIT_"
                ];
                for (var ii = 0; ii < browserPrefixes.length; ++ii) {
                    var prefixedName = browserPrefixes[ii] + name;
                    var ext = this.webgl.getExtension(prefixedName);
                    if (ext) {
                        return ext;
                    }
                }
                return null;
            };
            glTexture2D.prototype.uploadImage = function (img, mipmap, linear, premultiply, repeat, mirroredU, mirroredV) {
                if (premultiply === void 0) { premultiply = true; }
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.width = img.width;
                this.height = img.height;
                this.mipmap = mipmap;
                this.linear = linear;
                this.premultiply = premultiply;
                this.repeat = repeat;
                this.mirroredU = mirroredU;
                this.mirroredV = mirroredV;
                this.loaded = true;
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, formatGL, this.webgl.UNSIGNED_BYTE, img);
                if (mipmap) {
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            };
            glTexture2D.prototype.uploadByteArray = function (mipmap, linear, width, height, data, repeat, mirroredU, mirroredV) {
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.width = width;
                this.height = height;
                this.mipmap = mipmap;
                this.linear = linear;
                this.repeat = repeat;
                this.mirroredU = mirroredU;
                this.mirroredV = mirroredV;
                this.loaded = true;
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, this.webgl.UNSIGNED_BYTE, data);
                if (mipmap) {
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            };
            glTexture2D.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen;
                if (this.mipmap) {
                    len = len * (1 - Math.pow(0.25, 10)) / 0.75;
                }
                return len;
            };
            glTexture2D.prototype.getReader = function (redOnly) {
                if (redOnly === void 0) { redOnly = false; }
                if (this.reader != null) {
                    if (this.reader.gray != redOnly)
                        throw new Error("get param diff with this.reader");
                    return this.reader;
                }
                if (this.format != TextureFormatEnum.RGBA)
                    throw new Error("only rgba texture can read");
                if (this.texture == null)
                    return null;
                if (this.reader == null)
                    this.reader = new textureReader(this.webgl, this.texture, this.width, this.height, redOnly);
                return this.reader;
            };
            glTexture2D.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glTexture2D.prototype.isFrameBuffer = function () {
                return false;
            };
            glTexture2D.formGrayArray = function (webgl, array, width, height) {
                var mipmap = false;
                var linear = true;
                var t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(array.length * 4);
                for (var y = 0; y < width; y++) {
                    for (var x = 0; x < width; x++) {
                        var fi = y * 512 + x;
                        var i = y * width + x;
                        data[fi * 4] = array[i] * 255;
                        data[fi * 4 + 1] = array[i] * 255;
                        data[fi * 4 + 2] = array[i] * 255;
                        data[fi * 4 + 3] = 255;
                    }
                }
                t.uploadByteArray(mipmap, linear, 512, 512, data);
                return t;
            };
            glTexture2D.staticTexture = function (webgl, name) {
                var t = glTexture2D.mapTexture[name];
                if (t != undefined)
                    return t;
                var mipmap = false;
                var linear = true;
                t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(4);
                var width = 1;
                var height = 1;
                data[0] = 128;
                data[1] = 0;
                data[2] = 128;
                data[3] = 255;
                if (name == "gray") {
                    data[0] = 128;
                    data[1] = 128;
                    data[2] = 128;
                    data[3] = 255;
                }
                else if (name == "white") {
                    data[0] = 255;
                    data[1] = 255;
                    data[2] = 255;
                    data[3] = 255;
                }
                else if (name == "black") {
                    data[0] = 0;
                    data[1] = 0;
                    data[2] = 0;
                    data[3] = 255;
                }
                else if (name == "normal") {
                    data[0] = 128;
                    data[1] = 128;
                    data[2] = 255;
                    data[3] = 255;
                }
                else if (name == "grid") {
                    width = 256;
                    height = 256;
                    data = new Uint8Array(width * width * 4);
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            var seek = (y * width + x) * 4;
                            if (((x - width * 0.5) * (y - height * 0.5)) > 0) {
                                data[seek] = 0;
                                data[seek + 1] = 0;
                                data[seek + 2] = 0;
                                data[seek + 3] = 255;
                            }
                            else {
                                data[seek] = 255;
                                data[seek + 1] = 255;
                                data[seek + 2] = 255;
                                data[seek + 3] = 255;
                            }
                        }
                    }
                }
                t.uploadByteArray(mipmap, linear, width, height, data);
                glTexture2D.mapTexture[name] = t;
                return t;
            };
            glTexture2D.mapTexture = {};
            return glTexture2D;
        }());
        render.glTexture2D = glTexture2D;
        var glTextureCube = (function () {
            function glTextureCube(webgl, format, mipmap, linear) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (mipmap === void 0) { mipmap = false; }
                if (linear === void 0) { linear = true; }
                this.loaded = false;
                this.width = 0;
                this.height = 0;
                this.mipmap = false;
                this.linear = false;
                this.webgl = webgl;
                this.format = format;
                this.mipmap = mipmap;
                this.linear = linear;
                this.texture = webgl.createTexture();
            }
            glTextureCube.prototype.uploadImages = function (Texture_NEGATIVE_X, Texture_NEGATIVE_Y, Texture_NEGATIVE_Z, Texture_POSITIVE_X, Texture_POSITIVE_Y, Texture_POSITIVE_Z) {
                var wrc = WebGLRenderingContext;
                var textures = [Texture_NEGATIVE_X, Texture_NEGATIVE_Y, Texture_NEGATIVE_Z, Texture_POSITIVE_X, Texture_POSITIVE_Y, Texture_POSITIVE_Z];
                var typeArr = [wrc.TEXTURE_CUBE_MAP_NEGATIVE_X, wrc.TEXTURE_CUBE_MAP_NEGATIVE_Y, wrc.TEXTURE_CUBE_MAP_NEGATIVE_Z, wrc.TEXTURE_CUBE_MAP_POSITIVE_X, wrc.TEXTURE_CUBE_MAP_POSITIVE_Y, wrc.TEXTURE_CUBE_MAP_POSITIVE_Z];
                for (var i = 0; i < typeArr.length; i++) {
                    var reader = textures[i].glTexture.getReader();
                    if (!reader) {
                        console.warn("getReader() fail : " + textures[i].getName());
                        return;
                    }
                    this.upload(reader.data, reader.width, reader.height, typeArr[i]);
                }
            };
            glTextureCube.prototype.upload = function (data, width, height, TEXTURE_CUBE_MAP_) {
                this.width = width;
                this.height = height;
                this.loaded = true;
                var gl = this.webgl;
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                this.webgl.bindTexture(this.webgl.TEXTURE_CUBE_MAP, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                if (data instanceof HTMLImageElement) {
                    this.webgl.texImage2D(TEXTURE_CUBE_MAP_, 0, formatGL, formatGL, this.webgl.UNSIGNED_BYTE, data);
                }
                else {
                    this.webgl.texImage2D(TEXTURE_CUBE_MAP_, 0, formatGL, width, height, 0, formatGL, this.webgl.UNSIGNED_BYTE, data);
                }
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                var mipmap = this.mipmap;
                var linear = this.linear;
            };
            glTextureCube.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen * 6;
                if (this.mipmap) {
                    len = len * (1 - Math.pow(0.25, 10)) / 0.75;
                }
                return len;
            };
            glTextureCube.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glTextureCube.prototype.isFrameBuffer = function () {
                return false;
            };
            return glTextureCube;
        }());
        render.glTextureCube = glTextureCube;
        var WriteableTexture2D = (function () {
            function WriteableTexture2D(webgl, format, width, height, linear, premultiply, repeat, mirroredU, mirroredV) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (premultiply === void 0) { premultiply = true; }
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.premultiply = true;
                this.repeat = false;
                this.mirroredU = false;
                this.mirroredV = false;
                this.width = 0;
                this.height = 0;
                this.webgl = webgl;
                this.texture = webgl.createTexture();
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.format = format;
                this.formatGL = this.webgl.RGBA;
                if (format == TextureFormatEnum.RGB)
                    this.formatGL = this.webgl.RGB;
                else if (format == TextureFormatEnum.Gray)
                    this.formatGL = this.webgl.LUMINANCE;
                var data = null;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, this.formatGL, width, height, 0, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
                if (linear) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            }
            WriteableTexture2D.prototype.updateRect = function (data, x, y, width, height) {
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, width, height, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            };
            WriteableTexture2D.prototype.updateRectImg = function (data, x, y) {
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            };
            WriteableTexture2D.prototype.isFrameBuffer = function () {
                return false;
            };
            WriteableTexture2D.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            WriteableTexture2D.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen;
                return len;
            };
            return WriteableTexture2D;
        }());
        render.WriteableTexture2D = WriteableTexture2D;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
//# sourceMappingURL=gd3d.js.map