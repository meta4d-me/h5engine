var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let NotifyType;
        (function (NotifyType) {
            NotifyType[NotifyType["AddChild"] = 0] = "AddChild";
            NotifyType[NotifyType["RemoveChild"] = 1] = "RemoveChild";
            NotifyType[NotifyType["ChangeVisible"] = 2] = "ChangeVisible";
            NotifyType[NotifyType["AddCamera"] = 3] = "AddCamera";
            NotifyType[NotifyType["AddCanvasRender"] = 4] = "AddCanvasRender";
        })(NotifyType = framework.NotifyType || (framework.NotifyType = {}));
        let CanvasFixedType;
        (function (CanvasFixedType) {
            CanvasFixedType[CanvasFixedType["Free"] = 0] = "Free";
            CanvasFixedType[CanvasFixedType["FixedWidthType"] = 1] = "FixedWidthType";
            CanvasFixedType[CanvasFixedType["FixedHeightType"] = 2] = "FixedHeightType";
        })(CanvasFixedType = framework.CanvasFixedType || (framework.CanvasFixedType = {}));
        class application {
            constructor() {
                this.limitFrame = true;
                this.version = "v0.0.1";
                this.build = "b000061";
                this._tar = -1;
                this._standDeltaTime = -1;
                this.canvasFixedType = CanvasFixedType.Free;
                this._scaleFromPandding = 1;
                this.beStepNumber = 0;
                this.pretimer = 0;
                this.isFrustumCulling = true;
                this._userCode = [];
                this._userCodeNew = [];
                this._editorCode = [];
                this._editorCodeNew = [];
                this._bePlay = false;
                this.be2dstate = false;
                this.curcameraindex = -1;
                this._bePause = false;
                this._beStepForward = false;
                this.orientation = framework.OrientationMode.AUTO;
                this.shouldRotate = false;
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.OffOrientationUpdate = false;
            }
            get width() {
                return this.webgl.canvas.width;
            }
            get height() {
                return this.webgl.canvas.height;
            }
            set timeScale(val) {
                this._timeScale = val;
            }
            get timeScale() {
                return this._timeScale;
            }
            set targetFrame(val) {
                if (val == 0)
                    val = -1;
                this._tar = val;
                this._standDeltaTime = 1 / this._tar;
            }
            get targetFrame() {
                return this._tar;
            }
            set canvasFixHeight(val) {
                this._fixHeight = val;
            }
            set canvasFixWidth(val) {
                this._fixWidth = val;
            }
            get canvasClientWidth() {
                return this._canvasClientWidth;
            }
            get canvasClientHeight() {
                return this._canvasClientHeight;
            }
            get scaleFromPandding() { return this._scaleFromPandding; }
            start(div, type = CanvasFixedType.Free, val = 1200, webglDebug = false) {
                console.log("version: " + this.version + "  build: " + this.build);
                if (div == null) {
                    console.error("root div does Null at application start ");
                    return;
                }
                div.style.overflow = "hidden";
                div.style.position = "absolute";
                div.style.width = "100%";
                div.style.height = "100%";
                this.outcontainer = div;
                var rotateDiv = document.createElement("div");
                rotateDiv.className = "full";
                rotateDiv.style.overflow = "hidden";
                rotateDiv.style.position = "absolute";
                rotateDiv.style.width = "100%";
                rotateDiv.style.height = "100%";
                this.container = rotateDiv;
                div.appendChild(rotateDiv);
                var canvas = document.createElement("canvas");
                if (canvas == null) {
                    alert("Failed to create canvas at the application.start()");
                    throw Error("Failed to create canvas at the application.start()");
                }
                canvas.className = "full";
                canvas.style.position = "absolute";
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                canvas.style.backgroundColor = "#1e1e1e";
                canvas.setAttribute("tabindex", "1");
                rotateDiv.appendChild(canvas);
                this.startForCanvas(canvas, type, val, webglDebug);
            }
            startForCanvas(canvas, type = CanvasFixedType.Free, val = 1200, webglDebug = false) {
                this._timeScale = 1;
                framework.sceneMgr.app = this;
                let tempWebGlUtil = new framework.WebGLUtils();
                this.webgl = tempWebGlUtil.setupWebGL(canvas);
                if (this.webgl == null) {
                    alert("Failed to get webgl at the application.start()");
                    throw Error("Failed to get webgl at the application.start()");
                }
                this.canvasFixedType = type;
                if (this.outcontainer) {
                    switch (type) {
                        case CanvasFixedType.Free:
                            this.screenAdaptiveType = "宽高度自适应(宽高都不固定,真实像素宽高)";
                            this.webgl.canvas.width = this.webgl.canvas.clientWidth;
                            this.webgl.canvas.height = this.webgl.canvas.clientHeight;
                            this._scaleFromPandding = 1;
                            break;
                        case CanvasFixedType.FixedWidthType:
                            this.canvasFixWidth = val;
                            this.screenAdaptiveType = "宽度自适应(宽度固定,一般横屏使用)";
                            this.webgl.canvas.width = this._fixWidth;
                            this.webgl.canvas.height = this._fixWidth * this.webgl.canvas.clientHeight / this.webgl.canvas.clientWidth;
                            this._scaleFromPandding = this.webgl.canvas.clientHeight / this.webgl.canvas.height;
                            break;
                        case CanvasFixedType.FixedHeightType:
                            this.canvasFixHeight = val;
                            this.screenAdaptiveType = "高度自适应(高度固定，一般竖屏使用)";
                            this.webgl.canvas.height = this._fixHeight;
                            this.webgl.canvas.width = this.webgl.canvas.clientWidth * this._fixHeight / this.webgl.canvas.clientHeight;
                            this._scaleFromPandding = this.webgl.canvas.clientHeight / this.webgl.canvas.height;
                            break;
                    }
                }
                this._canvasClientWidth = canvas.width;
                this._canvasClientHeight = canvas.height;
                gd3d.render.webglkit.initConst(this.webgl);
                this.initRender();
                this.initAssetMgr();
                this.initInputMgr();
                this.initScene();
                this.beginTimer = this.lastTimer = this.pretimer = Date.now() / 1000;
                this.loop();
                gd3d.io.referenceInfo.regDefaultType();
                let initovercallback = window["initovercallback"];
                if (initovercallback != null) {
                    initovercallback(this);
                }
                if (webglDebug) {
                    let tempWebGLDebugUtils = new framework.WebGLDebugUtils();
                    this.webgl = tempWebGLDebugUtils.makeDebugContext(this.webgl);
                    console.error(" i am ---webglDebug-");
                }
            }
            markNotify(trans, type) {
                this.doNotify(trans, type);
            }
            doNotify(trans, type) {
                if (trans == null)
                    return;
                if (!this.checkFilter(trans))
                    return;
                if (this.notify)
                    this.notify.notify(trans, type);
                if (trans.children != null) {
                    for (let index in trans.children) {
                        this.doNotify(trans.children[index], type);
                    }
                }
            }
            checkFilter(trans) {
                if (trans instanceof gd3d.framework.transform) {
                    if (trans.gameObject.hideFlags & gd3d.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                if (trans instanceof gd3d.framework.transform2D) {
                    if (trans.hideFlags & gd3d.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                return true;
            }
            showFps() {
                if (this.stats == null) {
                    this.stats = new Stats.Stats(this);
                    this.stats.container.style.position = 'absolute';
                    this.stats.container.style.left = '0px';
                    this.stats.container.style.top = '0px';
                    this.container.appendChild(this.stats.container);
                }
                else {
                    this.container.appendChild(this.stats.container);
                }
            }
            closeFps() {
                if (this.stats != null) {
                    this.container.removeChild(this.stats.container);
                }
            }
            update(delta) {
                {
                    this.updateOrientationMode();
                }
                this.updateScreenAsp();
                if (this.bePlay) {
                    if (this.bePause) {
                        if (this.beStepForward && this.beStepNumber > 0) {
                            this.beStepNumber--;
                            this.updateUserCode(delta);
                        }
                    }
                    else {
                        this.updateUserCode(delta);
                    }
                }
                this.updateEditorCode(delta);
                if (this._scene != null) {
                    this._scene.update(delta);
                }
            }
            updateScreenAsp() {
                if (!this.outcontainer)
                    return;
                if (this.webgl.canvas.clientWidth != this._canvasClientWidth || this.webgl.canvas.clientHeight != this._canvasClientHeight) {
                    this._canvasClientWidth = this.webgl.canvas.clientWidth;
                    this._canvasClientHeight = this.webgl.canvas.clientHeight;
                    if (this.canvasFixedType == CanvasFixedType.Free) {
                        this.webgl.canvas.width = this.webgl.canvas.clientWidth;
                        this.webgl.canvas.height = this.webgl.canvas.clientHeight;
                        this._scaleFromPandding = 1;
                    }
                    else if (this.canvasFixedType == CanvasFixedType.FixedWidthType) {
                        this.webgl.canvas.width = this._fixWidth;
                        this.webgl.canvas.height = this._fixWidth * this.webgl.canvas.clientHeight / this.webgl.canvas.clientWidth;
                        this._scaleFromPandding = this.webgl.canvas.clientHeight / this.webgl.canvas.height;
                    }
                    else if (this.canvasFixedType == CanvasFixedType.FixedHeightType) {
                        this.webgl.canvas.height = this._fixHeight;
                        this.webgl.canvas.width = this.webgl.canvas.clientWidth * this._fixHeight / this.webgl.canvas.clientHeight;
                        this._scaleFromPandding = this.webgl.canvas.clientHeight / this.webgl.canvas.height;
                    }
                }
            }
            getUserUpdateTimer() {
                return this.usercodetime;
            }
            getTotalTime() {
                return this.totalTime;
            }
            get deltaTime() {
                return this._deltaTime * this._timeScale;
            }
            getUpdateTimer() {
                return this.updateTimer;
            }
            loop() {
                var now = Date.now() / 1000;
                this._deltaTime = now - this.lastTimer;
                this.totalTime = now - this.beginTimer;
                this.updateTimer = now - this.pretimer;
                if (this._deltaTime < this._standDeltaTime) {
                    let _this = this;
                    let del = this._standDeltaTime - this._deltaTime;
                    setTimeout(function () {
                        var _now = Date.now() / 1000;
                        _this.lastTimer = _now;
                        _this.pretimer = _now;
                        _this.update(_this._standDeltaTime);
                        if (_this.stats != null)
                            _this.stats.update();
                        _this.loop();
                    }, del * 1000);
                }
                else {
                    this.update(this.deltaTime);
                    if (this.stats != null)
                        this.stats.update();
                    this.lastTimer = now;
                    this.pretimer = now;
                    if (this.limitFrame) {
                        requestAnimationFrame(this.loop.bind(this));
                    }
                    else {
                        setTimeout(this.loop.bind(this), 1);
                    }
                }
            }
            initScene() {
                if (this._scene == null) {
                    this._scene = new framework.scene(this);
                    framework.sceneMgr.scene = this._scene;
                }
            }
            initRender() {
                framework.uniformSetter.initAutouniform();
                gd3d.render.shaderUniform.webgl = this.webgl;
                gd3d.render.shaderUniform.initApplyUnifmFunc();
            }
            getScene() {
                return this._scene;
            }
            initAssetMgr() {
                if (this._assetmgr == null) {
                    this._assetmgr = new framework.assetMgr(this);
                    this._assetmgr.initDefAsset();
                }
            }
            getAssetMgr() {
                return this._assetmgr;
            }
            initInputMgr() {
                if (this._inputmgr == null) {
                    this._inputmgr = new framework.inputMgr(this);
                }
            }
            getInputMgr() {
                return this._inputmgr;
            }
            get bePlay() {
                return this._bePlay;
            }
            set bePlay(value) {
                this._bePlay = value;
            }
            get bePause() {
                return this._bePause;
            }
            set bePause(value) {
                this._bePause = value;
            }
            get beStepForward() {
                return this._beStepForward;
            }
            set beStepForward(value) {
                this._beStepForward = value;
            }
            updateUserCode(delta) {
                for (var i = this._userCodeNew.length - 1; i >= 0; i--) {
                    var c = this._userCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._userCode.push(c);
                        this._userCodeNew.splice(i, 1);
                    }
                }
                var closeindex = -1;
                for (var i = 0; i < this._userCode.length; i++) {
                    var c = this._userCode[i];
                    if (c.isClosed() == false) {
                        c.onUpdate(delta);
                    }
                    else if (closeindex < 0) {
                        closeindex = i;
                    }
                }
                if (closeindex >= 0) {
                    this._userCode.splice(closeindex, 1);
                }
            }
            updateEditorCode(delta) {
                for (let i = this._editorCodeNew.length - 1; i >= 0; i--) {
                    let c = this._editorCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._editorCode.push(c);
                        this._editorCodeNew.splice(i, 1);
                    }
                }
                let closeindex = -1;
                for (let i = this._editorCode.length - 1; i >= 0; i--) {
                    let c = this._editorCode[i];
                    if (c.isClosed()) {
                        this._editorCode.splice(i, 1);
                    }
                    else {
                        c.onUpdate(delta);
                    }
                }
            }
            addUserCodeDirect(program) {
                this._userCodeNew.push(program);
            }
            addUserCode(classname) {
                var prototype = gd3d.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = gd3d.reflect.createInstance(prototype, { "usercode": "1" });
                    this.addUserCodeDirect(code);
                }
            }
            addEditorCode(classname) {
                var prototype = gd3d.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = gd3d.reflect.createInstance(prototype, { "editorcode": "1" });
                    this.addEditorCodeDirect(code);
                }
            }
            addEditorCodeDirect(program) {
                this._editorCodeNew.push(program);
            }
            updateOrientationMode() {
                if (this.OffOrientationUpdate || !this.outcontainer)
                    return;
                let screenRect = this.outcontainer.getBoundingClientRect();
                this.shouldRotate = false;
                if (this.orientation != framework.OrientationMode.AUTO) {
                    this.shouldRotate =
                        (this.orientation == framework.OrientationMode.LANDSCAPE || this.orientation == framework.OrientationMode.LANDSCAPE_FLIPPED) && screenRect.height > screenRect.width ||
                            this.orientation == framework.OrientationMode.PORTRAIT && screenRect.width > screenRect.height;
                }
                let screenWidth = this.shouldRotate ? screenRect.height : screenRect.width;
                let screenHeight = this.shouldRotate ? screenRect.width : screenRect.height;
                if (this.lastWidth == screenWidth && this.lastHeight == screenHeight)
                    return;
                this.lastWidth = screenWidth;
                this.lastHeight = screenHeight;
                if (this.container) {
                    this.container.style[getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
                    this.container.style.width = screenWidth + "px";
                    this.container.style.height = screenHeight + "px";
                    let rotation = 0;
                    if (this.shouldRotate) {
                        if (this.orientation == framework.OrientationMode.LANDSCAPE) {
                            rotation = 90;
                            this.container.style.top = (screenRect.height - screenWidth) / 2 + "px";
                            this.container.style.left = (screenRect.width + screenHeight) / 2 + "px";
                        }
                        else {
                            rotation = -90;
                            this.container.style.top = (screenRect.height + screenWidth) / 2 + "px";
                            this.container.style.left = (screenRect.width - screenHeight) / 2 + "px";
                        }
                    }
                    else {
                        this.container.style.top = (screenRect.height - screenHeight) / 2 + "px";
                        this.container.style.left = (screenRect.width - screenWidth) / 2 + "px";
                    }
                    let transform = `rotate(${rotation}deg)`;
                    this.container.style[getPrefixStyleName("transform")] = transform;
                }
            }
        }
        framework.application = application;
        framework.OrientationMode = {
            AUTO: "auto",
            PORTRAIT: "portrait",
            LANDSCAPE: "landscape",
            LANDSCAPE_FLIPPED: "landscapeFlipped"
        };
        let currentPrefix = null;
        function getPrefixStyleName(name, element) {
            let header = "";
            if (element != null) {
                header = getPrefix(name, element);
            }
            else {
                if (currentPrefix == null) {
                    let tempStyle = document.createElement('div').style;
                    currentPrefix = getPrefix("transform", tempStyle);
                }
                header = currentPrefix;
            }
            if (header == "") {
                return name;
            }
            return header + name.charAt(0).toUpperCase() + name.substring(1, name.length);
        }
        framework.getPrefixStyleName = getPrefixStyleName;
        function getPrefix(name, element) {
            if (name in element) {
                return "";
            }
            name = name.charAt(0).toUpperCase() + name.substring(1, name.length);
            let transArr = ["webkit", "ms", "Moz", "O"];
            for (let i = 0; i < transArr.length; i++) {
                let tempStyle = transArr[i] + name;
                if (tempStyle in element) {
                    return transArr[i];
                }
            }
            return "";
        }
        framework.getPrefix = getPrefix;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class DeviceInfo {
            static getExtension() {
                this.debuginfo = framework.sceneMgr.app.webgl.getExtension('WEBGL_debug_renderer_info');
                if (this.debuginfo == null) {
                    console.warn("extension(WEBGL_debug_renderer_info) not support!");
                }
            }
            static get GraphDevice() {
                if (this.debuginfo == null) {
                    this.getExtension();
                }
                if (this.debuginfo) {
                    let device = framework.sceneMgr.app.webgl.getParameter(this.debuginfo.UNMASKED_RENDERER_WEBGL);
                    return device;
                }
                else {
                    return "unknown";
                }
            }
            static get CanvasWidth() {
                if (framework.sceneMgr.app) {
                    return framework.sceneMgr.app.webgl.canvas.width;
                }
                else {
                    return null;
                }
            }
            static get CanvasHeight() {
                if (framework.sceneMgr.app) {
                    return framework.sceneMgr.app.webgl.canvas.height;
                }
                else {
                    return null;
                }
            }
            static get ScreenAdaptiveType() {
                if (framework.sceneMgr.app) {
                    return framework.sceneMgr.app.screenAdaptiveType;
                }
                else {
                    return "unknown";
                }
            }
            static get ScreenWidth() {
                return window.screen.width * (window.devicePixelRatio || 1);
            }
            static get ScreenHeight() {
                return window.screen.height * (window.devicePixelRatio || 1);
            }
        }
        framework.DeviceInfo = DeviceInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class sceneMgr {
            static get ins() {
                if (sceneMgr._ins == null)
                    sceneMgr._ins = new sceneMgr();
                return sceneMgr._ins;
            }
        }
        framework.sceneMgr = sceneMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var Stats;
(function (Stats_1) {
    class Stats {
        constructor(app) {
            this.mode = 0;
            this.app = app;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', (event) => {
                event.preventDefault();
                this.showPanel(++this.mode % this.container.children.length);
            }, false);
            this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.frames = 0;
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            this.ratePanel = this.addPanel(new Panel('%', '#0f0', '#020'));
            this.userratePanel = this.addPanel(new Panel('%', '#0f0', '#020'));
            if (self.performance && self.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        update() {
            this.beginTime = this.end();
        }
        showPanel(id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        }
        addPanel(panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        }
        begin() {
            this.beginTime = (performance || Date).now();
        }
        end() {
            this.frames++;
            var time = (performance || Date).now();
            this.msPanel.update(time - this.beginTime, 200);
            if (time > this.prevTime + 1000) {
                let fps = (this.frames * 1000) / (time - this.prevTime);
                this.fpsPanel.update(fps, 100);
                this.ratePanel.update(this.app.getUpdateTimer() * this.frames / 10, 100);
                this.userratePanel.update(this.app.getUserUpdateTimer() * this.frames / 10, 100);
                this.prevTime = time;
                this.frames = 0;
                if (this.memPanel) {
                    var memory = performance["memory"];
                    this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
                }
            }
            return time;
        }
    }
    Stats_1.Stats = Stats;
    class Panel {
        constructor(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        update(value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        }
    }
})(Stats || (Stats = {}));
var gd3d;
(function (gd3d) {
    gd3d.gd3d_reflect_root = {};
    let reflect;
    (function (reflect) {
        function regType(target, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"]["class"] == undefined)
                target["__gdmeta__"]["class"] = {};
            var name = target["constructor"]["name"];
            if (name == null) {
                var fs = target["constructor"].toString();
                var i = fs.indexOf("(");
                name = fs.substring(9, i);
            }
            target["__gdmeta__"]["class"]["typename"] = name;
            if (gd3d.gd3d_reflect_root["__gdmeta__"] == null)
                gd3d.gd3d_reflect_root["__gdmeta__"] = {};
            gd3d.gd3d_reflect_root["__gdmeta__"][name] = target;
            if (target["__gdmeta__"]["class"]["custom"] == null)
                target["__gdmeta__"]["class"]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"]["class"]["custom"][key] = customInfo[key];
                }
            }
        }
        function regFunc(target, funcname, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"][funcname] == null)
                target["__gdmeta__"][funcname] = {};
            target["__gdmeta__"][funcname]["type"] = "function";
            var tp = Reflect.getMetadata("design:paramtypes", target, funcname);
            var tr = Reflect.getMetadata("design:returntype", target, funcname);
            target["__gdmeta__"][funcname]["paramtypes"] = [];
            for (var i in tp) {
                target["__gdmeta__"][funcname]["paramtypes"][i] = tp[i]["name"];
            }
            target["__gdmeta__"][funcname]["returntype"] = tr == null ? null : tr["name"];
            if (target["__gdmeta__"][funcname]["custom"] == null)
                target["__gdmeta__"][funcname]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][funcname]["custom"][key] = customInfo[key];
                }
            }
        }
        function regField(target, fieldName, customInfo) {
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"][fieldName] == null)
                target["__gdmeta__"][fieldName] = {};
            target["__gdmeta__"][fieldName]["type"] = "field";
            if (target["__gdmeta__"][fieldName]["custom"] == null)
                target["__gdmeta__"][fieldName]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][fieldName]["custom"][key] = customInfo[key];
                }
            }
        }
        function getPrototypes() {
            return gd3d.gd3d_reflect_root["__gdmeta__"];
        }
        reflect.getPrototypes = getPrototypes;
        function getPrototype(name) {
            return gd3d.gd3d_reflect_root["__gdmeta__"][name];
        }
        reflect.getPrototype = getPrototype;
        function createInstance(prototype, matchTag) {
            if (matchTag == null) {
                var ctor = prototype.constructor;
                return new ctor();
            }
            else {
                var info = prototype["__gdmeta__"]["class"]["custom"];
                for (var key in matchTag) {
                    if (info[key] != matchTag[key]) {
                        console.warn("createInstance:" + name + ". tag do not match.");
                        return null;
                    }
                }
                var ctor = prototype.constructor;
                return new ctor();
            }
        }
        reflect.createInstance = createInstance;
        function getClassName(prototype) {
            var info = prototype["__gdmeta__"]["class"]["typename"];
            return info;
        }
        reflect.getClassName = getClassName;
        function getClassTag(prototype, tag) {
            var info = prototype["__gdmeta__"]["class"]["custom"];
            return info[tag];
        }
        reflect.getClassTag = getClassTag;
        function getMeta(prototype) {
            var meta = prototype.__gdmeta__;
            return meta;
        }
        reflect.getMeta = getMeta;
        function attr_Class(constructorObj) {
            regType(constructorObj.prototype, null);
        }
        reflect.attr_Class = attr_Class;
        function attr_Func(customInfo = null) {
            return function (target, propertyKey, value) {
                regFunc(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Func = attr_Func;
        function attr_Field(customInfo = null) {
            return function (target, propertyKey) {
                regField(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Field = attr_Field;
        function userCode(constructorObj) {
            regType(constructorObj.prototype, { "usercode": "1" });
        }
        reflect.userCode = userCode;
        function editorCode(constructorObj) {
            regType(constructorObj.prototype, { "editorcode": "1" });
        }
        reflect.editorCode = editorCode;
        function selfClone(constructorObj) {
            regType(constructorObj.prototype, { "selfclone": "1" });
        }
        reflect.selfClone = selfClone;
        function nodeComponent(constructorObj) {
            regType(constructorObj.prototype, { "nodecomp": "1" });
        }
        reflect.nodeComponent = nodeComponent;
        function nodeComponentInspector(constructorObj) {
            regType(constructorObj.prototype, { "nodecomp_inspector": "1" });
        }
        reflect.nodeComponentInspector = nodeComponentInspector;
        function nodeRender(constructorObj) {
            regType(constructorObj.prototype, { "renderer": "1" });
        }
        reflect.nodeRender = nodeRender;
        function nodeCamera(constructorObj) {
            regType(constructorObj.prototype, { "camera": "1" });
        }
        reflect.nodeCamera = nodeCamera;
        function nodeLight(constructorObj) {
            regType(constructorObj.prototype, { "light": "1" });
        }
        reflect.nodeLight = nodeLight;
        function nodeBoxCollider(constructorObj) {
            regType(constructorObj.prototype, { "boxcollider": "1" });
        }
        reflect.nodeBoxCollider = nodeBoxCollider;
        function nodeBoxCollider2d(constructorObj) {
            regType(constructorObj.prototype, { "boxcollider2d": "1" });
        }
        reflect.nodeBoxCollider2d = nodeBoxCollider2d;
        function nodeSphereCollider(constructorObj) {
            regType(constructorObj.prototype, { "spherecollider": "1" });
        }
        reflect.nodeSphereCollider = nodeSphereCollider;
        function nodeEffectBatcher(constructorObj) {
            regType(constructorObj.prototype, { "effectbatcher": "1" });
        }
        reflect.nodeEffectBatcher = nodeEffectBatcher;
        function nodeMeshCollider(constructorObj) {
            regType(constructorObj.prototype, { "meshcollider": "1" });
        }
        reflect.nodeMeshCollider = nodeMeshCollider;
        function nodeCanvasRendererCollider(constructorObj) {
            regType(constructorObj.prototype, { "canvasRenderer": "1" });
        }
        reflect.nodeCanvasRendererCollider = nodeCanvasRendererCollider;
        function node2DComponent(constructorObj) {
            regType(constructorObj.prototype, { "2dcomp": "1" });
        }
        reflect.node2DComponent = node2DComponent;
        function pluginMenuItem(constructorObj) {
            regType(constructorObj.prototype, { "plugin_menuitem": "1" });
        }
        reflect.pluginMenuItem = pluginMenuItem;
        function pluginWindow(constructorObj) {
            regType(constructorObj.prototype, { "plugin_window": "1" });
        }
        reflect.pluginWindow = pluginWindow;
        function pluginExt(constructorObj) {
            regType(constructorObj.prototype, { "plugin_ext": "1" });
        }
        reflect.pluginExt = pluginExt;
        function compValue(integer = false, defvalue = 0, min = Number.MIN_VALUE, max = Number.MAX_VALUE) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "compValue": "1",
                    "integer": integer ? "1" : "0",
                    "defvalue": defvalue.toString(),
                    "min": min.toString(),
                    "max": max.toString(),
                });
            };
        }
        reflect.compValue = compValue;
        function compCall(customInfo = null) {
            return function (target, propertyKey, value) {
                regFunc(target, propertyKey, { "compcall": "1" });
                regFunc(target, propertyKey, customInfo);
            };
        }
        reflect.compCall = compCall;
        function SerializeType(constructorObj) {
            regType(constructorObj.prototype, { "SerializeType": "1" });
        }
        reflect.SerializeType = SerializeType;
        function Field(valueType, defaultValue = undefined, enumRealType = undefined) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "SerializeField": true,
                    "valueType": valueType
                });
                if (defaultValue == undefined) {
                }
                else {
                    regField(target, propertyKey, {
                        "defaultValue": defaultValue
                    });
                }
            };
        }
        reflect.Field = Field;
        function UIComment(comment) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "UIComment": comment
                });
            };
        }
        reflect.UIComment = UIComment;
        let FieldUIStyle;
        (function (FieldUIStyle) {
            FieldUIStyle[FieldUIStyle["None"] = 0] = "None";
            FieldUIStyle[FieldUIStyle["RangeFloat"] = 1] = "RangeFloat";
            FieldUIStyle[FieldUIStyle["MultiLineString"] = 2] = "MultiLineString";
            FieldUIStyle[FieldUIStyle["Enum"] = 3] = "Enum";
        })(FieldUIStyle = reflect.FieldUIStyle || (reflect.FieldUIStyle = {}));
        function UIStyle(style, min, max, defvalue) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "FieldUIStyle": style,
                    "min": min ? min : null,
                    "max": max ? max : null,
                    "defvalue": defvalue ? defvalue : null
                });
            };
        }
        reflect.UIStyle = UIStyle;
    })(reflect = gd3d.reflect || (gd3d.reflect = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let canvas = class canvas {
            constructor() {
                this.is2dUI = true;
                this.pointDown = false;
                this.pointSelect = null;
                this.pointEvent = new framework.PointEvent();
                this.pointX = 0;
                this.pointY = 0;
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.lastMaskSta = -1;
                this.pixelWidth = 640;
                this.pixelHeight = 480;
                this.rootNode = new framework.transform2D();
                this.rootNode.canvas = this;
            }
            addChild(node) {
                this.rootNode.addChild(node);
            }
            removeChild(node) {
                this.rootNode.removeChild(node);
            }
            getChildren() {
                return this.rootNode.children;
            }
            getChildCount() {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            }
            getChild(index) {
                return this.rootNode.children[index];
            }
            update(delta, touch, XOnModelSpace, YOnModelSpace) {
                var asp = this.pixelWidth / this.pixelHeight;
                this.rootNode.localScale.x = 2 / this.pixelWidth;
                this.rootNode.localScale.y = -2 / this.pixelHeight;
                this.rootNode.localTranslate.y = 1;
                this.rootNode.localTranslate.x = -1;
                if (this.pixelWidth != this.lastWidth || this.pixelHeight != this.lastHeight) {
                    this.lastWidth = this.rootNode.width = this.pixelWidth;
                    this.lastHeight = this.rootNode.height = this.pixelHeight;
                    this.rootNode.markDirty();
                }
                this.rootNode.pivot.x = 0;
                this.rootNode.pivot.y = 0;
                this.rootNode.updateTran(false);
                {
                    this.pointEvent.eated = false;
                    this.pointEvent.x = XOnModelSpace;
                    this.pointEvent.y = YOnModelSpace;
                    this.pointEvent.selected = this.pointSelect;
                    var skip = false;
                    if (this.pointDown == false && touch == false) {
                        skip = true;
                    }
                    else if (this.pointDown == false && touch == true) {
                        this.pointEvent.type = framework.PointEventEnum.PointDown;
                    }
                    else if (this.pointDown == true && touch == true) {
                        this.pointEvent.type = framework.PointEventEnum.PointHold;
                        if (this.pointX == this.pointEvent.x && this.pointY == this.pointEvent.y) {
                            skip = true;
                        }
                    }
                    else if (this.pointDown == true && touch == false) {
                        this.pointEvent.type = framework.PointEventEnum.PointUp;
                    }
                    if (!skip) {
                        if (this.scene.app.bePlay) {
                            this.rootNode.onCapturePointEvent(this, this.pointEvent);
                            this.rootNode.onPointEvent(this, this.pointEvent);
                        }
                        this.pointSelect = this.pointEvent.selected;
                        this.pointDown = touch;
                        this.pointX = this.pointEvent.x;
                        this.pointY = this.pointEvent.y;
                    }
                }
                this.rootNode.update(delta);
            }
            render(context, assetmgr) {
                this.context = context;
                this.assetmgr = assetmgr;
                this.lastMat = null;
                if (this.batcher == null) {
                    this.webgl = context.webgl;
                    this.batcher = new framework.batcher2D();
                    var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0 | gd3d.render.VertexFormatMask.ColorEX;
                    this.batcher.initBuffer(context.webgl, vf, gd3d.render.DrawModeEnum.VboTri);
                }
                if (this.beforeRender != null)
                    this.beforeRender();
                this.drawScene(this.rootNode, context, assetmgr);
                this.batcher.end(context.webgl);
                if (this.afterRender != null)
                    this.afterRender();
            }
            pushRawData(mat, data) {
                if (mat != this.lastMat) {
                    this.lastMat = mat;
                    this.batcher.end(this.webgl);
                    let pass = this.lastMat.getShader().passes["base"][0];
                    pass.use(this.webgl);
                    mat.uploadUnifoms(pass, this.context);
                    this.batcher.begin(this.webgl, pass);
                }
                else {
                    let msta = mat.statedMapUniforms["MaskState"];
                    let mr = mat.statedMapUniforms["_maskRect"];
                    if (msta != null && msta.value != null && mr != null && mr.value != null) {
                        let rect = mr.value;
                        if (this.lastMaskV4 == null)
                            this.lastMaskV4 = new gd3d.math.vector4();
                        if (msta.value != this.lastMaskSta || this.lastMaskV4.x != rect.x || this.lastMaskV4.y != rect.y || this.lastMaskV4.z != rect.z || this.lastMaskV4.w != rect.w) {
                            this.lastMaskSta = msta.value;
                            gd3d.math.vec4Clone(rect, this.lastMaskV4);
                            this.batcher.end(this.webgl);
                            let pass = this.lastMat.getShader().passes["base"][0];
                            mat.uploadUnifoms(pass, this.context);
                        }
                    }
                }
                this.batcher.push(this.webgl, data, null);
            }
            drawScene(node, context, assetmgr) {
                if (!node.visible)
                    return;
                if (node.renderer != null) {
                    node.renderer.render(this);
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.drawScene(node.children[i], context, assetmgr);
                    }
                }
            }
            getRoot() {
                if (this.rootNode == null) {
                    this.rootNode = new framework.transform2D();
                    this.rootNode.canvas = this;
                    this.scene.app.markNotify(this.rootNode, framework.NotifyType.AddChild);
                }
                return this.rootNode;
            }
            ModelPosToCanvasPos(fromP, outP) {
                if (fromP == null || outP == null)
                    return;
                let scalx = 1 - (fromP.x - 1) / -2;
                let scaly = (fromP.y - 1) / -2;
                outP.x = scalx * this.pixelWidth;
                outP.y = scaly * this.pixelHeight;
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], canvas.prototype, "pixelWidth", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], canvas.prototype, "pixelHeight", void 0);
        __decorate([
            gd3d.reflect.Field("transform2D"),
            __metadata("design:type", framework.transform2D)
        ], canvas.prototype, "rootNode", void 0);
        canvas = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [])
        ], canvas);
        framework.canvas = canvas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class batcher2D {
            constructor() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            initBuffer(webgl, vf, drawMode) {
                this.mesh = new gd3d.render.glMesh();
                this.mesh.initBuffer(webgl, vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == gd3d.render.DrawModeEnum.EboLine || drawMode == gd3d.render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
            }
            begin(webgl, pass) {
                if (this.vboCount > 0)
                    this.end(webgl);
                this.curPass = pass;
            }
            push(webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > 2048
                    ||
                        (ebodata != null && this.eboCount + ebodata.length > 2048)) {
                    this.end(webgl);
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    let narr = new Float32Array(this.dataForVbo.length * 2);
                    for (var i = 0; i < this.dataForVbo.length; i++) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (var i = 0; i < vbodata.length; i++) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == gd3d.render.DrawModeEnum.VboLine || this.drawMode == gd3d.render.DrawModeEnum.VboTri)
                    return;
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        let narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (var i = 0; i < this.dataForEbo.length; i++) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (var i = 0; i < ebodata.length; i++) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            }
            end(webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexData(webgl, this.dataForVbo);
                if (this.eboCount > 0) {
                    this.mesh.uploadIndexData(webgl, 0, this.dataForEbo);
                }
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                this.curPass.use(webgl);
                this.mesh.bind(webgl, this.curPass.program, (this.drawMode == gd3d.render.DrawModeEnum.EboLine || this.drawMode == gd3d.render.DrawModeEnum.EboTri) ? 0 : -1);
                if (this.drawMode == gd3d.render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == gd3d.render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
            }
        }
        framework.batcher2D = batcher2D;
        let canvasRenderer = class canvasRenderer {
            constructor() {
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                this.cupTans2ds = [];
                this.canvas = new framework.canvas();
                this.canvas.is2dUI = false;
            }
            get renderLayer() { return this.gameObject.layer; }
            set renderLayer(layer) {
                this.gameObject.layer = layer;
            }
            getBound() {
                return null;
            }
            intersectsTransform(tran) {
                return false;
            }
            start() {
                this.canvas.scene = this.gameObject.getScene();
                this.canvas.parentTrans = this.gameObject.transform;
                this.inputmgr = this.gameObject.getScene().app.getInputMgr();
            }
            onPlay() {
            }
            addChild(node) {
                this.canvas.addChild(node);
            }
            removeChild(node) {
                this.canvas.removeChild(node);
            }
            getChildren() {
                return this.canvas.getChildren();
            }
            getChildCount() {
                return this.canvas.getChildCount();
            }
            getChild(index) {
                return this.canvas.getChild(index);
            }
            update(delta) {
                let asp = this.canvas.pixelWidth / this.canvas.pixelHeight;
                this.gameObject.transform.localScale.x = this.gameObject.transform.localScale.y * asp;
                if (this.cameraTouch != null) {
                    let scene = this.gameObject.getScene();
                    let tempv2 = gd3d.math.pool.new_vector2(this.inputmgr.point.x, this.inputmgr.point.y);
                    let ray = this.cameraTouch.creatRayByScreen(tempv2, scene.app);
                    let outModel = gd3d.math.pool.new_vector2();
                    let bool = this.pickModelPos(ray, outModel);
                    if (bool) {
                        this.canvas.update(delta, this.inputmgr.point.touch, outModel.x, outModel.y);
                    }
                    else {
                        this.canvas.update(delta, false, 0, 0);
                    }
                    gd3d.math.pool.delete_vector2(tempv2);
                    gd3d.math.pool.delete_vector2(outModel);
                }
                else {
                    this.canvas.update(delta, false, 0, 0);
                }
            }
            pickModelPos(ray, outModelPos) {
                let result = false;
                if (!ray || !outModelPos)
                    return result;
                let scene = this.gameObject.getScene();
                let tempInfo = gd3d.math.pool.new_pickInfo();
                let bool = ray.intersectPlaneTransform(this.gameObject.transform, tempInfo);
                if (bool && tempInfo.pickedtran == this.gameObject.transform) {
                    var mat = this.gameObject.transform.getWorldMatrix();
                    var matinv = gd3d.math.pool.new_matrix();
                    gd3d.math.matrixInverse(mat, matinv);
                    var outv = gd3d.math.pool.new_vector3();
                    gd3d.math.matrixTransformVector3(tempInfo.hitposition, matinv, outv);
                    outModelPos.x = outv.x;
                    outModelPos.y = outv.y;
                    result = true;
                    gd3d.math.pool.delete_matrix(matinv);
                    gd3d.math.pool.delete_vector3(outv);
                }
                return result;
            }
            pickAll2d(ray) {
                let result;
                let outv = gd3d.math.pool.new_vector2();
                let bool = this.pickModelPos(ray, outv);
                if (bool) {
                    result = [];
                    this.dopick2d(outv, this.canvas.getRoot(), result, true);
                }
                gd3d.math.pool.delete_vector2(outv);
                return result;
            }
            pick2d(ray) {
                let result;
                let outv = gd3d.math.pool.new_vector2();
                let bool = this.pickModelPos(ray, outv);
                if (bool) {
                    let temparr = [];
                    this.dopick2d(outv, this.canvas.getRoot(), temparr);
                    if (temparr && temparr[0])
                        result = temparr[0];
                }
                gd3d.math.pool.delete_vector2(outv);
                return result;
            }
            dopick2d(ModelPos, tran, outPicks, isAll = false) {
                if (!ModelPos || !tran || !outPicks)
                    return;
                if (tran.children && tran.children.length > 0) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        this.dopick2d(ModelPos, tran.children[i], outPicks, isAll);
                    }
                }
                if (tran.ContainsCanvasPoint(ModelPos)) {
                    outPicks.push(tran);
                    if (!isAll)
                        return;
                }
            }
            calScreenPosToCanvasPos(camera, screenPos, outCanvasPos) {
                if (!camera || !screenPos || !outCanvasPos)
                    return;
                let ray = camera.creatRayByScreen(screenPos, this.gameObject.getScene().app);
                let ModelPos = gd3d.math.pool.new_vector2();
                this.pickModelPos(ray, ModelPos);
                this.canvas.ModelPosToCanvasPos(ModelPos, outCanvasPos);
                gd3d.math.pool.delete_vector2(ModelPos);
            }
            calCanvasPosToWorldPos(from, out) {
                if (!this.canvas || !from || !out)
                    return;
                let ModelPos = gd3d.math.pool.new_vector3();
                ModelPos.x = (from.x / this.canvas.pixelWidth) * 2 - 1;
                ModelPos.y = (from.y / this.canvas.pixelHeight) * -2 + 1;
                let m_mtx = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixTransformVector3(ModelPos, m_mtx, out);
                out.z = this.gameObject.transform.getWorldTranslate().z;
                gd3d.math.pool.delete_vector3(ModelPos);
            }
            render(context, assetmgr, camera) {
                context.updateModel(this.gameObject.transform);
                this.canvas.render(context, assetmgr);
            }
            remove() {
            }
            clone() {
            }
        };
        __decorate([
            gd3d.reflect.Field("canvas"),
            __metadata("design:type", framework.canvas)
        ], canvasRenderer.prototype, "canvas", void 0);
        canvasRenderer = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeCanvasRendererCollider,
            __metadata("design:paramtypes", [])
        ], canvasRenderer);
        framework.canvasRenderer = canvasRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let PointEventEnum;
        (function (PointEventEnum) {
            PointEventEnum[PointEventEnum["PointNothing"] = 0] = "PointNothing";
            PointEventEnum[PointEventEnum["PointDown"] = 1] = "PointDown";
            PointEventEnum[PointEventEnum["PointHold"] = 2] = "PointHold";
            PointEventEnum[PointEventEnum["PointUp"] = 3] = "PointUp";
        })(PointEventEnum = framework.PointEventEnum || (framework.PointEventEnum = {}));
        class PointEvent {
        }
        framework.PointEvent = PointEvent;
        class UIEvent {
            constructor() {
                this.funcs = [];
            }
            addListener(func) {
                this.funcs.push(func);
            }
            excute() {
                for (let key in this.funcs) {
                    this.funcs[key]();
                }
            }
            clear() {
                this.funcs.length = 0;
            }
        }
        framework.UIEvent = UIEvent;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let UIScaleMode;
        (function (UIScaleMode) {
            UIScaleMode[UIScaleMode["CONSTANT_PIXEL_SIZE"] = 0] = "CONSTANT_PIXEL_SIZE";
            UIScaleMode[UIScaleMode["SCALE_WITH_SCREEN_SIZE"] = 1] = "SCALE_WITH_SCREEN_SIZE";
        })(UIScaleMode = framework.UIScaleMode || (framework.UIScaleMode = {}));
        let overlay2D = class overlay2D {
            constructor() {
                this.init = false;
                this.autoAsp = true;
                this.screenMatchRate = 0;
                this.matchReference_width = 800;
                this.matchReference_height = 600;
                this.scaleMode = UIScaleMode.CONSTANT_PIXEL_SIZE;
                this.sortOrder = 0;
                this.viewPixelrect = new gd3d.math.rect();
                this.canvas = new framework.canvas();
                framework.sceneMgr.app.markNotify(this.canvas.getRoot(), framework.NotifyType.AddChild);
            }
            start(camera) {
                if (camera == this.camera)
                    return;
                this.camera = camera;
                this.app = camera.gameObject.getScene().app;
                this.canvas.scene = camera.gameObject.getScene();
                this.inputmgr = camera.gameObject.getScene().app.getInputMgr();
            }
            addChild(node) {
                this.canvas.addChild(node);
            }
            removeChild(node) {
                this.canvas.removeChild(node);
            }
            getChildren() {
                return this.canvas.getChildren();
            }
            getChildCount() {
                return this.canvas.getChildCount();
            }
            getChild(index) {
                return this.canvas.getChild(index);
            }
            render(context, assetmgr, camera) {
                if (!this.canvas.getRoot().visible || !this.camera)
                    return;
                let vp = new gd3d.math.rect();
                this.camera.calcViewPortPixel(assetmgr.app, vp);
                switch (this.scaleMode) {
                    case UIScaleMode.CONSTANT_PIXEL_SIZE:
                        if (this.canvas.pixelWidth == vp.w && this.canvas.pixelHeight == vp.h)
                            break;
                        this.canvas.pixelWidth = vp.w;
                        this.canvas.pixelHeight = vp.h;
                        this.canvas.getRoot().markDirty();
                        break;
                    case UIScaleMode.SCALE_WITH_SCREEN_SIZE:
                        let match = this.screenMatchRate < 0 ? 0 : this.screenMatchRate;
                        match = match > 1 ? 1 : match;
                        let asp = vp.w / vp.h;
                        let w = gd3d.math.numberLerp(this.matchReference_width, this.matchReference_height * asp, match);
                        let h = gd3d.math.numberLerp(this.matchReference_height, this.matchReference_width / asp, 1 - match);
                        if (this.canvas.pixelWidth != w || this.canvas.pixelHeight != h) {
                            this.canvas.pixelWidth = w;
                            this.canvas.pixelHeight = h;
                            this.canvas.getRoot().markDirty();
                        }
                        break;
                }
                context.updateOverlay();
                this.canvas.render(context, assetmgr);
            }
            update(delta) {
                this.camera.calcViewPortPixel(this.app, this.viewPixelrect);
                let rect = this.camera.viewport;
                let real_x = this.inputmgr.point.x - rect.x * this.app.width;
                let real_y = this.inputmgr.point.y - rect.y * this.app.height;
                let sx = (real_x / this.viewPixelrect.w) * 2 - 1;
                let sy = (real_y / this.viewPixelrect.h) * -2 + 1;
                if (this.canvas["pointEvent"].type == framework.PointEventEnum.PointDown) {
                    this.canvas;
                }
                this.canvas.update(delta, this.inputmgr.point.touch, sx, sy);
            }
            pick2d(mx, my, tolerance = 0) {
                if (this.camera == null)
                    return null;
                var vp = new gd3d.math.rect();
                var app = this.camera.calcViewPortPixel(this.app, vp);
                var sx = (mx / vp.w) * 2 - 1;
                var sy = (my / vp.h) * -2 + 1;
                var outv2 = gd3d.math.pool.new_vector2();
                outv2.x = sx;
                outv2.y = sy;
                var root = this.canvas.getRoot();
                let trans = this.dopick2d(outv2, root, tolerance);
                gd3d.math.pool.delete_vector2(outv2);
                return trans;
            }
            dopick2d(ModelPos, tran, tolerance = 0) {
                if (tran.components != null) {
                    for (var i = tran.components.length - 1; i >= 0; i--) {
                        var comp = tran.components[i];
                        if (comp != null)
                            if (comp.comp.transform.ContainsCanvasPoint(ModelPos, tolerance)) {
                                return comp.comp.transform;
                            }
                    }
                }
                if (tran.children != null) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        var tran2 = this.dopick2d(ModelPos, tran.children[i], tolerance);
                        if (tran2 != null)
                            return tran2;
                    }
                }
                return null;
            }
            calScreenPosToCanvasPos(screenPos, outCanvasPos) {
                if (!this.camera || !this.canvas)
                    return;
                var vp = new gd3d.math.rect();
                this.camera.calcViewPortPixel(this.app, vp);
                var temt = gd3d.math.pool.new_vector2();
                temt.x = (screenPos.x / vp.w) * 2 - 1;
                temt.y = (screenPos.y / vp.h) * -2 + 1;
                var mat = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Clone(this.canvas.getRoot().getWorldMatrix(), mat);
                gd3d.math.matrix3x2Inverse(mat, mat);
                gd3d.math.matrix3x2TransformVector2(mat, temt, outCanvasPos);
                gd3d.math.pool.delete_vector2(temt);
            }
        };
        __decorate([
            gd3d.reflect.Field("canvas"),
            __metadata("design:type", framework.canvas)
        ], overlay2D.prototype, "canvas", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], overlay2D.prototype, "autoAsp", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], overlay2D.prototype, "screenMatchRate", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object)
        ], overlay2D.prototype, "matchReference_width", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object)
        ], overlay2D.prototype, "matchReference_height", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], overlay2D.prototype, "scaleMode", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], overlay2D.prototype, "sortOrder", void 0);
        overlay2D = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [])
        ], overlay2D);
        framework.overlay2D = overlay2D;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        var _ubyte = new Uint8Array(1);
        var _byte = new Int8Array(1);
        var _int16 = new Int16Array(1);
        var _int32 = new Int32Array(1);
        var _uint16 = new Uint16Array(1);
        var _uint32 = new Uint32Array(1);
        var _float32 = new Float32Array(1);
        var _float64 = new Float64Array(1);
        function UByte(v = 0) {
            if (typeof (v) == "string")
                v = Number(v);
            _ubyte[0] = v;
            return _ubyte[0];
        }
        math.UByte = UByte;
        function Byte(v = 0) {
            if (typeof (v) == "string")
                v = Number(v);
            _byte[0] = v;
            return _byte[0];
        }
        math.Byte = Byte;
        function Int16(v = 0) {
            if (typeof (v) == "string")
                v = Number(v);
            _int16[0] = v;
            return _int16[0];
        }
        math.Int16 = Int16;
        function Int32(v = 0) {
            if (typeof (v) == "string")
                v = Number(v);
            _int32[0] = v;
            return _int32[0];
        }
        math.Int32 = Int32;
        function UInt16(v = 0) {
            if (typeof (v) == "string")
                v = Number(v);
            _uint16[0] = v;
            return _uint16[0];
        }
        math.UInt16 = UInt16;
        function UInt32(v = 0) {
            if (typeof (v) == "string")
                v = Number(v);
            _uint32[0] = v;
            return _uint32[0];
        }
        math.UInt32 = UInt32;
        function Float(v = 0) {
            if (typeof (v) == "string")
                v = Number(v);
            _float32[0] = v;
            return _float32[0];
        }
        math.Float = Float;
        function Double(v = 0) {
            if (typeof (v) == "string")
                v = Number(v);
            _float64[0] = v;
            return _float64[0];
        }
        math.Double = Double;
        let vector2 = class vector2 {
            constructor(x = 0, y = 0, w = 0, h = 0) {
                this.rawData = new Float32Array(2);
                this.rawData[0] = x;
                this.rawData[1] = y;
            }
            get x() {
                return this.rawData[0];
            }
            ;
            set x(x) {
                this.rawData[0] = x;
            }
            get y() {
                return this.rawData[1];
            }
            ;
            set y(y) {
                this.rawData[1] = y;
            }
            toString() {
                return `${this.x},${this.y}`;
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], vector2.prototype, "x", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], vector2.prototype, "y", null);
        vector2 = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], vector2);
        math.vector2 = vector2;
        let rect = class rect {
            constructor(x = 0, y = 0, w = 0, h = 0) {
                this.rawData = new Float32Array(4);
                this.rawData[0] = x;
                this.rawData[1] = y;
                this.rawData[2] = w;
                this.rawData[3] = h;
            }
            get x() {
                return this.rawData[0];
            }
            ;
            set x(x) {
                this.rawData[0] = x;
            }
            get y() {
                return this.rawData[1];
            }
            ;
            set y(y) {
                this.rawData[1] = y;
            }
            get w() {
                return this.rawData[2];
            }
            ;
            set w(w) {
                this.rawData[2] = w;
            }
            get h() {
                return this.rawData[3];
            }
            ;
            set h(h) {
                this.rawData[3] = h;
            }
            toString() {
                return `${this.rawData[0]},${this.rawData[1]},${this.rawData[2]},${this.rawData[3]}`;
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], rect.prototype, "x", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], rect.prototype, "y", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], rect.prototype, "w", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], rect.prototype, "h", null);
        rect = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], rect);
        math.rect = rect;
        let border = class border {
            constructor(l = 0, t = 0, r = 0, b = 0) {
                this.rawData = new Float32Array(4);
                this.rawData[0] = l;
                this.rawData[1] = t;
                this.rawData[2] = r;
                this.rawData[3] = b;
            }
            get l() {
                return this.rawData[0];
            }
            ;
            set l(l) {
                this.rawData[0] = l;
            }
            get t() {
                return this.rawData[1];
            }
            ;
            set t(t) {
                this.rawData[1] = t;
            }
            get r() {
                return this.rawData[2];
            }
            ;
            set r(r) {
                this.rawData[2] = r;
            }
            get b() {
                return this.rawData[3];
            }
            ;
            set b(b) {
                this.rawData[3] = b;
            }
            toString() {
                return `${this.r},${this.t},${this.r},${this.b}`;
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], border.prototype, "l", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], border.prototype, "t", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], border.prototype, "r", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], border.prototype, "b", null);
        border = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], border);
        math.border = border;
        let color = class color {
            constructor(r = 1, g = 1, b = 1, a = 1) {
                this.rawData = new Float32Array(4);
                this.rawData[0] = r;
                this.rawData[1] = g;
                this.rawData[2] = b;
                this.rawData[3] = a;
            }
            get r() {
                return this.rawData[0];
            }
            ;
            set r(r) {
                this.rawData[0] = r;
            }
            get g() {
                return this.rawData[1];
            }
            ;
            set g(g) {
                this.rawData[1] = g;
            }
            get b() {
                return this.rawData[2];
            }
            ;
            set b(b) {
                this.rawData[2] = b;
            }
            get a() {
                return this.rawData[3];
            }
            ;
            set a(a) {
                this.rawData[3] = a;
            }
            toString() {
                return `${this.r},${this.g},${this.b},${this.a}`;
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], color.prototype, "r", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], color.prototype, "g", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], color.prototype, "b", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], color.prototype, "a", null);
        color = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], color);
        math.color = color;
        let vector3 = class vector3 {
            constructor(x = 0, y = 0, z = 0) {
                this.rawData = new Float32Array(3);
                this.rawData[0] = x;
                this.rawData[1] = y;
                this.rawData[2] = z;
            }
            get x() {
                return this.rawData[0];
            }
            ;
            set x(x) {
                this.rawData[0] = x;
            }
            get y() {
                return this.rawData[1];
            }
            ;
            set y(y) {
                this.rawData[1] = y;
            }
            get z() {
                return this.rawData[2];
            }
            ;
            set z(z) {
                this.rawData[2] = z;
            }
            toString() {
                return `${this.rawData[0]},${this.rawData[1]},${this.rawData[2]}`;
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], vector3.prototype, "x", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], vector3.prototype, "y", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], vector3.prototype, "z", null);
        vector3 = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number])
        ], vector3);
        math.vector3 = vector3;
        let vector4 = class vector4 {
            constructor(x = 0, y = 0, z = 0, w = 0) {
                this.rawData = new Float32Array(4);
                this.rawData[0] = x;
                this.rawData[1] = y;
                this.rawData[2] = z;
                this.rawData[3] = w;
            }
            get x() {
                return this.rawData[0];
            }
            ;
            set x(x) {
                this.rawData[0] = x;
            }
            get y() {
                return this.rawData[1];
            }
            ;
            set y(y) {
                this.rawData[1] = y;
            }
            get z() {
                return this.rawData[2];
            }
            ;
            set z(z) {
                this.rawData[2] = z;
            }
            get w() {
                return this.rawData[3];
            }
            ;
            set w(w) {
                this.rawData[3] = w;
            }
            toString() {
                return `${this.rawData[0]},${this.rawData[1]},${this.rawData[2]},${this.rawData[3]}`;
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], vector4.prototype, "x", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], vector4.prototype, "y", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], vector4.prototype, "z", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], vector4.prototype, "w", null);
        vector4 = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], vector4);
        math.vector4 = vector4;
        let quaternion = class quaternion {
            constructor(x = 0, y = 0, z = 0, w = 1) {
                this.rawData = new Float32Array(4);
                this.rawData[0] = x;
                this.rawData[1] = y;
                this.rawData[2] = z;
                this.rawData[3] = w;
            }
            get x() {
                return this.rawData[0];
            }
            ;
            set x(x) {
                this.rawData[0] = x;
            }
            get y() {
                return this.rawData[1];
            }
            ;
            set y(y) {
                this.rawData[1] = y;
            }
            get z() {
                return this.rawData[2];
            }
            ;
            set z(z) {
                this.rawData[2] = z;
            }
            get w() {
                return this.rawData[3];
            }
            ;
            set w(w) {
                this.rawData[3] = w;
            }
            toString() {
                return `${this.rawData[0]},${this.rawData[1]},${this.rawData[2]},${this.rawData[3]}`;
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], quaternion.prototype, "x", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], quaternion.prototype, "y", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], quaternion.prototype, "z", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], quaternion.prototype, "w", null);
        quaternion = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Number, Number, Number])
        ], quaternion);
        math.quaternion = quaternion;
        class matrix {
            constructor(datas = null) {
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
            }
            toString() {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "," + this.rawData[3] + "],"
                    + "[" + this.rawData[4] + "," + this.rawData[5] + "," + this.rawData[6] + "," + this.rawData[7] + "],"
                    + "[" + this.rawData[8] + "," + this.rawData[9] + "," + this.rawData[10] + "," + this.rawData[11] + "],"
                    + "[" + this.rawData[12] + "," + this.rawData[13] + "," + this.rawData[14] + "," + this.rawData[15] + "]";
            }
        }
        math.matrix = matrix;
        class matrix3x2 {
            constructor(datas = null) {
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = new Float32Array([1, 0, 0, 1, 0, 0]);
            }
            toString() {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "],"
                    + "[" + this.rawData[3] + "," + this.rawData[4] + "," + this.rawData[5] + "]";
            }
        }
        math.matrix3x2 = matrix3x2;
        function vec4FormJson(json, vec4) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            let arr = json.split(",");
            vec4.x = Number(arr[0]);
            vec4.y = Number(arr[1]);
            vec4.z = Number(arr[2]);
            vec4.w = Number(arr[3]);
        }
        math.vec4FormJson = vec4FormJson;
        function vec3FormJson(json, vec3) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            let arr = json.split(",");
            vec3.x = Number(arr[0]);
            vec3.y = Number(arr[1]);
            vec3.z = Number(arr[2]);
        }
        math.vec3FormJson = vec3FormJson;
        function vec2FormJson(json, vec2) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            let arr = json.split(",");
            vec2.x = Number(arr[0]);
            vec2.y = Number(arr[1]);
        }
        math.vec2FormJson = vec2FormJson;
        function colorFormJson(json, _color) {
            json = json.replace("RGBA(", "");
            json = json.replace(")", "");
            let arr = json.split(",");
            _color.r = Number(arr[0]);
            _color.g = Number(arr[1]);
            _color.b = Number(arr[2]);
            _color.a = Number(arr[3]);
        }
        math.colorFormJson = colorFormJson;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let layoutOption;
        (function (layoutOption) {
            layoutOption[layoutOption["LEFT"] = 1] = "LEFT";
            layoutOption[layoutOption["TOP"] = 2] = "TOP";
            layoutOption[layoutOption["RIGHT"] = 4] = "RIGHT";
            layoutOption[layoutOption["BOTTOM"] = 8] = "BOTTOM";
            layoutOption[layoutOption["H_CENTER"] = 16] = "H_CENTER";
            layoutOption[layoutOption["V_CENTER"] = 32] = "V_CENTER";
        })(layoutOption = framework.layoutOption || (framework.layoutOption = {}));
        let C2DComponent = class C2DComponent {
            constructor(comp, init = false) {
                this.comp = comp;
                this.init = init;
            }
        };
        __decorate([
            gd3d.reflect.Field("I2DComponent"),
            __metadata("design:type", Object)
        ], C2DComponent.prototype, "comp", void 0);
        C2DComponent = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Object, Boolean])
        ], C2DComponent);
        framework.C2DComponent = C2DComponent;
        let transform2D = class transform2D {
            constructor() {
                this.layer = framework.cullingmaskutil.maskTolayer(framework.CullingMask.default);
                this.tag = framework.StringUtil.builtinTag_Untagged;
                this.name = "noname";
                this.isStatic = false;
                this.width = 0;
                this.height = 0;
                this.pivot = new gd3d.math.vector2(0, 0);
                this.hideFlags = framework.HideFlags.None;
                this._visible = true;
                this.insId = new framework.insID();
                this.dirty = true;
                this.dirtyChild = true;
                this.dirtyWorldDecompose = false;
                this.localTranslate = new gd3d.math.vector2(0, 0);
                this.localScale = new gd3d.math.vector2(1, 1);
                this.localRotate = 0;
                this._isMask = false;
                this._parentIsMask = false;
                this.localMatrix = new gd3d.math.matrix3x2;
                this.worldMatrix = new gd3d.math.matrix3x2();
                this.canvasWorldMatrix = new gd3d.math.matrix3x2();
                this.worldRotate = new gd3d.math.angelref();
                this.worldTranslate = new gd3d.math.vector2(0, 0);
                this.worldScale = new gd3d.math.vector2(1, 1);
                this.components = [];
                this.optionArr = [layoutOption.LEFT, layoutOption.TOP, layoutOption.RIGHT, layoutOption.BOTTOM, layoutOption.H_CENTER, layoutOption.V_CENTER];
                this._layoutState = 0;
                this.layoutValueMap = {};
                this._layoutPercentState = 0;
                this.layoutDirty = false;
                this.lastParentWidth = 0;
                this.lastParentHeight = 0;
                this.lastParentPivot = new gd3d.math.vector2(0, 0);
                this.lastPivot = new gd3d.math.vector2(0, 0);
            }
            set canvas(val) {
                if (!val)
                    return;
                this._canvas = val;
            }
            get canvas() {
                if (this._canvas == null) {
                    if (this.parent == null)
                        return null;
                    return this.parent.canvas;
                }
                return this._canvas;
            }
            get visibleInScene() {
                let obj = this;
                while (obj.visible) {
                    obj = obj.parent;
                }
                return obj.visible;
            }
            get visible() {
                return this._visible;
            }
            ;
            set visible(val) {
                if (val != this._visible) {
                    this._visible = val;
                    framework.sceneMgr.app.markNotify(this, framework.NotifyType.ChangeVisible);
                }
            }
            get transform() {
                return this;
            }
            get maskRect() {
                if (this._temp_maskRect == null)
                    this._temp_maskRect = new gd3d.math.rect();
                if (this._maskRect != null) {
                    this._temp_maskRect.x = this._maskRect.x;
                    this._temp_maskRect.y = this._maskRect.y;
                    this._temp_maskRect.w = this._maskRect.w;
                    this._temp_maskRect.h = this._maskRect.h;
                }
                return this._temp_maskRect;
            }
            get isMask() {
                return this._isMask;
            }
            set isMask(b) {
                this._isMask = b;
                this.markDirty();
                if (this.parent != null)
                    this.updateTran(true);
            }
            updateMaskRect() {
                let rect_x;
                let rect_y;
                let rect_w;
                let rect_h;
                let ParentRect;
                if (this.parent != null) {
                    this._parentIsMask = this.parent.isMask || this.parent.parentIsMask;
                    ParentRect = this.parent.maskRect;
                }
                else
                    this._parentIsMask = false;
                if (this.isMask || this.parentIsMask) {
                    if (this.isMask) {
                        let wPos = this.getWorldTranslate();
                        let wW = this.canvas.pixelWidth;
                        let wH = this.canvas.pixelHeight;
                        rect_x = wPos.x / wW;
                        rect_y = wPos.y / wH;
                        rect_w = this.width / wW;
                        rect_h = this.height / wH;
                        if (this.parentIsMask && ParentRect != null) {
                            let min_x = Math.max(rect_x, ParentRect.x);
                            let min_y = Math.max(rect_y, ParentRect.y);
                            let max_x = Math.min(rect_x + rect_w, ParentRect.x + ParentRect.w);
                            let max_y = Math.min(rect_y + rect_h, ParentRect.y + ParentRect.h);
                            rect_x = min_x;
                            rect_y = min_y;
                            rect_w = max_x - min_x;
                            rect_h = max_y - min_y;
                        }
                    }
                    else if (ParentRect != null) {
                        rect_x = ParentRect.x;
                        rect_y = ParentRect.y;
                        rect_w = ParentRect.w;
                        rect_h = ParentRect.h;
                    }
                    if (this._maskRect == null)
                        this._maskRect = new gd3d.math.rect();
                    if (this._maskRect.x != rect_x || this._maskRect.x != rect_y || this._maskRect.x != rect_w || this._maskRect.x != rect_h) {
                        this._maskRect.x = rect_x;
                        this._maskRect.y = rect_y;
                        this._maskRect.w = rect_w;
                        this._maskRect.h = rect_h;
                    }
                }
            }
            get parentIsMask() {
                return this._parentIsMask;
            }
            addChild(node) {
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.push(node);
                node.parent = this;
                node.canvas = this.canvas;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                this.markDirty();
            }
            addChildAt(node, index) {
                if (index < 0)
                    return;
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.splice(index, 0, node);
                node.canvas = this.canvas;
                node.parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                this.markDirty();
            }
            removeChild(node) {
                if (node.parent != this || this.children == null) {
                    throw new Error("not my child.");
                }
                var i = this.children.indexOf(node);
                if (i >= 0) {
                    this.children.splice(i, 1);
                    node.parent = null;
                    framework.sceneMgr.app.markNotify(node, framework.NotifyType.RemoveChild);
                }
            }
            removeAllChild() {
                while (this.children.length > 0) {
                    this.removeChild(this.children[0]);
                }
            }
            markDirty() {
                this.dirty = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p = p.parent;
                }
            }
            updateTran(parentChange) {
                if (this.dirtyChild == false && this.dirty == false && parentChange == false)
                    return;
                if (this.dirty) {
                    gd3d.math.matrix3x2MakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                if (this.dirty || parentChange) {
                    this.refreshLayout();
                    if (this.parent == null) {
                        gd3d.math.matrix3x2Clone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        gd3d.math.matrix3x2Multiply(this.parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    this.updateMaskRect();
                    if (this.renderer != null) {
                        this.renderer.updateTran();
                    }
                    this.dirtyWorldDecompose = true;
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].updateTran(parentChange || this.dirty);
                    }
                }
                this.dirty = false;
                this.dirtyChild = false;
            }
            updateWorldTran() {
                var p = this.parent;
                var dirtylist = [];
                dirtylist.push(this);
                while (p != null) {
                    if (p.dirty)
                        dirtylist.push(p);
                    p = p.parent;
                }
                var top = dirtylist.pop();
                top.updateTran(false);
            }
            CalcReCanvasMtx(out) {
                if (!out)
                    return;
                let tsca = gd3d.math.pool.new_vector2();
                let ttran = gd3d.math.pool.new_vector2();
                tsca.x = this.canvas.pixelWidth / 2;
                tsca.y = -this.canvas.pixelHeight / 2;
                ttran.x = this.canvas.pixelWidth / 2;
                ttran.y = this.canvas.pixelHeight / 2;
                gd3d.math.matrix3x2MakeTransformRTS(ttran, tsca, 0, out);
            }
            decomposeWorldMatrix() {
                if (this.dirtyWorldDecompose) {
                    let reCanvasMtx = gd3d.math.pool.new_matrix3x2();
                    this.CalcReCanvasMtx(reCanvasMtx);
                    gd3d.math.matrix3x2Multiply(reCanvasMtx, this.worldMatrix, this.canvasWorldMatrix);
                    gd3d.math.matrix3x2Decompose(this.canvasWorldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    gd3d.math.pool.delete_matrix3x2(reCanvasMtx);
                    this.dirtyWorldDecompose = false;
                }
            }
            getWorldTranslate() {
                this.decomposeWorldMatrix();
                return this.worldTranslate;
            }
            getWorldScale() {
                this.decomposeWorldMatrix();
                return this.worldScale;
            }
            getWorldRotate() {
                this.decomposeWorldMatrix();
                return this.worldRotate;
            }
            getLocalMatrix() {
                return this.localMatrix;
            }
            getWorldMatrix() {
                return this.worldMatrix;
            }
            getCanvasWorldMatrix() {
                this.decomposeWorldMatrix();
                return this.canvasWorldMatrix;
            }
            static getTransInfoInCanvas(trans, out) {
                var mat = trans.getWorldMatrix();
                var rotmat = trans.canvas.getRoot().getWorldMatrix();
                var inversemat = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Inverse(rotmat, inversemat);
                var mattoRoot = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Multiply(inversemat, mat, mattoRoot);
                var rotscale = gd3d.math.pool.new_vector2();
                var rotRot = new gd3d.math.angelref();
                var rotPos = gd3d.math.pool.new_vector2();
                gd3d.math.matrix3x2Decompose(mattoRoot, rotscale, rotRot, rotPos);
                gd3d.math.vec2Clone(trans.pivot, out.pivot);
                gd3d.math.vec2Clone(rotPos, out.pivotPos);
                out.rot = rotRot.v;
                out.width = trans.width * rotscale.x;
                out.height = trans.height * rotscale.y;
                gd3d.math.pool.delete_matrix3x2(inversemat);
                gd3d.math.pool.delete_matrix3x2(mattoRoot);
                gd3d.math.pool.delete_vector2(rotscale);
                gd3d.math.pool.delete_vector2(rotPos);
            }
            setWorldPosition(pos) {
                this.dirty = true;
                this.updateWorldTran();
                var thispos = this.getWorldTranslate();
                var dir = gd3d.math.pool.new_vector2();
                dir.x = pos.x - thispos.x;
                dir.y = pos.y - thispos.y;
                var pworld = gd3d.math.pool.new_matrix3x2();
                if (this.parent != null) {
                    gd3d.math.matrix3x2Clone(this.parent.worldMatrix, pworld);
                }
                else {
                    gd3d.math.matrix3x2MakeIdentity(pworld);
                }
                var matinv = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Inverse(pworld, matinv);
                var dirinv = gd3d.math.pool.new_vector2();
                gd3d.math.matrix3x2TransformNormal(matinv, dir, dirinv);
                this.localTranslate.x += dirinv.x;
                this.localTranslate.y += dirinv.y;
                gd3d.math.pool.delete_matrix3x2(matinv);
                gd3d.math.pool.delete_vector2(dir);
                gd3d.math.pool.delete_vector2(dirinv);
            }
            dispose() {
                if (this.children) {
                    for (var k in this.children) {
                        this.children[k].dispose();
                    }
                    this.removeAllChild();
                }
                this.removeAllComponents();
            }
            update(delta) {
                if (framework.sceneMgr.app.bePlay) {
                    if (this.components != null) {
                        for (var i = 0; i < this.components.length; i++) {
                            if (this.components[i].init == false) {
                                this.components[i].comp.start();
                                this.components[i].init = true;
                            }
                            if (framework.sceneMgr.app.bePlay && !framework.sceneMgr.app.bePause)
                                this.components[i].comp.update(delta);
                        }
                    }
                    if (this.children != null) {
                        for (var i = 0; i < this.children.length; i++) {
                            this.children[i].update(delta);
                        }
                    }
                }
            }
            addComponent(type) {
                if (this.components == null)
                    this.components = [];
                for (var key in this.components) {
                    var st = this.components[key]["comp"]["constructor"]["name"];
                    if (st == type) {
                        throw new Error("已经有一个" + type + "的组件了，不能俩");
                    }
                }
                var pp = gd3d.reflect.getPrototype(type);
                var comp = gd3d.reflect.createInstance(pp, { "2dcomp": "1" });
                return this.addComponentDirect(comp);
            }
            addComponentDirect(comp) {
                if (comp.transform != null) {
                    throw new Error("this components has added to a  gameObject");
                }
                comp.transform = this;
                if (this.components == null)
                    this.components = [];
                let _comp = new C2DComponent(comp, false);
                this.components.push(_comp);
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1") {
                    if (this.renderer == null) {
                        this.renderer = comp;
                    }
                    else {
                        throw new Error("已经有一个渲染器的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "boxcollider2d") == "1") {
                    if (this.collider == null) {
                        this.collider = comp;
                    }
                    else {
                        throw new Error("已经有一个碰撞组件了，不能俩");
                    }
                }
                return comp;
            }
            removeComponent(comp) {
                if (!comp)
                    return;
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        if (this.components[i].init) {
                        }
                        let p = this.components.splice(i, 1);
                        comp.remove();
                        break;
                    }
                }
            }
            removeComponentByTypeName(type) {
                for (var i = 0; i < this.components.length; i++) {
                    if (gd3d.reflect.getClassName(this.components[i].comp) == type) {
                        var p = this.components.splice(i, 1);
                        if (p[0].comp == this.renderer)
                            this.renderer = null;
                        if (p[0].comp == this.collider)
                            this.collider = null;
                        p[0].comp.remove();
                        return p[0];
                    }
                }
            }
            removeAllComponents() {
                for (var i = 0; i < this.components.length; i++) {
                    this.components[i].comp.remove();
                }
                if (this.renderer)
                    this.renderer = null;
                if (this.collider)
                    this.renderer = null;
                this.components.length = 0;
            }
            getComponent(type) {
                for (var i = 0; i < this.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return this.components[i].comp;
                    }
                }
                return null;
            }
            getComponents() {
                let components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            }
            getComponentsInChildren(type) {
                let components = [];
                this.getNodeCompoents(this, type, components);
                return components;
            }
            getNodeCompoents(node, _type, comps) {
                for (var i in node.components) {
                    var cname = gd3d.reflect.getClassName(node.components[i].comp["__proto__"]);
                    if (cname == _type) {
                        comps.push(node.components[i].comp);
                    }
                }
                if (node.children != null) {
                    for (var i in node.children) {
                        this.getNodeCompoents(node.children[i], _type, comps);
                    }
                }
            }
            onCapturePointEvent(canvas, ev) {
                if (this.components != null) {
                    for (var i = 0; i <= this.components.length; i++) {
                        if (ev.eated == false) {
                            var comp = this.components[i];
                            if (comp != null)
                                if (comp.init) {
                                    comp.comp.onPointEvent(canvas, ev, true);
                                }
                        }
                    }
                }
                if (ev.eated == false) {
                    if (this.children != null) {
                        for (var i = 0; i <= this.children.length; i++) {
                            var c = this.children[i];
                            if (c != null && c.visible)
                                c.onCapturePointEvent(canvas, ev);
                        }
                    }
                }
            }
            ContainsCanvasPoint(ModelPos, tolerance = 0) {
                let result = false;
                var mworld = this.getWorldMatrix();
                var mout = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Inverse(mworld, mout);
                var p2 = gd3d.math.pool.new_vector2();
                gd3d.math.matrix3x2TransformVector2(mout, ModelPos, p2);
                p2.x += this.pivot.x * this.width;
                p2.y += this.pivot.y * this.height;
                result = p2.x + tolerance >= 0 && p2.y + tolerance >= 0 && p2.x < this.width + tolerance && p2.y < this.height + tolerance;
                gd3d.math.pool.delete_matrix3x2(mout);
                gd3d.math.pool.delete_vector2(p2);
                return result;
            }
            onPointEvent(canvas, ev) {
                if (this.children != null) {
                    for (var i = this.children.length - 1; i >= 0; i--) {
                        if (ev.eated == false) {
                            var c = this.children[i];
                            if (c != null && c.visible)
                                c.onPointEvent(canvas, ev);
                        }
                    }
                }
                if (ev.eated == false && this.components != null) {
                    for (var i = this.components.length - 1; i >= 0; i--) {
                        var comp = this.components[i];
                        if (comp != null)
                            if (comp.init) {
                                comp.comp.onPointEvent(canvas, ev, false);
                            }
                    }
                }
            }
            set layoutState(state) {
                if (isNaN(state) || state == undefined)
                    return;
                if (state != this._layoutState) {
                    this.layoutDirty = true;
                    this.markDirty();
                    this._layoutState = state;
                }
            }
            get layoutState() {
                return this._layoutState;
            }
            setLayoutValue(option, value) {
                if (isNaN(option) || isNaN(value) || option == undefined || value == undefined)
                    return;
                if (this.layoutValueMap[option] == undefined || value != this.layoutValueMap[option]) {
                    this.layoutDirty = true;
                    this.markDirty();
                    this.layoutValueMap[option] = value;
                }
            }
            getLayoutValue(option) {
                if (this.layoutValueMap[option] == undefined)
                    this.layoutValueMap[option] = 0;
                return this.layoutValueMap[option];
            }
            set layoutPercentState(state) {
                if (isNaN(state) || state == undefined)
                    return;
                if (state != this._layoutPercentState) {
                    this.layoutDirty = true;
                    this.markDirty();
                    this._layoutPercentState = state;
                }
            }
            get layoutPercentState() {
                return this._layoutPercentState;
            }
            refreshLayout() {
                let parent = this.parent;
                if (!parent)
                    return;
                if (parent.width != this.lastParentWidth || parent.height != this.lastParentHeight || parent.pivot.x != this.lastParentPivot.x
                    || parent.pivot.y != this.lastParentPivot.y || this.pivot.x != this.lastPivot.x || this.pivot.y != this.lastPivot.y)
                    this.layoutDirty = true;
                if (!this.layoutDirty)
                    return;
                let state = this._layoutState;
                if (state != 0) {
                    if (state & layoutOption.LEFT) {
                        if (state & layoutOption.RIGHT) {
                            this.width = parent.width - this.getLayValue(layoutOption.LEFT) - this.getLayValue(layoutOption.RIGHT);
                        }
                        this.localTranslate.x = this.getLayValue(layoutOption.LEFT) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    else if (state & layoutOption.RIGHT) {
                        this.localTranslate.x = parent.width - this.width - this.getLayValue(layoutOption.RIGHT) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    if (state & layoutOption.H_CENTER) {
                        this.localTranslate.x = (parent.width - this.width) / 2 + this.getLayValue(layoutOption.H_CENTER) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    if (state & layoutOption.TOP) {
                        if (state & layoutOption.BOTTOM) {
                            this.height = parent.height - this.getLayValue(layoutOption.TOP) - this.getLayValue(layoutOption.BOTTOM);
                        }
                        this.localTranslate.y = this.getLayValue(layoutOption.TOP) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    else if (state & layoutOption.BOTTOM) {
                        this.localTranslate.y = parent.height - this.height - this.getLayValue(layoutOption.BOTTOM) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    if (state & layoutOption.V_CENTER) {
                        this.localTranslate.y = (parent.height - this.height) / 2 + this.getLayValue(layoutOption.V_CENTER) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    gd3d.math.matrix3x2MakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                this.layoutDirty = false;
                this.lastParentWidth = parent.width;
                this.lastParentHeight = parent.height;
                this.lastParentPivot.x = parent.pivot.x;
                this.lastParentPivot.y = parent.pivot.y;
                this.lastPivot.x = this.pivot.x;
                this.lastPivot.y = this.pivot.y;
            }
            getLayValue(option) {
                if (this.layoutValueMap[option] == undefined)
                    this.layoutValueMap[option] = 0;
                let value = 0;
                if (this._layoutPercentState & option) {
                    if (this.parent) {
                        switch (option) {
                            case layoutOption.LEFT:
                            case layoutOption.H_CENTER:
                            case layoutOption.RIGHT:
                                value = this.parent.width * this.layoutValueMap[option] / 100;
                                break;
                            case layoutOption.TOP:
                            case layoutOption.V_CENTER:
                            case layoutOption.BOTTOM:
                                value = this.parent.height * this.layoutValueMap[option] / 100;
                                break;
                        }
                    }
                }
                else {
                    value = this.layoutValueMap[option];
                }
                return value;
            }
            clone() {
                return gd3d.io.cloneObj(this);
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            gd3d.reflect.UIStyle("enum"),
            __metadata("design:type", Number)
        ], transform2D.prototype, "layer", void 0);
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], transform2D.prototype, "tag", void 0);
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], transform2D.prototype, "name", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], transform2D.prototype, "isStatic", void 0);
        __decorate([
            gd3d.reflect.Field("transform2D[]"),
            __metadata("design:type", Array)
        ], transform2D.prototype, "children", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], transform2D.prototype, "width", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], transform2D.prototype, "height", void 0);
        __decorate([
            gd3d.reflect.Field("vector2"),
            __metadata("design:type", gd3d.math.vector2)
        ], transform2D.prototype, "pivot", void 0);
        __decorate([
            gd3d.reflect.Field("vector2"),
            __metadata("design:type", gd3d.math.vector2)
        ], transform2D.prototype, "localTranslate", void 0);
        __decorate([
            gd3d.reflect.Field("vector2"),
            __metadata("design:type", gd3d.math.vector2)
        ], transform2D.prototype, "localScale", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], transform2D.prototype, "localRotate", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Boolean])
        ], transform2D.prototype, "isMask", null);
        __decorate([
            gd3d.reflect.Field("C2DComponent[]"),
            __metadata("design:type", Array)
        ], transform2D.prototype, "components", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], transform2D.prototype, "layoutState", null);
        __decorate([
            gd3d.reflect.Field("numberdic"),
            __metadata("design:type", Object)
        ], transform2D.prototype, "layoutValueMap", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], transform2D.prototype, "layoutPercentState", null);
        transform2D = __decorate([
            gd3d.reflect.SerializeType
        ], transform2D);
        framework.transform2D = transform2D;
        class t2dInfo {
            constructor() {
                this.pivot = new gd3d.math.vector2();
                this.pivotPos = new gd3d.math.vector2();
            }
            static getCenter(info, outCenter) {
                outCenter.x = info.pivotPos.x + info.width * (0.5 - info.pivot.x) * Math.cos(info.rot) - info.height * (0.5 - info.pivot.y) * Math.sin(info.rot);
                outCenter.y = info.pivotPos.y - info.width * (0.5 - info.pivot.x) * Math.sin(info.rot) + info.height * (0.5 - info.pivot.y) * Math.cos(info.rot);
            }
        }
        framework.t2dInfo = t2dInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class behaviour2d {
            start() {
            }
            update(delta) {
            }
            onPointEvent(canvas, ev, oncap) {
            }
            remove() {
            }
        }
        framework.behaviour2d = behaviour2d;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let boxcollider2d = class boxcollider2d {
            getBound() {
                return this._obb;
            }
            intersectsTransform(tran) {
                if (tran == null)
                    return false;
                if (this._obb == null || tran.collider.getBound() == null)
                    return false;
                var _obb = tran.collider.getBound();
                return this._obb.intersects(_obb);
            }
            build() {
                let t = this.transform;
                this._obb = new framework.obb2d();
                this._obb.buildByCenterSize(t.getWorldTranslate(), t.width, t.height);
                this.refreshTofullOver();
            }
            refreshTofullOver() {
                if (!this._obb || !this._obb.size || !this._obb.offset)
                    return;
                let t = this.transform;
                this._obb.size.x = t.width;
                this._obb.size.y = t.height;
                this._obb.offset.x = (0.5 - t.pivot.x) * this._obb.size.x;
                this._obb.offset.y = (0.5 - t.pivot.y) * this._obb.size.y;
            }
            start() {
                this.build();
            }
            update(delta) {
                if (this._obb) {
                    this._obb.update(this.transform.getCanvasWorldMatrix());
                }
            }
            onPointEvent(canvas, ev, oncap) {
            }
            remove() {
                if (this._obb)
                    this._obb.dispose();
                this._obb = null;
            }
        };
        boxcollider2d = __decorate([
            gd3d.reflect.node2DComponent,
            gd3d.reflect.nodeBoxCollider2d
        ], boxcollider2d);
        framework.boxcollider2d = boxcollider2d;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let TransitionType;
        (function (TransitionType) {
            TransitionType[TransitionType["None"] = 0] = "None";
            TransitionType[TransitionType["ColorTint"] = 1] = "ColorTint";
            TransitionType[TransitionType["SpriteSwap"] = 2] = "SpriteSwap";
        })(TransitionType = framework.TransitionType || (framework.TransitionType = {}));
        let button = class button {
            constructor() {
                this._transition = TransitionType.ColorTint;
                this._origianlSpriteName = "";
                this._pressedSpriteName = "";
                this._normalColor = new gd3d.math.color(1, 1, 1, 1);
                this._pressedColor = new gd3d.math.color(0.5, 0.5, 0.5, 1);
                this._fadeDuration = 0.1;
                this.onClick = new framework.UIEvent();
                this._downInThis = false;
                this._dragOut = false;
            }
            get transition() {
                return this._transition;
            }
            set transition(transition) {
                this._transition = transition;
                if (this._targetImage != null) {
                    if (transition == TransitionType.ColorTint) {
                        this._targetImage.color = this.normalColor;
                    }
                    else {
                        this._targetImage.color = this._originalColor;
                    }
                }
            }
            get targetImage() {
                return this._targetImage;
            }
            set targetImage(graphic) {
                if (this._targetImage != null) {
                    this._targetImage.color = this._originalColor;
                }
                if (graphic != null) {
                    this._originalColor = graphic.color;
                    this._originalSprite = graphic.sprite;
                    if (graphic.sprite)
                        this._origianlSpriteName = graphic.sprite.getName();
                    if (this._transition == TransitionType.ColorTint) {
                        graphic.color = this.normalColor;
                    }
                }
                else {
                    this._originalColor = null;
                    this._originalSprite = null;
                }
                this._targetImage = graphic;
            }
            get pressedGraphic() {
                return this._pressedSprite;
            }
            set pressedGraphic(sprite) {
                this._pressedSprite = sprite;
                if (sprite != null) {
                    this._pressedSpriteName = sprite.getName();
                }
            }
            get normalColor() {
                return this._normalColor;
            }
            set normalColor(color) {
                this._normalColor = color;
                if (this._targetImage != null && this.transition == TransitionType.ColorTint) {
                    this._targetImage.color = color;
                }
            }
            get pressedColor() {
                return this._pressedColor;
            }
            set pressedColor(color) {
                this._pressedColor = color;
            }
            get fadeDuration() {
                return this._fadeDuration;
            }
            set fadeDuration(duration) {
                this._fadeDuration = duration;
            }
            render(canvas) {
            }
            updateTran() {
            }
            start() {
            }
            update(delta) {
            }
            remove() {
                this._targetImage = null;
                this.transform = null;
                this._normalColor = null;
                this._originalColor = null;
                this._pressedColor = null;
                if (this.pressedGraphic)
                    this.pressedGraphic.unuse(true);
            }
            onPointEvent(canvas, ev, oncap) {
                if (oncap == false) {
                    var b = this.transform.ContainsCanvasPoint(new gd3d.math.vector2(ev.x, ev.y));
                    if (b) {
                        ev.eated = true;
                        if (ev.type == framework.PointEventEnum.PointDown) {
                            this._downInThis = true;
                            this.showPress();
                        }
                        else if (ev.type == framework.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == true) {
                                this._dragOut = false;
                                this.showPress();
                            }
                        }
                        else if (ev.type == framework.PointEventEnum.PointUp && this._downInThis) {
                            this._downInThis = false;
                            this.showNormal();
                            this.onClick.excute();
                        }
                    }
                    else {
                        if (ev.type == framework.PointEventEnum.PointUp) {
                            this._downInThis = false;
                        }
                        else if (ev.type == framework.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == false) {
                                this._dragOut = true;
                                this.showNormal();
                            }
                        }
                    }
                }
            }
            showNormal() {
                if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._normalColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    if (!this._originalSprite) {
                        this._originalSprite = this.tryGetSprite(this._origianlSpriteName);
                    }
                    this.changeSprite(this._originalSprite);
                }
            }
            showPress() {
                if (this.transition == TransitionType.None) {
                    return;
                }
                else if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._pressedColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    if (this._targetImage != null && this._targetImage.sprite != null && this._originalSprite == null) {
                        this._originalSprite = this._targetImage.sprite;
                    }
                    if (!this._pressedSprite) {
                        this._pressedSprite = this.tryGetSprite(this._pressedSpriteName);
                    }
                    this.changeSprite(this._pressedSprite);
                }
            }
            tryGetSprite(spriteName) {
                let temp = this.transform.canvas.assetmgr.mapNamed[spriteName];
                if (temp != null) {
                    let tsprite = this.transform.canvas.assetmgr.getAssetByName(spriteName);
                    if (tsprite)
                        return tsprite;
                }
            }
            changeColor(targetColor) {
                if (this._targetImage != null) {
                    this._targetImage.color = targetColor;
                    this._targetImage.transform.markDirty();
                }
            }
            changeSprite(sprite) {
                if (sprite == null)
                    return;
                if (this._targetImage != null) {
                    this._targetImage.sprite = sprite;
                    this._targetImage.transform.markDirty();
                }
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], button.prototype, "transition", null);
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], button.prototype, "_origianlSpriteName", void 0);
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], button.prototype, "_pressedSpriteName", void 0);
        __decorate([
            gd3d.reflect.Field("reference"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [framework.image2D])
        ], button.prototype, "targetImage", null);
        __decorate([
            gd3d.reflect.Field("color"),
            gd3d.reflect.UIStyle("color"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [gd3d.math.color])
        ], button.prototype, "normalColor", null);
        __decorate([
            gd3d.reflect.Field("color"),
            gd3d.reflect.UIStyle("color"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [gd3d.math.color])
        ], button.prototype, "pressedColor", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], button.prototype, "fadeDuration", null);
        button = __decorate([
            gd3d.reflect.node2DComponent
        ], button);
        framework.button = button;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let image2D = class image2D {
            constructor() {
                this._unitLen = 13;
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.needRefreshImg = false;
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
                this._imageType = ImageType.Simple;
                this._fillMethod = FillMethod.Horizontal;
                this._fillAmmount = 1;
                this._spriteName = "";
                this._imageBorder = new gd3d.math.border();
                gd3d.io.enumMgr.enumMap["ImageType"] = ImageType;
                gd3d.io.enumMgr.enumMap["FillMethod"] = FillMethod;
            }
            get uimat() {
                if (this._sprite && this._sprite.texture) {
                    let rectPostfix = this.transform.parentIsMask ? `_(${this.transform.insId})` : "";
                    let matName = this._sprite.texture.getName() + "_uimask" + rectPostfix;
                    let canvas = this.transform.canvas;
                    if (!canvas.assetmgr)
                        return;
                    let mat = this._uimat;
                    if (!mat || mat.getName() != matName) {
                        if (mat)
                            mat.unuse();
                        mat = canvas.assetmgr.getAssetByName(matName);
                        if (mat)
                            mat.use();
                    }
                    if (mat == null) {
                        mat = new framework.material(matName);
                        mat.setShader(canvas.assetmgr.getShader("shader/defmaskui"));
                        mat.use();
                    }
                    mat.setFloat("MaskState", this.transform.parentIsMask ? 1 : 0);
                    this._uimat = mat;
                }
                return this._uimat;
            }
            get imageType() {
                return this._imageType;
            }
            set imageType(type) {
                this._imageType = type;
                this.prepareData();
                if (this.transform != null)
                    this.transform.markDirty();
            }
            get fillMethod() {
                return this._fillMethod;
            }
            set fillMethod(method) {
                this._fillMethod = method;
                this.prepareData();
                if (this.transform != null)
                    this.transform.markDirty();
            }
            get fillAmmount() {
                return this._fillAmmount;
            }
            set fillAmmount(ammount) {
                this._fillAmmount = ammount;
                if (this.transform != null)
                    this.transform.markDirty();
            }
            set sprite(sprite) {
                if (sprite == this._sprite)
                    return;
                this.needRefreshImg = true;
                if (this._sprite) {
                    this._sprite.unuse();
                }
                this._sprite = sprite;
                if (sprite) {
                    this._sprite.use();
                    this._spriteName = this._sprite.getName();
                    this.prepareData();
                    if (this.transform != null) {
                        this.transform.markDirty();
                        this.updateTran();
                    }
                }
                else {
                    this._spriteName = "";
                }
            }
            get sprite() {
                return this._sprite;
            }
            get imageBorder() {
                return this._imageBorder;
            }
            render(canvas) {
                if (this._sprite == null) {
                    let temp = canvas.assetmgr.mapNamed[this._spriteName];
                    let tspr;
                    if (temp != null) {
                        tspr = canvas.assetmgr.getAssetByName(this._spriteName);
                    }
                    else {
                        if (canvas.assetmgr.mapDefaultSprite[this._spriteName])
                            tspr = canvas.assetmgr.getDefaultSprite(this._spriteName);
                    }
                    if (tspr) {
                        this.sprite = tspr;
                        this.needRefreshImg = true;
                    }
                }
                let mat = this.uimat;
                if (!mat)
                    return;
                var img = null;
                if (this._sprite != null && this._sprite.texture != null) {
                    img = this._sprite.texture;
                }
                if (img != null) {
                    if (this.needRefreshImg) {
                        mat.setTexture("_MainTex", img);
                        this.needRefreshImg = false;
                    }
                    if (this.transform.parentIsMask) {
                        if (this._cacheMaskV4 == null)
                            this._cacheMaskV4 = new gd3d.math.vector4();
                        let rect = this.transform.maskRect;
                        if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h) {
                            this._cacheMaskV4.x = rect.x;
                            this._cacheMaskV4.y = rect.y;
                            this._cacheMaskV4.z = rect.w;
                            this._cacheMaskV4.w = rect.h;
                            mat.setVector4("_maskRect", this._cacheMaskV4);
                        }
                    }
                    canvas.pushRawData(mat, this.datar);
                }
            }
            start() {
            }
            update(delta) {
            }
            remove() {
                if (this._sprite)
                    this._sprite.unuse(true);
                if (this._uimat)
                    this._uimat.unuse(true);
                this.datar.length = 0;
                this.transform = null;
                this._imageBorder = null;
            }
            onPointEvent(canvas, ev, oncap) {
            }
            prepareData() {
                if (this._sprite == null)
                    return;
                let urange = this._sprite.urange;
                let vrange = this._sprite.vrange;
                let ulen = urange.y - urange.x;
                let vlen = vrange.y - vrange.x;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        break;
                    case ImageType.Sliced:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                        ];
                        break;
                    case ImageType.Tiled:
                        this.datar = [];
                        break;
                    case ImageType.Filled:
                        let halfu = urange.x + 0.5 * ulen;
                        let halfv = vrange.x + 0.5 * vlen;
                        switch (this._fillMethod) {
                            case FillMethod.Horizontal:
                            case FillMethod.Vertical:
                            case FillMethod.Radial_90:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_180:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_360:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                ];
                                break;
                        }
                        break;
                }
            }
            updateTran() {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                if (this._sprite == null)
                    return;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.updateSimpleData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Sliced:
                        this.updateSlicedData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Tiled:
                        this.updateTiledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Filled:
                        this.updateFilledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                }
                let vertexCount = this.datar.length / this._unitLen;
                for (var i = 0; i < vertexCount; i++) {
                    this.datar[i * this._unitLen + 3] = this.color.r;
                    this.datar[i * this._unitLen + 4] = this.color.g;
                    this.datar[i * this._unitLen + 5] = this.color.b;
                    this.datar[i * this._unitLen + 6] = this.color.a;
                }
            }
            updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3, quadIndex = 0, mirror = false) {
                let _index = quadIndex * 6;
                if (!mirror) {
                    this.datar[(_index + 0) * this._unitLen] = x0;
                    this.datar[(_index + 0) * this._unitLen + 1] = y0;
                    this.datar[(_index + 1) * this._unitLen] = x1;
                    this.datar[(_index + 1) * this._unitLen + 1] = y1;
                    this.datar[(_index + 2) * this._unitLen] = x2;
                    this.datar[(_index + 2) * this._unitLen + 1] = y2;
                    this.datar[(_index + 3) * this._unitLen] = x2;
                    this.datar[(_index + 3) * this._unitLen + 1] = y2;
                    this.datar[(_index + 4) * this._unitLen] = x1;
                    this.datar[(_index + 4) * this._unitLen + 1] = y1;
                    this.datar[(_index + 5) * this._unitLen] = x3;
                    this.datar[(_index + 5) * this._unitLen + 1] = y3;
                }
                else {
                    this.datar[(_index + 0) * this._unitLen] = x0;
                    this.datar[(_index + 0) * this._unitLen + 1] = y0;
                    this.datar[(_index + 1) * this._unitLen] = x1;
                    this.datar[(_index + 1) * this._unitLen + 1] = y1;
                    this.datar[(_index + 2) * this._unitLen] = x3;
                    this.datar[(_index + 2) * this._unitLen + 1] = y3;
                    this.datar[(_index + 3) * this._unitLen] = x0;
                    this.datar[(_index + 3) * this._unitLen + 1] = y0;
                    this.datar[(_index + 4) * this._unitLen] = x3;
                    this.datar[(_index + 4) * this._unitLen + 1] = y3;
                    this.datar[(_index + 5) * this._unitLen] = x2;
                    this.datar[(_index + 5) * this._unitLen + 1] = y2;
                }
            }
            updateSimpleData(x0, y0, x1, y1, x2, y2, x3, y3) {
                this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
            }
            updateSlicedData(x0, y0, x1, y1, x2, y2, x3, y3) {
                let border = this._imageBorder;
                let rect = this._sprite.rect;
                let r1c1 = gd3d.math.pool.new_vector2();
                let r1c4 = gd3d.math.pool.new_vector2();
                let r4c1 = gd3d.math.pool.new_vector2();
                let r4c4 = gd3d.math.pool.new_vector2();
                let r1c2 = gd3d.math.pool.new_vector2();
                let r1c3 = gd3d.math.pool.new_vector2();
                let r2c1 = gd3d.math.pool.new_vector2();
                let r3c1 = gd3d.math.pool.new_vector2();
                let r2c2 = gd3d.math.pool.new_vector2();
                let r2c3 = gd3d.math.pool.new_vector2();
                let r2c4 = gd3d.math.pool.new_vector2();
                let r3c2 = gd3d.math.pool.new_vector2();
                let r3c3 = gd3d.math.pool.new_vector2();
                let r3c4 = gd3d.math.pool.new_vector2();
                let r4c2 = gd3d.math.pool.new_vector2();
                let r4c3 = gd3d.math.pool.new_vector2();
                let r1c1_uv = gd3d.math.pool.new_vector2();
                let r1c4_uv = gd3d.math.pool.new_vector2();
                let r4c1_uv = gd3d.math.pool.new_vector2();
                let r4c4_uv = gd3d.math.pool.new_vector2();
                let r1c2_uv = gd3d.math.pool.new_vector2();
                let r1c3_uv = gd3d.math.pool.new_vector2();
                let r2c1_uv = gd3d.math.pool.new_vector2();
                let r3c1_uv = gd3d.math.pool.new_vector2();
                let r2c2_uv = gd3d.math.pool.new_vector2();
                let r2c3_uv = gd3d.math.pool.new_vector2();
                let r2c4_uv = gd3d.math.pool.new_vector2();
                let r3c2_uv = gd3d.math.pool.new_vector2();
                let r3c3_uv = gd3d.math.pool.new_vector2();
                let r3c4_uv = gd3d.math.pool.new_vector2();
                let r4c2_uv = gd3d.math.pool.new_vector2();
                let r4c3_uv = gd3d.math.pool.new_vector2();
                let help1 = gd3d.math.pool.new_vector2();
                let help2 = gd3d.math.pool.new_vector2();
                let help3 = gd3d.math.pool.new_vector2();
                r1c1.x = x0;
                r1c1.y = y0;
                r1c4.x = x1;
                r1c4.y = y1;
                r4c1.x = x2;
                r4c1.y = y2;
                r4c4.x = x3;
                r4c4.y = y3;
                let width = gd3d.math.vec2Distance(r1c1, r1c4);
                let height = gd3d.math.vec2Distance(r1c1, r4c1);
                let urange = this._sprite.urange;
                let vrange = this._sprite.vrange;
                let l_vertex = (border.l) / this.transform.width;
                let r_vertex = (border.r) / this.transform.width;
                let t_vertex = (border.t) / this.transform.height;
                let b_vertex = (border.b) / this.transform.height;
                let l = (border.l) / rect.w * (urange.y - urange.x);
                let r = (border.r) / rect.w * (urange.y - urange.x);
                let t = (border.t) / rect.h * (vrange.y - vrange.x);
                let b = (border.b) / rect.h * (vrange.y - vrange.x);
                gd3d.math.vec2Subtract(r1c4, r1c1, r1c2);
                gd3d.math.vec2ScaleByNum(r1c2, l_vertex, r1c2);
                gd3d.math.vec2Add(r1c2, r1c1, r1c2);
                gd3d.math.vec2Subtract(r1c1, r1c4, r1c3);
                gd3d.math.vec2ScaleByNum(r1c3, r_vertex, r1c3);
                gd3d.math.vec2Add(r1c3, r1c4, r1c3);
                gd3d.math.vec2Subtract(r4c1, r1c1, r2c1);
                gd3d.math.vec2ScaleByNum(r2c1, t_vertex, r2c1);
                gd3d.math.vec2Add(r2c1, r1c1, r2c1);
                gd3d.math.vec2Subtract(r1c1, r4c1, r3c1);
                gd3d.math.vec2ScaleByNum(r3c1, b_vertex, r3c1);
                gd3d.math.vec2Add(r3c1, r4c1, r3c1);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c3);
                gd3d.math.vec2Subtract(r1c4, r1c1, help1);
                gd3d.math.vec2Subtract(r2c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r2c4);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c3);
                gd3d.math.vec2Subtract(r1c4, r1c1, help1);
                gd3d.math.vec2Subtract(r3c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r3c4);
                gd3d.math.vec2Subtract(r1c2, r1c1, help1);
                gd3d.math.vec2Subtract(r4c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r4c2);
                gd3d.math.vec2Subtract(r1c3, r1c1, help1);
                gd3d.math.vec2Subtract(r4c1, r1c1, help2);
                gd3d.math.vec2Add(help1, help2, help3);
                gd3d.math.vec2Add(help3, r1c1, r4c3);
                r1c1_uv.x = urange.x;
                r1c1_uv.y = vrange.x;
                r1c2_uv.x = l + urange.x;
                r1c2_uv.y = vrange.x;
                r1c3_uv.x = urange.y - r;
                r1c3_uv.y = vrange.x;
                r1c4_uv.x = urange.y;
                r1c4_uv.y = vrange.x;
                r2c1_uv.x = urange.x;
                r2c1_uv.y = t + vrange.x;
                r2c2_uv.x = l + urange.x;
                r2c2_uv.y = t + vrange.x;
                r2c3_uv.x = urange.y - r;
                r2c3_uv.y = t + vrange.x;
                r2c4_uv.x = urange.y;
                r2c4_uv.y = t + vrange.x;
                r3c1_uv.x = urange.x;
                r3c1_uv.y = vrange.y - b;
                r3c2_uv.x = l + urange.x;
                r3c2_uv.y = vrange.y - b;
                r3c3_uv.x = urange.y - r;
                r3c3_uv.y = vrange.y - b;
                r3c4_uv.x = urange.y;
                r3c4_uv.y = vrange.y - b;
                r4c1_uv.x = urange.x;
                r4c1_uv.y = vrange.y;
                r4c2_uv.x = l + urange.x;
                r4c2_uv.y = vrange.y;
                r4c3_uv.x = urange.y - r;
                r4c3_uv.y = vrange.y;
                r4c4_uv.x = urange.y;
                r4c4_uv.y = vrange.y;
                let vertexs = [r1c1, r1c2, r1c3, r1c4, r2c1, r2c2, r2c3, r2c4, r3c1, r3c2, r3c3, r3c4, r4c1, r4c2, r4c3, r4c4];
                let uvs = [r1c1_uv, r1c2_uv, r1c3_uv, r1c4_uv, r2c1_uv, r2c2_uv, r2c3_uv, r2c4_uv, r3c1_uv, r3c2_uv, r3c3_uv, r3c4_uv, r4c1_uv, r4c2_uv, r4c3_uv, r4c4_uv];
                let partVertexs;
                let partUVs;
                for (let i = 0; i < 9; i++) {
                    let r = Math.floor(i / 3);
                    let c = i % 3;
                    partVertexs = [vertexs[0 + c + r * 4], vertexs[1 + c + r * 4], vertexs[4 + c + r * 4], vertexs[5 + c + r * 4]];
                    partUVs = [uvs[0 + c + r * 4], uvs[1 + c + r * 4], uvs[4 + c + r * 4], uvs[5 + c + r * 4]];
                    this.updateQuadData(partVertexs[0].x, partVertexs[0].y, partVertexs[1].x, partVertexs[1].y, partVertexs[2].x, partVertexs[2].y, partVertexs[3].x, partVertexs[3].y, i);
                    this.datar[(0 + i * 6) * this._unitLen + 7] = partUVs[0].x;
                    this.datar[(0 + i * 6) * this._unitLen + 8] = partUVs[0].y;
                    this.datar[(1 + i * 6) * this._unitLen + 7] = partUVs[1].x;
                    this.datar[(1 + i * 6) * this._unitLen + 8] = partUVs[1].y;
                    this.datar[(2 + i * 6) * this._unitLen + 7] = partUVs[2].x;
                    this.datar[(2 + i * 6) * this._unitLen + 8] = partUVs[2].y;
                    this.datar[(3 + i * 6) * this._unitLen + 7] = partUVs[2].x;
                    this.datar[(3 + i * 6) * this._unitLen + 8] = partUVs[2].y;
                    this.datar[(4 + i * 6) * this._unitLen + 7] = partUVs[1].x;
                    this.datar[(4 + i * 6) * this._unitLen + 8] = partUVs[1].y;
                    this.datar[(5 + i * 6) * this._unitLen + 7] = partUVs[3].x;
                    this.datar[(5 + i * 6) * this._unitLen + 8] = partUVs[3].y;
                    partVertexs.length = 0;
                    partUVs.length = 0;
                }
                gd3d.math.pool.delete_vector2Array(vertexs);
                gd3d.math.pool.delete_vector2Array(uvs);
                gd3d.math.pool.delete_vector2Array([help1, help2, help3]);
            }
            updateFilledData(x0, y0, x1, y1, x2, y2, x3, y3) {
                let urange = this._sprite.urange;
                let vrange = this._sprite.vrange;
                let ulen = urange.y - urange.x;
                let vlen = vrange.y - vrange.x;
                let halfu = urange.x + 0.5 * ulen;
                let halfv = vrange.x + 0.5 * vlen;
                switch (this._fillMethod) {
                    case FillMethod.Horizontal:
                    case FillMethod.Vertical:
                    case FillMethod.Radial_90:
                        if (this._fillMethod == FillMethod.Horizontal) {
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x0);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y0);
                            x3 = x3 - (1 - this.fillAmmount) * (x3 - x2);
                            y3 = y3 - (1 - this.fillAmmount) * (y3 - y2);
                            this.datar[1 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[4 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[5 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                        }
                        else if (this._fillMethod == FillMethod.Vertical) {
                            x0 = x0 - (1 - this.fillAmmount) * (x0 - x2);
                            y0 = y0 - (1 - this.fillAmmount) * (y0 - y2);
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x3);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y3);
                            this.datar[0 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[1 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[4 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                        }
                        else if (this._fillMethod == FillMethod.Radial_90) {
                            if (this.fillAmmount >= 0.5) {
                                let _fillRate = 2 * (1 - this.fillAmmount);
                                x0 = x0 - _fillRate * (x0 - x1);
                                y0 = y0 - _fillRate * (y0 - y1);
                                this.datar[0 * this._unitLen + 7] = urange.x + _fillRate * ulen;
                                this.datar[1 * this._unitLen + 8] = vrange.x;
                                this.datar[4 * this._unitLen + 8] = vrange.x;
                            }
                            else {
                                let _fillRate = 2 * (0.5 - this.fillAmmount);
                                x1 = x1 - _fillRate * (x1 - x3);
                                y1 = y1 - _fillRate * (y1 - y3);
                                x0 = x1;
                                y0 = y1;
                                this.datar[0 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                                this.datar[1 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                                this.datar[4 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                            }
                        }
                        this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case FillMethod.Radial_180:
                        let tx = (x0 + x1) / 2;
                        let ty = (y0 + y1) / 2;
                        let bx = (x2 + x3) / 2;
                        let by = (y2 + y3) / 2;
                        if (this.fillAmmount >= 0.75) {
                            let _fillRate = 4 * (1 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - x0);
                            y2 = y2 - _fillRate * (y2 - y0);
                            this.datar[5 * this._unitLen + 8] = vrange.y - _fillRate * vlen;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            let _fillRate = 4 * (0.75 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - tx);
                            y0 = y0 - _fillRate * (y0 - ty);
                            x2 = x0;
                            y2 = y0;
                            this.datar[0 * this._unitLen + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[3 * this._unitLen + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            let _fillRate = 4 * (0.5 - this.fillAmmount);
                            tx = tx - _fillRate * (tx - x1);
                            ty = ty - _fillRate * (ty - y1);
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[6 * this._unitLen + 7] = halfu + 0.5 * ulen * _fillRate;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else {
                            let _fillRate = 4 * (0.25 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - x3);
                            y1 = y1 - _fillRate * (y1 - y3);
                            tx = x1;
                            ty = y1;
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[7 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                            this.datar[10 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                        }
                        this.updateQuadData(x0, y0, tx, ty, x2, y2, bx, by, 0, true);
                        this.updateQuadData(tx, ty, x1, y1, bx, by, x3, y3, 1);
                        break;
                    case FillMethod.Radial_360:
                        let t_x = (x0 + x1) / 2;
                        let t_y = (y0 + y1) / 2;
                        let l_x = (x0 + x2) / 2;
                        let l_y = (y0 + y2) / 2;
                        let b_x = (x2 + x3) / 2;
                        let b_y = (y2 + y3) / 2;
                        let r_x = (x1 + x3) / 2;
                        let r_y = (y1 + y3) / 2;
                        let c_x = (l_x + r_x) / 2;
                        let c_y = (l_y + r_y) / 2;
                        let b_x1 = b_x;
                        let b_y1 = b_y;
                        if (this.fillAmmount >= 0.875) {
                            let _fillRate = 8 * (1 - this.fillAmmount);
                            b_x = b_x - _fillRate * (b_x - x2);
                            b_y = b_y - _fillRate * (b_y - y2);
                            this.datar[17 * this._unitLen + 7] = halfu - 0.5 * _fillRate * ulen;
                            this.datar[14 * this._unitLen + 8] = vrange.y;
                            this.datar[15 * this._unitLen + 8] = vrange.y;
                            this.datar[5 * this._unitLen + 8] = halfv;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.75) {
                            let _fillRate = 8 * (0.875 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - l_x);
                            y2 = y2 - _fillRate * (y2 - l_y);
                            b_x = x2;
                            b_y = y2;
                            this.datar[14 * this._unitLen + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[15 * this._unitLen + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[5 * this._unitLen + 8] = halfv;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.625) {
                            let _fillRate = 8 * (0.75 - this.fillAmmount);
                            l_x = l_x - _fillRate * (l_x - x0);
                            l_y = l_y - _fillRate * (l_y - y0);
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[5 * this._unitLen + 8] = halfv - 0.5 * _fillRate * vlen;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            let _fillRate = 8 * (0.625 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - t_x);
                            y0 = y0 - _fillRate * (y0 - t_y);
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[0 * this._unitLen + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[3 * this._unitLen + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.375) {
                            let _fillRate = 8 * (0.5 - this.fillAmmount);
                            t_x = t_x - _fillRate * (t_x - x1);
                            t_y = t_y - _fillRate * (t_y - y1);
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[6 * this._unitLen + 7] = halfu + 0.5 * _fillRate * ulen;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            let _fillRate = 8 * (0.375 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - r_x);
                            y1 = y1 - _fillRate * (y1 - r_y);
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[7 * this._unitLen + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[10 * this._unitLen + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.125) {
                            let _fillRate = 8 * (0.25 - this.fillAmmount);
                            r_x = r_x - _fillRate * (r_x - x3);
                            r_y = r_y - _fillRate * (r_y - y3);
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[19 * this._unitLen + 8] = halfv + 0.5 * _fillRate * vlen;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else {
                            let _fillRate = 8 * (0.125 - this.fillAmmount);
                            x3 = x3 - _fillRate * (x3 - b_x);
                            y3 = y3 - _fillRate * (y3 - b_y);
                            r_x = x3;
                            r_y = y3;
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[20 * this._unitLen + 7] = urange.y - 0.5 * _fillRate * ulen;
                            this.datar[22 * this._unitLen + 7] = urange.y - 0.5 * _fillRate * ulen;
                        }
                        this.updateQuadData(x0, y0, t_x, t_y, l_x, l_y, c_x, c_y, 0, true);
                        this.updateQuadData(t_x, t_y, x1, y1, c_x, c_y, r_x, r_y, 1);
                        this.updateQuadData(l_x, l_y, c_x, c_y, x2, y2, b_x, b_y, 2);
                        this.updateQuadData(c_x, c_y, r_x, r_y, b_x1, b_y1, x3, y3, 3, true);
                        break;
                }
            }
            updateTiledData(x0, y0, x1, y1, x2, y2, x3, y3) {
                let rect = this._sprite.rect;
                let border = this._imageBorder;
                let urange = this._sprite.urange;
                let vrange = this._sprite.vrange;
                let ulen = urange.y - urange.x;
                let vlen = vrange.y - vrange.x;
                let xlen = x1 - x0;
                let ylen = y2 - y0;
                let _ul = this.transform.width / rect.w;
                let _vl = this.transform.height / rect.h;
                let inv_ul = 1 / _ul;
                let inv_vl = 1 / _vl;
                let dindex = 0;
                for (var i = 0; i < _vl - 1; i++) {
                    for (var j = 0; j < _ul - 1; j++) {
                        let tdata = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        this.datar = this.datar.concat(tdata);
                        let tx0 = x0 + inv_ul * xlen * j;
                        let ty0 = y0 + inv_vl * ylen * i;
                        let tx1 = x0 + inv_ul * xlen * (j + 1);
                        let ty1 = y0 + inv_vl * ylen * i;
                        let tx2 = x0 + inv_ul * xlen * j;
                        let ty2 = y0 + inv_vl * ylen * (i + 1);
                        let tx3 = x0 + inv_ul * xlen * (j + 1);
                        let ty3 = y0 + inv_vl * ylen * (i + 1);
                        this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                        dindex++;
                    }
                }
                var intvl = Math.ceil(_vl) - 1;
                var tvl = _vl - Math.ceil(_vl) + 1;
                for (var j = 0; j < _ul - 1; j++) {
                    let tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    let tx0 = x0 + inv_ul * xlen * j;
                    let ty0 = y0 + inv_vl * ylen * intvl;
                    let tx1 = x0 + inv_ul * xlen * (j + 1);
                    let ty1 = y0 + inv_vl * ylen * intvl;
                    let tx2 = x0 + inv_ul * xlen * j;
                    let ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                    let tx3 = x0 + inv_ul * xlen * (j + 1);
                    let ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
                var intul = Math.ceil(_ul) - 1;
                var tul = _ul - Math.ceil(_ul) + 1;
                for (var i = 0; i < _vl - 1; i++) {
                    let tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.y, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    let tx0 = x0 + inv_ul * xlen * intul;
                    let ty0 = y0 + inv_vl * ylen * i;
                    let tx1 = x0 + inv_ul * xlen * (intul + tul);
                    let ty1 = y0 + inv_vl * ylen * i;
                    let tx2 = x0 + inv_ul * xlen * intul;
                    let ty2 = y0 + inv_vl * ylen * (i + 1);
                    let tx3 = x0 + inv_ul * xlen * (intul + tul);
                    let ty3 = y0 + inv_vl * ylen * (i + 1);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
                {
                    let tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    let tx0 = x0 + inv_ul * xlen * intul;
                    let ty0 = y0 + inv_vl * ylen * intvl;
                    let tx1 = x0 + inv_ul * xlen * (intul + tul);
                    let ty1 = y0 + inv_vl * ylen * intvl;
                    let tx2 = x0 + inv_ul * xlen * intul;
                    let ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                    let tx3 = x0 + inv_ul * xlen * (intul + tul);
                    let ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
            }
        };
        __decorate([
            gd3d.reflect.Field("color"),
            gd3d.reflect.UIStyle("color"),
            __metadata("design:type", gd3d.math.color)
        ], image2D.prototype, "color", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            gd3d.reflect.UIStyle("enum"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], image2D.prototype, "imageType", null);
        __decorate([
            gd3d.reflect.Field("number"),
            gd3d.reflect.UIStyle("enum"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], image2D.prototype, "fillMethod", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], image2D.prototype, "fillAmmount", null);
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], image2D.prototype, "_spriteName", void 0);
        __decorate([
            gd3d.reflect.Field("border"),
            __metadata("design:type", Object)
        ], image2D.prototype, "_imageBorder", void 0);
        image2D = __decorate([
            gd3d.reflect.node2DComponent,
            gd3d.reflect.nodeRender,
            __metadata("design:paramtypes", [])
        ], image2D);
        framework.image2D = image2D;
        let ImageType;
        (function (ImageType) {
            ImageType[ImageType["Simple"] = 0] = "Simple";
            ImageType[ImageType["Sliced"] = 1] = "Sliced";
            ImageType[ImageType["Tiled"] = 2] = "Tiled";
            ImageType[ImageType["Filled"] = 3] = "Filled";
        })(ImageType = framework.ImageType || (framework.ImageType = {}));
        let FillMethod;
        (function (FillMethod) {
            FillMethod[FillMethod["Horizontal"] = 0] = "Horizontal";
            FillMethod[FillMethod["Vertical"] = 1] = "Vertical";
            FillMethod[FillMethod["Radial_90"] = 2] = "Radial_90";
            FillMethod[FillMethod["Radial_180"] = 3] = "Radial_180";
            FillMethod[FillMethod["Radial_360"] = 4] = "Radial_360";
        })(FillMethod = framework.FillMethod || (framework.FillMethod = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let inputField = class inputField {
            constructor() {
                this.customRegexStr = "";
                this.beFocus = false;
                this._text = "";
                this._charlimit = 0;
                this._lineType = lineType.SingleLine;
                this._contentType = contentType.None;
            }
            get frameImage() {
                return this._frameImage;
            }
            set frameImage(frameImg) {
                this._frameImage = frameImg;
            }
            get text() {
                return this._text;
            }
            get characterLimit() { return this._charlimit; }
            set characterLimit(charlimit) {
                this._charlimit = parseInt(`${charlimit}`);
                this._charlimit = isNaN(this._charlimit) || this._charlimit < 0 ? 0 : this._charlimit;
            }
            get LineType() { return this._lineType; }
            set LineType(lineType) {
                this._lineType = lineType;
            }
            get ContentType() { return this._contentType; }
            set ContentType(contentType) {
                this._contentType = contentType;
            }
            get TextLabel() {
                return this._textLable;
            }
            set TextLabel(textLabel) {
                textLabel.text = this._text;
                this._textLable = textLabel;
            }
            get PlaceholderLabel() {
                return this._placeholderLabel;
            }
            set PlaceholderLabel(placeholderLabel) {
                if (placeholderLabel.text == null || placeholderLabel.text == "")
                    placeholderLabel.text = "Enter Text...";
                this._placeholderLabel = placeholderLabel;
            }
            updateData(_font) {
            }
            render(canvas) {
            }
            updateTran() {
                this.inputElmLayout();
                if (this._placeholderLabel) {
                    if (this._placeholderLabel.transform.width != this.transform.width)
                        this._placeholderLabel.transform.width = this.transform.width;
                    if (this._placeholderLabel.transform.height != this.transform.height)
                        this._placeholderLabel.transform.height = this.transform.height;
                }
                if (this._textLable) {
                    if (this._textLable.transform.width != this.transform.width)
                        this._textLable.transform.width = this.transform.width;
                    if (this._textLable.transform.height != this.transform.height)
                        this._textLable.transform.height = this.transform.height;
                }
            }
            start() {
                this.inputElement = document.createElement("Input");
                this.inputElement.style.opacity = "0";
                this.inputElement.style.visibility = "hidden";
                if (this.transform.canvas.scene) {
                    let htmlCanv = this.transform.canvas.scene.webgl.canvas;
                    if (htmlCanv)
                        htmlCanv.parentElement.appendChild(this.inputElement);
                }
                this.inputElement.onblur = (e) => {
                    this.beFocus = false;
                };
                this.inputElement.onfocus = (e) => {
                    this.beFocus = true;
                };
                this.inputElmLayout();
            }
            inputElmLayout() {
                if (this.inputElement == null)
                    return;
                let pos = this.transform.getWorldTranslate();
                this.transform.localTranslate;
                let cssStyle = this.inputElement.style;
                if (pos.x + "px" == cssStyle.left && pos.y + "px" == cssStyle.top && this.transform.width + "px" == cssStyle.width && this.transform.height + "px" == cssStyle.height)
                    return;
                let scale = this.transform.canvas.scene.app.canvasClientHeight / this.transform.canvas.pixelHeight;
                cssStyle.position = "absolute";
                cssStyle.left = pos.x * scale + "px";
                cssStyle.top = pos.y * scale + "px";
                cssStyle.width = this.transform.width * scale + "px";
                cssStyle.height = this.transform.height * scale + "px";
            }
            textRefresh() {
                if (!this.beFocus || !this._textLable || !this._placeholderLabel || !this.inputElement || this._text == this.inputElement.value)
                    return;
                if (this._charlimit > 0 && this.inputElement.value.length >= this._charlimit) {
                    if (this.inputElement.value != this._text)
                        if (this.inputElement.value.length > this._text.length) {
                            this.inputElement.value = this._text;
                        }
                        else {
                            this._text = this.inputElement.value;
                        }
                    return;
                }
                this._text = this.inputElement.value;
                if (this._contentType == contentType.Custom) {
                    if (this.customRegexStr != null && this.customRegexStr != "")
                        this._text = this._text.replace(this.customRegexStr, '');
                }
                else {
                    if (this._contentType == contentType.None) {
                    }
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word) && (this._contentType & contentType.ChineseCharacter) && (this._contentType & contentType.Underline)) {
                        this._text = this._text.replace(/^[\u4E00-\u9FA5a-zA-Z0-9_]{3,20}$/ig, '');
                    }
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word) && (this._contentType & contentType.Underline)) {
                        this._text = this._text.replace(/[^\w\.\/]/ig, '');
                    }
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word)) {
                        this._text = this._text.replace(/[^(A-Za-z0-9)]/ig, '');
                    }
                    else if ((this._contentType & contentType.ChineseCharacter) && (this._contentType & contentType.Word)) {
                        this._text = this._text.replace(/[^(A-Za-z\u4E00-\u9FA5)]/ig, '');
                    }
                    else if (this._contentType == contentType.Number) {
                        this._text = this._text.replace(/\D+/g, '');
                    }
                    else if (this._contentType == contentType.ChineseCharacter) {
                        this._text = this._text.replace(/[^\u4E00-\u9FA5]/g, '');
                    }
                }
                this.inputElement.value = this._text;
                if (this._textLable) {
                    this._textLable.text = this._text;
                    this.filterContentText();
                }
                if (this._text == "") {
                    this._placeholderLabel.transform.visible = true;
                    this._textLable.transform.visible = false;
                }
                else {
                    this._placeholderLabel.transform.visible = false;
                    this._textLable.transform.visible = true;
                }
            }
            filterContentText() {
                if (!this._textLable || this._text == null)
                    return;
                let lab = this._textLable;
                let rate = lab.fontsize / lab.font.lineHeight;
                let font = lab.font;
                let addw = 0;
                let addh = 0;
                let str = "";
                switch (this._lineType) {
                    case lineType.SingleLine:
                        for (var i = lab.text.length - 1; i >= 0; i--) {
                            let c = lab.text.charAt(i);
                            let cinfo = font.cmap[c];
                            if (!cinfo) {
                                console.warn(`can't find character "${c}" in ${font.getName()} Font`);
                                continue;
                            }
                            addw += cinfo.xAddvance * rate;
                            if (addw > lab.transform.width) {
                                lab.text = str;
                                break;
                            }
                            str = lab.text[i] + str;
                        }
                        break;
                    case lineType.MultiLine:
                        let fristline = true;
                        addh += lab.fontsize * lab.linespace;
                        for (var i = lab.text.length - 1; i >= 0; i--) {
                            let c = lab.text.charAt(i);
                            let cinfo = font.cmap[c];
                            if (!cinfo) {
                                console.warn(`can't find character "${c}" in ${font.getName()} Font`);
                                continue;
                            }
                            addw += cinfo.xAddvance * rate;
                            if (addw > lab.transform.width) {
                                addw = 0;
                                fristline = false;
                                addh += lab.fontsize * lab.linespace;
                            }
                            if (!fristline && addh > lab.transform.height) {
                                lab.text = str;
                                break;
                            }
                            str = lab.text[i] + str;
                        }
                        break;
                }
            }
            update(delta) {
                this.textRefresh();
            }
            remove() {
                this._placeholderLabel = null;
                this._textLable = null;
                this.transform = null;
                this._frameImage = null;
                if (this.inputElement) {
                    this.inputElement.disabled = false;
                    this.inputElement.value = "";
                    this.inputElement.style.visibility = "hidden";
                    if (this.inputElement.parentElement)
                        this.inputElement.parentElement.removeChild(this.inputElement);
                    this.inputElement = null;
                }
            }
            onPointEvent(canvas, ev, oncap) {
                if (oncap == false) {
                    if (ev.type != framework.PointEventEnum.PointDown)
                        return;
                    var b = this.transform.ContainsCanvasPoint(new gd3d.math.vector2(ev.x, ev.y));
                    if (b) {
                        this.inputElement.style.visibility = "visible";
                        this.inputElement.focus();
                    }
                    else {
                        if (this.beFocus)
                            this.inputElement.blur();
                        if (this.inputElement.style.visibility != "hidden")
                            this.inputElement.style.visibility = "hidden";
                    }
                }
            }
        };
        __decorate([
            gd3d.reflect.Field("reference"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [framework.image2D])
        ], inputField.prototype, "frameImage", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], inputField.prototype, "characterLimit", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], inputField.prototype, "LineType", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], inputField.prototype, "ContentType", null);
        __decorate([
            gd3d.reflect.Field("reference"),
            __metadata("design:type", framework.label),
            __metadata("design:paramtypes", [framework.label])
        ], inputField.prototype, "TextLabel", null);
        __decorate([
            gd3d.reflect.Field("reference"),
            __metadata("design:type", framework.label),
            __metadata("design:paramtypes", [framework.label])
        ], inputField.prototype, "PlaceholderLabel", null);
        inputField = __decorate([
            gd3d.reflect.node2DComponent,
            gd3d.reflect.nodeRender
        ], inputField);
        framework.inputField = inputField;
        let lineType;
        (function (lineType) {
            lineType[lineType["SingleLine"] = 0] = "SingleLine";
            lineType[lineType["MultiLine"] = 1] = "MultiLine";
        })(lineType = framework.lineType || (framework.lineType = {}));
        let contentType;
        (function (contentType) {
            contentType[contentType["None"] = 0] = "None";
            contentType[contentType["Number"] = 1] = "Number";
            contentType[contentType["Word"] = 2] = "Word";
            contentType[contentType["Underline"] = 4] = "Underline";
            contentType[contentType["ChineseCharacter"] = 8] = "ChineseCharacter";
            contentType[contentType["NoneChineseCharacter"] = 16] = "NoneChineseCharacter";
            contentType[contentType["Email"] = 32] = "Email";
            contentType[contentType["PassWord"] = 64] = "PassWord";
            contentType[contentType["Custom"] = 128] = "Custom";
        })(contentType = framework.contentType || (framework.contentType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let label = class label {
            constructor() {
                this.needRefreshFont = false;
                this._fontName = "defFont";
                this._fontsize = 14;
                this.linespace = 1;
                this.horizontalType = HorizontalType.Left;
                this.verticalType = VerticalType.Center;
                this.horizontalOverflow = false;
                this.verticalOverflow = false;
                this.indexarr = [];
                this.remainarrx = [];
                this.data_begin = new gd3d.math.vector2(0, 0);
                this.datar = [];
                this.color = new gd3d.math.color(1, 1, 1, 1);
                this.color2 = new gd3d.math.color(0, 0, 0.5, 0.5);
                this.dirtyData = true;
            }
            get text() {
                return this._text;
            }
            set text(text) {
                text = text == null ? "" : text;
                this._text = text;
                this.initdater();
                this.dirtyData = true;
            }
            initdater() {
                var cachelen = 6 * 13 * this._text.length;
                this.datar.splice(0, this.datar.length);
                while (this.datar.length < cachelen) {
                    this.datar.push(0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
                }
                while (this.datar.length < cachelen) {
                    this.datar.pop();
                }
            }
            get font() {
                return this._font;
            }
            set font(font) {
                if (font == this._font)
                    return;
                this.needRefreshFont = true;
                if (this._font) {
                    this._font.unuse();
                }
                this._font = font;
                if (font) {
                    this._font.use();
                    this._fontName = this._font.getName();
                }
                else {
                    this._fontName = "";
                }
            }
            get fontsize() {
                return this._fontsize;
            }
            set fontsize(size) {
                this._fontsize = size;
            }
            updateData(_font) {
                this.dirtyData = false;
                var rate = this._fontsize / _font.lineHeight;
                var m = this.transform.getWorldMatrix();
                var m11 = m.rawData[0];
                var m12 = m.rawData[2];
                var m21 = m.rawData[1];
                var m22 = m.rawData[3];
                var bx = this.data_begin.x;
                var by = this.data_begin.y;
                var txadd = 0;
                var tyadd = 0;
                this.indexarr = [];
                this.remainarrx = [];
                var remainy = 0;
                tyadd += this._fontsize * this.linespace;
                let contrast_w = this.horizontalOverflow ? Number.MAX_VALUE : this.transform.width;
                let contrast_h = this.verticalOverflow ? Number.MAX_VALUE : this.transform.height;
                for (var i = 0; i < this._text.length; i++) {
                    let c = this._text.charAt(i);
                    let cinfo = _font.cmap[c];
                    if (cinfo == undefined) {
                        continue;
                    }
                    if (txadd + cinfo.xAddvance * rate > contrast_w) {
                        if (tyadd + this._fontsize * this.linespace > contrast_h) {
                            break;
                        }
                        else {
                            this.indexarr.push(i);
                            this.remainarrx.push(this.transform.width - txadd);
                            txadd = 0;
                            tyadd += this._fontsize * this.linespace;
                        }
                    }
                    txadd += cinfo.xAddvance * rate;
                }
                this.indexarr.push(i);
                this.remainarrx.push(this.transform.width - txadd);
                remainy = this.transform.height - tyadd;
                var i = 0;
                var xadd = 0;
                var yadd = 0;
                if (this.verticalType == VerticalType.Center) {
                    yadd += remainy / 2;
                }
                else if (this.verticalType == VerticalType.Boom) {
                    yadd += remainy;
                }
                this.initdater();
                for (var arri = 0; arri < this.indexarr.length; arri++) {
                    xadd = 0;
                    if (this.horizontalType == HorizontalType.Center) {
                        xadd += this.remainarrx[arri] / 2;
                    }
                    else if (this.horizontalType == HorizontalType.Right) {
                        xadd += this.remainarrx[arri];
                    }
                    for (; i < this.indexarr[arri]; i++) {
                        let c = this._text.charAt(i);
                        let cinfo = _font.cmap[c];
                        if (cinfo == undefined) {
                            continue;
                        }
                        var cx = xadd + cinfo.xOffset * rate;
                        var cy = yadd - cinfo.yOffset * rate + _font.baseline * rate;
                        var ch = rate * cinfo.ySize;
                        var cw = rate * cinfo.xSize;
                        xadd += cinfo.xAddvance * rate;
                        var x1 = cx + cw;
                        var y1 = cy;
                        var x2 = cx;
                        var y2 = cy + ch;
                        var x3 = cx + cw;
                        var y3 = cy + ch;
                        this.datar[i * 6 * 13 + 0] = bx + cx * m11 + cy * m12;
                        this.datar[i * 6 * 13 + 1] = by + cx * m21 + cy * m22;
                        this.datar[i * 6 * 13 + 13 * 1 + 0] = bx + x1 * m11 + y1 * m12;
                        this.datar[i * 6 * 13 + 13 * 1 + 1] = by + x1 * m21 + y1 * m22;
                        this.datar[i * 6 * 13 + 13 * 2 + 0] = bx + x2 * m11 + y2 * m12;
                        this.datar[i * 6 * 13 + 13 * 2 + 1] = by + x2 * m21 + y2 * m22;
                        this.datar[i * 6 * 13 + 13 * 3 + 0] = bx + x2 * m11 + y2 * m12;
                        this.datar[i * 6 * 13 + 13 * 3 + 1] = by + x2 * m21 + y2 * m22;
                        this.datar[i * 6 * 13 + 13 * 4 + 0] = bx + x1 * m11 + y1 * m12;
                        this.datar[i * 6 * 13 + 13 * 4 + 1] = by + x1 * m21 + y1 * m22;
                        this.datar[i * 6 * 13 + 13 * 5 + 0] = bx + x3 * m11 + y3 * m12;
                        this.datar[i * 6 * 13 + 13 * 5 + 1] = by + x3 * m21 + y3 * m22;
                        var u0 = cinfo.x;
                        var v0 = cinfo.y;
                        var u1 = cinfo.x + cinfo.w;
                        var v1 = cinfo.y;
                        var u2 = cinfo.x;
                        var v2 = cinfo.y + cinfo.h;
                        var u3 = cinfo.x + cinfo.w;
                        var v3 = cinfo.y + cinfo.h;
                        this.datar[i * 6 * 13 + 7] = u0;
                        this.datar[i * 6 * 13 + 8] = v0;
                        this.datar[i * 6 * 13 + 13 * 1 + 7] = u1;
                        this.datar[i * 6 * 13 + 13 * 1 + 8] = v1;
                        this.datar[i * 6 * 13 + 13 * 2 + 7] = u2;
                        this.datar[i * 6 * 13 + 13 * 2 + 8] = v2;
                        this.datar[i * 6 * 13 + 13 * 3 + 7] = u2;
                        this.datar[i * 6 * 13 + 13 * 3 + 8] = v2;
                        this.datar[i * 6 * 13 + 13 * 4 + 7] = u1;
                        this.datar[i * 6 * 13 + 13 * 4 + 8] = v1;
                        this.datar[i * 6 * 13 + 13 * 5 + 7] = u3;
                        this.datar[i * 6 * 13 + 13 * 5 + 8] = v3;
                        for (var j = 0; j < 6; j++) {
                            this.datar[i * 6 * 13 + 13 * j + 3] = this.color.r;
                            this.datar[i * 6 * 13 + 13 * j + 4] = this.color.g;
                            this.datar[i * 6 * 13 + 13 * j + 5] = this.color.b;
                            this.datar[i * 6 * 13 + 13 * j + 6] = this.color.a;
                            this.datar[i * 6 * 13 + 13 * j + 9] = this.color2.r;
                            this.datar[i * 6 * 13 + 13 * j + 10] = this.color2.g;
                            this.datar[i * 6 * 13 + 13 * j + 11] = this.color2.b;
                            this.datar[i * 6 * 13 + 13 * j + 12] = this.color2.a;
                        }
                    }
                    yadd += this._fontsize * this.linespace;
                }
            }
            get uimat() {
                if (this.font && this.font.texture) {
                    let rectPostfix = this.transform.parentIsMask ? `_(${this.transform.insId})` : "";
                    let matName = this.font.texture.getName() + "_fontmask" + rectPostfix;
                    let canvas = this.transform.canvas;
                    if (!canvas.assetmgr)
                        return;
                    let mat = this._uimat;
                    if (!mat || mat.getName() != matName) {
                        if (mat)
                            mat.unuse();
                        mat = canvas.assetmgr.getAssetByName(matName);
                        if (mat)
                            mat.use();
                    }
                    if (mat == null) {
                        mat = new framework.material(matName);
                        mat.setShader(canvas.assetmgr.getShader("shader/defmaskfont"));
                        mat.use();
                    }
                    mat.setFloat("MaskState", this.transform.parentIsMask ? 1 : 0);
                    this._uimat = mat;
                }
                return this._uimat;
            }
            render(canvas) {
                if (this._font == null) {
                    let temp = canvas.assetmgr.mapNamed[this._fontName];
                    if (temp != null) {
                        let tfont = canvas.assetmgr.getAssetByName(this._fontName);
                        if (tfont) {
                            this.font = tfont;
                            this.needRefreshFont = true;
                        }
                    }
                }
                if (this._font != null) {
                    if (this.dirtyData == true) {
                        this.updateData(this._font);
                        this.dirtyData = false;
                    }
                    let mat = this.uimat;
                    if (!mat)
                        return;
                    var img;
                    if (this._font != null) {
                        img = this._font.texture;
                    }
                    if (img != null) {
                        if (this.needRefreshFont) {
                            mat.setTexture("_MainTex", img);
                            this.needRefreshFont = false;
                        }
                        if (this.transform.parentIsMask) {
                            if (this._cacheMaskV4 == null)
                                this._cacheMaskV4 = new gd3d.math.vector4();
                            let rect = this.transform.maskRect;
                            if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h) {
                                this._cacheMaskV4.x = rect.x;
                                this._cacheMaskV4.y = rect.y;
                                this._cacheMaskV4.z = rect.w;
                                this._cacheMaskV4.w = rect.h;
                                mat.setVector4("_maskRect", this._cacheMaskV4);
                            }
                        }
                        if (this.datar.length != 0)
                            canvas.pushRawData(mat, this.datar);
                    }
                }
            }
            updateTran() {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var t = -this.transform.pivot.y * this.transform.height;
                this.data_begin.x = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                this.data_begin.y = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                this.dirtyData = true;
            }
            start() {
            }
            update(delta) {
            }
            remove() {
                if (this._font)
                    this._font.unuse(true);
                if (this._uimat)
                    this._uimat.unuse(true);
                this.indexarr.length = 0;
                this.remainarrx.length = 0;
                this.datar.length = 0;
                this.transform = null;
                this._cacheMaskV4 = null;
            }
            onPointEvent(canvas, ev, oncap) {
            }
        };
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String),
            __metadata("design:paramtypes", [String])
        ], label.prototype, "text", null);
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", Object)
        ], label.prototype, "_fontName", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], label.prototype, "fontsize", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], label.prototype, "linespace", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], label.prototype, "horizontalType", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], label.prototype, "verticalType", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], label.prototype, "horizontalOverflow", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], label.prototype, "verticalOverflow", void 0);
        __decorate([
            gd3d.reflect.Field("color"),
            gd3d.reflect.UIStyle("color"),
            __metadata("design:type", gd3d.math.color)
        ], label.prototype, "color", void 0);
        __decorate([
            gd3d.reflect.Field("color"),
            gd3d.reflect.UIStyle("color"),
            __metadata("design:type", gd3d.math.color)
        ], label.prototype, "color2", void 0);
        label = __decorate([
            gd3d.reflect.node2DComponent,
            gd3d.reflect.nodeRender
        ], label);
        framework.label = label;
        let HorizontalType;
        (function (HorizontalType) {
            HorizontalType[HorizontalType["Center"] = 0] = "Center";
            HorizontalType[HorizontalType["Left"] = 1] = "Left";
            HorizontalType[HorizontalType["Right"] = 2] = "Right";
        })(HorizontalType = framework.HorizontalType || (framework.HorizontalType = {}));
        let VerticalType;
        (function (VerticalType) {
            VerticalType[VerticalType["Center"] = 0] = "Center";
            VerticalType[VerticalType["Top"] = 1] = "Top";
            VerticalType[VerticalType["Boom"] = 2] = "Boom";
        })(VerticalType = framework.VerticalType || (framework.VerticalType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let rawImage2D = class rawImage2D {
            constructor() {
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.needRefreshImg = false;
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
            }
            get image() {
                return this._image;
            }
            set image(_image) {
                if (this._image == _image)
                    return;
                this.needRefreshImg = true;
                if (this._image) {
                    this._image.unuse();
                }
                this._image = _image;
                if (_image) {
                    this._image.use();
                }
            }
            get uimat() {
                if (this.image != null) {
                    let rectPostfix = this.transform.parentIsMask ? `_(${this.transform.insId})` : "";
                    let matName = this._image.getName() + "_uimask" + rectPostfix;
                    let canvas = this.transform.canvas;
                    if (!canvas.assetmgr)
                        return;
                    let mat = this._uimat;
                    if (!mat || mat.getName() != matName) {
                        if (mat)
                            mat.unuse();
                        mat = canvas.assetmgr.getAssetByName(matName);
                        if (mat)
                            mat.use();
                    }
                    if (mat == null) {
                        mat = new framework.material(matName);
                        mat.setShader(canvas.assetmgr.getShader("shader/defmaskui"));
                        mat.use();
                    }
                    mat.setFloat("MaskState", this.transform.parentIsMask ? 1 : 0);
                    this._uimat = mat;
                }
                return this._uimat;
            }
            render(canvas) {
                let img = this.image;
                let mat = this.uimat;
                if (!mat)
                    return;
                if (img != null) {
                    if (this.needRefreshImg) {
                        mat.setTexture("_MainTex", img);
                        this.needRefreshImg = false;
                    }
                    if (this.transform.parentIsMask) {
                        if (this._cacheMaskV4 == null)
                            this._cacheMaskV4 = new gd3d.math.vector4();
                        let rect = this.transform.maskRect;
                        if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h) {
                            this._cacheMaskV4.x = rect.x;
                            this._cacheMaskV4.y = rect.y;
                            this._cacheMaskV4.z = rect.w;
                            this._cacheMaskV4.w = rect.h;
                            mat.setVector4("_maskRect", this._cacheMaskV4);
                        }
                    }
                    canvas.pushRawData(mat, this.datar);
                }
            }
            updateTran() {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                this.datar[0 * 13] = x0;
                this.datar[0 * 13 + 1] = y0;
                this.datar[1 * 13] = x1;
                this.datar[1 * 13 + 1] = y1;
                this.datar[2 * 13] = x2;
                this.datar[2 * 13 + 1] = y2;
                this.datar[3 * 13] = x2;
                this.datar[3 * 13 + 1] = y2;
                this.datar[4 * 13] = x1;
                this.datar[4 * 13 + 1] = y1;
                this.datar[5 * 13] = x3;
                this.datar[5 * 13 + 1] = y3;
                for (var i = 0; i < 6; i++) {
                    this.datar[i * 13 + 3] = this.color.r;
                    this.datar[i * 13 + 4] = this.color.g;
                    this.datar[i * 13 + 5] = this.color.b;
                    this.datar[i * 13 + 6] = this.color.a;
                }
            }
            start() {
            }
            update(delta) {
            }
            remove() {
                if (this._image)
                    this._image.unuse(true);
                if (this._uimat)
                    this._uimat.unuse(true);
                this._image = null;
                this._cacheMaskV4 = null;
                this.transform = null;
                this.datar.length = 0;
            }
            onPointEvent(canvas, ev, oncap) {
            }
        };
        __decorate([
            gd3d.reflect.Field("texture"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [framework.texture])
        ], rawImage2D.prototype, "image", null);
        __decorate([
            gd3d.reflect.Field("color"),
            gd3d.reflect.UIStyle("vector4"),
            __metadata("design:type", gd3d.math.color)
        ], rawImage2D.prototype, "color", void 0);
        rawImage2D = __decorate([
            gd3d.reflect.node2DComponent,
            gd3d.reflect.nodeRender
        ], rawImage2D);
        framework.rawImage2D = rawImage2D;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let scrollRect = class scrollRect {
            constructor() {
                this.horizontal = true;
                this.vertical = true;
                this.isPointDown = false;
            }
            get content() {
                return this._content;
            }
            set content(content) {
                this._content = content;
            }
            start() {
            }
            update(delta) {
            }
            onPointEvent(canvas, ev, oncap) {
                if (oncap == false) {
                    var b = this.transform.ContainsCanvasPoint(new gd3d.math.vector2(ev.x, ev.y));
                    if (b) {
                        ev.eated = true;
                        if (this._content == null)
                            return;
                        if (!this.horizontal && !this.vertical)
                            return;
                        let temps = gd3d.math.pool.new_vector2();
                        temps.x = ev.x;
                        temps.y = ev.y;
                        let tempc = gd3d.math.pool.new_vector2();
                        this.transform.canvas.ModelPosToCanvasPos(temps, tempc);
                        if (this.strPoint == null)
                            this.strPoint = new gd3d.math.vector2();
                        let sp = this.strPoint;
                        if (ev.type == framework.PointEventEnum.PointDown) {
                            this.isPointDown = true;
                            sp.x = tempc.x;
                            sp.y = tempc.y;
                            if (this.strPos == null)
                                this.strPos = new gd3d.math.vector2();
                            gd3d.math.vec2Clone(this._content.transform.localTranslate, this.strPos);
                        }
                        if (ev.type == framework.PointEventEnum.PointHold && this.isPointDown) {
                            if (this.lastPoint == null)
                                this.lastPoint = new gd3d.math.vector2();
                            let lp = this.lastPoint;
                            if (lp.x != tempc.x || lp.y != tempc.y) {
                                lp.x = tempc.x;
                                lp.y = tempc.y;
                                let addtransX = lp.x - sp.x;
                                let addtransY = lp.y - sp.y;
                                this.SlideTo(addtransX, addtransY);
                            }
                        }
                        gd3d.math.pool.delete_vector2(temps);
                        gd3d.math.pool.delete_vector2(tempc);
                    }
                }
                if (ev.type == framework.PointEventEnum.PointUp) {
                    this.isPointDown = false;
                }
            }
            SlideTo(addtransX, addtransY) {
                if (this._content == null || this.strPos == null)
                    return;
                let ctrans = this._content.transform;
                let cpos = ctrans.localTranslate;
                let trans = this.transform;
                gd3d.math.vec2Clone(this.strPos, cpos);
                if (this.horizontal) {
                    cpos.x += addtransX;
                    if (cpos.x > 0)
                        cpos.x = 0;
                    if (ctrans.width >= trans.width && cpos.x + ctrans.width < trans.width)
                        cpos.x = -1 * (ctrans.width - trans.width);
                }
                if (this.vertical) {
                    cpos.y += addtransY;
                    if (cpos.y > 0)
                        cpos.y = 0;
                    if (ctrans.height >= trans.height && cpos.y + ctrans.height < trans.height)
                        cpos.y = -1 * (ctrans.height - trans.height);
                }
                ctrans.markDirty();
            }
            remove() {
                this._content = null;
                this.transform = null;
            }
        };
        __decorate([
            gd3d.reflect.Field("reference"),
            __metadata("design:type", framework.transform2D),
            __metadata("design:paramtypes", [framework.transform2D])
        ], scrollRect.prototype, "content", null);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], scrollRect.prototype, "horizontal", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], scrollRect.prototype, "vertical", void 0);
        scrollRect = __decorate([
            gd3d.reflect.node2DComponent
        ], scrollRect);
        framework.scrollRect = scrollRect;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let uirect = class uirect {
            constructor() {
                this.canbeClick = true;
            }
            start() {
            }
            update(delta) {
            }
            onPointEvent(canvas, ev, oncap) {
            }
            remove() {
                this.transform = null;
            }
        };
        uirect = __decorate([
            gd3d.reflect.node2DComponent
        ], uirect);
        framework.uirect = uirect;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class resID {
            constructor() {
                this.id = resID.next();
            }
            static next() {
                var next = resID.idAll;
                resID.idAll++;
                return next;
            }
            getID() {
                return this.id;
            }
        }
        resID.idAll = 1;
        framework.resID = resID;
        let constText = class constText {
            constructor(text) {
                this.name = text;
            }
            getText() {
                return this.name;
            }
        };
        constText = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], constText);
        framework.constText = constText;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let AssetTypeEnum;
        (function (AssetTypeEnum) {
            AssetTypeEnum[AssetTypeEnum["Unknown"] = 0] = "Unknown";
            AssetTypeEnum[AssetTypeEnum["Auto"] = 1] = "Auto";
            AssetTypeEnum[AssetTypeEnum["Bundle"] = 2] = "Bundle";
            AssetTypeEnum[AssetTypeEnum["CompressBundle"] = 3] = "CompressBundle";
            AssetTypeEnum[AssetTypeEnum["GLVertexShader"] = 4] = "GLVertexShader";
            AssetTypeEnum[AssetTypeEnum["GLFragmentShader"] = 5] = "GLFragmentShader";
            AssetTypeEnum[AssetTypeEnum["Shader"] = 6] = "Shader";
            AssetTypeEnum[AssetTypeEnum["Texture"] = 7] = "Texture";
            AssetTypeEnum[AssetTypeEnum["TextureDesc"] = 8] = "TextureDesc";
            AssetTypeEnum[AssetTypeEnum["Mesh"] = 9] = "Mesh";
            AssetTypeEnum[AssetTypeEnum["Prefab"] = 10] = "Prefab";
            AssetTypeEnum[AssetTypeEnum["Material"] = 11] = "Material";
            AssetTypeEnum[AssetTypeEnum["Aniclip"] = 12] = "Aniclip";
            AssetTypeEnum[AssetTypeEnum["KeyFrameAniclip"] = 13] = "KeyFrameAniclip";
            AssetTypeEnum[AssetTypeEnum["Scene"] = 14] = "Scene";
            AssetTypeEnum[AssetTypeEnum["Atlas"] = 15] = "Atlas";
            AssetTypeEnum[AssetTypeEnum["Font"] = 16] = "Font";
            AssetTypeEnum[AssetTypeEnum["TextAsset"] = 17] = "TextAsset";
            AssetTypeEnum[AssetTypeEnum["PackBin"] = 18] = "PackBin";
            AssetTypeEnum[AssetTypeEnum["PackTxt"] = 19] = "PackTxt";
            AssetTypeEnum[AssetTypeEnum["PathAsset"] = 20] = "PathAsset";
            AssetTypeEnum[AssetTypeEnum["PVR"] = 21] = "PVR";
            AssetTypeEnum[AssetTypeEnum["F14Effect"] = 22] = "F14Effect";
            AssetTypeEnum[AssetTypeEnum["DDS"] = 23] = "DDS";
        })(AssetTypeEnum = framework.AssetTypeEnum || (framework.AssetTypeEnum = {}));
        let AssetBundleLoadState;
        (function (AssetBundleLoadState) {
            AssetBundleLoadState[AssetBundleLoadState["None"] = 0] = "None";
            AssetBundleLoadState[AssetBundleLoadState["Shader"] = 1] = "Shader";
            AssetBundleLoadState[AssetBundleLoadState["Mesh"] = 2] = "Mesh";
            AssetBundleLoadState[AssetBundleLoadState["Texture"] = 4] = "Texture";
            AssetBundleLoadState[AssetBundleLoadState["Material"] = 8] = "Material";
            AssetBundleLoadState[AssetBundleLoadState["Anclip"] = 16] = "Anclip";
            AssetBundleLoadState[AssetBundleLoadState["Prefab"] = 32] = "Prefab";
            AssetBundleLoadState[AssetBundleLoadState["Scene"] = 64] = "Scene";
            AssetBundleLoadState[AssetBundleLoadState["Textasset"] = 128] = "Textasset";
            AssetBundleLoadState[AssetBundleLoadState["Pvr"] = 256] = "Pvr";
            AssetBundleLoadState[AssetBundleLoadState["f14eff"] = 512] = "f14eff";
            AssetBundleLoadState[AssetBundleLoadState["Dds"] = 1024] = "Dds";
        })(AssetBundleLoadState = framework.AssetBundleLoadState || (framework.AssetBundleLoadState = {}));
        class ResourceState {
            constructor() {
                this.res = null;
                this.state = 0;
                this.loadedLength = 0;
            }
        }
        framework.ResourceState = ResourceState;
        class RefResourceState extends ResourceState {
            constructor() {
                super(...arguments);
                this.refLoadedLength = 0;
            }
        }
        framework.RefResourceState = RefResourceState;
        class stateLoad {
            constructor() {
                this.iserror = false;
                this.isfinish = false;
                this.resstate = {};
                this.curtask = 0;
                this.bundleLoadState = 0;
                this.totaltask = 0;
                this.totalByteLength = 0;
                this.progressCall = false;
                this.compressTextLoaded = 0;
                this.compressBinLoaded = 0;
                this.logs = [];
                this.errs = [];
            }
            get fileProgress() {
                return this.curtask / this.totaltask;
            }
            get curByteLength() {
                let result = 0;
                for (let key in this.resstate) {
                    let _resState = this.resstate[key];
                    result += _resState.loadedLength;
                    if (_resState instanceof RefResourceState) {
                        result += _resState.refLoadedLength;
                    }
                }
                result += this.compressTextLoaded + this.compressBinLoaded;
                return result;
            }
            get progress() {
                return this.curByteLength / this.totalByteLength;
            }
        }
        framework.stateLoad = stateLoad;
        class assetBundle {
            constructor(url) {
                this.files = [];
                this.packages = [];
                this.bundlePackBin = {};
                this.totalLength = 0;
                this.mapNamed = {};
                this.url = url;
                var i = url.lastIndexOf("/");
                this.path = url.substring(0, i);
            }
            loadCompressBundle(url, onstate, state, assetmgr) {
                state.totalByteLength = this.totalLength;
                gd3d.io.loadText(url, (txt, err) => {
                    if (err != null) {
                        state.iserror = true;
                        state.errs.push(new Error(err.message));
                        onstate(state);
                        return;
                    }
                    let json = JSON.parse(txt);
                    this.bundlePackJson = json;
                    this.parse(json["bundleinfo"], this.totalLength);
                    this.load(assetmgr, onstate, state);
                    assetmgr.mapBundle[this.name] = this;
                }, (loadedLength, totalLength) => {
                    state.compressTextLoaded = loadedLength;
                    onstate(state);
                });
            }
            parse(json, totalLength = 0) {
                var files = json["files"];
                for (var i = 0; i < files.length; i++) {
                    var item = files[i];
                    let packes = -1;
                    if (item.packes != undefined)
                        packes = item.packes;
                    this.files.push({ name: item.name, length: item.length, packes: packes });
                }
                if (json["packes"] != undefined) {
                    let packes = json["packes"];
                    for (var i = 0; i < packes.length; i++) {
                        this.packages.push(packes[i]);
                    }
                }
                else {
                    if (json["totalLength"] != undefined) {
                        if (totalLength == 0) {
                            this.totalLength = json["totalLength"];
                        }
                    }
                }
            }
            unload() {
                for (let key in this.mapNamed) {
                    let asset = this.assetmgr.getAssetByName(key, this.name);
                    if (asset) {
                        this.assetmgr.unuse(asset);
                    }
                }
                this.assetmgr.removeAssetBundle(this.name);
            }
            load(assetmgr, onstate, state) {
                state.totalByteLength = this.totalLength;
                let totoal = this.files.length;
                this.assetmgr = assetmgr;
                this.curLoadState = AssetBundleLoadState.None;
                let glvshaders = [];
                let glfshaders = [];
                let shaders = [];
                let meshs = [];
                let textures = [];
                let texturedescs = [];
                let materials = [];
                let anclips = [];
                let prefabs = [];
                let scenes = [];
                let textassets = [];
                let pvrs = [];
                let packs = [];
                let f14effs = [];
                let fonts = [];
                let atlass = [];
                let ddss = [];
                let kfaniclips = [];
                let asslist = [];
                let assstatelist = [];
                asslist.push(packs, glvshaders, glfshaders, shaders, textassets, meshs, textures, pvrs, ddss, texturedescs, fonts, atlass, materials, anclips, kfaniclips, f14effs, prefabs, scenes);
                assstatelist.push(AssetBundleLoadState.None, AssetBundleLoadState.None, AssetBundleLoadState.None, AssetBundleLoadState.Shader, AssetBundleLoadState.Prefab, AssetBundleLoadState.Mesh, AssetBundleLoadState.Material, AssetBundleLoadState.Scene, AssetBundleLoadState.None, AssetBundleLoadState.Texture, AssetBundleLoadState.Anclip, AssetBundleLoadState.Textasset, AssetBundleLoadState.Pvr, AssetBundleLoadState.f14eff, AssetBundleLoadState.Dds);
                let realTotal = 0;
                var mapPackes = {};
                for (var i = 0; i < this.packages.length; i++) {
                    let pack = this.packages[i];
                    let type = assetmgr.calcType(pack);
                    let url = this.path + "/" + pack;
                    packs.push({ url: url, type: type, asset: null });
                }
                for (var i = 0; i < this.files.length; i++) {
                    var fitem = this.files[i];
                    var type = assetmgr.calcType(fitem.name);
                    let url = this.path + "/" + fitem.name;
                    let fileName = assetmgr.getFileName(url);
                    if (fitem.packes != -1) {
                        mapPackes[url] = fitem.packes;
                    }
                    {
                        let asset = null;
                        switch (type) {
                            case AssetTypeEnum.GLFragmentShader:
                                glfshaders.push({ url, type, asset: null });
                                break;
                            case AssetTypeEnum.GLVertexShader:
                                glvshaders.push({ url, type, asset: null });
                                break;
                            case AssetTypeEnum.Shader:
                                asset = new framework.shader(fileName);
                                shaders.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.Texture:
                                asset = new framework.texture(fileName);
                                textures.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.TextureDesc:
                                asset = new framework.texture(fileName);
                                texturedescs.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.Mesh:
                                asset = new framework.mesh(fileName);
                                meshs.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.Material:
                                asset = new framework.material(fileName);
                                materials.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.Aniclip:
                                asset = new framework.animationClip(fileName);
                                anclips.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.Prefab:
                                asset = new framework.prefab(fileName);
                                prefabs.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.Scene:
                                asset = new framework.rawscene(fileName);
                                scenes.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.TextAsset:
                                asset = new framework.textasset(fileName);
                                textassets.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.PVR:
                                asset = new framework.texture(fileName);
                                pvrs.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.F14Effect:
                                asset = new framework.f14eff(fileName);
                                f14effs.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.DDS:
                                asset = new framework.texture(fileName);
                                ddss.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.Font:
                                asset = new framework.font(fileName);
                                fonts.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.Atlas:
                                asset = new framework.atlas(fileName);
                                atlass.push({ url, type, asset: asset });
                                break;
                            case AssetTypeEnum.KeyFrameAniclip:
                                asset = new framework.keyFrameAniClip(fileName);
                                kfaniclips.push({ url, type, asset: asset });
                                break;
                        }
                        if (type != AssetTypeEnum.GLVertexShader && type != AssetTypeEnum.GLFragmentShader && type != AssetTypeEnum.Shader
                            && type != AssetTypeEnum.PackBin && type != AssetTypeEnum.PackTxt) {
                            if (!asset)
                                continue;
                            this.mapNamed[fileName] = asset.getGUID();
                            assetmgr.regRes(fileName, asset);
                        }
                    }
                }
                let list = [];
                for (let i = 0; i < asslist.length; i++) {
                    for (let j = 0; j < asslist[i].length; j++) {
                        let url = asslist[i][j].url;
                        let type = asslist[i][j].type;
                        let asset = asslist[i][j].asset;
                        let state = null;
                        if (j == asslist[i].length - 1)
                            state = assstatelist[i];
                        list.push({ url, type, asset, state });
                    }
                }
                realTotal = list.length;
                if (totoal > realTotal) {
                    console.log("assetBundle中某个file不是资源或后缀有问题");
                }
                state.totaltask = realTotal + 1;
                state.curtask = 1;
                onstate(state);
                assetmgr.doWaitState(this.url, state);
                state.bundleLoadState = AssetBundleLoadState.None;
                var loadcall = () => {
                    let surl = list[state.curtask - 1].url;
                    let type = list[state.curtask - 1].type;
                    let asset = list[state.curtask - 1].asset;
                    let _fileName = assetmgr.getFileName(surl);
                    let loadstate = list[state.curtask - 1].state;
                    if (mapPackes[surl] != undefined) {
                        let respack;
                        if (mapPackes[surl] == 0)
                            respack = this.bundlePackJson;
                        else if (mapPackes[surl] == 1)
                            respack = this.bundlePackBin;
                        else
                            console.log("未识别的packnum: " + mapPackes[surl]);
                        assetmgr.loadResByPack(respack, surl, type, (s) => {
                            if (s.progressCall) {
                                s.progressCall = false;
                                onstate(state);
                                return;
                            }
                            if (state != undefined)
                                state.bundleLoadState |= loadstate;
                            realTotal--;
                            state.curtask++;
                            if (realTotal === 0) {
                                state.isfinish = true;
                                onstate(state);
                                assetmgr.loadByMulQueue();
                            }
                            else {
                                onstate(state);
                                loadcall();
                            }
                            assetmgr.doWaitState(this.url, state);
                        }, state, asset);
                    }
                    else {
                        if (type == AssetTypeEnum.PackBin) {
                            gd3d.io.loadArrayBuffer(surl, (_buffer, err) => {
                                if (err != null) {
                                    state.iserror = true;
                                    state.errs.push(new Error(err.message));
                                    onstate(state);
                                    assetmgr.loadByMulQueue();
                                    return;
                                }
                                var read = new gd3d.io.binReader(_buffer);
                                let index = read.readInt32();
                                read.position = index;
                                while (read.canread()) {
                                    let indindex = read.readInt32();
                                    if (index == 0)
                                        break;
                                    let key = read.readStringUtf8FixLength(indindex);
                                    let strs = key.split('|');
                                    let start = parseInt(strs[1]);
                                    let len = parseInt(strs[2]);
                                    let bufs = _buffer.slice(start, start + len);
                                    this.bundlePackBin[strs[0]] = bufs;
                                }
                                if (state != undefined)
                                    state.bundleLoadState |= loadstate;
                                realTotal--;
                                state.curtask++;
                                if (realTotal === 0) {
                                    state.isfinish = true;
                                    onstate(state);
                                    assetmgr.loadByMulQueue();
                                }
                                else {
                                    onstate(state);
                                    loadcall();
                                }
                            }, (loadedLength, totalLength) => {
                                state.compressBinLoaded = loadedLength;
                                onstate(state);
                            });
                        }
                        else {
                            assetmgr.loadSingleRes(surl, type, (s) => {
                                if (s.iserror) {
                                    onstate(state);
                                    assetmgr.loadByMulQueue();
                                    return;
                                }
                                if (s.progressCall) {
                                    s.progressCall = false;
                                    onstate(state);
                                    return;
                                }
                                if (state != undefined)
                                    state.bundleLoadState |= loadstate;
                                realTotal--;
                                state.curtask++;
                                if (realTotal === 0) {
                                    state.isfinish = true;
                                    onstate(state);
                                    assetmgr.loadByMulQueue();
                                }
                                else {
                                    onstate(state);
                                    loadcall();
                                }
                                assetmgr.doWaitState(this.url, state);
                            }, state, asset);
                        }
                    }
                };
                loadcall();
            }
        }
        framework.assetBundle = assetBundle;
        class assetMgr {
            constructor(app) {
                this.mapShader = {};
                this.mapDefaultMesh = {};
                this.mapDefaultTexture = {};
                this.mapDefaultCubeTexture = {};
                this.mapDefaultSprite = {};
                this.mapMaterial = {};
                this.mapBundle = {};
                this.mapRes = {};
                this.mapNamed = {};
                this._loadingTag = "_AssetLoingTag_";
                this.mapInLoad = {};
                this.assetUrlDic = {};
                this.assetFactorys = {};
                this.waitStateDic = {};
                this.waitQueueState = [];
                this.loadingQueueState = [];
                this.loadingCountLimit = 2;
                this.app = app;
                this.webgl = app.webgl;
                this.shaderPool = new gd3d.render.shaderPool();
                this.initAssetFactorys();
            }
            initDefAsset() {
                framework.defMesh.initDefaultMesh(this);
                framework.defTexture.initDefaultTexture(this);
                framework.defsprite.initDefaultSprite(this);
                framework.defShader.initDefaultShader(this);
                framework.defmaterial.initDefaultMaterial(this);
            }
            getShader(name) {
                return this.mapShader[name];
            }
            getDefaultMesh(name) {
                return this.mapDefaultMesh[name];
            }
            getDefaultTexture(name) {
                return this.mapDefaultTexture[name];
            }
            getDefaultCubeTexture(name) {
                return this.mapDefaultCubeTexture[name];
            }
            getDefaultSprite(name) {
                return this.mapDefaultSprite[name];
            }
            getMaterial(name) {
                return this.mapMaterial[name];
            }
            getAsset(id) {
                var r = this.mapRes[id];
                if (r == null)
                    return null;
                return r.asset;
            }
            getAssetByName(name, bundlename = null) {
                let id = null;
                if (this.mapNamed[name] != null) {
                    id = this.mapNamed[name][this.mapNamed[name].length - 1];
                }
                if (bundlename != null) {
                    let assetbundle = this.mapBundle[bundlename];
                    if (assetbundle != null)
                        id = assetbundle.mapNamed[name] || id;
                }
                let flag = true;
                if (id != null) {
                    var r = this.mapRes[id];
                    if (r != null && !r[this._loadingTag])
                        return r.asset;
                }
                if (flag) {
                    if (this.mapDefaultMesh[name] != undefined)
                        return this.mapDefaultMesh[name];
                    if (this.mapDefaultTexture[name] != undefined)
                        return this.mapDefaultTexture[name];
                    if (this.mapShader[name] != undefined)
                        return this.mapShader[name];
                }
            }
            getAssetBundle(bundlename) {
                if (this.mapBundle[bundlename])
                    return this.mapBundle[bundlename];
                return null;
            }
            unuse(res, disposeNow = false) {
                var id = res.getGUID();
                var name = res.getName();
                if (res.defaultAsset) {
                    return;
                }
                if (!this.mapRes[id])
                    return;
                this.mapRes[id].refcount--;
                if (disposeNow && this.mapRes[id].refcount <= 0) {
                    this.mapRes[id].asset.dispose();
                    if (name != null) {
                        if (this.mapNamed[name].length <= 1) {
                            delete this.mapNamed[name];
                        }
                        else {
                            for (let key in this.mapNamed[name]) {
                                if (id == this.mapNamed[name][key]) {
                                    this.mapNamed[name].splice(parseInt(key), 1);
                                }
                            }
                        }
                    }
                    delete this.mapRes[id];
                }
            }
            use(res) {
                var id = res.getGUID();
                var name = res.getName();
                if (id <= 0) {
                    throw new Error("不合法的res guid:" + name);
                }
                if (res.defaultAsset) {
                    return;
                }
                if (this.mapRes[id] == null) {
                    this.mapRes[id] = { asset: res, refcount: 0 };
                    if (name != null) {
                        if (this.mapNamed[name] == null)
                            this.mapNamed[name] = [];
                        this.mapNamed[name].push(id);
                    }
                }
                this.mapRes[id].refcount++;
                if (this.mapRes[id][this._loadingTag]) {
                    delete this.mapRes[id][this._loadingTag];
                }
            }
            regRes(name, asset) {
                let id = asset.getGUID();
                if (this.mapRes[id] == null) {
                    this.mapRes[id] = { asset: asset, refcount: 0 };
                    this.mapRes[id][this._loadingTag] = true;
                    if (name != null) {
                        if (this.mapNamed[name] == null)
                            this.mapNamed[name] = [];
                        this.mapNamed[name].push(id);
                    }
                }
            }
            releaseUnuseAsset() {
                for (let k in this.mapRes) {
                    if (this.mapRes[k].refcount <= 0) {
                        if (this.mapRes[k][this._loadingTag])
                            continue;
                        let name = this.mapRes[k].asset.getName();
                        if (this.mapNamed[name].length <= 1) {
                            delete this.mapNamed[name];
                        }
                        else {
                            for (let key in this.mapNamed[name]) {
                                if (this.mapRes[k].asset.getGUID() == this.mapNamed[name][key]) {
                                    this.mapNamed[name].splice(parseInt(key), 1);
                                }
                            }
                        }
                        this.mapRes[k].asset.dispose();
                        delete this.mapRes[k];
                    }
                }
            }
            getAssetsRefcount() {
                let mapRefcout = {};
                for (var k in this.mapNamed) {
                    if (this.mapNamed[k].length == 1) {
                        let res = this.mapRes[this.mapNamed[k][0]];
                        mapRefcout[k] = res.refcount;
                    }
                    else {
                        for (let key in this.mapNamed[k]) {
                            let res = this.mapRes[this.mapNamed[k][key]];
                            mapRefcout[k + "(" + key + ")"] = res.refcount;
                        }
                    }
                }
                return mapRefcout;
            }
            removeAssetBundle(name) {
                if (this.mapBundle[name] != null)
                    delete this.mapBundle[name];
                if (this.mapInLoad[name] != null)
                    delete this.mapInLoad[name];
            }
            setAssetUrl(asset, url) {
                this.assetUrlDic[asset.getGUID()] = url;
            }
            getAssetUrl(asset) {
                return this.assetUrlDic[asset.getGUID()];
            }
            loadResByPack(respack, url, type, onstate, state, asset) {
                let assetFactory = this.getAssetFactory(type);
                if (assetFactory != null) {
                    assetFactory.loadByPack(respack, url, onstate, state, this, asset);
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
            }
            regAssetFactory(type, factory) {
                this.assetFactorys[type.toString()] = factory;
            }
            getAssetFactory(type) {
                return this.assetFactorys[type];
            }
            initAssetFactorys() {
                this.regAssetFactory(AssetTypeEnum.GLVertexShader, new framework.AssetFactory_GLVertexShader());
                this.regAssetFactory(AssetTypeEnum.GLFragmentShader, new framework.AssetFactory_GLFragmentShader());
                this.regAssetFactory(AssetTypeEnum.Shader, new framework.AssetFactory_Shader());
                this.regAssetFactory(AssetTypeEnum.Texture, new framework.AssetFactory_Texture());
                this.regAssetFactory(AssetTypeEnum.TextureDesc, new framework.AssetFactory_TextureDesc());
                this.regAssetFactory(AssetTypeEnum.Mesh, new framework.AssetFactory_Mesh());
                this.regAssetFactory(AssetTypeEnum.Prefab, new framework.AssetFactory_Prefab());
                this.regAssetFactory(AssetTypeEnum.Material, new framework.AssetFactory_Material());
                this.regAssetFactory(AssetTypeEnum.Aniclip, new framework.AssetFactory_Aniclip());
                this.regAssetFactory(AssetTypeEnum.Scene, new framework.AssetFactory_Scene());
                this.regAssetFactory(AssetTypeEnum.Atlas, new framework.AssetFactory_Atlas());
                this.regAssetFactory(AssetTypeEnum.Font, new framework.AssetFactory_Font());
                this.regAssetFactory(AssetTypeEnum.TextAsset, new framework.AssetFactory_TextAsset());
                this.regAssetFactory(AssetTypeEnum.PathAsset, new framework.AssetFactory_PathAsset());
                this.regAssetFactory(AssetTypeEnum.PVR, new framework.AssetFactory_PVR());
                this.regAssetFactory(AssetTypeEnum.F14Effect, new framework.AssetFactory_f14eff());
                this.regAssetFactory(AssetTypeEnum.DDS, new framework.AssetFactory_DDS());
                this.regAssetFactory(AssetTypeEnum.KeyFrameAniclip, new framework.assetfactory_keyFrameAniClip());
            }
            loadSingleRes(url, type, onstate, state, asset) {
                if (url.indexOf("glsl") == -1 && url.indexOf(".shader.json") == -1) {
                }
                let assetFactory = this.getAssetFactory(type);
                if (assetFactory != null) {
                    assetFactory.load(url, onstate, state, this, asset);
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
            }
            doWaitState(name, state) {
                if (this.waitStateDic[name] == null)
                    return;
                for (var key in this.waitStateDic[name]) {
                    this.waitStateDic[name][key](state);
                }
                if (state.isfinish) {
                    this.waitStateDic[name].length = 0;
                }
            }
            checkFreeChannel() {
                let freechannel = -1;
                for (let k = 0; k < this.loadingQueueState.length; k++) {
                    if (this.loadingQueueState[k] == undefined) {
                        freechannel = k;
                        break;
                    }
                    else if (!this.loadingQueueState[k].state.isfinish && !this.loadingQueueState[k].state.iserror) {
                        continue;
                    }
                    else {
                        delete this.loadingQueueState[k];
                        freechannel = k;
                        break;
                    }
                }
                if (freechannel == -1 && this.loadingQueueState.length < this.loadingCountLimit) {
                    freechannel = this.loadingQueueState.length;
                }
                return freechannel;
            }
            loadByMulQueue() {
                if (this.waitQueueState.length == 0)
                    return;
                let freechannel = this.checkFreeChannel();
                if (freechannel == -1)
                    return;
                let curloadinfo = this.waitQueueState.shift();
                this.loadingQueueState[freechannel] = curloadinfo;
                let state = curloadinfo.state;
                let url = state.url;
                let type = curloadinfo.type;
                let onstate = curloadinfo.onstate;
                if (type == AssetTypeEnum.Bundle) {
                    gd3d.io.loadText(url, (txt, err) => {
                        if (err != null) {
                            curloadinfo.state.iserror = true;
                            curloadinfo.state.errs.push(new Error(err.message));
                            onstate(state);
                            return;
                        }
                        let json = JSON.parse(txt);
                        let filename = "";
                        if (json["files"]) {
                            filename = this.getFileName(url);
                            var ab = new assetBundle(url);
                            ab.name = filename;
                            ab.parse(JSON.parse(txt));
                            ab.load(this, onstate, state);
                        }
                        else {
                            let loadurl = url.replace(".assetbundle.json", ".packs.txt");
                            filename = this.getFileName(url);
                            var ab = new assetBundle(url);
                            ab.name = filename;
                            ab.totalLength = json["totalLength"];
                            ab.loadCompressBundle(loadurl, onstate, state, this);
                        }
                        this.mapBundle[filename] = ab;
                    });
                }
                else if (type == AssetTypeEnum.CompressBundle) {
                    gd3d.io.loadText(url, (txt, err) => {
                        if (err != null) {
                            curloadinfo.state.iserror = true;
                            curloadinfo.state.errs.push(new Error(err.message));
                            onstate(state);
                            return;
                        }
                        let loadurl = url.replace(".assetbundle.json", ".packs.txt");
                        let filename = this.getFileName(url);
                        let json = JSON.parse(txt);
                        var ab = new assetBundle(url);
                        ab.name = filename;
                        ab.totalLength = json["totalLength"];
                        ab.loadCompressBundle(loadurl, onstate, state, this);
                    });
                }
                else {
                    state.totaltask = 1;
                    this.loadSingleRes(url, type, (s) => {
                        if (s.iserror) {
                            onstate(state);
                            this.loadByMulQueue();
                            return;
                        }
                        if (s.progressCall) {
                            s.progressCall = false;
                            onstate(state);
                            return;
                        }
                        state.curtask = 1;
                        s.isfinish = true;
                        onstate(s);
                        this.doWaitState(url, s);
                        this.loadByMulQueue();
                    }, state);
                }
            }
            loadCompressBundle(url, onstate = null) {
                let name = this.getFileName(url);
                let type = this.calcType(url);
                var state = new stateLoad();
                this.mapInLoad[name] = state;
                state.url = url;
                if (type != AssetTypeEnum.Bundle) {
                    state.errs.push(new Error("is not bundle compress type:" + url));
                    state.iserror = true;
                    onstate(state);
                    this.doWaitState(url, state);
                    return;
                }
                type = AssetTypeEnum.CompressBundle;
                this.waitQueueState.push({ state, type, onstate });
                this.loadByMulQueue();
            }
            load(url, type = AssetTypeEnum.Auto, onstate = null) {
                if (onstate == null)
                    onstate = () => { };
                let name = this.getFileName(url);
                if (this.mapInLoad[name] != null) {
                    let _state = this.mapInLoad[name];
                    if (_state.isfinish) {
                        onstate(this.mapInLoad[name]);
                    }
                    else {
                        if (this.waitStateDic[name] == null)
                            this.waitStateDic[name] = [];
                        this.waitStateDic[name].push(onstate);
                    }
                    return;
                }
                var state = new stateLoad();
                this.mapInLoad[name] = state;
                state.url = url;
                if (type == AssetTypeEnum.Auto) {
                    type = this.calcType(url);
                }
                if (type == AssetTypeEnum.Unknown) {
                    state.errs.push(new Error("can not sure about type:" + url));
                    state.iserror = true;
                    onstate(state);
                    this.doWaitState(url, state);
                    return;
                }
                this.waitQueueState.push({ state, type, onstate });
                this.loadByMulQueue();
            }
            unload(url, onstate = null) {
                let name = this.getFileName(url);
                if (this.mapInLoad[name] == null)
                    return;
                let state = this.mapInLoad[name];
                for (let key in state.resstate) {
                    state.resstate[key].res.unuse();
                }
                delete this.mapInLoad[name];
            }
            loadScene(sceneName, onComplete) {
                let firstChilds = new Array();
                let scene = this.app.getScene();
                if (sceneName.length > 0) {
                    var _rawscene = this.getAssetByName(sceneName);
                    let willLoadRoot = _rawscene.getSceneRoot();
                    while (willLoadRoot.children.length > 0) {
                        let trans = willLoadRoot.children.shift();
                        firstChilds.push(trans);
                        scene.addChild(trans);
                    }
                    scene["_overlay2d"] = new Array();
                    _rawscene.useLightMap(scene);
                    _rawscene.useFog(scene);
                    _rawscene.useNavMesh(scene);
                }
                else {
                    var _camera = new framework.transform();
                    _camera.gameObject.addComponent("camera");
                    _camera.name = "camera";
                    firstChilds.push(_camera);
                    scene.addChild(_camera);
                }
                scene.name = sceneName;
                scene.getRoot().markDirty();
                onComplete(firstChilds);
            }
            saveScene(fun) {
                gd3d.io.SerializeDependent.resourseDatas = [];
                let info = new SaveInfo();
                let _scene = {};
                let scene = this.app.getScene();
                let _rootNode = gd3d.io.serializeObj(scene.getRoot(), null, this);
                let _lightmaps = [];
                let lightmaps = scene.lightmaps;
                for (var str in lightmaps) {
                    let _lightmap = {};
                    _lightmap["name"] = lightmaps[str].getName();
                    _lightmaps.push(_lightmap);
                    let lightMapUrl = this.getAssetUrl(lightmaps[str]);
                    gd3d.io.SerializeDependent.resourseDatas.push({ "url": lightMapUrl, "type": gd3d.io.SaveAssetType.FullUrl });
                }
                let navstr = framework.NavMeshLoadManager.Instance.navmeshJson;
                navstr = navstr == null ? "" : navstr;
                let navmeshJson = { data: navstr };
                _scene["rootNode"] = _rootNode;
                _scene["lightmap"] = _lightmaps;
                _scene["fog"] = scene.fog;
                _scene["navmesh"] = navmeshJson;
                let _sceneStr = JSON.stringify(_scene);
                var _rawscene = this.getAssetByName(scene.name);
                _rawscene.Parse(_sceneStr, this);
                let url = this.getAssetUrl(_rawscene);
                info.files[url] = _sceneStr;
                fun(info, gd3d.io.SerializeDependent.resourseDatas);
            }
            savePrefab(trans, prefabName, fun) {
                gd3d.io.SerializeDependent.resourseDatas = [];
                let info = new SaveInfo();
                var _prefab = this.getAssetByName(prefabName);
                _prefab.apply(trans);
                let _rootTrans = gd3d.io.serializeObj(trans, null, this);
                let url = this.getAssetUrl(_prefab);
                info.files[url] = JSON.stringify(_rootTrans);
                fun(info, gd3d.io.SerializeDependent.resourseDatas);
            }
            saveMaterial(mat, fun) {
                let info = new SaveInfo();
                let data = {};
                let mapUniform = {};
                let shader = mat.getShader();
                let shaderPropertis = shader.defaultMapUniform;
                data["shader"] = shader.getName();
                data["mapUniform"] = mapUniform;
                let url = this.getAssetUrl(mat);
                info.files[url] = JSON.stringify(data);
                fun(info);
            }
            loadSingleResImmediate(url, type) {
                let result;
                let filename = this.getFileName(url);
                let name = filename.substring(0, filename.indexOf("."));
                if (type == AssetTypeEnum.GLVertexShader) {
                    gd3d.io.loadText(url, (txt, err) => {
                        this.shaderPool.compileVS(this.webgl, name, txt);
                    });
                }
                else if (type == AssetTypeEnum.GLFragmentShader) {
                    gd3d.io.loadText(url, (txt, err) => {
                        this.shaderPool.compileFS(this.webgl, name, txt);
                    });
                }
                else if (type == AssetTypeEnum.Shader) {
                    result = new framework.shader(filename);
                    gd3d.io.loadText(url, (txt, err) => {
                        result.parse(this, JSON.parse(txt));
                        this.mapShader[filename] = result;
                    });
                }
                else if (type == AssetTypeEnum.Texture) {
                    result = new framework.texture(filename);
                    var img = new Image();
                    img.src = url;
                    img.onload = () => {
                        var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                        result.glTexture = new gd3d.render.glTexture2D(this.webgl, _textureFormat);
                        result.glTexture.uploadImage(img, true, true, true, true);
                        this.use(result);
                    };
                }
                else if (type == AssetTypeEnum.Mesh) {
                    result = new framework.mesh(filename);
                    gd3d.io.loadArrayBuffer(url, (txt, err) => {
                        result.Parse(txt, this.webgl);
                        this.use(result);
                    });
                }
                else {
                    throw new Error("cant use the type:" + type);
                }
                this.regRes(filename, result);
                return result;
            }
            loadImmediate(url, type = AssetTypeEnum.Auto) {
                var result;
                if (type == AssetTypeEnum.Auto) {
                    type = this.calcType(url);
                }
                if (type == AssetTypeEnum.Unknown) {
                    throw new Error("unknown format");
                }
                else if (type == AssetTypeEnum.Bundle) {
                    result = new assetBundle(url);
                    gd3d.io.loadText(url, (txt, err) => {
                        result.parse(JSON.parse(txt));
                    });
                }
                else {
                    result = this.loadSingleResImmediate(url, type);
                }
                return result;
            }
            getFileName(url) {
                var filei = url.lastIndexOf("/");
                var file = url.substr(filei + 1);
                return file;
            }
            calcType(url) {
                var filei = url.lastIndexOf("/");
                var file = url.substr(filei + 1);
                var i = file.indexOf(".", 0);
                var extname = null;
                while (i >= 0) {
                    extname = file.substr(i);
                    if (extname == ".vs.glsl") {
                        return AssetTypeEnum.GLVertexShader;
                    }
                    else if (extname == ".assetbundle.json") {
                        return AssetTypeEnum.Bundle;
                    }
                    else if (extname == ".fs.glsl") {
                        return AssetTypeEnum.GLFragmentShader;
                    }
                    else if (extname == ".shader.json") {
                        return AssetTypeEnum.Shader;
                    }
                    else if (extname == ".png" || extname == ".jpg") {
                        return AssetTypeEnum.Texture;
                    }
                    else if (extname == ".pvr.bin" || extname == ".pvr") {
                        return AssetTypeEnum.PVR;
                    }
                    else if (extname == ".imgdesc.json") {
                        return AssetTypeEnum.TextureDesc;
                    }
                    else if (extname == ".mat.json") {
                        return AssetTypeEnum.Material;
                    }
                    else if (extname == ".mesh.bin") {
                        return AssetTypeEnum.Mesh;
                    }
                    else if (extname == ".aniclip.bin") {
                        return AssetTypeEnum.Aniclip;
                    }
                    else if (extname == ".prefab.json") {
                        return AssetTypeEnum.Prefab;
                    }
                    else if (extname == ".scene.json") {
                        return AssetTypeEnum.Scene;
                    }
                    else if (extname == ".atlas.json") {
                        return AssetTypeEnum.Atlas;
                    }
                    else if (extname == ".font.json") {
                        return AssetTypeEnum.Font;
                    }
                    else if (extname == ".json" || extname == ".txt" || extname == ".effect.json") {
                        return AssetTypeEnum.TextAsset;
                    }
                    else if (extname == ".packs.bin") {
                        return AssetTypeEnum.PackBin;
                    }
                    else if (extname == ".packs.txt") {
                        return AssetTypeEnum.PackTxt;
                    }
                    else if (extname == ".path.json") {
                        return AssetTypeEnum.PathAsset;
                    }
                    else if (extname == ".f14effect.json") {
                        return AssetTypeEnum.F14Effect;
                    }
                    else if (extname == ".dds" || extname == ".dds.bin") {
                        return AssetTypeEnum.DDS;
                    }
                    else if (extname == ".keyframeAniclip.json") {
                        return AssetTypeEnum.KeyFrameAniclip;
                    }
                    i = file.indexOf(".", i + 1);
                }
                return AssetTypeEnum.Unknown;
            }
            getDefParticleMat() {
                if (this.particlemat == null) {
                    var mat = new framework.material("defparticle");
                    var shader = this.getShader("particles_additive.shader.json");
                    if (shader == null) {
                        shader = this.getShader("shader/def");
                    }
                    mat.setShader(shader);
                    var tex = this.getDefaultTexture("grid");
                    mat.setTexture("_MainTex", tex);
                    this.particlemat = mat;
                }
                return this.particlemat;
            }
        }
        framework.assetMgr = assetMgr;
        class assetRef {
        }
        framework.assetRef = assetRef;
        class SaveInfo {
            constructor() {
                this.files = {};
            }
        }
        framework.SaveInfo = SaveInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
class PvrParse {
    constructor(gl) {
        this.version = 0x03525650;
        this.flags = 0;
        this.pixelFormatH = 0;
        this.pixelFormatL = 0;
        this.channelType = 0;
        this.height = 1;
        this.width = 1;
        this.depth = 1;
        this.numFaces = 1;
        this.mipMapCount = 1;
        this.metaDataSize = 0;
        this.gl = gl;
    }
    parse(_buffer) {
        let ar = new Uint8Array(_buffer);
        _buffer = null;
        var tool = new gd3d.io.binTool();
        tool.writeUint8Array(ar);
        this.version = tool.readUInt32();
        if (this.version === 0x03525650) {
            let tex = this.parseV3(tool);
            tool.dispose();
            return tex;
        }
        else if (this.version === 0x50565203) {
            console.error("v2");
        }
        else {
            console.error("pvr parse error!:" + this.version);
            return null;
        }
    }
    parseV3(tool) {
        this.flags = tool.readUInt32();
        if (this.flags == 0)
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
        else
            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
        this.pixelFormatH = tool.readUInt32();
        this.pixelFormatL = tool.readUInt32();
        tool.readBytes(4);
        this.channelType = tool.readUInt32();
        this.height = tool.readUInt32();
        this.width = tool.readUInt32();
        this.depth = tool.readUInt32();
        tool.readBytes(4);
        this.numFaces = tool.readUInt32();
        this.mipMapCount = tool.readUInt32();
        this.metaDataSize = tool.readUInt32();
        tool.readBytes(this.metaDataSize);
        let engineFormat;
        let textureFormat;
        let textureType;
        var t2d = new gd3d.render.glTexture2D(this.gl);
        switch (this.pixelFormatH) {
            case 0:
                textureFormat = t2d.ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                break;
            case 1:
                textureFormat = t2d.ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC2_RGBA;
                break;
            case 2:
                textureFormat = t2d.ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC4_RGB;
                break;
            case 3:
                textureFormat = t2d.ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                engineFormat = gd3d.render.TextureFormatEnum.PVRTC4_RGBA;
                break;
            default:
                textureFormat = this.gl.RGB;
                engineFormat = gd3d.render.TextureFormatEnum.RGB;
                console.log("unknow pixel format::" + this.pixelFormatH);
        }
        t2d.format = engineFormat;
        switch (this.channelType) {
            case ChannelTypes.UnsignedByteNorm:
                textureType = this.gl.UNSIGNED_BYTE;
                break;
            case ChannelTypes.UnsignedShortNorm:
                break;
        }
        var target = this.gl.TEXTURE_2D;
        if (this.numFaces > 1)
            target = this.gl.TEXTURE_CUBE_MAP;
        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, 0);
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(target, t2d.texture);
        if (this.numFaces > 1)
            target = this.gl.TEXTURE_CUBE_MAP_POSITIVE_X;
        function textureLevelSize(format, width, height) {
            switch (format) {
                case t2d.ext.COMPRESSED_RGB_S3TC_DXT1_EXT:
                case t2d.ext.COMPRESSED_RGB_ATC_WEBGL:
                case t2d.ext.COMPRESSED_RGB_ETC1_WEBGL:
                    return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;
                case t2d.ext.COMPRESSED_RGBA_S3TC_DXT3_EXT:
                case t2d.ext.COMPRESSED_RGBA_S3TC_DXT5_EXT:
                case t2d.ext.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:
                case t2d.ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:
                    return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;
                case t2d.ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
                case t2d.ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
                    return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);
                case t2d.ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
                case t2d.ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
                    return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);
                default:
                    return 0;
            }
        }
        var offset = 0;
        let _width = this.width;
        let _height = this.height;
        for (var i = 0; i < this.mipMapCount; ++i) {
            var levelSize = textureLevelSize(textureFormat, _width, _height);
            let data = tool.readBytes(levelSize);
            this.gl.compressedTexImage2D(this.gl.TEXTURE_2D, i, textureFormat, _width, _height, 0, data);
            _width = _width >> 1;
            if (_width < 1)
                _width = 1;
            _height = _height >> 1;
            if (_height < 1)
                _height = 1;
            offset += levelSize;
        }
        if (this.mipMapCount > 1) {
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_NEAREST);
        }
        else {
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        }
        return t2d;
    }
}
var ChannelTypes;
(function (ChannelTypes) {
    ChannelTypes[ChannelTypes["UnsignedByteNorm"] = 0] = "UnsignedByteNorm";
    ChannelTypes[ChannelTypes["SignedByteNorm"] = 1] = "SignedByteNorm";
    ChannelTypes[ChannelTypes["UnsignedByte"] = 2] = "UnsignedByte";
    ChannelTypes[ChannelTypes["SignedByte"] = 3] = "SignedByte";
    ChannelTypes[ChannelTypes["UnsignedShortNorm"] = 4] = "UnsignedShortNorm";
    ChannelTypes[ChannelTypes["SignedShortNorm"] = 5] = "SignedShortNorm";
    ChannelTypes[ChannelTypes["UnsignedShort"] = 6] = "UnsignedShort";
    ChannelTypes[ChannelTypes["SignedShort"] = 7] = "SignedShort";
    ChannelTypes[ChannelTypes["UnsignedIntegerNorm"] = 8] = "UnsignedIntegerNorm";
    ChannelTypes[ChannelTypes["SignedIntegerNorm"] = 9] = "SignedIntegerNorm";
    ChannelTypes[ChannelTypes["UnsignedInteger"] = 10] = "UnsignedInteger";
    ChannelTypes[ChannelTypes["SignedInteger"] = 11] = "SignedInteger";
    ChannelTypes[ChannelTypes["SignedFloat"] = 12] = "SignedFloat";
    ChannelTypes[ChannelTypes["Float"] = 12] = "Float";
    ChannelTypes[ChannelTypes["UnsignedFloat"] = 13] = "UnsignedFloat";
})(ChannelTypes || (ChannelTypes = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class defmaterial {
            static initDefaultMaterial(assetmgr) {
                {
                    let mat = new framework.material();
                    let sh = assetmgr.getShader("shader/defui");
                    mat.setShader(sh);
                    assetmgr.mapMaterial[sh.getName()] = mat;
                }
            }
        }
        framework.defmaterial = defmaterial;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class defMesh {
            static initDefaultMesh(assetmgr) {
                assetmgr.mapDefaultMesh["cube"] = defMesh.createDefaultMesh("cube", gd3d.render.meshData.genBoxCCW(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["quad"] = defMesh.createDefaultMesh("circleline", gd3d.render.meshData.genQuad(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["quad_particle"] = defMesh.createDefaultMesh("quad_particle", gd3d.render.meshData.genQuad_forparticle(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh["plane"] = defMesh.createDefaultMesh("plane", gd3d.render.meshData.genPlaneCCW(10), assetmgr.webgl);
                assetmgr.mapDefaultMesh["sphere"] = defMesh.createDefaultMesh("sphere", gd3d.render.meshData.genSphereCCW(), assetmgr.webgl);
                assetmgr.mapDefaultMesh["sphere_quality"] = defMesh.createDefaultMesh("sphere_quality", gd3d.render.meshData.genSphereCCW(2.58, 40, 40), assetmgr.webgl);
                assetmgr.mapDefaultMesh["pyramid"] = defMesh.createDefaultMesh("pyramid", gd3d.render.meshData.genPyramid(2, 0.5), assetmgr.webgl);
                assetmgr.mapDefaultMesh["cylinder"] = defMesh.createDefaultMesh("cylinder", gd3d.render.meshData.genCylinderCCW(2, 0.5), assetmgr.webgl);
                assetmgr.mapDefaultMesh["circleline"] = defMesh.createDefaultMesh("circleline", gd3d.render.meshData.genCircleLineCCW(1), assetmgr.webgl);
            }
            static createDefaultMesh(name, meshData, webgl) {
                var _mesh = new framework.mesh(name + ".mesh.bin");
                _mesh.defaultAsset = true;
                _mesh.data = meshData;
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                _mesh.data.originVF = vf;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArray();
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = false;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            }
        }
        framework.defMesh = defMesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class defShader {
            static initDefaultShader(assetmgr) {
                var pool = assetmgr.shaderPool;
                pool.compileVS(assetmgr.webgl, "def", defShader.vscode);
                pool.compileFS(assetmgr.webgl, "def", defShader.fscode);
                pool.compileFS(assetmgr.webgl, "def2", defShader.fscode2);
                pool.compileFS(assetmgr.webgl, "defui", defShader.fscodeui);
                pool.compileVS(assetmgr.webgl, "defuifont", defShader.vscodeuifont);
                pool.compileFS(assetmgr.webgl, "defuifont", defShader.fscodeuifont);
                pool.compileVS(assetmgr.webgl, "diffuse", defShader.vsdiffuse);
                pool.compileFS(assetmgr.webgl, "diffuse", defShader.fsdiffuse);
                pool.compileVS(assetmgr.webgl, "line", defShader.vsline);
                pool.compileFS(assetmgr.webgl, "line", defShader.fsline);
                pool.compileVS(assetmgr.webgl, "materialcolor", defShader.vsmaterialcolor);
                pool.compileVS(assetmgr.webgl, "defUIMaskVS", defShader.vsUiMaskCode);
                pool.compileFS(assetmgr.webgl, "defUIMaskFS", defShader.fscodeMaskUi);
                pool.compileVS(assetmgr.webgl, "defuifontMaskVS", defShader.vscodeuifontmask);
                pool.compileFS(assetmgr.webgl, "defuifontMaskFS", defShader.fscodeuifontmask);
                var program = pool.linkProgram(assetmgr.webgl, "def", "def");
                var program2 = pool.linkProgram(assetmgr.webgl, "def", "defui");
                var programuifont = pool.linkProgram(assetmgr.webgl, "defuifont", "defuifont");
                var programdiffuse = pool.linkProgram(assetmgr.webgl, "diffuse", "diffuse");
                var programline = pool.linkProgram(assetmgr.webgl, "line", "line");
                var programmaterialcolor = pool.linkProgram(assetmgr.webgl, "materialcolor", "line");
                var programMaskUI = pool.linkProgram(assetmgr.webgl, "defUIMaskVS", "defUIMaskFS");
                var programMaskfont = pool.linkProgram(assetmgr.webgl, "defuifontMaskVS", "defuifontMaskFS");
                {
                    var sh = new framework.shader("shader/def");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(program);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = true;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/def3dbeforeui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(programdiffuse);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = false;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/def2");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(program2);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(program2);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend_PreMultiply);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defuifont");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    p.setProgram(programuifont);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend_PreMultiply);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/line");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(programline);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = true;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/materialcolor");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(programmaterialcolor);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = false;
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend);
                    sh.layer = framework.RenderLayerEnum.Overlay;
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defmaskui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.uishader).properties);
                    p.setProgram(programMaskUI);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend_PreMultiply);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defmaskfont");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new gd3d.render.glDrawPass();
                    sh.passes["base"].push(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.shaderuifront).properties);
                    p.setProgram(programMaskfont);
                    sh.fillUnDefUniform(p);
                    p.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                    p.setAlphaBlend(gd3d.render.BlendModeEnum.Blend_PreMultiply);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
            }
        }
        defShader.shader0 = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\"\
            ]\
          }";
        defShader.vscode = "\
        attribute vec4 _glesVertex;   \
        attribute vec4 _glesColor;                  \
        attribute vec4 _glesMultiTexCoord0;         \
        uniform highp mat4 glstate_matrix_mvp;      \
        varying lowp vec4 xlv_COLOR;                \
        varying highp vec2 xlv_TEXCOORD0;           \
        void main()                                     \
        {                                               \
            highp vec4 tmpvar_1;                        \
            tmpvar_1.w = 1.0;                           \
            tmpvar_1.xyz = _glesVertex.xyz;             \
            xlv_COLOR = _glesColor;                     \
            xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;     \
            gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
        }";
        defShader.vsUiMaskCode = "\
        attribute vec4 _glesVertex;   \
        attribute vec4 _glesColor;                  \
        attribute vec4 _glesMultiTexCoord0;         \
        uniform highp mat4 glstate_matrix_mvp;      \
        uniform lowp float MaskState;      \
        varying lowp vec4 xlv_COLOR;                \
        varying highp vec2 xlv_TEXCOORD0;           \
        varying highp vec2 mask_TEXCOORD;           \
        void main()                                     \
        {                                               \
            highp vec4 tmpvar_1;                        \
            tmpvar_1.w = 1.0;                           \
            tmpvar_1.xyz = _glesVertex.xyz;             \
            xlv_COLOR = _glesColor;                     \
            xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);     \
            if(MaskState != 0.0){    \
                mask_TEXCOORD.x = (_glesVertex.x - 1.0)/-2.0;\
                mask_TEXCOORD.y = (_glesVertex.y - 1.0)/-2.0;\
            }\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
        }";
        defShader.fscodeMaskUi = "         \
        uniform sampler2D _MainTex;                                                 \
        uniform highp vec4 _maskRect;                                                 \
        uniform lowp float MaskState;      \
        varying lowp vec4 xlv_COLOR;                                                 \
        varying highp vec2 xlv_TEXCOORD0;   \
        varying highp vec2 mask_TEXCOORD;           \
        bool CalcuCut(){   \
            highp float l;\
            highp float t;\
            highp float r;\
            highp float b;\
            highp vec2 texc1;\
            bool beCut;\
            l = _maskRect.x;\
            t = _maskRect.y;\
            r = _maskRect.z + l;\
            b = _maskRect.w + t;\
            texc1 = mask_TEXCOORD;\
            if(texc1.x >(1.0 - l) || texc1.x <(1.0 - r) || texc1.y <t || texc1.y>b){ \
                beCut = true; \
            }else{\
                beCut = false;\
            }\
            return beCut;\
        }\
           \
        void main() \
        {\
            if(MaskState != 0.0 && CalcuCut()) discard;\
            lowp vec4 tmpvar_3;\
            tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\
            gl_FragData[0] = tmpvar_3 ;\
        }\
        ";
        defShader.fscode = "         \
        uniform sampler2D _MainTex;                                                 \
        varying lowp vec4 xlv_COLOR;                                                 \
        varying highp vec2 xlv_TEXCOORD0;   \
        void main() \
        {\
            lowp vec4 col_1;    \
            mediump vec4 prev_2;\
            lowp vec4 tmpvar_3;\
            tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\
            prev_2 = tmpvar_3;\
            mediump vec4 tmpvar_4;\
            tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\
            col_1 = tmpvar_4;\
            col_1.x =xlv_TEXCOORD0.x;\
            col_1.y =xlv_TEXCOORD0.y;\
            gl_FragData[0] = col_1;\
        }\
        ";
        defShader.fscode2 = "         \
        void main() \
        {\
            gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);\
        }\
        ";
        defShader.uishader = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\",\
              \"_MaskTex('MaskTex',Texture)='white'{}\"\
            ]\
            }";
        defShader.fscodeui = "         \
        uniform sampler2D _MainTex;                                                 \
        varying lowp vec4 xlv_COLOR;                                                 \
        varying highp vec2 xlv_TEXCOORD0;   \
        void main() \
        {\
            lowp vec4 tmpvar_3;\
            tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\
            gl_FragData[0] = tmpvar_3;\
        }\
        ";
        defShader.shaderuifront = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\"\
            ]\
            }";
        defShader.vscodeuifont = "\
        attribute vec4 _glesVertex;   \
        attribute vec4 _glesColor;                  \
        attribute vec4 _glesColorEx;                  \
        attribute vec4 _glesMultiTexCoord0;         \
        uniform highp mat4 glstate_matrix_mvp;      \
        varying lowp vec4 xlv_COLOR;                \
        varying lowp vec4 xlv_COLOREx;                                                 \
        varying highp vec2 xlv_TEXCOORD0;           \
        void main()                                     \
        {                                               \
            highp vec4 tmpvar_1;                        \
            tmpvar_1.w = 1.0;                           \
            tmpvar_1.xyz = _glesVertex.xyz;             \
            xlv_COLOR = _glesColor;                     \
            xlv_COLOREx = _glesColorEx;                     \
            xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);     \
            gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
        }";
        defShader.fscodeuifont = "\
        precision mediump float ;\
        uniform sampler2D _MainTex;\
        varying lowp vec4 xlv_COLOR;\
        varying lowp vec4 xlv_COLOREx;\
        varying highp vec2 xlv_TEXCOORD0;    \
        void main()  \
        { \
            float scale = 10.0;   \
            float d = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.5)*scale;   \
        float bd = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.34)*scale;   \
        \
        float c=xlv_COLOR.a * clamp ( d,0.0,1.0);  \
        float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0);  \
        bc =min(1.0-c,bc); \
        \
        \
        \
        gl_FragData[0] =xlv_COLOR*c + xlv_COLOREx*bc; \
    }";
        defShader.vscodeuifontmask = "\
        attribute vec4 _glesVertex;   \
        attribute vec4 _glesColor;                  \
        attribute vec4 _glesColorEx;                  \
        attribute vec4 _glesMultiTexCoord0;         \
        uniform highp mat4 glstate_matrix_mvp;      \
        uniform lowp float MaskState;      \
        varying lowp vec4 xlv_COLOR;                \
        varying lowp vec4 xlv_COLOREx;                                                 \
        varying highp vec2 xlv_TEXCOORD0;           \
        varying highp vec2 mask_TEXCOORD;           \
        void main()                                     \
        {                                               \
            highp vec4 tmpvar_1;                        \
            tmpvar_1.w = 1.0;                           \
            tmpvar_1.xyz = _glesVertex.xyz;             \
            xlv_COLOR = _glesColor;                     \
            xlv_COLOREx = _glesColorEx;                     \
            xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);     \
            if(MaskState != 0.0){    \
                mask_TEXCOORD.x = (_glesVertex.x - 1.0)/-2.0;\
                mask_TEXCOORD.y = (_glesVertex.y - 1.0)/-2.0;\
            }\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);  \
        }";
        defShader.fscodeuifontmask = "\
        precision mediump float;\
            uniform sampler2D _MainTex;  \
            uniform lowp float MaskState;      \
            uniform highp vec4 _maskRect;       \
            varying lowp vec4 xlv_COLOR; \
            varying lowp vec4 xlv_COLOREx; \
            varying highp vec2 xlv_TEXCOORD0;    \
            varying highp vec2 mask_TEXCOORD;     \
            bool CalcuCut(){   \
                highp float l;\
                highp float t;\
                highp float r;\
                highp float b;\
                highp vec2 texc1;\
                bool beCut;\
                l = _maskRect.x;\
                t = _maskRect.y;\
                r = _maskRect.z + l;\
                b = _maskRect.w + t;\
                texc1 = mask_TEXCOORD;\
                if(texc1.x >(1.0 - l) || texc1.x <(1.0 - r) || texc1.y <t || texc1.y>b){ \
                    beCut = true; \
                }else{\
                    beCut = false;\
                }\
                return beCut;\
            }\
            \
            void main()  \
            { \
                if(MaskState != 0.0 && CalcuCut())  discard;\
            float scale = 10.0;   \
            float d = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.5)*scale;  \
            float bd = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.34)*scale;  \
            \
            float c=xlv_COLOR.a * clamp ( d,0.0,1.0);  \
            float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0);  \
            bc =min(1.0-c,bc); \
            lowp vec4 final =  xlv_COLOR*c + xlv_COLOREx*bc ;\
            gl_FragData[0] = final ;\
            }";
        defShader.diffuseShader = "{\
            \"properties\": [\
              \"_MainTex('MainTex',Texture)='white'{}\",\
              \"_AlphaCut('AlphaCut',Range(0.0,1.0)) = 0.5\"\
            ]\
            }";
        defShader.vsdiffuse = "\
        attribute vec4 _glesVertex;\
        attribute vec4 _glesMultiTexCoord0;\
        uniform highp mat4 glstate_matrix_mvp;\
        varying highp vec2 xlv_TEXCOORD0;\
        void main()\
        {\
            highp vec4 tmpvar_1;\
            tmpvar_1.w = 1.0;\
            tmpvar_1.xyz = _glesVertex.xyz;\
            xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);\
        }";
        defShader.fsdiffuse = "\
        uniform sampler2D _MainTex;\
        uniform lowp float _AlphaCut;\
        varying highp vec2 xlv_TEXCOORD0;\
        void main() \
        {\
            lowp vec4 tmpvar_3 = texture2D(_MainTex, xlv_TEXCOORD0);\
            if(tmpvar_3.a < _AlphaCut)\
                discard;\
            gl_FragData[0] = tmpvar_3;\
        }";
        defShader.vsline = "\
        attribute vec4 _glesVertex;\
        attribute vec4 _glesColor;\
        uniform highp mat4 glstate_matrix_mvp;\
        varying lowp vec4 xlv_COLOR;\
        void main()\
        {\
            highp vec4 tmpvar_1;\
            tmpvar_1.w = 1.0;\
            tmpvar_1.xyz = _glesVertex.xyz;\
            xlv_COLOR = _glesColor;\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);\
        }";
        defShader.fsline = "\
        varying lowp vec4 xlv_COLOR;\
        void main()\
        {\
            gl_FragData[0] = xlv_COLOR;\
        }";
        defShader.materialShader = "{\
            \"properties\": [\
              \"_Color('Color',Vector) = (1,1,1,1)\",\
              \"_Alpha('Alpha', Range(0.0, 1.0)) = 1.0\"\
            ]\
            }";
        defShader.vsmaterialcolor = "\
        attribute vec4 _glesVertex;\
        uniform vec4 _Color;\
        uniform float _Alpha;\
        uniform highp mat4 glstate_matrix_mvp;\
        varying lowp vec4 xlv_COLOR;\
        void main()\
        {\
            highp vec4 tmpvar_1;\
            tmpvar_1.w = 1.0;\
            tmpvar_1.xyz = _glesVertex.xyz;\
            xlv_COLOR = _Color;\
            xlv_COLOR.a = xlv_COLOR.a * _Alpha;\
            gl_Position = (glstate_matrix_mvp * tmpvar_1);\
        }";
        framework.defShader = defShader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class defsprite {
            static initDefaultSprite(assetmgr) {
                let spt_white = new framework.sprite("white_sprite");
                spt_white.texture = assetmgr.getDefaultTexture("white");
                spt_white.defaultAsset = true;
                spt_white.rect = new gd3d.math.rect(0, 0, spt_white.texture.glTexture.width, spt_white.texture.glTexture.height);
                assetmgr.mapDefaultSprite["white_sprite"] = spt_white;
                let spt_gray = new framework.sprite("gray_sprite");
                spt_gray.texture = assetmgr.getDefaultTexture("gray");
                spt_gray.defaultAsset = true;
                spt_gray.rect = new gd3d.math.rect(0, 0, spt_gray.texture.glTexture.width, spt_gray.texture.glTexture.height);
                assetmgr.mapDefaultSprite["gray_sprite"] = spt_gray;
                let spt_grid = new framework.sprite("grid_sprite");
                spt_grid.texture = assetmgr.getDefaultTexture("grid");
                spt_grid.defaultAsset = true;
                spt_grid.rect = new gd3d.math.rect(0, 0, spt_grid.texture.glTexture.width, spt_grid.texture.glTexture.height);
                assetmgr.mapDefaultSprite["grid_sprite"] = spt_grid;
            }
        }
        framework.defsprite = defsprite;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class defTexture {
            static initDefaultTexture(assetmgr) {
                var t = new framework.texture("white");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "white");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["white"] = t;
                var t = new framework.texture("gray");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "gray");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["gray"] = t;
                var t = new framework.texture("normal");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "normal");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["normal"] = t;
                var t = new framework.texture("grid");
                t.glTexture = gd3d.render.glTexture2D.staticTexture(assetmgr.webgl, "grid");
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture["grid"] = t;
                defTexture.initDefaultCubeTexture(assetmgr);
            }
            static initDefaultCubeTexture(assetmgr) {
                let whiteTex = assetmgr.mapDefaultTexture["white"];
                var t = new framework.texture("white");
                t.glTexture = new gd3d.render.glTextureCube(assetmgr.app.webgl);
                t.glTexture.uploadImages(whiteTex, whiteTex, whiteTex, whiteTex, whiteTex, whiteTex);
                t.defaultAsset = true;
                assetmgr.mapDefaultCubeTexture["white"] = t;
            }
        }
        framework.defTexture = defTexture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_Aniclip {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadArrayBuffer(url, (_buffer, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _clip = asset ? asset : new framework.animationClip(filename);
                    _clip.Parse(_buffer);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                let _buffer = respack[filename];
                let _clip = asset ? asset : new framework.animationClip(filename);
                _clip.Parse(_buffer);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
            }
        }
        framework.AssetFactory_Aniclip = AssetFactory_Aniclip;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_Atlas {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _atlas = asset ? asset : new framework.atlas(filename);
                    _atlas.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _atlas, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                let txt = respack[filename];
                let _atlas = asset ? asset : new framework.atlas(filename);
                _atlas.Parse(txt, assetMgr);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _atlas, url);
            }
        }
        framework.AssetFactory_Atlas = AssetFactory_Atlas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_DDS {
            newAsset() {
                return null;
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadArrayBuffer(url, (_buffer, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _texture = asset ? asset : new framework.texture(filename);
                    assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                    let textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
                    textureUtil.loadDDS(url, null, (texture, error, stats) => {
                        let t2d = new gd3d.render.glTexture2D(assetMgr.webgl);
                        t2d.format = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                        t2d.texture = texture;
                        _texture.glTexture = t2d;
                    });
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
        }
        framework.AssetFactory_DDS = AssetFactory_DDS;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_f14eff {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let bundlename = framework.getFileName(state.url);
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _f14eff = asset ? asset : new framework.f14eff(filename);
                    _f14eff.assetbundle = bundlename;
                    _f14eff.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _f14eff, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let bundlename = framework.getFileName(state.url);
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                let txt = respack[filename];
                let _f14eff = asset ? asset : new framework.f14eff(filename);
                _f14eff.assetbundle = bundlename;
                _f14eff.Parse(txt, assetMgr);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _f14eff, url);
            }
        }
        framework.AssetFactory_f14eff = AssetFactory_f14eff;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_Font {
            newAsset(filename) {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _font = asset ? asset : new framework.font(filename);
                    _font.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _font, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                let txt = respack[filename];
                let _font = asset ? asset : new framework.font(filename);
                _font.Parse(txt, assetMgr);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _font, url);
            }
        }
        framework.AssetFactory_Font = AssetFactory_Font;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_GLFragmentShader {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                let name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    state.resstate[filename].state = 1;
                    state.logs.push("load a glshader:" + filename);
                    assetMgr.shaderPool.mapFSString[name] = txt;
                    onstate(state);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                let name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                let txt = respack[filename];
                txt = decodeURI(txt);
                state.resstate[filename].state = 1;
                state.logs.push("load a glshader:" + filename);
                assetMgr.shaderPool.mapFSString[name] = txt;
                onstate(state);
            }
        }
        framework.AssetFactory_GLFragmentShader = AssetFactory_GLFragmentShader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_GLVertexShader {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                let name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    state.resstate[filename].state = 1;
                    state.logs.push("load a glshader:" + filename);
                    assetMgr.shaderPool.mapVSString[name] = txt;
                    onstate(state);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                let name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                let txt = respack[filename];
                txt = decodeURI(txt);
                state.resstate[filename].state = 1;
                state.logs.push("load a glshader:" + filename);
                assetMgr.shaderPool.mapVSString[name] = txt;
                onstate(state);
            }
        }
        framework.AssetFactory_GLVertexShader = AssetFactory_GLVertexShader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactoryTools {
            static catchError(err, onstate, state) {
                if (err != null) {
                    state.iserror = true;
                    state.errs.push(new Error(err.message));
                    onstate(state);
                    return true;
                }
                return false;
            }
            static useAsset(assetMgr, onstate, state, asset, url) {
                let fileName = getFileName(url);
                assetMgr.setAssetUrl(asset, url);
                assetMgr.use(asset);
                state.resstate[fileName].state = 1;
                state.resstate[fileName].res = asset;
                onstate(state);
            }
            static onProgress(loadedLength, totalLength, onstate, state, filename) {
                state.resstate[filename].loadedLength = loadedLength;
                state.progressCall = true;
                onstate(state);
            }
            static onRefProgress(loadedLength, totalLength, onstate, state, filename) {
                let _restate = state.resstate[filename];
                _restate.refLoadedLength = loadedLength;
                state.progressCall = true;
                onstate(state);
            }
        }
        framework.AssetFactoryTools = AssetFactoryTools;
        function getFileName(url) {
            var filei = url.lastIndexOf("/");
            var file = url.substr(filei + 1);
            return file;
        }
        framework.getFileName = getFileName;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class assetfactory_keyFrameAniClip {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (text, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _clip = asset ? asset : new framework.keyFrameAniClip(filename);
                    _clip.Parse(text);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                let _buffer = respack[filename];
                let _clip = asset ? asset : new framework.keyFrameAniClip(filename);
                _clip.Parse(_buffer);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
            }
        }
        framework.assetfactory_keyFrameAniClip = assetfactory_keyFrameAniClip;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_Material {
            newAsset(filename) {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                let assetbundleName = framework.getFileName(state.url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _material = asset ? asset : new framework.material(filename);
                    _material.Parse(assetMgr, JSON.parse(txt), assetbundleName);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _material, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                let assetbundleName = framework.getFileName(state.url);
                state.resstate[filename] = new framework.ResourceState();
                let txt = respack[filename];
                let _material = asset ? asset : new framework.material(filename);
                _material.Parse(assetMgr, JSON.parse(txt), assetbundleName);
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _material, url);
            }
        }
        framework.AssetFactory_Material = AssetFactory_Material;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_Mesh {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadArrayBuffer(url, (_buffer, err) => __awaiter(this, void 0, void 0, function* () {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _mesh = asset ? asset : new framework.mesh(filename);
                    yield _mesh.Parse(_buffer, assetMgr.webgl);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
                }), (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                return __awaiter(this, void 0, void 0, function* () {
                    let filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    let _buffer = respack[filename];
                    let _mesh = asset ? asset : new framework.mesh(filename);
                    yield _mesh.Parse(_buffer, assetMgr.webgl);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
                });
            }
        }
        framework.AssetFactory_Mesh = AssetFactory_Mesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_PathAsset {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _path = asset ? asset : new framework.pathasset(filename);
                    _path.Parse(JSON.parse(txt));
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _path, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                let txt = respack[filename];
                let _path = asset ? asset : new framework.pathasset(filename);
                _path.Parse(JSON.parse(txt));
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _path, url);
            }
        }
        framework.AssetFactory_PathAsset = AssetFactory_PathAsset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_Prefab {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let bundlename = framework.getFileName(state.url);
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => __awaiter(this, void 0, void 0, function* () {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _prefab = asset ? asset : new framework.prefab(filename);
                    _prefab.assetbundle = bundlename;
                    yield _prefab.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
                }), (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                return __awaiter(this, void 0, void 0, function* () {
                    let bundlename = framework.getFileName(state.url);
                    let filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    let txt = respack[filename];
                    let _prefab = asset ? asset : new framework.prefab(filename);
                    _prefab.assetbundle = bundlename;
                    yield _prefab.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
                });
            }
        }
        framework.AssetFactory_Prefab = AssetFactory_Prefab;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_PVR {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadArrayBuffer(url, (_buffer, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _texture = asset ? asset : new framework.texture(filename);
                    let pvr = new PvrParse(assetMgr.webgl);
                    _texture.glTexture = pvr.parse(_buffer);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
            }
        }
        framework.AssetFactory_PVR = AssetFactory_PVR;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_Scene {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let bundlename = framework.getFileName(state.url);
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => __awaiter(this, void 0, void 0, function* () {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _scene = asset ? asset : new framework.rawscene(filename);
                    _scene.assetbundle = bundlename;
                    yield _scene.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _scene, url);
                }), (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                return __awaiter(this, void 0, void 0, function* () {
                    let bundlename = framework.getFileName(state.url);
                    let filename = framework.getFileName(url);
                    state.resstate[filename] = new framework.ResourceState();
                    let txt = respack[filename];
                    let _scene = asset ? asset : new framework.rawscene(filename);
                    _scene.assetbundle = bundlename;
                    yield _scene.Parse(txt, assetMgr);
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _scene, url);
                });
            }
        }
        framework.AssetFactory_Scene = AssetFactory_Scene;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_Shader {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _shader = new framework.shader(filename);
                    try {
                        _shader.parse(assetMgr, JSON.parse(txt));
                    }
                    catch (e) {
                        console.error("error  filename :" + filename);
                        throw new Error("shader on parse");
                    }
                    assetMgr.setAssetUrl(_shader, url);
                    assetMgr.mapShader[filename] = _shader;
                    state.resstate[filename].state = 1;
                    onstate(state);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                let name = filename.substring(0, filename.indexOf("."));
                state.resstate[filename] = new framework.ResourceState();
                let txt = respack[filename];
                state.resstate[filename].state = 1;
                var _shader = new framework.shader(filename);
                try {
                    _shader.parse(assetMgr, JSON.parse(txt));
                }
                catch (e) {
                    console.error("error  filename :" + filename);
                    throw new Error("shader on parse");
                }
                assetMgr.setAssetUrl(_shader, url);
                assetMgr.mapShader[filename] = _shader;
                onstate(state);
            }
        }
        framework.AssetFactory_Shader = AssetFactory_Shader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_TextAsset {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadText(url, (txt, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    let _textasset = asset ? asset : new framework.textasset(filename);
                    _textasset.content = txt;
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _textasset, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                let txt = respack[filename];
                let _textasset = asset ? asset : new framework.textasset(filename);
                _textasset.content = txt;
                framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _textasset, url);
            }
        }
        framework.AssetFactory_TextAsset = AssetFactory_TextAsset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_Texture {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.ResourceState();
                gd3d.io.loadImg(url, (_tex, _err) => {
                    if (framework.AssetFactoryTools.catchError(_err, onstate, state))
                        return;
                    let _texture = asset ? asset : new framework.texture(filename);
                    var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                    var t2d = new gd3d.render.glTexture2D(assetMgr.webgl, _textureFormat);
                    t2d.uploadImage(_tex, true, true, true, true);
                    _texture.glTexture = t2d;
                    framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
            }
        }
        framework.AssetFactory_Texture = AssetFactory_Texture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AssetFactory_TextureDesc {
            newAsset() {
                return null;
            }
            load(url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                state.resstate[filename] = new framework.RefResourceState();
                gd3d.io.loadText(url, (txt, err) => {
                    if (framework.AssetFactoryTools.catchError(err, onstate, state))
                        return;
                    var _texturedesc = JSON.parse(txt);
                    var _name = _texturedesc["name"];
                    var _filterMode = _texturedesc["filterMode"];
                    var _format = _texturedesc["format"];
                    var _mipmap = _texturedesc["mipmap"];
                    var _wrap = _texturedesc["wrap"];
                    var _premultiplyAlpha = _texturedesc["premultiplyAlpha"];
                    if (_premultiplyAlpha == undefined) {
                        _premultiplyAlpha = true;
                    }
                    var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                    if (_format == "RGB")
                        _textureFormat = gd3d.render.TextureFormatEnum.RGB;
                    else if (_format == "Gray")
                        _textureFormat = gd3d.render.TextureFormatEnum.Gray;
                    var _linear = true;
                    if (_filterMode.indexOf("linear") < 0)
                        _linear = false;
                    var _repeat = false;
                    if (_wrap.indexOf("Repeat") >= 0)
                        _repeat = true;
                    var _textureSrc = url.replace(filename, _name);
                    if (_textureSrc.indexOf(".pvr.bin") >= 0) {
                        gd3d.io.loadArrayBuffer(_textureSrc, (_buffer, err) => {
                            if (framework.AssetFactoryTools.catchError(err, onstate, state))
                                return;
                            let _texture = asset ? asset : new framework.texture(filename);
                            let pvr = new PvrParse(assetMgr.webgl);
                            _texture.glTexture = pvr.parse(_buffer);
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                        }, (loadedLength, totalLength) => {
                            framework.AssetFactoryTools.onRefProgress(loadedLength, totalLength, onstate, state, filename);
                        });
                    }
                    else if (_textureSrc.indexOf(".dds.bin") >= 0) {
                        gd3d.io.loadArrayBuffer(_textureSrc, (_buffer, err) => {
                            if (framework.AssetFactoryTools.catchError(err, onstate, state))
                                return;
                            let _texture = asset ? asset : new framework.texture(filename);
                            assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                            let textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
                            textureUtil.loadDDS(_textureSrc, null, (texture, error, stats) => {
                                let t2d = new gd3d.render.glTexture2D(assetMgr.webgl);
                                t2d.format = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                                t2d.texture = texture;
                                _texture.glTexture = t2d;
                            });
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                        }, (loadedLength, totalLength) => {
                            framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                        });
                    }
                    else {
                        gd3d.io.loadImg(_textureSrc, (_tex, _err) => {
                            if (framework.AssetFactoryTools.catchError(_err, onstate, state))
                                return;
                            let _texture = asset ? asset : new framework.texture(filename);
                            _texture.realName = _name;
                            var t2d = new gd3d.render.glTexture2D(assetMgr.webgl, _textureFormat);
                            t2d.uploadImage(_tex, _mipmap, _linear, _premultiplyAlpha, _repeat);
                            _texture.glTexture = t2d;
                            framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                        }, (loadedLength, totalLength) => {
                            framework.AssetFactoryTools.onRefProgress(loadedLength, totalLength, onstate, state, filename);
                        });
                    }
                }, (loadedLength, totalLength) => {
                    framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                });
            }
            loadByPack(respack, url, onstate, state, assetMgr, asset) {
                let filename = framework.getFileName(url);
                let txt = respack[filename];
                var _texturedesc = JSON.parse(txt);
                var _name = _texturedesc["name"];
                var _filterMode = _texturedesc["filterMode"];
                var _format = _texturedesc["format"];
                var _mipmap = _texturedesc["mipmap"];
                var _wrap = _texturedesc["wrap"];
                var _premultiplyAlpha = _texturedesc["premultiplyAlpha"];
                if (_premultiplyAlpha == undefined) {
                    _premultiplyAlpha = true;
                }
                var _textureFormat = gd3d.render.TextureFormatEnum.RGBA;
                if (_format == "RGB") {
                    _textureFormat = gd3d.render.TextureFormatEnum.RGB;
                }
                else if (_format == "Gray") {
                    _textureFormat = gd3d.render.TextureFormatEnum.Gray;
                }
                var _linear = true;
                if (_filterMode.indexOf("linear") < 0) {
                    _linear = false;
                }
                var _repeat = false;
                if (_wrap.indexOf("Repeat") >= 0) {
                    _repeat = true;
                }
                var _textureSrc = url.replace(filename, _name);
                state.resstate[filename] = new framework.ResourceState();
                if (_textureSrc.indexOf(".pvr.bin") >= 0) {
                    gd3d.io.loadArrayBuffer(_textureSrc, (_buffer, err) => {
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        let _texture = asset ? asset : new framework.texture(filename);
                        let pvr = new PvrParse(assetMgr.webgl);
                        console.log(_textureSrc);
                        _texture.glTexture = pvr.parse(_buffer);
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                    }, (loadedLength, totalLength) => {
                        framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    });
                }
                else if (_textureSrc.indexOf(".dds.bin") >= 0) {
                    gd3d.io.loadArrayBuffer(_textureSrc, (_buffer, err) => {
                        if (framework.AssetFactoryTools.catchError(err, onstate, state))
                            return;
                        let _texture = asset ? asset : new framework.texture(filename);
                        assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                        let textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
                        textureUtil.loadDDS(_textureSrc, null, (texture, error, stats) => {
                            let t2d = new gd3d.render.glTexture2D(assetMgr.webgl);
                            t2d.format = gd3d.render.TextureFormatEnum.PVRTC2_RGB;
                            t2d.texture = texture;
                            _texture.glTexture = t2d;
                        });
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                    }, (loadedLength, totalLength) => {
                        framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    });
                }
                else {
                    gd3d.io.loadImg(_textureSrc, (_tex, _err) => {
                        if (framework.AssetFactoryTools.catchError(_err, onstate, state))
                            return;
                        let _texture = asset ? asset : new framework.texture(filename);
                        _texture.realName = _name;
                        var t2d = new gd3d.render.glTexture2D(assetMgr.webgl, _textureFormat);
                        t2d.uploadImage(_tex, _mipmap, _linear, _premultiplyAlpha, _repeat);
                        _texture.glTexture = t2d;
                        framework.AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
                    }, (loadedLength, totalLength) => {
                        framework.AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    });
                }
            }
        }
        framework.AssetFactory_TextureDesc = AssetFactory_TextureDesc;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let animationClip = class animationClip {
            constructor(assetName = null) {
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.frames = {};
                if (!assetName) {
                    assetName = "animationClip_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            dispose() {
                this.bones.length = 0;
                this.subclips.length = 0;
                delete this.frames;
            }
            caclByteLength() {
                let total = 0;
                for (let k in this.bones) {
                    total += gd3d.math.caclStringByteLength(this.bones[k]);
                }
                for (let k in this.frames) {
                    total += this.frames[k].byteLength;
                    total += gd3d.math.caclStringByteLength(k);
                }
                total += subClip.caclByteLength() * this.subclips.length;
                return total;
            }
            Parse(buf) {
                var read = new gd3d.io.binReader(buf);
                var _name = read.readStringAnsi();
                this.fps = read.readFloat();
                this.loop = read.readBoolean();
                this.boneCount = read.readInt();
                this.bones = [];
                for (let i = 0; i < this.boneCount; i++) {
                    this.bones.push(read.readStringAnsi());
                }
                this.subclipCount = read.readInt();
                this.subclips = [];
                for (let i = 0; i < this.subclipCount; i++) {
                    let _subClip = new subClip();
                    _subClip.name = read.readStringAnsi();
                    _subClip.loop = read.readBoolean();
                    this.subclips.push(_subClip);
                }
                this.frameCount = read.readInt();
                this.frames = {};
                for (let i = 0; i < this.frameCount; i++) {
                    let _fid = read.readInt().toString();
                    let _key = read.readBoolean();
                    let _frame = new Float32Array(this.boneCount * 7 + 1);
                    _frame[0] = _key ? 1 : 0;
                    let _boneInfo = new PoseBoneMatrix();
                    for (let i = 0; i < this.boneCount; i++) {
                        _boneInfo.load(read);
                        _frame[i * 7 + 1] = _boneInfo.r.x;
                        _frame[i * 7 + 2] = _boneInfo.r.y;
                        _frame[i * 7 + 3] = _boneInfo.r.z;
                        _frame[i * 7 + 4] = _boneInfo.r.w;
                        _frame[i * 7 + 5] = _boneInfo.t.x;
                        _frame[i * 7 + 6] = _boneInfo.t.y;
                        _frame[i * 7 + 7] = _boneInfo.t.z;
                    }
                    this.frames[_fid] = _frame;
                }
                buf = null;
            }
            get time() {
                if (!this.frameCount || !this.fps)
                    return 0;
                return this.frameCount / this.fps;
            }
        };
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], animationClip.prototype, "name", void 0);
        animationClip = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], animationClip);
        framework.animationClip = animationClip;
        let PoseBoneMatrix = PoseBoneMatrix_1 = class PoseBoneMatrix {
            static caclByteLength() {
                let total = 12 + 16;
                return total;
            }
            Clone() {
                var p = new PoseBoneMatrix_1();
                p.t = new gd3d.math.vector3();
                p.r = new gd3d.math.quaternion();
                gd3d.math.vec3Clone(this.t, p.t);
                gd3d.math.quatClone(this.r, p.r);
                return p;
            }
            load(read) {
                {
                    var x = read.readSingle();
                    var y = read.readSingle();
                    var z = read.readSingle();
                    var w = read.readSingle();
                    this.r = new gd3d.math.quaternion(x, y, z, w);
                }
                {
                    var x = read.readSingle();
                    var y = read.readSingle();
                    var z = read.readSingle();
                    this.t = new gd3d.math.vector3(x, y, z);
                }
            }
            static createDefault() {
                var pt = new PoseBoneMatrix_1();
                pt.r = new gd3d.math.quaternion(0, 0, 0, 1);
                pt.t = new gd3d.math.vector3(0, 0, 0);
                return pt;
            }
            copyFrom(src) {
                this.r.x = src.r.x;
                this.r.y = src.r.y;
                this.r.z = src.r.z;
                this.r.w = src.r.w;
                this.t.x = src.t.x;
                this.t.y = src.t.y;
                this.t.z = src.t.z;
            }
            copyFromData(src, seek) {
                this.r.x = src[seek + 0];
                this.r.y = src[seek + 1];
                this.r.z = src[seek + 2];
                this.r.w = src[seek + 3];
                this.t.x = src[seek + 4];
                this.t.y = src[seek + 5];
                this.t.z = src[seek + 6];
            }
            invert() {
                gd3d.math.quatInverse(this.r, this.r);
                gd3d.math.quatTransformVector(this.r, this.t, this.t);
                this.t.x *= -1;
                this.t.y *= -1;
                this.t.z *= -1;
            }
            lerpInWorld(_tpose, from, to, v) {
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiply(to, _tpose);
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            }
            lerpInWorldWithData(_tpose, from, todata, toseek, v) {
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiplyDataAndMatrix(todata, toseek, _tpose);
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            }
            static sMultiply(left, right, target = null) {
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(right.t, dir);
                var dirtran = gd3d.math.pool.new_vector3();
                gd3d.math.quatTransformVector(left.r, dir, dirtran);
                target.t.x = dirtran.x + left.t.x;
                target.t.y = dirtran.y + left.t.y;
                target.t.z = dirtran.z + left.t.z;
                gd3d.math.quatMultiply(left.r, right.r, target.r);
                gd3d.math.pool.delete_vector3(dir);
                gd3d.math.pool.delete_vector3(dirtran);
                return target;
            }
            static sMultiplyDataAndMatrix(leftdata, leftseek, right, target = null) {
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(right.t, dir);
                var dirtran = gd3d.math.pool.new_vector3();
                gd3d.math.quatTransformVectorDataAndQuat(leftdata, leftseek + 0, dir, dirtran);
                target.t.x = dirtran.x + leftdata[leftseek + 4];
                target.t.y = dirtran.y + leftdata[leftseek + 5];
                target.t.z = dirtran.z + leftdata[leftseek + 6];
                gd3d.math.quatMultiplyDataAndQuat(leftdata, leftseek + 0, right.r, target.r);
                gd3d.math.pool.delete_vector3(dir);
                gd3d.math.pool.delete_vector3(dirtran);
                return target;
            }
            static sLerp(left, right, v, target = null) {
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                target.t.x = left.t.x * (1 - v) + right.t.x * v;
                target.t.y = left.t.y * (1 - v) + right.t.y * v;
                target.t.z = left.t.z * (1 - v) + right.t.z * v;
                gd3d.math.quatLerp(left.r, right.r, target.r, v);
                return target;
            }
        };
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], PoseBoneMatrix.prototype, "t", void 0);
        __decorate([
            gd3d.reflect.Field("quaternion"),
            __metadata("design:type", gd3d.math.quaternion)
        ], PoseBoneMatrix.prototype, "r", void 0);
        PoseBoneMatrix = PoseBoneMatrix_1 = __decorate([
            gd3d.reflect.SerializeType
        ], PoseBoneMatrix);
        framework.PoseBoneMatrix = PoseBoneMatrix;
        class subClip {
            static caclByteLength() {
                let total = 0;
                total += gd3d.math.caclStringByteLength(name);
                total += 1;
                total += 8;
                return total;
            }
        }
        framework.subClip = subClip;
        var PoseBoneMatrix_1;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let atlas = class atlas {
            constructor(assetName = null) {
                this.id = new framework.resID();
                this.sprites = {};
                if (!assetName) {
                    assetName = "atlas_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            dispose() {
                for (var key in this.sprites) {
                    this.sprites[key].unuse();
                }
                this.texture.unuse();
                delete this.sprites;
            }
            caclByteLength() {
                let total = 0;
                for (let k in this.sprites) {
                    total += this.sprites[k].caclByteLength();
                    total += gd3d.math.caclStringByteLength(k);
                }
                return total;
            }
            get texture() {
                return this._texture;
            }
            set texture(value) {
                if (this._texture != null) {
                    this._texture.unuse();
                }
                this._texture = value;
                this._texture.use();
            }
            Parse(jsonStr, assetmgr) {
                var json = JSON.parse(jsonStr);
                var name = json["t"];
                this.texturewidth = json["w"];
                this.textureheight = json["h"];
                var s = json["s"];
                this.texture = assetmgr.getAssetByName(name);
                if (this.texture == null) {
                    console.log("atlas的图片名字不对");
                }
                for (var i in s) {
                    var ss = s[i];
                    var spriteName = ss[0];
                    var r = new framework.sprite(this.getName() + "_" + spriteName);
                    assetmgr.use(r);
                    if (this.texture) {
                        r.texture = this.texture;
                    }
                    r.rect = new gd3d.math.rect(ss[1], ss[2], ss[3], ss[4]);
                    r.border = new gd3d.math.border(0, 0, 0, 0);
                    r.atlas = this.getName();
                    this.sprites[spriteName] = r;
                }
            }
        };
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], atlas.prototype, "name", void 0);
        atlas = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], atlas);
        framework.atlas = atlas;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class f14node {
        }
        framework.f14node = f14node;
        let f14eff = class f14eff {
            constructor(assetName = null) {
                this.defaultAsset = false;
                this.name = null;
                this.id = new framework.resID();
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "f14eff_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
            }
            unuse(disposeNow) {
            }
            dispose() {
            }
            caclByteLength() {
                return 0;
            }
            Parse(jsonStr, assetmgr) {
                let json = JSON.parse(jsonStr);
                this.data = new framework.F14EffectData();
                this.data.parsejson(json, assetmgr, this.assetbundle);
            }
        };
        f14eff = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], f14eff);
        framework.f14eff = f14eff;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let font = class font {
            constructor(assetName = null) {
                this.id = new framework.resID();
                if (!assetName) {
                    assetName = "font_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            dispose() {
                if (this.texture) {
                    this.texture.unuse(true);
                }
                delete this.cmap;
            }
            caclByteLength() {
                let total = 0;
                for (let k in this.cmap) {
                    total += gd3d.math.caclStringByteLength(k);
                    total += charinfo.caclByteLength();
                }
                return total;
            }
            get texture() {
                return this._texture;
            }
            set texture(value) {
                if (this._texture != null) {
                    this._texture.unuse();
                }
                this._texture = value;
                this._texture.use();
            }
            Parse(jsonStr, assetmgr) {
                let d1 = new Date().valueOf();
                let json = JSON.parse(jsonStr);
                var font = json["font"];
                this.fontname = font[0];
                var picName = font[1];
                this.texture = assetmgr.getAssetByName(picName);
                this.pointSize = font[2];
                this.padding = font[3];
                this.lineHeight = font[4];
                this.baseline = font[5];
                this.atlasWidth = font[6];
                this.atlasHeight = font[7];
                this.cmap = {};
                let map = json["map"];
                for (var c in map) {
                    let finfo = new charinfo();
                    this.cmap[c] = finfo;
                    finfo.x = (map[c][0] - 0.5) / this.atlasWidth;
                    finfo.y = (map[c][1] - 0.5) / this.atlasHeight;
                    finfo.w = (map[c][2] + 1.0) / this.atlasWidth;
                    finfo.h = (map[c][3] + 1.0) / this.atlasHeight;
                    finfo.xSize = map[c][2];
                    finfo.ySize = map[c][3];
                    finfo.xOffset = map[c][4];
                    finfo.yOffset = map[c][5];
                    finfo.xAddvance = map[c][6];
                }
                map = null;
                json = null;
                let d2 = new Date().valueOf();
                let n = d2 - d1;
            }
        };
        font = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], font);
        framework.font = font;
        class charinfo {
            constructor() {
                this.xOffset = 0;
                this.yOffset = 0;
            }
            static caclByteLength() {
                return 36;
            }
        }
        framework.charinfo = charinfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let transform = class transform {
            constructor() {
                this.name = "noname";
                this.insId = new insID();
                this.prefab = null;
                this.aabbdirty = true;
                this.aabbchilddirty = true;
                this.dirty = true;
                this.dirtyChild = true;
                this.hasComponent = false;
                this.hasComponentChild = false;
                this.hasRendererComp = false;
                this.hasRendererCompChild = false;
                this.dirtyWorldDecompose = false;
                this.localRotate = new gd3d.math.quaternion();
                this.localTranslate = new gd3d.math.vector3(0, 0, 0);
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.localMatrix = new gd3d.math.matrix();
                this._localEulerAngles = new gd3d.math.vector3(0, 0, 0);
                this.worldMatrix = new gd3d.math.matrix();
                this.worldRotate = new gd3d.math.quaternion();
                this.worldTranslate = new gd3d.math.vector3(0, 0, 0);
                this.worldScale = new gd3d.math.vector3(1, 1, 1);
                this.tempWorldMatrix = new gd3d.math.matrix();
                this._beDispose = false;
            }
            set scene(value) {
                this._scene = value;
            }
            get scene() {
                if (this._scene == null) {
                    if (this.parent == null)
                        return null;
                    this._scene = this.parent.scene;
                }
                return this._scene;
            }
            markAABBDirty() {
                this.aabbdirty = true;
                this.markAABBChildDirty();
                var p = this.parent;
                while (p != null) {
                    p.markAABBChildDirty();
                    p = p.parent;
                }
            }
            markAABBChildDirty() {
                this.aabbchilddirty = true;
            }
            caclAABB() {
                if (this.gameObject.components == null)
                    return;
                if (this.aabb == null) {
                    this.aabb = this.buildAABB();
                    this.aabbchild = this.aabb.clone();
                }
                this.aabb.update(this.worldMatrix);
            }
            caclAABBChild() {
                if (this.aabb == null)
                    return;
                this.aabbchild = this.aabb.clone();
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.aabbchild.addAABB(this.children[i].aabbchild);
                    }
                }
            }
            buildAABB() {
                var minimum = new gd3d.math.vector3();
                var maximum = new gd3d.math.vector3();
                var filter = this.gameObject.getComponent("meshFilter");
                if (filter != null && filter.mesh != null && filter.mesh.data != null && filter.mesh.data.pos != null) {
                    var meshdata = filter.mesh.data;
                    gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                    gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                    for (var i = 0; i < meshdata.pos.length; i++) {
                        gd3d.math.vec3Max(meshdata.pos[i], maximum, maximum);
                        gd3d.math.vec3Min(meshdata.pos[i], minimum, minimum);
                    }
                }
                else {
                    var skinmesh = this.gameObject.getComponent("skinnedMeshRenderer");
                    if (skinmesh != null && skinmesh.mesh != null && skinmesh.mesh.data != null && skinmesh.mesh.data.pos != null) {
                        var skinmeshdata = skinmesh.mesh.data;
                        gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                        gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                        for (var i = 0; i < skinmeshdata.pos.length; i++) {
                            gd3d.math.vec3Max(skinmeshdata.pos[i], maximum, maximum);
                            gd3d.math.vec3Min(skinmeshdata.pos[i], minimum, minimum);
                        }
                    }
                    else {
                        minimum.x = -1;
                        minimum.y = -1;
                        minimum.z = -1;
                        maximum.x = 1;
                        maximum.y = 1;
                        maximum.z = 1;
                    }
                }
                var _aabb = new framework.aabb(minimum, maximum);
                return _aabb;
            }
            addChild(node) {
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.push(node);
                node.scene = this.scene;
                node.parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                if (node.hasComponent || node.hasComponentChild)
                    this.markHaveComponent();
                if (node.hasRendererComp || node.hasRendererCompChild)
                    this.markHaveRendererComp();
            }
            addChildAt(node, index) {
                if (index < 0)
                    return;
                if (node.parent != null) {
                    node.parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.splice(index, 0, node);
                node.scene = this.scene;
                node.parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                if (node.hasComponent || node.hasComponentChild)
                    this.markHaveComponent();
                if (node.hasRendererComp || node.hasRendererCompChild)
                    this.markHaveRendererComp();
            }
            removeAllChild() {
                if (this.children == undefined)
                    return;
                while (this.children.length > 0) {
                    this.removeChild(this.children[0]);
                }
            }
            removeChild(node) {
                if (node.parent != this || this.children == null) {
                    throw new Error("not my child.");
                }
                var i = this.children.indexOf(node);
                if (i >= 0) {
                    this.children.splice(i, 1);
                    framework.sceneMgr.app.markNotify(node, framework.NotifyType.RemoveChild);
                    node.parent = null;
                }
            }
            find(name) {
                if (this.name == name)
                    return this;
                else {
                    if (this.children != undefined) {
                        for (let i in this.children) {
                            let res = this.children[i].find(name);
                            if (res != null)
                                return res;
                            else {
                                continue;
                            }
                        }
                    }
                }
                return null;
            }
            checkImpactTran(tran) {
                if (this.gameObject.collider == null)
                    return false;
                return this.gameObject.collider.intersectsTransform(tran);
            }
            checkImpact() {
                var trans = new Array();
                this.doImpact(this.scene.getRoot(), trans);
                return trans;
            }
            doImpact(tran, impacted) {
                if (tran == this)
                    return;
                if (tran.gameObject != null && tran.gameObject.collider != null) {
                    if (this.checkImpactTran(tran)) {
                        impacted.push(tran);
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        this.doImpact(tran.children[i], impacted);
                    }
                }
            }
            markDirty() {
                this.dirty = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p = p.parent;
                }
            }
            markHaveComponent() {
                this.hasComponent = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p.hasComponentChild = true;
                    p = p.parent;
                }
            }
            markHaveRendererComp() {
                this.hasRendererComp = true;
                var p = this.parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p.hasRendererCompChild = true;
                    p = p.parent;
                }
            }
            updateTran(parentChange) {
                if (this.dirtyChild == false && this.dirty == false && parentChange == false)
                    return;
                if (this.dirty) {
                    gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                if (this.dirty || parentChange) {
                    if (this.parent == null) {
                        gd3d.math.matrixClone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        gd3d.math.matrixMultiply(this.parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    this.dirtyWorldDecompose = true;
                    this.markAABBDirty();
                }
                if (this.children != null) {
                    for (var i = 0; i < this.children.length; i++) {
                        this.children[i].updateTran(parentChange || this.dirty);
                    }
                }
                this.dirty = false;
                this.dirtyChild = false;
                if (this.aabbdirty) {
                    this.caclAABB();
                    this.aabbdirty = false;
                }
            }
            updateWorldTran() {
                var p = this.parent;
                var dirtylist = [];
                dirtylist.push(this);
                while (p != null) {
                    if (p.dirty)
                        dirtylist.push(p);
                    p = p.parent;
                }
                var top = dirtylist.pop();
                top.updateTran(false);
            }
            updateAABBChild() {
                if (this.aabbchilddirty) {
                    if (this.children != null) {
                        for (var i = 0; i < this.children.length; i++) {
                            this.children[i].updateAABBChild();
                        }
                    }
                    this.caclAABBChild();
                    this.aabbchilddirty = false;
                }
            }
            set localPosition(position) {
                this.localTranslate = position;
            }
            get localPosition() {
                return this.localTranslate;
            }
            get localEulerAngles() {
                gd3d.math.quatToEulerAngles(this.localRotate, this._localEulerAngles);
                return this._localEulerAngles;
            }
            set localEulerAngles(angle) {
                gd3d.math.quatFromEulerAngles(angle.x, angle.y, angle.z, this.localRotate);
            }
            getWorldTranslate() {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrixDecompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldTranslate;
            }
            getWorldScale() {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrixDecompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldScale;
            }
            getWorldRotate() {
                if (this.dirtyWorldDecompose) {
                    gd3d.math.matrixDecompose(this.worldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    this.dirtyWorldDecompose = false;
                }
                return this.worldRotate;
            }
            getLocalMatrix() {
                if (this.dirty)
                    gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                return this.localMatrix;
            }
            getWorldMatrix() {
                if (this.dirty) {
                    if (!this.parent)
                        gd3d.math.matrixMultiply(this.parent.worldMatrix, this.getLocalMatrix(), this.tempWorldMatrix);
                    else
                        gd3d.math.matrixClone(this.getLocalMatrix(), this.tempWorldMatrix);
                    return this.tempWorldMatrix;
                }
                else
                    return this.worldMatrix;
            }
            getForwardInWorld(out) {
                var forward = gd3d.math.pool.new_vector3();
                forward.x = 0;
                forward.y = 0;
                forward.z = 1;
                gd3d.math.matrixTransformNormal(forward, this.getWorldMatrix(), out);
                gd3d.math.vec3Normalize(out, out);
                gd3d.math.pool.delete_vector3(forward);
            }
            getRightInWorld(out) {
                var right = gd3d.math.pool.new_vector3();
                right.x = 1;
                right.y = 0;
                right.z = 0;
                gd3d.math.matrixTransformNormal(right, this.getWorldMatrix(), out);
                gd3d.math.vec3Normalize(out, out);
                gd3d.math.pool.delete_vector3(right);
            }
            getUpInWorld(out) {
                var up = gd3d.math.pool.new_vector3();
                up.x = 0;
                up.y = 1;
                up.z = 0;
                gd3d.math.matrixTransformNormal(up, this.getWorldMatrix(), out);
                gd3d.math.vec3Normalize(out, out);
                gd3d.math.pool.delete_vector3(up);
            }
            setWorldMatrix(mat) {
                this.dirty = true;
                this.updateWorldTran();
                var pworld = gd3d.math.pool.new_matrix();
                if (this.parent != null) {
                    gd3d.math.matrixClone(this.parent.worldMatrix, pworld);
                }
                else {
                    gd3d.math.matrixMakeIdentity(pworld);
                }
                var invparentworld = gd3d.math.pool.new_matrix();
                gd3d.math.matrixInverse(pworld, invparentworld);
                gd3d.math.matrixClone(mat, this.worldMatrix);
                this.dirtyWorldDecompose = true;
                gd3d.math.matrixMultiply(invparentworld, this.worldMatrix, this.localMatrix);
                gd3d.math.matrixDecompose(this.localMatrix, this.localScale, this.localRotate, this.localTranslate);
                this.markDirty();
                gd3d.math.pool.delete_matrix(pworld);
                gd3d.math.pool.delete_matrix(invparentworld);
            }
            setWorldPosition(pos) {
                this.dirty = true;
                this.updateWorldTran();
                var pworld = gd3d.math.pool.new_matrix();
                if (this.parent != null) {
                    gd3d.math.matrixClone(this.parent.worldMatrix, pworld);
                }
                else {
                    gd3d.math.matrixMakeIdentity(pworld);
                }
                var invparentworld = gd3d.math.pool.new_matrix();
                gd3d.math.matrixInverse(pworld, invparentworld);
                this.worldMatrix.rawData[12] = pos.x;
                this.worldMatrix.rawData[13] = pos.y;
                this.worldMatrix.rawData[14] = pos.z;
                gd3d.math.matrixMultiply(invparentworld, this.worldMatrix, this.localMatrix);
                gd3d.math.matrixDecompose(this.localMatrix, this.localScale, this.localRotate, this.localTranslate);
                this.markDirty();
                gd3d.math.pool.delete_matrix(pworld);
                gd3d.math.pool.delete_matrix(invparentworld);
            }
            lookat(trans) {
                this.dirty = true;
                trans.updateWorldTran();
                this.updateWorldTran();
                var p0 = this.getWorldTranslate();
                var p1 = trans.getWorldTranslate();
                var d = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(p1, p0, d);
                var quatworld = gd3d.math.pool.new_quaternion();
                var quat = gd3d.math.pool.new_quaternion();
                gd3d.math.quatLookat(p0, p1, quatworld);
                var quatworldCur = this.parent.getWorldRotate();
                gd3d.math.quatInverse(quatworldCur, quat);
                gd3d.math.quatMultiply(quat, quatworld, this.localRotate);
                gd3d.math.pool.delete_vector3(d);
                gd3d.math.pool.delete_quaternion(quatworld);
                gd3d.math.pool.delete_quaternion(quat);
            }
            lookatPoint(point) {
                this.dirty = true;
                this.updateWorldTran();
                var p0 = this.getWorldTranslate();
                var p1 = point;
                var d = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(p1, p0, d);
                var quatworld = gd3d.math.pool.new_quaternion();
                var quat = gd3d.math.pool.new_quaternion();
                gd3d.math.quatLookat(p0, p1, quatworld);
                var quatworldCur = this.parent.getWorldRotate();
                gd3d.math.quatInverse(quatworldCur, quat);
                gd3d.math.quatMultiply(quat, quatworld, this.localRotate);
                this.markDirty();
                gd3d.math.pool.delete_vector3(d);
                gd3d.math.pool.delete_quaternion(quatworld);
                gd3d.math.pool.delete_quaternion(quat);
            }
            get gameObject() {
                if (this._gameObject == null) {
                    this._gameObject = new framework.gameObject();
                    this._gameObject.transform = this;
                }
                return this._gameObject;
            }
            clone() {
                return gd3d.io.cloneObj(this);
            }
            get beDispose() {
                return this._beDispose;
            }
            dispose() {
                if (this._beDispose)
                    return;
                if (this.parent) {
                    this.parent.removeChild(this);
                }
                if (this.children) {
                    for (var k in this.children) {
                        this.children[k].dispose();
                    }
                }
                this._gameObject.dispose();
                this._beDispose = true;
                if (this.onDispose)
                    this.onDispose();
            }
            destroy() {
                this.dispose();
            }
        };
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], transform.prototype, "name", void 0);
        __decorate([
            gd3d.reflect.Field("transform[]"),
            __metadata("design:type", Array)
        ], transform.prototype, "children", void 0);
        __decorate([
            gd3d.reflect.Field("quaternion"),
            __metadata("design:type", gd3d.math.quaternion)
        ], transform.prototype, "localRotate", void 0);
        __decorate([
            gd3d.reflect.Field("vector3", new gd3d.math.vector3(0, 0, 0)),
            __metadata("design:type", gd3d.math.vector3)
        ], transform.prototype, "localTranslate", void 0);
        __decorate([
            gd3d.reflect.Field("vector3", new gd3d.math.vector3(1, 1, 1)),
            __metadata("design:type", gd3d.math.vector3)
        ], transform.prototype, "localScale", void 0);
        __decorate([
            gd3d.reflect.Field("gameObject"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [])
        ], transform.prototype, "gameObject", null);
        transform = __decorate([
            gd3d.reflect.SerializeType
        ], transform);
        framework.transform = transform;
        class insID {
            constructor() {
                this.id = insID.next();
            }
            static next() {
                var next = insID.idAll;
                insID.idAll++;
                return next;
            }
            getInsID() {
                return this.id;
            }
        }
        insID.idAll = 1;
        framework.insID = insID;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let boxcollider = class boxcollider {
            constructor() {
                this._colliderVisible = false;
            }
            getBound() {
                return this.obb;
            }
            get matrix() {
                if (this.gameObject)
                    return this.gameObject.transform.getWorldMatrix();
                return new gd3d.math.matrix();
            }
            start() {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.build();
            }
            onPlay() {
            }
            update(delta) {
                if (this.obb) {
                    this.obb.update(this.matrix);
                }
            }
            get colliderVisible() {
                return this._colliderVisible;
            }
            set colliderVisible(value) {
                this._colliderVisible = value;
                if (this.subTran) {
                    this.subTran.gameObject.visible = this._colliderVisible;
                }
            }
            intersectsTransform(tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.obb == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.obb.intersects(_obb);
            }
            build() {
                this.obb = new framework.obb();
                if (this.center && this.size) {
                    this.obb.buildByCenterSize(this.center, this.size);
                }
                else {
                    var minimum = new gd3d.math.vector3();
                    var maximum = new gd3d.math.vector3();
                    if (this.filter) {
                        var meshdata = this.filter.getMeshOutput().data;
                        gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                        gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                        for (var i = 0; i < meshdata.pos.length; i++) {
                            gd3d.math.vec3Max(meshdata.pos[i], maximum, maximum);
                            gd3d.math.vec3Min(meshdata.pos[i], minimum, minimum);
                        }
                        console.log("add obb filter " + minimum + "  " + maximum);
                    }
                    else {
                        minimum.x = -1;
                        minimum.y = -1;
                        minimum.z = -1;
                        maximum.x = 1;
                        maximum.y = 1;
                        maximum.z = 1;
                    }
                    this.obb.buildByMaxMin(minimum, maximum);
                }
                this.buildMesh();
            }
            buildMesh() {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "boxcollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
            }
            getColliderMesh() {
                var _mesh = new framework.mesh();
                _mesh.data = gd3d.render.meshData.genBoxByArray_Quad(this.obb.vectors);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayQuad2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = true;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            }
            remove() {
                if (this.subTran) {
                    this.subTran.dispose();
                }
                if (this.obb) {
                    this.obb.dispose();
                }
            }
            clone() {
            }
        };
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], boxcollider.prototype, "center", void 0);
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], boxcollider.prototype, "size", void 0);
        boxcollider = __decorate([
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeBoxCollider
        ], boxcollider);
        framework.boxcollider = boxcollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let meshcollider = class meshcollider {
            constructor() {
                this._colliderVisible = false;
            }
            getBound() {
                return this.mesh;
            }
            start() {
                let filter = this.gameObject.getComponent("meshFilter");
                if (filter != null) {
                    this.mesh = filter.getMeshOutput();
                    this.buildMesh();
                }
            }
            onPlay() {
            }
            update(delta) {
            }
            get colliderVisible() {
                return this._colliderVisible;
            }
            set colliderVisible(value) {
                this._colliderVisible = value;
                if (this.subTran) {
                    this.subTran.gameObject.visible = this._colliderVisible;
                }
            }
            intersectsTransform(tran) {
                return false;
            }
            buildMesh() {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "meshcollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
            }
            getColliderMesh() {
                var _mesh = new framework.mesh();
                _mesh.data = this.mesh.data;
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayTri2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = true;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            }
            remove() {
                if (this.subTran) {
                    this.subTran.dispose();
                }
            }
            clone() {
            }
        };
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], meshcollider.prototype, "_colliderVisible", void 0);
        meshcollider = __decorate([
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeMeshCollider
        ], meshcollider);
        framework.meshcollider = meshcollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let meshFilter = class meshFilter {
            start() {
            }
            onPlay() {
            }
            update(delta) {
            }
            get mesh() {
                return this._mesh;
            }
            set mesh(mesh) {
                if (this._mesh != null) {
                    this._mesh.unuse();
                }
                this._mesh = mesh;
                if (this._mesh != null) {
                    this._mesh.use();
                }
            }
            getMeshOutput() {
                return this._mesh;
            }
            remove() {
                if (this.mesh)
                    this.mesh.unuse(true);
            }
            clone() {
            }
        };
        __decorate([
            gd3d.reflect.Field("mesh"),
            gd3d.reflect.UIStyle("WidgetDragSelect"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [framework.mesh])
        ], meshFilter.prototype, "mesh", null);
        meshFilter = __decorate([
            gd3d.reflect.nodeComponent
        ], meshFilter);
        framework.meshFilter = meshFilter;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let meshRenderer = class meshRenderer {
            constructor() {
                this.materials = [];
                this.useGlobalLightMap = true;
                this.lightmapIndex = -1;
                this.lightmapScaleOffset = new gd3d.math.vector4(1, 1, 0, 0);
                this.layer = framework.RenderLayerEnum.Common;
                this.issetq = false;
                this._queue = 0;
            }
            get renderLayer() { return this.gameObject.layer; }
            set renderLayer(layer) {
                this.gameObject.layer = layer;
            }
            get queue() {
                return this._queue;
            }
            set queue(value) {
                this._queue = value;
                this.issetq = true;
            }
            start() {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.refreshLayerAndQue();
                if (this.lightmapIndex == -2) {
                    this.useGlobalLightMap = false;
                }
            }
            onPlay() {
            }
            refreshLayerAndQue() {
                if (this.materials == null || this.materials.length == 0) {
                    this.materials = [];
                    let material = new framework.material();
                    material.use();
                    this.materials.push(material);
                    this.materials[0].setShader(framework.sceneMgr.app.getAssetMgr().getShader("shader/def"));
                }
                this.layer = this.materials[0].getLayer();
                if (!this.issetq)
                    this._queue = this.materials[0].getQueue();
            }
            update(delta) {
                if (this.materials != null && this.materials.length > 0) {
                    let _mat = this.materials[0];
                    if (_mat) {
                        this.layer = _mat.getLayer();
                        if (!this.issetq)
                            this._queue = _mat.getQueue();
                    }
                }
                if (this.filter == null) {
                    this.filter = this.gameObject.getComponent("meshFilter");
                }
            }
            render(context, assetmgr, camera) {
                context.updateLightMask(this.gameObject.layer);
                context.updateModel(this.gameObject.transform);
                if (this.filter != null) {
                    var mesh = this.filter.getMeshOutput();
                    if (mesh != null) {
                        mesh.glMesh.bindVboBuffer(context.webgl);
                        if (mesh.submesh != null) {
                            for (var i = 0; i < mesh.submesh.length; i++) {
                                var sm = mesh.submesh[i];
                                var mid = mesh.submesh[i].matIndex;
                                var usemat = this.materials[mid];
                                var drawtype = this.gameObject.transform.scene.fog ? "base_fog" : "base";
                                if (this.lightmapIndex >= 0) {
                                    drawtype = this.gameObject.transform.scene.fog ? "lightmap_fog" : "lightmap";
                                    if (this.gameObject.transform.scene.lightmaps.length > this.lightmapIndex) {
                                        context.lightmap = this.gameObject.transform.scene.lightmaps[this.lightmapIndex];
                                        context.lightmapOffset = this.lightmapScaleOffset;
                                        context.lightmapUV = mesh.glMesh.vertexFormat & gd3d.render.VertexFormatMask.UV1 ? 1 : 0;
                                    }
                                }
                                else {
                                    if (!this.useGlobalLightMap) {
                                        drawtype = this.gameObject.transform.scene.fog ? "lightmap_fog" : "lightmap";
                                        context.lightmapOffset = this.lightmapScaleOffset;
                                        context.lightmapUV = mesh.glMesh.vertexFormat & gd3d.render.VertexFormatMask.UV1 ? 1 : 0;
                                    }
                                }
                                if (this.gameObject.transform.scene.fog) {
                                    context.fog = this.gameObject.transform.scene.fog;
                                }
                                if (usemat != null)
                                    usemat.draw(context, mesh, sm, drawtype, this.useGlobalLightMap);
                            }
                        }
                    }
                }
            }
            remove() {
                this.materials.forEach(element => {
                    if (element)
                        element.unuse();
                });
                this.materials.length = 0;
            }
            clone() {
            }
        };
        __decorate([
            gd3d.reflect.Field("material[]"),
            __metadata("design:type", Array)
        ], meshRenderer.prototype, "materials", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], meshRenderer.prototype, "lightmapIndex", void 0);
        __decorate([
            gd3d.reflect.Field("vector4"),
            __metadata("design:type", gd3d.math.vector4)
        ], meshRenderer.prototype, "lightmapScaleOffset", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], meshRenderer.prototype, "layer", void 0);
        meshRenderer = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent,
            __metadata("design:paramtypes", [])
        ], meshRenderer);
        framework.meshRenderer = meshRenderer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let skinnedMeshRenderer = skinnedMeshRenderer_1 = class skinnedMeshRenderer {
            constructor() {
                this.layer = framework.RenderLayerEnum.Common;
                this.issetq = false;
                this._queue = 0;
                this.maxBoneCount = 0;
                this._skintype = 0;
                this._efficient = true;
            }
            get renderLayer() { return this.gameObject.layer; }
            set renderLayer(layer) {
                this.gameObject.layer = layer;
            }
            get queue() {
                return this._queue;
            }
            set queue(value) {
                this._queue = value;
                this.issetq = true;
            }
            get player() {
                if (this._player == null) {
                    this._player = this.gameObject.getComponentInParent("aniplayer");
                }
                return this._player;
            }
            get mesh() {
                return this._mesh;
            }
            set mesh(mesh) {
                if (this._mesh != null) {
                    this._mesh.unuse();
                }
                this._mesh = mesh;
                if (this._mesh != null) {
                    this._mesh.use();
                }
            }
            start() {
            }
            onPlay() {
            }
            getMatByIndex(index) {
                let data = this.mesh.data;
                if (data.blendIndex[index].v0 >= this.maxBoneCount || data.blendIndex[index].v1 >= this.maxBoneCount || data.blendIndex[index].v2 >= this.maxBoneCount || data.blendIndex[index].v3 >= this.maxBoneCount) {
                    return null;
                }
                let mat = new gd3d.math.matrix();
                if (this._efficient) {
                    let vec40r = gd3d.math.pool.new_vector4();
                    let vec30p = gd3d.math.pool.new_vector3();
                    vec40r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 0];
                    vec40r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 1];
                    vec40r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 2];
                    vec40r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 3];
                    vec30p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 4];
                    vec30p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 5];
                    vec30p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 6];
                    let vec41r = gd3d.math.pool.new_vector4();
                    let vec31p = gd3d.math.pool.new_vector3();
                    vec41r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 0];
                    vec41r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 1];
                    vec41r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 2];
                    vec41r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 3];
                    vec31p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 4];
                    vec31p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 5];
                    vec31p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 6];
                    let vec42r = gd3d.math.pool.new_vector4();
                    let vec32p = gd3d.math.pool.new_vector3();
                    vec42r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 0];
                    vec42r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 1];
                    vec42r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 2];
                    vec42r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 3];
                    vec32p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 4];
                    vec32p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 5];
                    vec32p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 6];
                    let vec43r = gd3d.math.pool.new_vector4();
                    let vec33p = gd3d.math.pool.new_vector3();
                    vec43r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 0];
                    vec43r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 1];
                    vec43r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 2];
                    vec43r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 3];
                    vec33p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 4];
                    vec33p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 5];
                    vec33p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 6];
                    let mat0 = gd3d.math.pool.new_matrix();
                    let mat1 = gd3d.math.pool.new_matrix();
                    let mat2 = gd3d.math.pool.new_matrix();
                    let mat3 = gd3d.math.pool.new_matrix();
                    gd3d.math.matrixMakeTransformRTS(vec30p, gd3d.math.pool.vector3_one, vec40r, mat0);
                    gd3d.math.matrixMakeTransformRTS(vec31p, gd3d.math.pool.vector3_one, vec41r, mat1);
                    gd3d.math.matrixMakeTransformRTS(vec32p, gd3d.math.pool.vector3_one, vec42r, mat2);
                    gd3d.math.matrixMakeTransformRTS(vec33p, gd3d.math.pool.vector3_one, vec43r, mat3);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    gd3d.math.matrixAdd(mat0, mat1, mat);
                    gd3d.math.matrixAdd(mat, mat2, mat);
                    gd3d.math.matrixAdd(mat, mat3, mat);
                    gd3d.math.pool.delete_vector4(vec40r);
                    gd3d.math.pool.delete_vector4(vec41r);
                    gd3d.math.pool.delete_vector4(vec42r);
                    gd3d.math.pool.delete_vector4(vec43r);
                    gd3d.math.pool.delete_vector3(vec30p);
                    gd3d.math.pool.delete_vector3(vec31p);
                    gd3d.math.pool.delete_vector3(vec32p);
                    gd3d.math.pool.delete_vector3(vec33p);
                    gd3d.math.pool.delete_matrix(mat0);
                    gd3d.math.pool.delete_matrix(mat1);
                    gd3d.math.pool.delete_matrix(mat2);
                    gd3d.math.pool.delete_matrix(mat3);
                }
                else {
                    let mat0 = gd3d.math.pool.new_matrix();
                    mat0.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v0, 16 * data.blendIndex[index].v0 + 16);
                    let mat1 = gd3d.math.pool.new_matrix();
                    mat1.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v1, 16 * data.blendIndex[index].v1 + 16);
                    let mat2 = gd3d.math.pool.new_matrix();
                    mat2.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v2, 16 * data.blendIndex[index].v2 + 16);
                    let mat3 = gd3d.math.pool.new_matrix();
                    mat3.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v3, 16 * data.blendIndex[index].v3 + 16);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    gd3d.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    gd3d.math.matrixAdd(mat0, mat1, mat);
                    gd3d.math.matrixAdd(mat, mat2, mat);
                    gd3d.math.matrixAdd(mat, mat3, mat);
                    gd3d.math.pool.delete_matrix(mat0);
                    gd3d.math.pool.delete_matrix(mat1);
                    gd3d.math.pool.delete_matrix(mat2);
                    gd3d.math.pool.delete_matrix(mat3);
                }
                return mat;
            }
            intersects(ray, outInfo) {
                let ishided = false;
                let lastDistance = Number.MAX_VALUE;
                let mvpmat = this.player.gameObject.transform.getWorldMatrix();
                let data = this.mesh.data;
                for (var i = 0; i < this.mesh.submesh.length; i++) {
                    var submesh = this.mesh.submesh[i];
                    var t0 = gd3d.math.pool.new_vector3();
                    var t1 = gd3d.math.pool.new_vector3();
                    var t2 = gd3d.math.pool.new_vector3();
                    for (var index = submesh.start; index < submesh.size; index += 3) {
                        let verindex0 = data.trisindex[index];
                        let verindex1 = data.trisindex[index + 1];
                        let verindex2 = data.trisindex[index + 2];
                        var p0 = data.pos[verindex0];
                        var p1 = data.pos[verindex1];
                        var p2 = data.pos[verindex2];
                        let mat0 = this.getMatByIndex(verindex0);
                        let mat1 = this.getMatByIndex(verindex1);
                        let mat2 = this.getMatByIndex(verindex2);
                        if (mat0 == null || mat1 == null || mat2 == null)
                            continue;
                        let mat00 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat0, mat00);
                        let mat11 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat1, mat11);
                        let mat22 = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(mvpmat, mat2, mat22);
                        gd3d.math.matrixTransformVector3(p0, mat00, t0);
                        gd3d.math.matrixTransformVector3(p1, mat11, t1);
                        gd3d.math.matrixTransformVector3(p2, mat22, t2);
                        let tempinfo = gd3d.math.pool.new_pickInfo();
                        var bool = ray.intersectsTriangle(t0, t1, t2, tempinfo);
                        if (bool) {
                            if (tempinfo.distance < 0)
                                continue;
                            if (lastDistance > tempinfo.distance) {
                                ishided = true;
                                outInfo.cloneFrom(tempinfo);
                                lastDistance = outInfo.distance;
                                outInfo.faceId = index / 3;
                                outInfo.subMeshId = i;
                                var tdir = gd3d.math.pool.new_vector3();
                                gd3d.math.vec3ScaleByNum(ray.direction, outInfo.distance, tdir);
                                gd3d.math.vec3Add(ray.origin, tdir, outInfo.hitposition);
                                gd3d.math.pool.delete_vector3(tdir);
                            }
                        }
                        gd3d.math.pool.delete_pickInfo(tempinfo);
                    }
                    gd3d.math.pool.delete_vector3(t0);
                    gd3d.math.pool.delete_vector3(t1);
                    gd3d.math.pool.delete_vector3(t2);
                }
                return ishided;
            }
            update(delta) {
                if (this._skeletonMatrixData == null) {
                    this._skintype = this.useBoneShader(this.materials[0]);
                    if (this._skintype == 1) {
                        this.maxBoneCount = 24;
                        this._skeletonMatrixData = new Float32Array(16 * this.maxBoneCount);
                        this._efficient = false;
                    }
                    else if (this._skintype == 2) {
                        this.maxBoneCount = 55;
                        this._skeletonMatrixData = new Float32Array(8 * this.maxBoneCount);
                        this._efficient = true;
                    }
                }
                if (this.materials != null && this.materials.length > 0) {
                    let _mat = this.materials[0];
                    if (_mat) {
                        this.layer = _mat.getLayer();
                        if (!this.issetq)
                            this._queue = _mat.getQueue();
                    }
                }
                if (this.player != null) {
                    if (this.player.isCache && !this.player.mix) {
                        let cacheKey = this.player.cacheKey + "_" + this.mesh.getGUID();
                        let data = skinnedMeshRenderer_1.dataCaches[cacheKey];
                        if (!data) {
                            let _cachePlayer = framework.aniplayer.playerCaches[this.player.cacheKey];
                            if (_cachePlayer) {
                                let baseSize = this._efficient ? 8 : 16;
                                data = new Float32Array(this.maxBoneCount * baseSize);
                                _cachePlayer.fillPoseData(data, this.bones, this._efficient);
                                skinnedMeshRenderer_1.dataCaches[cacheKey] = data;
                                this.cacheData = data;
                                return;
                            }
                        }
                        else {
                            this.cacheData = data;
                            return;
                        }
                    }
                    this.cacheData = null;
                    if (this._skeletonMatrixData != null) {
                        this.player.fillPoseData(this._skeletonMatrixData, this.bones, this._efficient);
                    }
                }
            }
            render(context, assetmgr, camera) {
                if (this.player != null) {
                    context.updateLightMask(this.gameObject.layer);
                    context.updateModel(this.player.gameObject.transform);
                }
                for (let i = 0; i < this.materials.length; i++) {
                    if (this.materials[i] == null)
                        continue;
                    if (this.cacheData != null && this._skintype > 0) {
                        if (this._efficient) {
                            context.vec4_bones = this.cacheData;
                        }
                        else {
                            context.matrix_bones = this.cacheData;
                        }
                        continue;
                    }
                    if (this._skeletonMatrixData != null && this._skintype > 0) {
                        if (this._efficient) {
                            context.vec4_bones = this._skeletonMatrixData;
                        }
                        else {
                            context.matrix_bones = this._skeletonMatrixData;
                        }
                    }
                }
                if (this._mesh && this.mesh.glMesh) {
                    this._mesh.glMesh.bindVboBuffer(context.webgl);
                    if (this._mesh.submesh != null) {
                        for (var i = 0; i < this._mesh.submesh.length; i++) {
                            var sm = this._mesh.submesh[i];
                            var mid = this._mesh.submesh[i].matIndex;
                            var usemat = this.materials[mid];
                            if (usemat != null) {
                                if (this.gameObject.transform.scene.fog) {
                                    context.fog = this.gameObject.transform.scene.fog;
                                    usemat.draw(context, this._mesh, sm, "skin_fog");
                                }
                                else {
                                    usemat.draw(context, this._mesh, sm, "skin");
                                }
                            }
                        }
                    }
                }
            }
            remove() {
                this.materials.forEach(element => {
                    if (element)
                        element.unuse();
                });
                if (this.mesh)
                    this.mesh.unuse(true);
                this.bones.length = 0;
            }
            clone() {
            }
            useBoneShader(mat) {
                var matpasses = mat.getShader().passes["skin"];
                if (matpasses == null || matpasses.length == 0)
                    return 0;
                if (matpasses[0].mapuniforms["glstate_vec4_bones"] != null)
                    return 2;
                else if (matpasses[0].mapuniforms["glstate_matrix_bones"] != null)
                    return 1;
                return 0;
            }
        };
        skinnedMeshRenderer.dataCaches = [];
        __decorate([
            gd3d.reflect.Field("material[]"),
            __metadata("design:type", Array)
        ], skinnedMeshRenderer.prototype, "materials", void 0);
        __decorate([
            gd3d.reflect.Field("mesh"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [framework.mesh])
        ], skinnedMeshRenderer.prototype, "mesh", null);
        __decorate([
            gd3d.reflect.Field("transform[]"),
            __metadata("design:type", Array)
        ], skinnedMeshRenderer.prototype, "bones", void 0);
        __decorate([
            gd3d.reflect.Field("transform"),
            __metadata("design:type", framework.transform)
        ], skinnedMeshRenderer.prototype, "rootBone", void 0);
        skinnedMeshRenderer = skinnedMeshRenderer_1 = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent,
            __metadata("design:paramtypes", [])
        ], skinnedMeshRenderer);
        framework.skinnedMeshRenderer = skinnedMeshRenderer;
        var skinnedMeshRenderer_1;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let WrapMode;
        (function (WrapMode) {
            WrapMode[WrapMode["Default"] = 0] = "Default";
            WrapMode[WrapMode["Once"] = 1] = "Once";
            WrapMode[WrapMode["Clamp"] = 1] = "Clamp";
            WrapMode[WrapMode["Loop"] = 2] = "Loop";
            WrapMode[WrapMode["PingPong"] = 4] = "PingPong";
            WrapMode[WrapMode["ClampForever"] = 8] = "ClampForever";
        })(WrapMode = framework.WrapMode || (framework.WrapMode = {}));
        let keyFrameAniClip = class keyFrameAniClip {
            constructor(assetName = null) {
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.length = 0;
                this.frameRate = 0;
                this.curves = [];
                if (!assetName) {
                    assetName = "keyFrameAniClip_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            dispose() {
                this.curves.length = 0;
            }
            caclByteLength() {
                let total = 0;
                return total;
            }
            Parse(jsonStr) {
                let obj = JSON.parse(jsonStr);
                let tag = obj["tag"];
                this.length = obj["length"];
                this._wrapMode = obj["wrapMode"];
                this.frameRate = obj["frameRate"];
                let curves_o = obj["curves"];
                for (var i = 0; i < curves_o.length; i++) {
                    let curve = new AnimationCurve();
                    let curve_o = curves_o[i];
                    let kfs_o = curve_o["keyFrames"];
                    curve.path = curve_o["path"];
                    curve.propertyName = kFAniClipUtil.converUnityTypeProperty(curve_o["type"], curve_o["propertyName"]);
                    curve.type = kFAniClipUtil.converUnityType(curve_o["type"]);
                    for (var j = 0; j < kfs_o.length; j++) {
                        let kf_o = kfs_o[j];
                        let kf = new keyFrame();
                        if (typeof (kf_o["inTangent"]) === "string")
                            kf.inTangent = Number(kf_o["inTangent"]);
                        else
                            kf.inTangent = kf_o["inTangent"];
                        if (typeof (kf_o["outTangent"]) === "string")
                            kf.outTangent = Number(kf_o["outTangent"]);
                        else
                            kf.outTangent = kf_o["outTangent"];
                        kf.tangentMode = kf_o["tangentMode"];
                        kf.time = kf_o["time"];
                        kf.value = kf_o["value"];
                        curve.keyFrames.push(kf);
                    }
                    this.curves.push(curve);
                }
            }
            get wrapMode() { return this._wrapMode; }
            get fps() {
                return this.frameRate;
            }
            get time() {
                return this.length;
            }
            get frameCount() { return Math.floor(this.frameRate * this.length); }
        };
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], keyFrameAniClip.prototype, "name", void 0);
        keyFrameAniClip = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], keyFrameAniClip);
        framework.keyFrameAniClip = keyFrameAniClip;
        class AnimationCurve {
            constructor() {
                this.keyFrames = [];
            }
        }
        framework.AnimationCurve = AnimationCurve;
        class keyFrame {
        }
        framework.keyFrame = keyFrame;
        class kFAniClipUtil {
            static get typePair() {
                if (!kFAniClipUtil._typePair)
                    kFAniClipUtil._typePair = kFAniClipUtil.regType();
                return kFAniClipUtil._typePair;
            }
            static isUnityExp(tag) {
                if (framework.StringUtil.isNullOrEmptyObject(tag))
                    return false;
                return tag.indexOf("unity") != -1;
            }
            static converUnityType(tyep) {
                let result = "";
                if (framework.StringUtil.isNullOrEmptyObject(tyep))
                    return result;
                if (tyep.indexOf("UnityEngine") == -1)
                    return tyep;
                let strs = tyep.split(".");
                if (strs.length < 1 || !strs[strs.length - 1])
                    return result;
                let tempT = strs[strs.length - 1];
                let obj = kFAniClipUtil._typePair[tempT];
                if (obj != null) {
                    result = obj["type"];
                }
                return result;
            }
            static converUnityTypeProperty(tyep, propertyName) {
                let result = propertyName;
                if (framework.StringUtil.isNullOrEmptyObject(propertyName))
                    return "";
                if (tyep.indexOf("UnityEngine") != -1) {
                    let strs = tyep.split(".");
                    tyep = strs[strs.length - 1];
                }
                let obj = kFAniClipUtil._typePair[tyep];
                let cgProperty = propertyName;
                if (propertyName.lastIndexOf(".") != -1) {
                    cgProperty = propertyName.substr(0, propertyName.lastIndexOf("."));
                }
                if (obj && obj[kFAniClipUtil.propTag] && obj[kFAniClipUtil.propTag][cgProperty]) {
                    let str = obj[kFAniClipUtil.propTag][cgProperty];
                    result = propertyName.replace(cgProperty, str);
                }
                return result;
            }
            static regType() {
                let result = {};
                result["Transform"] = { "type": framework.transform["name"] };
                result["BoxCollider"] = { "type": framework.boxcollider["name"] };
                result["MeshRenderer"] = { "type": framework.meshRenderer["name"] };
                result["MeshFilter"] = { "type": framework.meshFilter["name"] };
                result["SkinnedMeshRenderer"] = { "type": framework.skinnedMeshRenderer["name"] };
                kFAniClipUtil.regProperty(result);
                return result;
            }
            static regProperty(obj) {
                kFAniClipUtil.assemblyProp(obj, "Transform", "m_LocalPosition", "localTranslate");
                kFAniClipUtil.assemblyProp(obj, "Transform", "m_LocalScale", "localScale");
                kFAniClipUtil.assemblyProp(obj, "Transform", "m_LocalRotation", "localRotate");
            }
            static assemblyProp(obj, Type, prop, replaceProp) {
                if (!obj["Transform"][kFAniClipUtil.propTag])
                    obj["Transform"][kFAniClipUtil.propTag] = {};
                obj["Transform"][kFAniClipUtil.propTag][prop] = replaceProp;
            }
        }
        kFAniClipUtil.propTag = "__prop__";
        kFAniClipUtil._typePair = kFAniClipUtil.regType();
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let UniformData = class UniformData {
            constructor(type, value, defaultValue = null) {
                this.type = type;
                this.value = value;
                this.defaultValue = defaultValue;
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            gd3d.reflect.UIStyle("UniformTypeEnum"),
            __metadata("design:type", Number)
        ], UniformData.prototype, "type", void 0);
        __decorate([
            gd3d.reflect.Field("any"),
            __metadata("design:type", Object)
        ], UniformData.prototype, "value", void 0);
        UniformData = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Number, Object, Object])
        ], UniformData);
        framework.UniformData = UniformData;
        let material = material_1 = class material {
            constructor(assetName = null) {
                this.name = null;
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.queue = 0;
                this.statedMapUniforms = {};
                if (!assetName) {
                    assetName = "material_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
                gd3d.io.enumMgr.enumMap["UniformTypeEnum"] = gd3d.render.UniformTypeEnum;
            }
            getName() {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            dispose() {
                for (let id in this.statedMapUniforms) {
                    switch (this.defaultMapUniform[id].type) {
                        case gd3d.render.UniformTypeEnum.Texture:
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            if (this.statedMapUniforms[id] != null)
                                this.statedMapUniforms[id].unuse(true);
                            break;
                    }
                }
                delete this.statedMapUniforms;
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            caclByteLength() {
                let total = 0;
                if (this.shader) {
                    total += this.shader.caclByteLength();
                }
                for (let k in this.statedMapUniforms) {
                    let type = this.defaultMapUniform[k].type;
                    let value = this.statedMapUniforms[k].value;
                    let defaultValue = this.defaultMapUniform[k].value;
                    switch (type) {
                        case gd3d.render.UniformTypeEnum.Float:
                            total += 4;
                            break;
                        case gd3d.render.UniformTypeEnum.Floatv:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            total += 16;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4v:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4:
                            total += 64;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4x4v:
                            total += value.byteLength;
                            break;
                        case gd3d.render.UniformTypeEnum.Texture:
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            if (value != null) {
                                total += value.caclByteLength();
                            }
                            else if (defaultValue != null) {
                                total += defaultValue.caclByteLength();
                            }
                            break;
                    }
                }
                return total;
            }
            uploadUnifoms(pass, context) {
                gd3d.render.shaderUniform.texindex = 0;
                for (let key in pass.mapuniforms) {
                    let unifom = pass.mapuniforms[key];
                    let func = gd3d.render.shaderUniform.applyuniformFunc[unifom.type];
                    let unifomValue;
                    if (framework.uniformSetter.autoUniformDic[unifom.name] != null) {
                        let autoFunc = framework.uniformSetter.autoUniformDic[unifom.name];
                        unifomValue = autoFunc(context);
                    }
                    else {
                        if (this.statedMapUniforms[unifom.name] != null) {
                            unifomValue = this.statedMapUniforms[unifom.name];
                        }
                        else if (this.defaultMapUniform[unifom.name]) {
                            unifomValue = this.defaultMapUniform[unifom.name].value;
                        }
                        else {
                            console.error("Uniform don't be setted or have def value. uniform:" + unifom.name + "mat:" + this.getName());
                        }
                    }
                    func(unifom.location, unifomValue);
                }
            }
            setShader(shader) {
                this.shader = shader;
                this.defaultMapUniform = shader.defaultMapUniform;
            }
            getLayer() {
                return this.shader.layer;
            }
            getQueue() {
                return this.queue;
            }
            setQueue(queue) {
                this.queue = queue;
            }
            getShader() {
                return this.shader;
            }
            setFloat(_id, _number) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float) {
                    this.statedMapUniforms[_id] = _number;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            }
            setFloatv(_id, _numbers) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Floatv) {
                    this.statedMapUniforms[_id] = _numbers;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            }
            setVector4(_id, _vector4) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4) {
                    this.statedMapUniforms[_id] = _vector4;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            }
            setVector4v(_id, _vector4v) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4v) {
                    this.statedMapUniforms[_id] = _vector4v;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            }
            setMatrix(_id, _matrix) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4x4) {
                    this.statedMapUniforms[_id] = _matrix;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            }
            setMatrixv(_id, _matrixv) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Float4x4v) {
                    this.statedMapUniforms[_id] = _matrixv;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            }
            setTexture(_id, _texture, resname = "") {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.Texture) {
                    if (this.statedMapUniforms[_id] != null && (!this.statedMapUniforms[_id].defaultAsset)) {
                        this.statedMapUniforms[_id].unuse();
                    }
                    this.statedMapUniforms[_id] = _texture;
                    if (_texture != null) {
                        if (_texture.getName() == "_color") {
                            _texture;
                        }
                        if (!_texture.defaultAsset) {
                            _texture.use();
                        }
                        let _texelsizeName = _id + "_TexelSize";
                        let _gltexture = _texture.glTexture;
                        if (_gltexture != null && this.defaultMapUniform[_texelsizeName] != null) {
                            this.setVector4(_texelsizeName, new gd3d.math.vector4(1.0 / _gltexture.width, 1.0 / _gltexture.height, _gltexture.width, _gltexture.height));
                        }
                    }
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            }
            setCubeTexture(_id, _texture) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == gd3d.render.UniformTypeEnum.CubeTexture) {
                    if (this.statedMapUniforms[_id] != null && (!this.statedMapUniforms[_id].defaultAsset)) {
                        this.statedMapUniforms[_id].unuse();
                    }
                    this.statedMapUniforms[_id] = _texture;
                    if (_texture != null) {
                        if (!_texture.defaultAsset) {
                            _texture.use();
                        }
                        let _texelsizeName = _id + "_TexelSize";
                        let _gltexture = _texture.glTexture;
                        if (_gltexture != null) {
                            this.setVector4(_texelsizeName, new gd3d.math.vector4(1.0 / _gltexture.width, 1.0 / _gltexture.height, _gltexture.width, _gltexture.height));
                        }
                    }
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            }
            draw(context, mesh, sm, basetype = "base", useGLobalLightMap = true) {
                let drawPasses = this.shader.passes[basetype + context.drawtype];
                if (drawPasses == undefined) {
                    basetype = basetype.indexOf("fog") != -1 ? "base_fog" : "base";
                    drawPasses = this.shader.passes[basetype + context.drawtype];
                    if (drawPasses == undefined) {
                        drawPasses = this.shader.passes["base" + context.drawtype];
                        if (drawPasses == undefined)
                            return;
                    }
                }
                for (var i = 0; i < drawPasses.length; i++) {
                    var pass = drawPasses[i];
                    pass.use(context.webgl);
                    this.uploadUnifoms(pass, context);
                    mesh.glMesh.bind(context.webgl, pass.program, sm.useVertexIndex);
                    if (sm.useVertexIndex < 0) {
                        if (sm.line) {
                            mesh.glMesh.drawArrayLines(context.webgl, sm.start, sm.size);
                        }
                        else {
                            mesh.glMesh.drawArrayTris(context.webgl, sm.start, sm.size);
                        }
                    }
                    else {
                        if (sm.line) {
                            mesh.glMesh.drawElementLines(context.webgl, sm.start, sm.size);
                        }
                        else {
                            mesh.glMesh.drawElementTris(context.webgl, sm.start, sm.size);
                        }
                    }
                }
            }
            Parse(assetmgr, json, bundleName = null) {
                var shaderName = json["shader"];
                var shader = assetmgr.getShader(shaderName);
                if (shader == null) {
                    console.error("shader 为空！shadername：" + shaderName + " bundleName: " + bundleName);
                }
                this.setShader(shader);
                var queue = json["queue"];
                if (queue) {
                    this.queue = queue;
                }
                var mapUniform = json["mapUniform"];
                for (var i in mapUniform) {
                    var jsonChild = mapUniform[i];
                    var _uniformType = jsonChild["type"];
                    if (_uniformType == null)
                        continue;
                    switch (_uniformType) {
                        case gd3d.render.UniformTypeEnum.Texture:
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            var _value = jsonChild["value"];
                            var _texture = assetmgr.getAssetByName(_value, bundleName);
                            if (_texture == null) {
                                console.error("Material Mapuniform Texture 无效(" + _value + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            }
                            else {
                                this.setTexture(i, _texture, _value);
                            }
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            var _value = jsonChild["value"];
                            this.setFloat(i, parseFloat(_value));
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            var tempValue = jsonChild["value"];
                            try {
                                let values = tempValue.match(framework.RegexpUtil.vector4Regexp);
                                if (values != null) {
                                    var _float4 = new gd3d.math.vector4(parseFloat(values[1]), parseFloat(values[2]), parseFloat(values[3]), parseFloat(values[4]));
                                    this.setVector4(i, _float4);
                                }
                            }
                            catch (e) {
                                console.error("Material Mapuniform float4 无效:value (" + tempValue + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            }
                            break;
                        default:
                            console.error("Material Mapuniform 无效: 未识别类型(" + jsonChild["type"] + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            break;
                    }
                }
            }
            clone() {
                let mat = new material_1(this.getName());
                mat.setShader(this.shader);
                for (var i in this.statedMapUniforms) {
                    var _uniformType = this.defaultMapUniform[i].type;
                    let value = this.statedMapUniforms[i];
                    switch (_uniformType) {
                        case gd3d.render.UniformTypeEnum.Texture:
                            mat.setTexture(i, value);
                            break;
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                            mat.setCubeTexture(i, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            mat.setFloat(i, value);
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            mat.setVector4(i, value);
                            break;
                        default:
                            break;
                    }
                }
                return mat;
            }
            save() {
                let obj = {};
                obj["shader"] = this.shader.getName();
                obj["srcshader"] = "";
                obj["mapUniform"] = {};
                for (let item in this.statedMapUniforms) {
                    let __type = this.defaultMapUniform[item].type;
                    let val = this.statedMapUniforms;
                    let jsonValue;
                    switch (__type) {
                        case gd3d.render.UniformTypeEnum.CubeTexture:
                        case gd3d.render.UniformTypeEnum.Texture:
                            jsonValue = `${val[item].name.name}`;
                            break;
                        case gd3d.render.UniformTypeEnum.Float4:
                            jsonValue = `(${val.x},${val.y},${val.z},${val.w})`;
                            break;
                        case gd3d.render.UniformTypeEnum.Float:
                            jsonValue = val;
                            break;
                        default:
                            console.warn(`无法存储未解析类型:${__type},${item}`);
                            continue;
                    }
                    obj["mapUniform"][item] = jsonValue;
                }
                return JSON.stringify(obj);
            }
        };
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], material.prototype, "name", void 0);
        __decorate([
            gd3d.reflect.Field("shader"),
            __metadata("design:type", framework.shader)
        ], material.prototype, "shader", void 0);
        material = material_1 = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], material);
        framework.material = material;
        var material_1;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let mesh = mesh_1 = class mesh {
            constructor(assetName = null) {
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.submesh = [];
                this.reading = false;
                if (!assetName) {
                    assetName = "mesh_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                if (!this.name) {
                    return null;
                }
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            dispose() {
                this.glMesh.dispose(framework.sceneMgr.app.getAssetMgr().webgl);
                this.data = null;
                delete this.submesh;
            }
            caclByteLength() {
                let total = 0;
                total += this.glMesh.caclByteLength();
                if (this.data) {
                    total += this.data.caclByteLength();
                }
                return total;
            }
            readProcess(read, data, objVF, vcount, vec10tpose, callback) {
                if (this.reading)
                    return;
                var tag = read.readUInt8();
                if (tag == 255) {
                    callback();
                    return;
                }
                if (tag == 1) {
                    if (data.pos == undefined) {
                        data.pos = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Position;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _position = new gd3d.math.vector3();
                        _position.x = read.readSingle();
                        _position.y = read.readSingle();
                        _position.z = read.readSingle();
                        data.pos.push(_position);
                    }
                }
                else if (tag == 2) {
                    if (data.color == undefined) {
                        data.color = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Color;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _color = new gd3d.math.color();
                        _color.a = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.r = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.g = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.b = gd3d.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        data.color.push(_color);
                    }
                }
                else if (tag == 3) {
                    if (data.normal == undefined) {
                        data.normal = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Normal;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _normal = new gd3d.math.vector3();
                        _normal.x = read.readSingle();
                        _normal.y = read.readSingle();
                        _normal.z = read.readSingle();
                        data.normal.push(_normal);
                    }
                }
                else if (tag == 4) {
                    if (data.uv == undefined) {
                        data.uv = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.UV0;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var uv = new gd3d.math.vector2();
                        uv.x = read.readSingle();
                        uv.y = read.readSingle();
                        data.uv.push(uv);
                    }
                }
                else if (tag == 5) {
                    if (data.uv2 == undefined) {
                        data.uv2 = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.UV1;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var uv = new gd3d.math.vector2();
                        uv.x = read.readSingle();
                        uv.y = read.readSingle();
                        data.uv2.push(uv);
                    }
                }
                else if (tag == 6) {
                    for (var i = 0; i < vcount; i++) {
                        read.readSingle();
                        read.readSingle();
                    }
                }
                else if (tag == 7) {
                    if (data.tangent == undefined) {
                        data.tangent = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.Tangent;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var tangent = new gd3d.math.vector3();
                        var x = read.readSingle();
                        var y = read.readSingle();
                        var z = read.readSingle();
                        var w = read.readSingle();
                        tangent.x = x / w;
                        tangent.y = y / w;
                        tangent.z = z / w;
                        data.tangent.push(tangent);
                    }
                }
                else if (tag == 8) {
                    for (var i = 0; i < vcount; i++) {
                        read.readSingle();
                        read.readSingle();
                    }
                }
                else if (tag == 16) {
                    var tposelen = read.readUInt8();
                    for (var i = 0; i < tposelen; i++) {
                        vec10tpose[i * 10 + 0] = read.readSingle();
                        vec10tpose[i * 10 + 1] = read.readSingle();
                        vec10tpose[i * 10 + 2] = read.readSingle();
                        vec10tpose[i * 10 + 3] = read.readSingle();
                        vec10tpose[i * 10 + 4] = read.readSingle();
                        vec10tpose[i * 10 + 5] = read.readSingle();
                        vec10tpose[i * 10 + 6] = read.readSingle();
                        vec10tpose[i * 10 + 7] = read.readSingle();
                        vec10tpose[i * 10 + 8] = read.readSingle();
                        vec10tpose[i * 10 + 9] = read.readSingle();
                    }
                }
                else if (tag == 17) {
                    if (data.blendIndex == undefined) {
                        data.blendIndex = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.BlendIndex4;
                    }
                    if (data.blendWeight == undefined) {
                        data.blendWeight = [];
                        objVF.vf = objVF.vf | gd3d.render.VertexFormatMask.BlendWeight4;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _boneIndex = new gd3d.render.number4();
                        _boneIndex.v0 = read.readUInt32();
                        _boneIndex.v1 = read.readUInt32();
                        _boneIndex.v2 = read.readUInt32();
                        _boneIndex.v3 = read.readUInt32();
                        var _boneWeight = new gd3d.render.number4();
                        _boneWeight.v0 = read.readSingle();
                        _boneWeight.v1 = read.readSingle();
                        _boneWeight.v2 = read.readSingle();
                        _boneWeight.v3 = read.readSingle();
                        data.blendIndex.push(_boneIndex);
                        data.blendWeight.push(_boneWeight);
                    }
                }
                else {
                    throw "notwrite" + tag;
                }
                this.reading = false;
                setTimeout(() => {
                    this.readProcess(read, data, objVF, vcount, vec10tpose, () => {
                        callback();
                    });
                });
            }
            readFinish(read, data, buf, objVF, webgl) {
                var subcount = read.readUInt8();
                data.trisindex = [];
                this.submesh = [];
                for (var i = 0; i < subcount; i++) {
                    var _submeshinfo = new subMeshInfo();
                    var tv = read.readUInt32();
                    var sublen = read.readUInt32();
                    _submeshinfo.start = data.trisindex.length;
                    _submeshinfo.size = sublen;
                    _submeshinfo.matIndex = i;
                    this.submesh.push(_submeshinfo);
                    for (var j = 0; j < sublen; j++) {
                        var index = read.readUInt32();
                        data.trisindex.push(index);
                    }
                }
                buf = null;
                data.originVF = objVF.vf;
                this.data = data;
                this.glMesh = new gd3d.render.glMesh();
                var vertexs = this.data.genVertexDataArray(objVF.vf);
                var indices = this.data.genIndexDataArray();
                this.glMesh.initBuffer(webgl, objVF.vf, this.data.pos.length);
                this.glMesh.uploadVertexData(webgl, vertexs);
                this.glMesh.addIndex(webgl, indices.length);
                this.glMesh.uploadIndexData(webgl, 0, indices);
                this.onReadFinish();
            }
            Parse(buf, webgl) {
                return __awaiter(this, void 0, void 0, function* () {
                    let result = yield gd3d.threading.thread.Instance.Call("meshDataHandle", buf);
                    let objVF = result.objVF;
                    let data = result.meshData;
                    data.originVF = objVF.vf;
                    this.data = new gd3d.render.meshData();
                    for (let k in data)
                        this.data[k] = data[k];
                    this.submesh = result.subMesh;
                    this.glMesh = new gd3d.render.glMesh();
                    var vertexs = this.data.genVertexDataArray(objVF.vf);
                    var indices = this.data.genIndexDataArray();
                    this.glMesh.initBuffer(webgl, objVF.vf, this.data.pos.length);
                    this.glMesh.uploadVertexData(webgl, vertexs);
                    this.glMesh.addIndex(webgl, indices.length);
                    this.glMesh.uploadIndexData(webgl, 0, indices);
                });
            }
            intersects(ray, matrix, outInfo) {
                let ishided = false;
                if (!this.submesh)
                    return ishided;
                let lastDistance = Number.MAX_VALUE;
                for (var i = 0; i < this.submesh.length; i++) {
                    var submesh = this.submesh[i];
                    if (submesh.line) {
                    }
                    else {
                        if (submesh.useVertexIndex < 0) {
                        }
                        else {
                            var t0 = gd3d.math.pool.new_vector3();
                            var t1 = gd3d.math.pool.new_vector3();
                            var t2 = gd3d.math.pool.new_vector3();
                            for (var index = submesh.start; index < submesh.size; index += 3) {
                                var p0 = this.data.pos[this.data.trisindex[index]];
                                var p1 = this.data.pos[this.data.trisindex[index + 1]];
                                var p2 = this.data.pos[this.data.trisindex[index + 2]];
                                gd3d.math.matrixTransformVector3(p0, matrix, t0);
                                gd3d.math.matrixTransformVector3(p1, matrix, t1);
                                gd3d.math.matrixTransformVector3(p2, matrix, t2);
                                let tempinfo = gd3d.math.pool.new_pickInfo();
                                var bool = ray.intersectsTriangle(t0, t1, t2, tempinfo);
                                if (bool) {
                                    if (tempinfo.distance < 0)
                                        continue;
                                    if (lastDistance > tempinfo.distance) {
                                        ishided = true;
                                        outInfo.cloneFrom(tempinfo);
                                        lastDistance = outInfo.distance;
                                        outInfo.faceId = index / 3;
                                        outInfo.subMeshId = i;
                                        var tdir = gd3d.math.pool.new_vector3();
                                        gd3d.math.vec3ScaleByNum(ray.direction, outInfo.distance, tdir);
                                        gd3d.math.vec3Add(ray.origin, tdir, outInfo.hitposition);
                                        gd3d.math.pool.delete_vector3(tdir);
                                    }
                                }
                                gd3d.math.pool.delete_pickInfo(tempinfo);
                            }
                            gd3d.math.pool.delete_vector3(t0);
                            gd3d.math.pool.delete_vector3(t1);
                            gd3d.math.pool.delete_vector3(t2);
                        }
                    }
                }
                return ishided;
            }
            clone() {
                let _result = new mesh_1(this.getName());
                var vf = this.glMesh.vertexFormat;
                var data = new gd3d.render.meshData();
                if (this.data.pos != undefined) {
                    data.pos = [];
                    for (var i = 0; i < this.data.pos.length; i++) {
                        var _position = new gd3d.math.vector3();
                        _position.x = this.data.pos[i].x;
                        _position.y = this.data.pos[i].y;
                        _position.z = this.data.pos[i].z;
                        data.pos.push(_position);
                    }
                }
                if (this.data.color != undefined) {
                    data.color = [];
                    for (var i = 0; i < this.data.color.length; i++) {
                        var _color = new gd3d.math.color();
                        _color.a = this.data.color[i].a;
                        _color.r = this.data.color[i].r;
                        _color.g = this.data.color[i].g;
                        _color.b = this.data.color[i].b;
                        data.color.push(_color);
                    }
                }
                if (this.data.normal != undefined) {
                    data.normal = [];
                    for (var i = 0; i < this.data.normal.length; i++) {
                        var _normal = new gd3d.math.vector3();
                        _normal.x = this.data.normal[i].x;
                        _normal.y = this.data.normal[i].y;
                        _normal.z = this.data.normal[i].z;
                        data.normal.push(_normal);
                    }
                }
                if (this.data.uv != undefined) {
                    data.uv = [];
                    for (var i = 0; i < this.data.uv.length; i++) {
                        var uv = new gd3d.math.vector2();
                        uv.x = this.data.uv[i].x;
                        uv.y = this.data.uv[i].y;
                        data.uv.push(uv);
                    }
                }
                if (this.data.uv2 != undefined) {
                    data.uv2 = [];
                    for (var i = 0; i < this.data.uv2.length; i++) {
                        var uv = new gd3d.math.vector2();
                        uv.x = this.data.uv2[i].x;
                        uv.y = this.data.uv2[i].y;
                        data.uv2.push(uv);
                    }
                }
                if (this.data.tangent != undefined) {
                    data.tangent = [];
                    for (var i = 0; i < this.data.tangent.length; i++) {
                        var tangent = new gd3d.math.vector3();
                        tangent.x = this.data.tangent[i].x;
                        tangent.y = this.data.tangent[i].y;
                        tangent.z = this.data.tangent[i].z;
                        data.tangent.push(tangent);
                    }
                }
                if (this.data.blendIndex != undefined) {
                    data.blendIndex = [];
                    for (var i = 0; i < this.data.blendIndex.length; i++) {
                        var _boneIndex = new gd3d.render.number4();
                        _boneIndex.v0 = this.data.blendIndex[i].v0;
                        _boneIndex.v1 = this.data.blendIndex[i].v1;
                        _boneIndex.v2 = this.data.blendIndex[i].v2;
                        _boneIndex.v3 = this.data.blendIndex[i].v3;
                        data.blendIndex.push(_boneIndex);
                    }
                }
                if (this.data.blendWeight != undefined) {
                    data.blendWeight = [];
                    for (var i = 0; i < this.data.blendWeight.length; i++) {
                        var _boneWeight = new gd3d.render.number4();
                        _boneWeight.v0 = this.data.blendWeight[i].v0;
                        _boneWeight.v1 = this.data.blendWeight[i].v1;
                        _boneWeight.v2 = this.data.blendWeight[i].v2;
                        _boneWeight.v3 = this.data.blendWeight[i].v3;
                        data.blendWeight.push(_boneWeight);
                    }
                }
                _result.submesh = [];
                for (var i = 0; i < this.submesh.length; i++) {
                    var _submeshinfo = new subMeshInfo();
                    _submeshinfo.start = this.submesh[i].start;
                    _submeshinfo.size = this.submesh[i].size;
                    _submeshinfo.matIndex = i;
                    _result.submesh.push(_submeshinfo);
                }
                data.trisindex = this.data.trisindex.slice();
                _result.data = data;
                _result.glMesh = new gd3d.render.glMesh();
                var vertexs = _result.data.genVertexDataArray(vf);
                var indices = _result.data.genIndexDataArray();
                _result.glMesh.initBuffer(framework.sceneMgr.app.getAssetMgr().webgl, vf, this.data.pos.length);
                _result.glMesh.uploadVertexData(framework.sceneMgr.app.getAssetMgr().webgl, vertexs);
                _result.glMesh.addIndex(framework.sceneMgr.app.getAssetMgr().webgl, indices.length);
                _result.glMesh.uploadIndexData(framework.sceneMgr.app.getAssetMgr().webgl, 0, indices);
                return _result;
            }
        };
        mesh = mesh_1 = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], mesh);
        framework.mesh = mesh;
        class subMeshInfo {
            constructor() {
                this.useVertexIndex = 0;
                this.line = false;
            }
        }
        framework.subMeshInfo = subMeshInfo;
        var mesh_1;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let pathasset = class pathasset {
            constructor(assetName = null) {
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.paths = [];
                this.items = [];
                this.lines = [];
                if (!assetName) {
                    assetName = "path_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse() {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            }
            dispose() {
                this.paths.length = 0;
            }
            caclByteLength() {
                if (this.paths) {
                    var length = this.paths.length;
                    var value = length * 12;
                    return value;
                }
            }
            Parse(json) {
                var type = json["type"];
                switch (type) {
                    case "once":
                        this.type = pathtype.once;
                        break;
                    case "loop":
                        this.type = pathtype.loop;
                        break;
                    case "pingpong":
                        this.type = pathtype.pingpong;
                }
                this.instertPointcount = json["insertPointcount"];
                var paths = json["path"];
                for (var key in paths) {
                    var item = new pointitem();
                    var pointnode = paths[key];
                    var pointtype = pointnode["type"];
                    switch (pointtype) {
                        case "VertexPoint":
                            item.type = epointtype.VertexPoint;
                            break;
                        case "ControlPoint":
                            item.type = epointtype.ControlPoint;
                            break;
                    }
                    var pointlocation = pointnode["point"];
                    var arr = pointlocation.split(",");
                    item.point = new gd3d.math.vector3(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]));
                    this.items.push(item);
                }
                this.getpaths();
                this.items.length = 0;
                for (var i = 0; i < this.lines.length; i++) {
                    this.lines[i].length = 0;
                }
                this.lines.length = 0;
            }
            getpaths() {
                var line = new Array();
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (i == 0) {
                        line.push(item.point);
                        this.lines.push(line);
                    }
                    else if (i == this.items.length - 1) {
                        if (this.type == pathtype.loop) {
                            if (item.type == epointtype.VertexPoint) {
                                line.push(item.point);
                                line = new Array();
                                line.push(item.point);
                                line.push(this.items[0].point);
                                this.lines.push(line);
                            }
                            else {
                                line.push(item.point);
                                line.push(this.items[0].point);
                            }
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                    else {
                        if (item.type == epointtype.VertexPoint) {
                            line.push(item.point);
                            line = new Array();
                            line.push(item.point);
                            this.lines.push(line);
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                }
                var linecount = this.lines.length;
                var pathindex = 0;
                for (var i = 0; i < linecount; i++) {
                    if (i == linecount - 1) {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / (this.instertPointcount - 1);
                            this.paths[pathindex] = this.getBeisaierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                    else {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / this.instertPointcount;
                            this.paths[pathindex] = this.getBeisaierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                }
            }
            getBeisaierPointAlongCurve(points, rate, clearflag = false) {
                var length = points.length;
                if (points.length < 2) {
                    console.log("計算貝塞爾需要超過2個點");
                    return;
                }
                if (length == 2) {
                    var out = new gd3d.math.vector3();
                    this.vec3Lerp(points[0], points[1], rate, out);
                    if (clearflag) {
                        points.length = 0;
                    }
                    return out;
                }
                var temptpoints = [];
                for (var i = 0; i < length - 1; i++) {
                    var temp = gd3d.math.pool.new_vector3();
                    this.vec3Lerp(points[i], points[i + 1], rate, temp);
                    temptpoints[i] = temp;
                }
                if (clearflag) {
                    points.length = 0;
                }
                return this.getBeisaierPointAlongCurve(temptpoints, rate, true);
            }
            vec3Lerp(start, end, lerp, out) {
                gd3d.math.vec3Subtract(end, start, out);
                gd3d.math.vec3ScaleByNum(out, lerp, out);
                gd3d.math.vec3Add(start, out, out);
            }
        };
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], pathasset.prototype, "name", void 0);
        pathasset = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], pathasset);
        framework.pathasset = pathasset;
        let pathtype;
        (function (pathtype) {
            pathtype[pathtype["once"] = 0] = "once";
            pathtype[pathtype["loop"] = 1] = "loop";
            pathtype[pathtype["pingpong"] = 2] = "pingpong";
        })(pathtype = framework.pathtype || (framework.pathtype = {}));
        let epointtype;
        (function (epointtype) {
            epointtype[epointtype["VertexPoint"] = 0] = "VertexPoint";
            epointtype[epointtype["ControlPoint"] = 1] = "ControlPoint";
        })(epointtype = framework.epointtype || (framework.epointtype = {}));
        class pointitem {
        }
        framework.pointitem = pointitem;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let prefab = class prefab {
            constructor(assetName = null) {
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "prefab_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            dispose() {
                this.trans.dispose();
                this.jsonstr = null;
            }
            caclByteLength() {
                let total = 0;
                return total;
            }
            getCloneTrans() {
                let temp = gd3d.io.cloneObj(this.trans);
                if (temp instanceof framework.transform)
                    return temp;
            }
            getCloneTrans2D() {
                let temp = gd3d.io.cloneObj(this.trans);
                if (temp instanceof framework.transform2D)
                    return temp;
            }
            apply(trans) {
                this.trans = trans;
            }
            Parse(jsonStr, assetmgr) {
                this.jsonstr = jsonStr;
                let jsonObj = JSON.parse(jsonStr);
                let type = jsonObj["type"];
                switch (type) {
                    case "transform":
                        this.trans = new framework.transform;
                        break;
                    case "transform2D":
                        this.trans = new framework.transform2D;
                        break;
                }
                if (type != null)
                    gd3d.io.deSerialize(jsonObj, this.trans, assetmgr, this.assetbundle);
            }
        };
        prefab = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], prefab);
        framework.prefab = prefab;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let rawscene = class rawscene {
            constructor(assetName = null) {
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "rawscene_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            caclByteLength() {
                let total = 0;
                return total;
            }
            resetLightMap(assetmgr) {
                this.lightmaps.length = 0;
                let lightmapCount = this.lightmapData.length;
                for (let i = 0; i < lightmapCount; i++) {
                    if (this.lightmapData[i] == null) {
                        this.lightmaps.push(null);
                    }
                    else {
                        let lightmapName = this.lightmapData[i].name;
                        let lightmap = assetmgr.getAssetByName(lightmapName);
                        if (lightmap)
                            lightmap.use();
                        this.lightmaps.push(lightmap);
                    }
                }
            }
            Parse(txt, assetmgr) {
                let _json = JSON.parse(txt);
                this.rootNode = new framework.transform();
                this.rootNode.name = this.getName();
                gd3d.io.deSerialize(_json["rootNode"], this.rootNode, assetmgr, this.assetbundle);
                this.lightmaps = [];
                this.lightmapData = _json["lightmap"];
                let lightmapCount = this.lightmapData.length;
                for (let i = 0; i < lightmapCount; i++) {
                    if (this.lightmapData[i] == null) {
                        this.lightmaps.push(null);
                    }
                    else {
                        let lightmapName = this.lightmapData[i].name;
                        let lightmap = assetmgr.getAssetByName(lightmapName, this.assetbundle);
                        if (lightmap)
                            lightmap.use();
                        this.lightmaps.push(lightmap);
                    }
                }
                let fogData = _json["fog"];
                if (fogData != undefined) {
                    this.fog = new Fog();
                    this.fog._Start = fogData["_Start"];
                    this.fog._End = fogData["_End"];
                    let cor = fogData["_Color"];
                    if (typeof (cor) == "string") {
                        let array = cor.split(",");
                        this.fog._Color = new gd3d.math.vector4(parseFloat(array[0]), parseFloat(array[1]), parseFloat(array[2]), parseFloat(array[3]));
                    }
                    else
                        this.fog._Color = cor;
                    this.fog._Density = fogData["_Density"];
                }
                let nav = _json["navmesh"];
                if (nav != undefined && nav.data != null) {
                    this.navMeshJson = nav.data;
                }
            }
            getSceneRoot() {
                return gd3d.io.cloneObj(this.rootNode);
            }
            useLightMap(scene) {
                scene.lightmaps.length = 0;
                for (let i = 0; i < this.lightmaps.length; i++) {
                    scene.lightmaps.push(this.lightmaps[i]);
                }
            }
            useFog(scene) {
                scene.fog = this.fog;
            }
            useNavMesh(scene) {
                let loaded = false;
                if (this.navMeshJson == null || this.navMeshJson == "")
                    return loaded;
                framework.NavMeshLoadManager.Instance.loadNavMeshByDate(this.navMeshJson, scene.app, () => {
                    loaded = true;
                });
                return loaded;
            }
            dispose() {
                if (this.rootNode) {
                    this.rootNode.dispose();
                }
                for (let key in this.lightmaps) {
                    this.lightmaps[key].unuse(true);
                }
            }
        };
        rawscene = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], rawscene);
        framework.rawscene = rawscene;
        class Fog {
        }
        framework.Fog = Fog;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let shader = class shader {
            constructor(assetName = null) {
                this.name = null;
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.passes = {};
                this.defaultMapUniform = {};
                this.layer = framework.RenderLayerEnum.Common;
                if (!assetName) {
                    assetName = "shader_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            dispose() {
            }
            caclByteLength() {
                let total = 0;
                return total;
            }
            parse(assetmgr, json) {
                this._parseProperties(assetmgr, json.properties);
                if (json.layer) {
                    var layer = json.layer;
                    if (layer == "transparent")
                        this.layer = framework.RenderLayerEnum.Transparent;
                    else if (layer == "overlay")
                        this.layer = framework.RenderLayerEnum.Overlay;
                    else if (layer == "common")
                        this.layer = framework.RenderLayerEnum.Common;
                }
                var passes = json.passes;
                this.passes = {};
                for (var key in passes) {
                    var passbass = passes[key];
                    var curpasses;
                    if (key == "base" || key == "lightmap" || key == "skin" || key == "quad") {
                    }
                    else if (key.indexOf("base_") == 0 || key.indexOf("lightmap_") == 0 || key.indexOf("skin_") == 0) {
                    }
                    else {
                        continue;
                    }
                    this.passes[key] = [];
                    for (var i = 0; i < passbass.length; i++) {
                        this.passes[key].push(this._parsePass(assetmgr, passbass[i], key));
                    }
                }
                if (this.passes["base"] == undefined) {
                    throw new Error("do not have base passgroup.");
                }
                this.fillUnDefUniform(this.passes["base"][0]);
            }
            _parseProperties(assetmgr, properties) {
                this.defaultMapUniform = {};
                for (var index in properties) {
                    let property = properties[index];
                    let words = property.match(framework.RegexpUtil.floatRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.rangeRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.vectorRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.textureRegexp);
                    if (words == null) {
                        alert(this.getName() + " property error! info:\n" + property);
                        return;
                    }
                    if (words != null && words.length >= 4) {
                        let key = words[1];
                        let showName = words[2];
                        let type = words[3].toLowerCase();
                        switch (type) {
                            case "float":
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float, value: parseFloat(words[4]) };
                                break;
                            case "range":
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float, value: parseFloat(words[6]), min: parseFloat(words[4]), max: parseFloat(words[5]) };
                                break;
                            case "vector":
                                let _vector = new gd3d.math.vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float4, value: _vector };
                                break;
                            case "color":
                                let _color = new gd3d.math.vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Float4, value: _color, becolor: true };
                                break;
                            case "texture":
                                this.defaultMapUniform[key] = { type: gd3d.render.UniformTypeEnum.Texture, value: assetmgr.getDefaultTexture(words[4]) };
                                break;
                            default:
                                alert(this.getName() + " property error! unknown type : " + type);
                                break;
                        }
                    }
                }
            }
            _parsePass(assetmgr, json, type) {
                var pass = new gd3d.render.glDrawPass();
                var vs = json["vs"];
                var fs = json["fs"];
                switch (json["showface"]) {
                    case "cw":
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.CW;
                        break;
                    case "ccw":
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.CCW;
                        break;
                    default:
                        pass.state_showface = gd3d.render.ShowFaceStateEnum.ALL;
                        break;
                }
                var blendmode = gd3d.render.BlendModeEnum.Close;
                switch (json["zwrite"]) {
                    case "off":
                        pass.state_zwrite = false;
                        break;
                    case "on":
                    default:
                        pass.state_zwrite = true;
                        break;
                }
                pass.state_ztest = true;
                switch (json["ztest"]) {
                    case "greater":
                        pass.state_ztest_method = gd3d.render.webglkit.GREATER;
                        break;
                    case "gequal":
                        pass.state_ztest_method = gd3d.render.webglkit.GEQUAL;
                        break;
                    case "less":
                        pass.state_ztest_method = gd3d.render.webglkit.LESS;
                        break;
                    case "equal":
                        pass.state_ztest_method = gd3d.render.webglkit.EQUAL;
                        break;
                    case "notequal":
                        pass.state_ztest_method = gd3d.render.webglkit.NOTEQUAL;
                        break;
                    case "always":
                    case "off":
                        pass.state_ztest = false;
                        break;
                    case "never":
                        pass.state_ztest_method = gd3d.render.webglkit.NEVER;
                        break;
                    case "lequal":
                    default:
                        pass.state_ztest_method = gd3d.render.webglkit.LEQUAL;
                        break;
                }
                switch (json["blendmode"]) {
                    case "add":
                        blendmode = gd3d.render.BlendModeEnum.Add;
                        break;
                    case "addpremult":
                        blendmode = gd3d.render.BlendModeEnum.Add_PreMultiply;
                        break;
                    case "blend":
                        blendmode = gd3d.render.BlendModeEnum.Blend;
                        break;
                    case "blendpremult":
                        blendmode = gd3d.render.BlendModeEnum.Blend_PreMultiply;
                        break;
                }
                pass.setAlphaBlend(blendmode);
                var program = assetmgr.shaderPool.linkProgrambyPassType(assetmgr.webgl, type, vs, fs);
                pass.setProgram(program);
                if (this.layer == framework.RenderLayerEnum.Overlay) {
                    pass.state_ztest = true;
                    pass.state_zwrite = true;
                    pass.state_ztest_method = gd3d.render.webglkit.ALWAYS;
                }
                return pass;
            }
            fillUnDefUniform(pass) {
                for (let key in pass.mapuniforms) {
                    let item = pass.mapuniforms[key];
                    if (framework.uniformSetter.autoUniformDic[item.name] == null && this.defaultMapUniform[item.name] == null) {
                        switch (item.type) {
                            case gd3d.render.UniformTypeEnum.Float:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float, value: 0 };
                                break;
                            case gd3d.render.UniformTypeEnum.Floatv:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4x4v, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Float4:
                                if (item.name.indexOf("_ST") >= 0 || item.name.indexOf("_st") >= 0) {
                                    this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4, value: new gd3d.math.vector4(1, 1, 0, 0) };
                                }
                                else {
                                    this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4, value: new gd3d.math.vector4(1, 1, 1, 1) };
                                }
                                break;
                            case gd3d.render.UniformTypeEnum.Float4v:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4v, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Float4x4:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4x4, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Float4x4v:
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Float4x4v, value: null };
                                break;
                            case gd3d.render.UniformTypeEnum.Texture:
                                let tex = framework.sceneMgr.app.getAssetMgr().getDefaultTexture("white");
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.Texture, value: tex };
                                break;
                            case gd3d.render.UniformTypeEnum.CubeTexture:
                                let cubetex = framework.sceneMgr.app.getAssetMgr().getDefaultCubeTexture("white");
                                this.defaultMapUniform[item.name] = { type: gd3d.render.UniformTypeEnum.CubeTexture, value: cubetex };
                                break;
                        }
                    }
                }
            }
        };
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], shader.prototype, "name", void 0);
        shader = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], shader);
        framework.shader = shader;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let sprite = class sprite {
            constructor(assetName = null) {
                this.id = new framework.resID();
                this.border = new gd3d.math.border();
                if (!assetName) {
                    assetName = "sprite_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            dispose() {
                if (this.texture != null) {
                    this.texture.unuse(true);
                }
            }
            caclByteLength() {
                let total = 0;
                if (this._texture) {
                    total += this._texture.caclByteLength();
                }
                return total;
            }
            get texture() {
                return this._texture;
            }
            set texture(value) {
                if (this._texture != null) {
                    this._texture.unuse();
                }
                this._texture = value;
                this._texture.use();
            }
            get urange() {
                if (this._urange == null) {
                    this._urange = new gd3d.math.vector2();
                    this._urange.x = this.rect.x / this._texture.glTexture.width;
                    this._urange.y = (this.rect.x + this.rect.w) / this._texture.glTexture.width;
                }
                return this._urange;
            }
            get vrange() {
                if (this._vrange == null) {
                    this._vrange = new gd3d.math.vector2();
                    this._vrange.x = this.rect.y / this._texture.glTexture.height;
                    this._vrange.y = (this.rect.y + this.rect.h) / this._texture.glTexture.height;
                }
                return this._vrange;
            }
        };
        sprite = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], sprite);
        framework.sprite = sprite;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let textasset = class textasset {
            constructor(assetName = null) {
                this.id = new framework.resID();
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "texture_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse() {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            }
            dispose() {
                this.content == null;
            }
            caclByteLength() {
                if (this.content) {
                    return gd3d.math.caclStringByteLength(this.content);
                }
            }
        };
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], textasset.prototype, "name", void 0);
        textasset = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], textasset);
        framework.textasset = textasset;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let texture = class texture {
            constructor(assetName = null) {
                this.id = new framework.resID();
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "texture_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            getName() {
                return this.name.getText();
            }
            getGUID() {
                return this.id.getID();
            }
            use() {
                framework.sceneMgr.app.getAssetMgr().use(this);
            }
            unuse(disposeNow = false) {
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            }
            dispose() {
                if (this && this.glTexture) {
                    this.glTexture.dispose(framework.sceneMgr.app.getAssetMgr().webgl);
                }
            }
            caclByteLength() {
                if (this.glTexture) {
                    return this.glTexture.caclByteLength();
                }
            }
            get realName() {
                return this._realName;
            }
            set realName(name) {
                this._realName = name;
            }
        };
        __decorate([
            gd3d.reflect.Field("constText"),
            __metadata("design:type", framework.constText)
        ], texture.prototype, "name", void 0);
        texture = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [String])
        ], texture);
        framework.texture = texture;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class AudioEx {
            constructor() {
                try {
                    var _AudioContext = window["AudioContext"] || window["webkitAudioContext"] || window["mozAudioContext"] || window["msAudioContext"];
                    this.audioContext = new _AudioContext();
                    console.log("audio Context inited");
                }
                catch (e) {
                    console.error("!Your browser does not support AudioContext");
                }
            }
            static instance() {
                if (AudioEx.g_this == null)
                    AudioEx.g_this = new AudioEx();
                return AudioEx.g_this;
            }
            clickInit() {
                if (!this.isAvailable())
                    return;
                if (this.audioContext != null) {
                    var buffer = this.audioContext.createBuffer(1, 1, 22050);
                    var source = this.audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(this.audioContext.destination);
                    source.start();
                }
            }
            loadAudioBufferFromArrayBuffer(ab, fun) {
                this.audioContext.decodeAudioData(ab, (audiobuffer) => {
                    fun(audiobuffer, null);
                });
            }
            loadAudioBuffer(url, fun) {
                AudioEx.loadArrayBuffer(url, (_ab, __err) => {
                    if (__err != null)
                        fun(null, __err);
                    else {
                        this.audioContext.decodeAudioData(_ab, (audiobuffer) => {
                            fun(audiobuffer, null);
                        });
                    }
                });
            }
            isAvailable() {
                return this.audioContext ? true : false;
            }
            createAudioChannel(be3DSound) {
                if (!this.audioContext)
                    return;
                var cc = new AudioChannel();
                cc.source = this.audioContext.createBufferSource();
                cc.gainNode = this.audioContext.createGain();
                cc.source.connect(cc.gainNode);
                if (be3DSound) {
                    cc.pannerNode = this.audioContext.createPanner();
                    cc.gainNode.connect(cc.pannerNode);
                    cc.pannerNode.connect(this.audioContext.destination);
                }
                else {
                    cc.gainNode.connect(this.audioContext.destination);
                }
                cc.gainNode.gain.value = 1;
                return cc;
            }
            static loadArrayBuffer(url, fun) {
                var req = new XMLHttpRequest();
                req.open("GET", url);
                req.responseType = "arraybuffer";
                req.onreadystatechange = () => {
                    if (req.readyState == 4) {
                        if (req.status == 404)
                            fun(null, new Error("onerr 404"));
                        else
                            fun(req.response, null);
                    }
                };
                req.onerror = () => {
                    fun(null, new Error("onerr in req:"));
                };
                req.send();
            }
        }
        framework.AudioEx = AudioEx;
        class AudioChannel {
            get volume() {
                return this.gainNode.gain.value;
            }
            set volume(val) {
                val = val > 1 ? 1 : val;
                val = val <= 0 ? 0 : val;
                this.gainNode.gain.value = val;
            }
            stop() {
                if (this.source != null) {
                    this.source.stop();
                    this.source = null;
                }
                this.isplay = false;
            }
        }
        framework.AudioChannel = AudioChannel;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let aniplayer = aniplayer_1 = class aniplayer {
            constructor() {
                this._clipnameCount = 0;
                this._clipnames = null;
                this.autoplay = true;
                this.playIndex = 0;
                this._playClip = null;
                this.tpose = {};
                this.nowpose = {};
                this.lerppose = {};
                this.carelist = {};
                this._playFrameid = 0;
                this._playTimer = 0;
                this.speed = 1.0;
                this.crossdelta = 0;
                this.crossspeed = 0;
                this.beRevert = false;
                this.playStyle = PlayStyle.NormalPlay;
                this.percent = 0;
                this.mix = false;
                this.isCache = false;
                this._playCount = 0;
            }
            get clipnames() {
                if (this._clipnames == null || this._clipnameCount != this.clips.length) {
                    this._clipnameCount = this.clips.length;
                    this._clipnames = {};
                    for (let key in this.clips) {
                        if (this.clips[key])
                            this.clipnames[this.clips[key].getName()] = parseInt(key);
                    }
                }
                return this._clipnames;
            }
            get PlayFrameID() {
                return this._playFrameid;
            }
            get playCount() { return this._playCount; }
            get cacheKey() {
                if (this._playClip)
                    return this._playClip.getGUID() + "_" + this._playFrameid;
                return this._playFrameid;
            }
            init() {
                for (let i = 0; i < this.bones.length; i++) {
                    let _info = this.bones[i];
                    let name = _info.name;
                    var nb = new framework.PoseBoneMatrix();
                    nb.r = _info.tposeq;
                    nb.t = _info.tposep;
                    nb.invert();
                    this.tpose[name] = nb;
                    this.nowpose[name] = this.startPos[i].Clone();
                }
                let asbones = this.gameObject.getComponentsInChildren("asbone");
                for (let key in asbones) {
                    this.care(asbones[key].gameObject.transform);
                }
                if (this.autoplay && this.clips != null && this.clips.length > 0) {
                    this.playByIndex(this.playIndex);
                }
            }
            start() {
                if (this.bones != null) {
                    this.init();
                }
            }
            onPlay() {
            }
            update(delta) {
                if (this._playClip == null)
                    return;
                this.checkFrameId(delta);
                this.mix = false;
                if (this.crossdelta > 0) {
                    this.crossdelta -= delta / this.speed * this.crossspeed;
                    this.mix = true;
                }
                let cached = false;
                if (this.isCache && !this.mix && aniplayer_1.playerCaches[this.cacheKey]) {
                    cached = true;
                    if (framework.StringUtil.isNullOrEmptyObject(this.carelist))
                        return;
                }
                for (var i = 0; i < this._playClip.boneCount; i++) {
                    var bone = this._playClip.bones[i];
                    if (cached && !this.carelist[bone])
                        continue;
                    var frame;
                    if (this._playClip != null && this._playClip.frames != null) {
                        frame = this._playClip.frames[this._playFrameid];
                    }
                    else {
                        console.warn("is null of animationclip.frames! ");
                        return;
                    }
                    var nextseek = i * 7 + 1;
                    var outb = this.nowpose[bone];
                    var tpose = this.tpose[bone];
                    if (outb != undefined || frame == null) {
                        if (this.mix) {
                            var last = this.lerppose[bone];
                            if (last != undefined) {
                                outb.lerpInWorldWithData(tpose, last, frame, nextseek, 1 - this.crossdelta);
                            }
                            else {
                                outb.copyFromData(frame, nextseek);
                            }
                        }
                        else {
                            outb.copyFromData(frame, nextseek);
                        }
                    }
                    var careobj = this.carelist[bone];
                    if (careobj != undefined) {
                        let fmat = framework.PoseBoneMatrix.sMultiply(outb, tpose);
                        let _matrix = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMakeTransformRTS(fmat.t, gd3d.math.pool.vector3_one, fmat.r, _matrix);
                        let _newmatrix = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(this.gameObject.transform.getWorldMatrix(), _matrix, _newmatrix);
                        careobj.setWorldMatrix(_newmatrix);
                        careobj.updateTran(false);
                        gd3d.math.pool.delete_matrix(_matrix);
                        gd3d.math.pool.delete_matrix(_newmatrix);
                    }
                }
                if (!cached) {
                    aniplayer_1.playerCaches[this.cacheKey] = this;
                }
            }
            playByIndex(animIndex, speed = 1.0, beRevert = false) {
                this.playIndex = animIndex;
                if (this.clips.length <= animIndex) {
                    console.error("animIndex out Array of clips");
                    return;
                }
                this.playAniamtion(animIndex.toString(), speed, beRevert);
                this.crossdelta = 0;
            }
            playCrossByIndex(animIndex, crosstimer, speed = 1.0, beRevert = false) {
                this.playIndex = animIndex;
                if (this.clips.length <= animIndex) {
                    console.error("animIndex out Array of clips");
                    return;
                }
                this.playAniamtion(animIndex.toString(), speed, beRevert);
                this.crossspeed = 1.0 / crosstimer;
                this.crossdelta = 1;
            }
            play(animName, speed = 1.0, beRevert = false) {
                if (this.clipnames[animName] == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                this.playByIndex(this.clipnames[animName], speed, beRevert);
            }
            getPlayName() {
                if (this.isPlay())
                    return this._playClip.getName();
            }
            playCross(animName, crosstimer, speed = 1.0, beRevert = false) {
                if (this.clipnames[animName] == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                if (crosstimer <= 0) {
                    this.playByIndex(this.clipnames[animName], speed, beRevert);
                }
                else {
                    this.playCrossByIndex(this.clipnames[animName], crosstimer, speed, beRevert);
                }
            }
            playAniamtion(index, speed = 1.0, beRevert = false) {
                if (this.clips[index] == undefined)
                    return;
                this._playClip = this.clips[index];
                this._playTimer = 0;
                this._playFrameid = 0;
                this._playCount;
                this.speed = speed;
                this.beRevert = beRevert;
                this.playStyle = PlayStyle.NormalPlay;
                this.speed = speed;
                this.lerppose = {};
                for (var key in this.nowpose) {
                    var src = this.nowpose[key];
                    this.lerppose[key] = src.Clone();
                }
            }
            updateAnimation(animIndex, _frame) {
                if (!this.clips)
                    return;
                if (animIndex >= this.clips.length)
                    return;
                let _clip = this.clips[animIndex];
                if (!_clip)
                    return;
                for (var i = 0; i < _clip.boneCount; i++) {
                    var bone = _clip.bones[i];
                    var frame = _clip.frames[_frame];
                    var nextseek = i * 7 + 1;
                    var outb = this.nowpose[bone];
                    var tpose = this.tpose[bone];
                    if (outb != undefined) {
                        outb.copyFromData(frame, nextseek);
                    }
                    var careobj = this.carelist[bone];
                    if (careobj != undefined) {
                        let fmat = framework.PoseBoneMatrix.sMultiply(outb, tpose);
                        let _matrix = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMakeTransformRTS(fmat.t, gd3d.math.pool.vector3_one, fmat.r, _matrix);
                        let _newmatrix = gd3d.math.pool.new_matrix();
                        gd3d.math.matrixMultiply(this.gameObject.transform.getWorldMatrix(), _matrix, _newmatrix);
                        careobj.setWorldMatrix(_newmatrix);
                        careobj.updateTran(false);
                        gd3d.math.pool.delete_matrix(_matrix);
                        gd3d.math.pool.delete_matrix(_newmatrix);
                    }
                }
                let renders = this.gameObject.getComponentsInChildren(framework.StringUtil.COMPONENT_SKINMESHRENDER);
                for (let key in renders) {
                    let _render = renders[key];
                    _render.update(0);
                }
            }
            stop() {
                this._playClip = null;
            }
            isPlay() {
                return this._playClip != null;
            }
            isStop() {
                if (this._playClip == null)
                    return false;
                if (this.playStyle != PlayStyle.NormalPlay)
                    return false;
                if (this._playClip.loop)
                    return false;
                if (this._playFrameid == this._playClip.frameCount - 1)
                    return true;
                return false;
            }
            remove() {
                if (this.clips)
                    this.clips.forEach(temp => {
                        if (temp)
                            temp.unuse();
                    });
                this.clips.length = 0;
                this.bones.length = 0;
                this.startPos.length = 0;
                this._playClip = null;
                delete this.tpose;
                delete this.nowpose;
                delete this.lerppose;
                delete this.carelist;
                delete this._clipnames;
            }
            clone() {
            }
            addFinishedEventListener(finishCallBack, thisObject) {
                this.finishCallBack = finishCallBack;
                this.thisObject = thisObject;
            }
            checkFrameId(delay) {
                if (this.playStyle == PlayStyle.NormalPlay) {
                    this._playTimer += delay * this.speed;
                    this._playFrameid = (this._playClip.fps * this._playTimer) | 0;
                    if (this._playClip.loop) {
                        this._playCount += Math.floor(this._playFrameid / this._playClip.frameCount);
                        this._playFrameid %= this._playClip.frameCount;
                    }
                    else if (this._playFrameid > this._playClip.frameCount - 1) {
                        this._playFrameid = this._playClip.frameCount - 1;
                    }
                    if (this.beRevert) {
                        this._playFrameid = this._playClip.frameCount - this._playFrameid - 1;
                    }
                }
                else if (this.playStyle == PlayStyle.FramePlay) {
                    this._playFrameid = (this._playClip.frameCount * this.percent) - 1;
                    this._playFrameid = Math.round(this._playFrameid);
                }
                if (this._playFrameid < 0) {
                    this._playFrameid = 0;
                }
                if (this._playFrameid > this._playClip.frameCount - 1) {
                    this._playFrameid = this._playClip.frameCount - 1;
                }
                if (this.isStop()) {
                    if (this.finishCallBack) {
                        this.finishCallBack(this.thisObject);
                        this.finishCallBack = null;
                        this.thisObject = null;
                    }
                }
            }
            fillPoseData(data, bones, efficient = true) {
                var seek = 0;
                for (var i in bones) {
                    var key = bones[i].name;
                    var obj = this.nowpose[key];
                    if (obj == undefined) {
                        if (efficient) {
                            data[seek * 8 + 0] = 0;
                            data[seek * 8 + 1] = 0;
                            data[seek * 8 + 2] = 0;
                            data[seek * 8 + 3] = 1;
                            data[seek * 8 + 4] = 0;
                            data[seek * 8 + 5] = 0;
                            data[seek * 8 + 6] = 0;
                            data[seek * 8 + 7] = 1;
                        }
                        else {
                            data[seek * 16 + 0] = 1;
                            data[seek * 16 + 1] = 0;
                            data[seek * 16 + 2] = 0;
                            data[seek * 16 + 3] = 0;
                            data[seek * 16 + 4] = 0;
                            data[seek * 16 + 5] = 1;
                            data[seek * 16 + 6] = 0;
                            data[seek * 16 + 7] = 0;
                            data[seek * 16 + 8] = 0;
                            data[seek * 16 + 9] = 0;
                            data[seek * 16 + 10] = 1;
                            data[seek * 16 + 11] = 0;
                            data[seek * 16 + 12] = 0;
                            data[seek * 16 + 13] = 0;
                            data[seek * 16 + 14] = 0;
                            data[seek * 16 + 15] = 1;
                        }
                    }
                    else {
                        let _mat = gd3d.math.pool.new_matrix();
                        if (efficient) {
                            data[seek * 8 + 0] = obj.r.x;
                            data[seek * 8 + 1] = obj.r.y;
                            data[seek * 8 + 2] = obj.r.z;
                            data[seek * 8 + 3] = obj.r.w;
                            data[seek * 8 + 4] = obj.t.x;
                            data[seek * 8 + 5] = obj.t.y;
                            data[seek * 8 + 6] = obj.t.z;
                            data[seek * 8 + 7] = 1;
                        }
                        else {
                            gd3d.math.matrixMakeTransformRTS(obj.t, gd3d.math.pool.vector3_one, obj.r, _mat);
                            for (var j = 0; j < 16; j++) {
                                data[seek * 16 + j] = _mat.rawData[j];
                            }
                        }
                        gd3d.math.pool.delete_matrix(_mat);
                    }
                    seek++;
                }
            }
            care(node) {
                var pnode = node;
                while (true) {
                    if (this.nowpose[pnode.name] != undefined) {
                        this.carelist[pnode.name] = pnode;
                        return;
                    }
                    if (pnode.parent)
                        pnode = pnode.parent;
                    else
                        return;
                }
            }
        };
        aniplayer.playerCaches = [];
        __decorate([
            gd3d.reflect.Field("animationClip[]"),
            __metadata("design:type", Array)
        ], aniplayer.prototype, "clips", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], aniplayer.prototype, "autoplay", void 0);
        __decorate([
            gd3d.reflect.Field("tPoseInfo[]"),
            __metadata("design:type", Array)
        ], aniplayer.prototype, "bones", void 0);
        __decorate([
            gd3d.reflect.Field("PoseBoneMatrix[]"),
            __metadata("design:type", Array)
        ], aniplayer.prototype, "startPos", void 0);
        aniplayer = aniplayer_1 = __decorate([
            gd3d.reflect.nodeComponent
        ], aniplayer);
        framework.aniplayer = aniplayer;
        let tPoseInfo = class tPoseInfo {
        };
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], tPoseInfo.prototype, "name", void 0);
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], tPoseInfo.prototype, "tposep", void 0);
        __decorate([
            gd3d.reflect.Field("quaternion"),
            __metadata("design:type", gd3d.math.quaternion)
        ], tPoseInfo.prototype, "tposeq", void 0);
        tPoseInfo = __decorate([
            gd3d.reflect.SerializeType
        ], tPoseInfo);
        framework.tPoseInfo = tPoseInfo;
        let PlayStyle;
        (function (PlayStyle) {
            PlayStyle[PlayStyle["NormalPlay"] = 0] = "NormalPlay";
            PlayStyle[PlayStyle["FramePlay"] = 1] = "FramePlay";
            PlayStyle[PlayStyle["PingPang"] = 2] = "PingPang";
        })(PlayStyle = framework.PlayStyle || (framework.PlayStyle = {}));
        var aniplayer_1;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let asbone = class asbone {
            constructor() {
            }
            start() {
            }
            onPlay() {
            }
            update(delta) {
            }
            remove() {
            }
            clone() {
            }
        };
        asbone = __decorate([
            gd3d.reflect.nodeComponent,
            __metadata("design:paramtypes", [])
        ], asbone);
        framework.asbone = asbone;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let AudioListener = class AudioListener {
            constructor() {
                this.lastX = 0;
                this.lastY = 0;
                this.lastZ = 0;
            }
            start() {
                this.listener = framework.AudioEx.instance().audioContext.listener;
            }
            onPlay() {
            }
            update(delta) {
                this.curPos = this.gameObject.transform.getWorldTranslate();
                if (this.curPos.x != this.lastX || this.curPos.y != this.lastY || this.curPos.z != this.lastZ) {
                    this.listener.setPosition(this.curPos.x, this.curPos.y, this.curPos.z);
                    this.lastX = this.curPos.x;
                    this.lastY = this.curPos.y;
                    this.lastZ = this.curPos.z;
                }
            }
            remove() {
            }
            clone() {
            }
        };
        AudioListener = __decorate([
            gd3d.reflect.nodeComponent
        ], AudioListener);
        framework.AudioListener = AudioListener;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let AudioPlayer = class AudioPlayer {
            constructor() {
                this.be3DSound = true;
                this.lastX = 0;
                this.lastY = 0;
                this.lastZ = 0;
            }
            play(buffer, beLoop = false, volume = 0, onended) {
                if (this.audioChannel != null) {
                    if (this.audioChannel.isplay) {
                        this.stop();
                    }
                    this.audioChannel = null;
                }
                if (!(this.audioChannel = framework.AudioEx.instance().createAudioChannel(this.be3DSound)))
                    return;
                this.buffer = buffer;
                this.volume = volume;
                var c = this.audioChannel;
                c.source.loop = this.beLoop;
                c.source.buffer = this.buffer;
                c.volume = this.volume;
                c.source.start();
                c.isplay = true;
                if (!this.beLoop) {
                    c.source.onended = () => {
                        c.isplay = false;
                        c.source = null;
                        if (onended != undefined)
                            onended();
                    };
                }
            }
            stop() {
                if (this.audioChannel != null) {
                    this.audioChannel.stop();
                }
            }
            get volume() {
                return this.audioChannel == null ? -1 : this.audioChannel.volume;
            }
            set volume(val) {
                this.audioChannel == null ? 0 : this.audioChannel.volume = val;
            }
            isPlaying() {
                return this.audioChannel == undefined ? false : this.audioChannel.isplay;
            }
            start() {
                this.audioChannel = framework.AudioEx.instance().createAudioChannel(this.be3DSound);
            }
            onPlay() {
            }
            update(delta) {
                this.curPos = this.gameObject.transform.getWorldTranslate();
                if (this.audioChannel && (this.curPos.x != this.lastX || this.curPos.y != this.lastY || this.curPos.z != this.lastZ)) {
                    this.audioChannel.pannerNode.setPosition(this.curPos.x, this.curPos.y, this.curPos.z);
                    this.lastX = this.curPos.x;
                    this.lastY = this.curPos.y;
                    this.lastZ = this.curPos.z;
                }
            }
            remove() {
            }
            clone() {
            }
        };
        AudioPlayer = __decorate([
            gd3d.reflect.nodeComponent
        ], AudioPlayer);
        framework.AudioPlayer = AudioPlayer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let BeBillboard = class BeBillboard {
            constructor() {
                this.beActive = true;
                this.target = null;
            }
            start() {
            }
            onPlay() {
            }
            update(delta) {
                if (!this.beActive || this.target == null)
                    return;
                this.gameObject.transform.lookat(this.target);
            }
            remove() {
            }
            clone() {
            }
            setActive(active) {
                this.beActive = active;
            }
            setTarget(trans) {
                this.target = trans;
            }
        };
        BeBillboard = __decorate([
            gd3d.reflect.nodeComponent
        ], BeBillboard);
        framework.BeBillboard = BeBillboard;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class behaviour {
            start() {
            }
            onPlay() {
            }
            update(delta) {
            }
            remove() {
            }
            clone() {
            }
        }
        framework.behaviour = behaviour;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let bloomctr = class bloomctr {
            constructor() {
                this._bloomIntensity = 1.4;
                this._bloomThreshold = 0.5;
                this._blurSpread = 3;
                this.tag = "__bloomtag__";
                this._init = false;
            }
            get bloomThreshold() { return this._bloomThreshold; }
            ;
            set bloomThreshold(value) {
                this._bloomThreshold = value;
                if (!this.material || !this.material_1 || !this.material_2)
                    return;
                this.material.setFloat("_bloomThreshold", this._bloomThreshold);
            }
            get bloomIntensity() { return this._bloomIntensity; }
            ;
            set bloomIntensity(value) {
                this._bloomIntensity = value;
                if (!this.material || !this.material_3)
                    return;
                this.material_3.setFloat("_bloomIntensity", this._bloomIntensity);
            }
            get blurSpread() { return this._blurSpread; }
            ;
            set blurSpread(value) {
                this._blurSpread = value;
                if (!this.material_1 || !this.material_2)
                    return;
                let v4_1 = gd3d.math.pool.new_vector4();
                let v4_2 = gd3d.math.pool.new_vector4();
                v4_1.x = value;
                v4_1.y = 0;
                v4_2.x = 0;
                v4_2.y = value;
                this.material_1.setVector4("_blurSpread", v4_1);
                this.material_2.setVector4("_blurSpread", v4_2);
            }
            init() {
                let sh = this.scene.app.getAssetMgr().getShader("bloom.shader.json");
                if (!sh) {
                    console.warn(`bloom.shader.json not find`);
                    return;
                }
                let psize = 1024;
                var color = new framework.cameraPostQueue_Color();
                color[this.tag] = true;
                color.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                if (!this.camera.postQueues)
                    this.camera.postQueues = [];
                this.camera.postQueues.push(color);
                var textcolor = new framework.texture("_color");
                textcolor.glTexture = color.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material = post0.material;
                this.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", textcolor);
                post0.material.setFloat("_bloomIntensity", 1.2);
                post0.material.setFloat("_bloomThreshold", this._bloomThreshold);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(0, 0, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                var threTex = new framework.texture("_threshold");
                threTex.glTexture = post0.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material_1 = post0.material;
                this.material_1.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", threTex);
                post0.material.setTexture("_BlurTex", threTex);
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 1.0);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(this._blurSpread, 0, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                var hBlur = new framework.texture("_blur0");
                hBlur.glTexture = post0.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material_2 = post0.material;
                this.material_2.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", hBlur);
                post0.material.setTexture("_BlurTex", hBlur);
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 1.0);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(0, this._blurSpread, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                var hvBlur = new framework.texture("_blur1");
                hvBlur.glTexture = post0.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                post0[this.tag] = true;
                this.material_3 = post0.material;
                post0.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", hvBlur);
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 0.5);
                post0.material.setVector4("_blurSpread", new gd3d.math.vector4(0.5, 0.5, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                this._init = true;
            }
            start() {
                this.app = this.gameObject.transform.scene.app;
                this.scene = this.app.getScene();
            }
            onPlay() {
            }
            update(delta) {
                if (this._init)
                    return;
                if (!this.camera)
                    this.camera = this.gameObject.getComponent("camera");
                if (this.camera)
                    this.init();
            }
            remove() {
                this._init = false;
                if (this.camera) {
                    let arr = this.camera.postQueues;
                    let dArr = [];
                    for (var i = 0; i < arr.length; i++) {
                        let temp = arr[i];
                        if (temp[this.tag]) {
                            dArr.push(temp);
                        }
                    }
                    dArr.forEach(element => {
                        if (element) {
                            let idx = arr.indexOf(element);
                            if (idx != -1) {
                                arr.splice(idx, 1);
                            }
                        }
                    });
                }
                if (this.material) {
                    this.material.unuse();
                    this.material = null;
                }
                if (this.material_1) {
                    this.material_1.unuse();
                    this.material_1 = null;
                }
                if (this.material_2) {
                    this.material_2.unuse();
                    this.material_2 = null;
                }
                if (this.material_3) {
                    this.material_3.unuse();
                    this.material_3 = null;
                }
            }
            clone() {
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], bloomctr.prototype, "bloomThreshold", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], bloomctr.prototype, "bloomIntensity", null);
        bloomctr = __decorate([
            gd3d.reflect.nodeComponent
        ], bloomctr);
        framework.bloomctr = bloomctr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class cameraPostQueue_Depth {
            constructor() {
                this.renderTarget = null;
            }
            render(scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                context.webgl.depthMask(true);
                gd3d.render.glDrawPass.lastZWrite = true;
                context.webgl.clearColor(0, 0, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                camera._renderOnce(scene, context, "_depth");
                gd3d.render.glRenderTarget.useNull(context.webgl);
            }
        }
        framework.cameraPostQueue_Depth = cameraPostQueue_Depth;
        class cameraPostQueue_Quad {
            constructor() {
                this.renderTarget = null;
                this.material = new framework.material();
            }
            render(scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                context.webgl.depthMask(true);
                gd3d.render.glDrawPass.lastZWrite = true;
                context.webgl.clearColor(0, 0.3, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                var mesh = scene.app.getAssetMgr().getDefaultMesh("quad");
                context.drawtype = "";
                mesh.glMesh.bindVboBuffer(context.webgl);
                this.material.draw(context, mesh, mesh.submesh[0], "quad");
            }
        }
        framework.cameraPostQueue_Quad = cameraPostQueue_Quad;
        class cameraPostQueue_Color {
            constructor() {
                this.renderTarget = null;
            }
            render(scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, false);
                camera._renderOnce(scene, context, "");
                gd3d.render.glRenderTarget.useNull(context.webgl);
            }
        }
        framework.cameraPostQueue_Color = cameraPostQueue_Color;
        let camera = class camera {
            constructor() {
                this._near = 0.01;
                this._far = 1000;
                this.CullingMask = framework.CullingMask.everything ^ framework.CullingMask.editor;
                this._contextIdx = -1;
                this.clearOption_Color = true;
                this.clearOption_Depth = true;
                this.backgroundColor = new gd3d.math.color(0.5, 0.8, 1, 1);
                this.viewport = new gd3d.math.rect(0, 0, 1, 1);
                this.renderTarget = null;
                this.order = 0;
                this.overlays = [];
                this.matView = new gd3d.math.matrix;
                this.matProjP = new gd3d.math.matrix;
                this.matProjO = new gd3d.math.matrix;
                this.matProj = new gd3d.math.matrix;
                this.frameVecs = [];
                this.fov = 60 * Math.PI / 180;
                this.size = 2;
                this._opvalue = 1;
                this.postQueues = [];
            }
            get near() {
                return this._near;
            }
            set near(val) {
                if (this.opvalue > 0) {
                    if (val < 0.01)
                        val = 0.01;
                }
                if (val >= this.far)
                    val = this.far - 0.01;
                this._near = val;
            }
            get far() {
                return this._far;
            }
            set far(val) {
                if (val <= this.near)
                    val = this.near + 0.01;
                this._far = val;
            }
            get CurrContextIndex() { return this._contextIdx; }
            markDirty() {
            }
            start() {
            }
            onPlay() {
            }
            update(delta) {
                for (var i = 0; i < this.overlays.length; i++) {
                    if (!this.overlays[i].init) {
                        this.overlays[i].start(this);
                        this.overlays[i].init = true;
                    }
                    this.overlays[i].update(delta);
                }
            }
            addOverLay(overLay) {
                this.overlays.push(overLay);
                this.sortOverLays(this.overlays);
            }
            getOverLays() {
                return this.overlays;
            }
            removeOverLay(overLay) {
                if (this.overlays == null)
                    return;
                let index = this.overlays.indexOf(overLay);
                if (index >= 0)
                    this.overlays.splice(index, 1);
                this.sortOverLays(this.overlays);
            }
            sortOverLays(lays) {
                if (!lays || lays.length < 1)
                    return;
                lays.sort((a, b) => {
                    return a.sortOrder - b.sortOrder;
                });
            }
            calcViewMatrix(matrix) {
                var camworld = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixInverse(camworld, this.matView);
                gd3d.math.matrixClone(this.matView, matrix);
                return;
            }
            calcViewPortPixel(app, viewPortPixel) {
                var w;
                var h;
                if (this.renderTarget == null) {
                    w = app.width;
                    h = app.height;
                }
                else {
                    w = this.renderTarget.width;
                    h = this.renderTarget.height;
                }
                viewPortPixel.x = w * this.viewport.x;
                viewPortPixel.y = h * this.viewport.y;
                viewPortPixel.w = w * this.viewport.w;
                viewPortPixel.h = h * this.viewport.h;
            }
            calcProjectMatrix(asp, matrix) {
                if (this.opvalue > 0)
                    gd3d.math.matrixProject_PerspectiveLH(this.fov, asp, this.near, this.far, this.matProjP);
                if (this.opvalue < 1)
                    gd3d.math.matrixProject_OrthoLH(this.size * asp, this.size, this.near, this.far, this.matProjO);
                if (this.opvalue == 0)
                    gd3d.math.matrixClone(this.matProjO, this.matProj);
                else if (this.opvalue == 1)
                    gd3d.math.matrixClone(this.matProjP, this.matProj);
                else
                    gd3d.math.matrixLerp(this.matProjO, this.matProjP, this.opvalue, this.matProj);
                gd3d.math.matrixClone(this.matProj, matrix);
            }
            creatRayByScreen(screenpos, app) {
                var src1 = gd3d.math.pool.new_vector3();
                src1.x = screenpos.x;
                src1.y = screenpos.y;
                src1.z = 0;
                var src2 = gd3d.math.pool.new_vector3();
                src2.x = screenpos.x;
                src2.y = screenpos.y;
                src2.z = 1;
                var dest1 = gd3d.math.pool.new_vector3();
                var dest2 = gd3d.math.pool.new_vector3();
                this.calcWorldPosFromScreenPos(app, src1, dest1);
                this.calcWorldPosFromScreenPos(app, src2, dest2);
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(dest2, dest1, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var ray = new gd3d.framework.ray(dest1, dir);
                gd3d.math.pool.delete_vector3(src1);
                gd3d.math.pool.delete_vector3(src2);
                gd3d.math.pool.delete_vector3(dest1);
                gd3d.math.pool.delete_vector3(dest2);
                gd3d.math.pool.delete_vector3(dir);
                return ray;
            }
            calcWorldPosFromScreenPos(app, screenPos, outWorldPos) {
                var vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, vpp);
                var vppos = new gd3d.math.vector2(screenPos.x / vpp.w * 2 - 1, 1 - screenPos.y / vpp.h * 2);
                var matrixView = new gd3d.math.matrix();
                var matrixProject = new gd3d.math.matrix();
                var asp = vpp.w / vpp.h;
                this.calcViewMatrix(matrixView);
                this.calcProjectMatrix(asp, matrixProject);
                var matrixViewProject = new gd3d.math.matrix();
                var matinv = new gd3d.math.matrix();
                gd3d.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                gd3d.math.matrixInverse(matrixViewProject, matinv);
                var src1 = new gd3d.math.vector3(vppos.x, vppos.y, screenPos.z);
                gd3d.math.matrixTransformVector3(src1, matinv, outWorldPos);
            }
            calcScreenPosFromWorldPos(app, worldPos, outScreenPos) {
                var vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, vpp);
                var matrixView = new gd3d.math.matrix();
                var matrixProject = new gd3d.math.matrix();
                var asp = vpp.w / vpp.h;
                this.calcViewMatrix(matrixView);
                this.calcProjectMatrix(asp, matrixProject);
                var matrixViewProject = new gd3d.math.matrix();
                gd3d.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                var ndcPos = gd3d.math.pool.new_vector3();
                gd3d.math.matrixTransformVector3(worldPos, matrixViewProject, ndcPos);
                outScreenPos.x = (ndcPos.x + 1) * vpp.w / 2;
                outScreenPos.y = (1 - ndcPos.y) * vpp.h / 2;
            }
            calcCameraFrame(app) {
                var _vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, _vpp);
                var near_h = this.near * Math.tan(this.fov * 0.5);
                var asp = _vpp.w / _vpp.h;
                var near_w = near_h * asp;
                var nearLT = new gd3d.math.vector3(-near_w, near_h, this.near);
                var nearLD = new gd3d.math.vector3(-near_w, -near_h, this.near);
                var nearRT = new gd3d.math.vector3(near_w, near_h, this.near);
                var nearRD = new gd3d.math.vector3(near_w, -near_h, this.near);
                var far_h = this.far * Math.tan(this.fov * 0.5);
                var far_w = far_h * asp;
                var farLT = new gd3d.math.vector3(-far_w, far_h, this.far);
                var farLD = new gd3d.math.vector3(-far_w, -far_h, this.far);
                var farRT = new gd3d.math.vector3(far_w, far_h, this.far);
                var farRD = new gd3d.math.vector3(far_w, -far_h, this.far);
                let matrix = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixTransformVector3(farLD, matrix, farLD);
                gd3d.math.matrixTransformVector3(nearLD, matrix, nearLD);
                gd3d.math.matrixTransformVector3(farRD, matrix, farRD);
                gd3d.math.matrixTransformVector3(nearRD, matrix, nearRD);
                gd3d.math.matrixTransformVector3(farLT, matrix, farLT);
                gd3d.math.matrixTransformVector3(nearLT, matrix, nearLT);
                gd3d.math.matrixTransformVector3(farRT, matrix, farRT);
                gd3d.math.matrixTransformVector3(nearRT, matrix, nearRT);
                this.frameVecs.length = 0;
                this.frameVecs.push(farLD);
                this.frameVecs.push(nearLD);
                this.frameVecs.push(farRD);
                this.frameVecs.push(nearRD);
                this.frameVecs.push(farLT);
                this.frameVecs.push(nearLT);
                this.frameVecs.push(farRT);
                this.frameVecs.push(nearRT);
            }
            set opvalue(val) {
                if (val > 0 && this._near < 0.01) {
                    this._near = 0.01;
                    if (this._far <= this._near)
                        this._far = this._near + 0.01;
                }
                this._opvalue = val;
            }
            get opvalue() {
                return this._opvalue;
            }
            getPosAtXPanelInViewCoordinateByScreenPos(screenPos, app, z, out) {
                var vpp = new gd3d.math.rect();
                this.calcViewPortPixel(app, vpp);
                var nearpos = new gd3d.math.vector3;
                nearpos.z = -this.near;
                nearpos.x = screenPos.x - vpp.w * 0.5;
                nearpos.y = vpp.h * 0.5 - screenPos.y;
                var farpos = new gd3d.math.vector3;
                farpos.z = -this.far;
                farpos.x = this.far * nearpos.x / this.near;
                farpos.y = this.far * nearpos.y / this.near;
                ;
                var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
                out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
                out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
            }
            fillRenderer(scene) {
                scene.renderList.clear();
                if (scene.app.isFrustumCulling)
                    this.calcCameraFrame(scene.app);
                this._fillRenderer(scene, scene.getRoot());
            }
            _fillRenderer(scene, node) {
                if (node.hasRendererComp == false && node.hasRendererCompChild == false)
                    return;
                if (scene.app.isFrustumCulling && !this.testFrustumCulling(scene, node))
                    return;
                if (node.gameObject != null && node.gameObject.renderer != null && node.gameObject.visible) {
                    scene.renderList.addRenderer(node.gameObject.renderer);
                }
                if (node.children != null && node.gameObject.visible) {
                    for (var i = 0; i < node.children.length; i++) {
                        this._fillRenderer(scene, node.children[i]);
                    }
                }
            }
            testFrustumCulling(scene, node) {
                if (!node.gameObject.getComponent("frustumculling"))
                    return true;
                let spherecol = node.gameObject.getComponent("spherecollider");
                let worldPos = node.getWorldTranslate();
                if (!spherecol.caclPlaneInDir(this.frameVecs[0], this.frameVecs[1], this.frameVecs[5]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[1], this.frameVecs[3], this.frameVecs[7]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[3], this.frameVecs[2], this.frameVecs[6]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[2], this.frameVecs[0], this.frameVecs[4]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[5], this.frameVecs[7], this.frameVecs[6]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[0], this.frameVecs[2], this.frameVecs[3]))
                    return false;
                return true;
            }
            _targetAndViewport(target, scene, context, withoutClear) {
                {
                    var w;
                    var h;
                    if (target == null) {
                        w = scene.app.width;
                        h = scene.app.height;
                        gd3d.render.glRenderTarget.useNull(context.webgl);
                    }
                    else {
                        w = target.width;
                        h = target.height;
                        target.use(context.webgl);
                    }
                    context.webgl.viewport(w * this.viewport.x, h * this.viewport.y, w * this.viewport.w, h * this.viewport.h);
                    context.webgl.depthRange(0, 1);
                    if (withoutClear == false) {
                        if (this.clearOption_Color && this.clearOption_Depth) {
                            context.webgl.depthMask(true);
                            gd3d.render.glDrawPass.lastZWrite = true;
                            context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            context.webgl.clearDepth(1.0);
                            context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                        }
                        else if (this.clearOption_Depth) {
                            context.webgl.depthMask(true);
                            gd3d.render.glDrawPass.lastZWrite = true;
                            context.webgl.clearDepth(1.0);
                            context.webgl.clear(context.webgl.DEPTH_BUFFER_BIT);
                        }
                        else if (this.clearOption_Color) {
                            context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            context.webgl.clear(context.webgl.COLOR_BUFFER_BIT);
                        }
                        else {
                        }
                    }
                }
            }
            _renderOnce(scene, context, drawtype) {
                context.drawtype = drawtype;
                var assetmgr = scene.app.getAssetMgr();
                for (var i = 0; i < scene.renderList.renderLayers.length; i++) {
                    var layer = scene.renderList.renderLayers[i];
                    var list = layer.list;
                    for (var j = 0; j < list.length; j++) {
                        if (this.CullingMask & (1 << list[j].renderLayer)) {
                            list[j].render(context, assetmgr, this);
                        }
                    }
                }
            }
            renderScene(scene, context) {
                this._contextIdx = scene.renderContext.indexOf(context);
                for (var i = 0; i < scene.renderList.renderLayers.length; i++) {
                    let layer = scene.renderList.renderLayers[i];
                    let list = layer.list;
                    if (layer.needSort) {
                        if (list.length > 1) {
                            list.sort((a, b) => {
                                if (a.queue != b.queue) {
                                    return a.queue - b.queue;
                                }
                                else {
                                    let matrixView = context.matrixView;
                                    let az = gd3d.math.pool.new_vector3();
                                    let bz = gd3d.math.pool.new_vector3();
                                    gd3d.math.matrixTransformVector3(a.gameObject.transform.getWorldTranslate(), matrixView, az);
                                    gd3d.math.matrixTransformVector3(b.gameObject.transform.getWorldTranslate(), matrixView, bz);
                                    let result = bz.z - az.z;
                                    gd3d.math.pool.delete_vector3(az);
                                    gd3d.math.pool.delete_vector3(bz);
                                    return result;
                                }
                            });
                        }
                    }
                }
                if (this.postQueues.length == 0) {
                    this._targetAndViewport(this.renderTarget, scene, context, false);
                    this._renderOnce(scene, context, "");
                }
                else {
                    for (var i = 0; i < this.postQueues.length; i++) {
                        this.postQueues[i].render(scene, context, this);
                    }
                    context.webgl.flush();
                }
            }
            remove() {
            }
            clone() {
            }
        };
        __decorate([
            gd3d.reflect.UIStyle("rangeFloat", 1, 1000, 2),
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], camera.prototype, "near", null);
        __decorate([
            gd3d.reflect.UIStyle("rangeFloat", 1, 1000, 999),
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], camera.prototype, "far", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], camera.prototype, "CullingMask", void 0);
        __decorate([
            gd3d.reflect.compCall({ "use": "dirty", "display": "刷新camera" }),
            __metadata("design:type", Function),
            __metadata("design:paramtypes", []),
            __metadata("design:returntype", void 0)
        ], camera.prototype, "markDirty", null);
        __decorate([
            gd3d.reflect.Field("IOverLay[]"),
            __metadata("design:type", Array)
        ], camera.prototype, "overlays", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], camera.prototype, "fov", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], camera.prototype, "size", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number),
            __metadata("design:paramtypes", [Number])
        ], camera.prototype, "opvalue", null);
        camera = __decorate([
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeCamera
        ], camera);
        framework.camera = camera;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let canvascontainer = class canvascontainer {
            constructor() {
                this.isCanvasinit = false;
                this._lastMode = canvasRenderMode.ScreenSpaceOverlay;
                this._renderMode = canvasRenderMode.ScreenSpaceOverlay;
            }
            get canvas() {
                if (this._overlay2d && this._overlay2d.canvas)
                    return this._overlay2d.canvas;
            }
            setOverLay(lay) {
                this._overlay2d = lay;
                this.canvasInit();
            }
            getOverLay() {
                return this._overlay2d;
            }
            get sortOrder() {
                return this._overlay2d ? this._overlay2d.sortOrder : 0;
            }
            set sortOrder(order) {
                if (this._overlay2d)
                    this._overlay2d.sortOrder = order;
            }
            canvasInit() {
                if (!this.gameObject || !this.gameObject.transform || !this.gameObject.transform.scene)
                    return;
                if (!this._overlay2d || !this._overlay2d.canvas)
                    return;
                this._overlay2d.canvas.scene = this.gameObject.transform.scene;
                this._overlay2d.canvas.assetmgr = this._overlay2d.canvas.scene.app.getAssetMgr();
                this.isCanvasinit = true;
            }
            get renderMode() { return this._renderMode; }
            set renderMode(mode) {
                if (this._renderMode == mode)
                    return;
                this._lastMode = this._renderMode;
                this._renderMode = mode;
                this.styleToMode();
            }
            styleToMode() {
                switch (this._renderMode) {
                    case canvasRenderMode.ScreenSpaceOverlay:
                        if (!this._overlay2d)
                            return;
                        let scene = this.gameObject.getScene();
                        scene.addScreenSpaceOverlay(this._overlay2d);
                        break;
                }
            }
            start() {
                this.styleToMode();
            }
            onPlay() {
            }
            update(delta) {
                if (!this.isCanvasinit)
                    this.canvasInit();
            }
            remove() {
                if (this.gameObject.getScene())
                    this.gameObject.getScene().removeScreenSpaceOverlay(this._overlay2d);
            }
            clone() {
            }
        };
        __decorate([
            gd3d.reflect.Field("reference"),
            __metadata("design:type", framework.overlay2D)
        ], canvascontainer.prototype, "_overlay2d", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], canvascontainer.prototype, "renderMode", null);
        canvascontainer = __decorate([
            gd3d.reflect.nodeComponent,
            __metadata("design:paramtypes", [])
        ], canvascontainer);
        framework.canvascontainer = canvascontainer;
        let canvasRenderMode;
        (function (canvasRenderMode) {
            canvasRenderMode[canvasRenderMode["ScreenSpaceOverlay"] = 0] = "ScreenSpaceOverlay";
            canvasRenderMode[canvasRenderMode["ScreenSpaceCamera"] = 1] = "ScreenSpaceCamera";
            canvasRenderMode[canvasRenderMode["WorldSpace"] = 2] = "WorldSpace";
        })(canvasRenderMode = framework.canvasRenderMode || (framework.canvasRenderMode = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let effectSystem = effectSystem_1 = class effectSystem {
            constructor() {
                this.layer = framework.RenderLayerEnum.Transparent;
                this.queue = 0;
                this.autoplay = true;
                this.state = framework.EffectPlayStateEnum.None;
                this.curFrameId = -1;
                this.playTimer = 0;
                this.speed = 1;
                this.parser = new gd3d.framework.EffectParser();
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.effectBatchers = [];
                this.matDataGroups = [];
                this.particleElementDic = {};
                this.delayElements = [];
                this.refElements = [];
                this.beExecuteNextFrame = true;
            }
            get renderLayer() { return this.gameObject.layer; }
            set renderLayer(layer) {
                this.gameObject.layer = layer;
            }
            set jsonData(text) {
                this._textasset = text;
                this.setJsonDataStr(this.jsonData.content);
            }
            get jsonData() {
                return this._textasset;
            }
            setJsonData(_jsonData) {
                this._textasset = _jsonData;
                this.setJsonDataStr(this.jsonData.content);
            }
            setJsonDataStr(_jsonStr) {
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.data = this.parser.Parse(_jsonStr, gd3d.framework.sceneMgr.app.getAssetMgr());
            }
            updateJsonData(_jsonData) {
                this.jsonData = _jsonData;
                this.updateJsonDataStr(this.jsonData.content);
            }
            updateJsonDataStr(_jsonStr) {
                this.remove();
                this.data = this.parser.Parse(_jsonStr, gd3d.framework.sceneMgr.app.getAssetMgr());
                console.warn("开始解析特效");
            }
            set data(value) {
                this._data = value;
            }
            get data() {
                return this._data;
            }
            init() {
                if (this._data) {
                    this.addElements();
                }
            }
            get totalFrameCount() {
                return this.data.life * effectSystem_1.fps;
            }
            start() {
                this.init();
            }
            onPlay() {
            }
            update(delta) {
                if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined)
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.playTimer += delta * this.speed;
                    if (!this.beLoop) {
                        if (this.playTimer >= this.data.life) {
                            this.stop();
                        }
                    }
                    this._update(delta);
                }
                else if (this.state == framework.EffectPlayStateEnum.BeReady) {
                    if (this.autoplay) {
                        this.play();
                        this._update(delta);
                    }
                    else {
                        this.gameObject.visible = false;
                        this.gameObject.transform.markDirty();
                    }
                }
            }
            _update(delta) {
                if (this.delayElements.length > 0) {
                    if (this.refElements.length > 0)
                        this.refElements = [];
                    for (let i = this.delayElements.length - 1; i >= 0; i--) {
                        let data = this.delayElements[i];
                        if (data.delayTime <= this.playTimer) {
                            this.addElement(this.delayElements[i]);
                            this.delayElements.splice(i, 1);
                        }
                    }
                }
                if (this.particles != undefined) {
                    this.particles.updateForEmission(delta);
                }
                if (this.checkFrameId()) {
                    for (let i in this.effectBatchers) {
                        let subEffectBatcher = this.effectBatchers[i];
                        for (let key in subEffectBatcher.effectElements) {
                            let element = subEffectBatcher.effectElements[key];
                            if (element.delayTime == undefined || element.delayTime <= this.playTimer) {
                                subEffectBatcher.mesh.submesh[0].size = element.endEboIndex;
                            }
                            else {
                                if (subEffectBatcher.mesh.submesh[0].size > element.startEboIndex)
                                    subEffectBatcher.mesh.submesh[0].size = element.startEboIndex;
                            }
                            let frameId = (this.curFrameId - this.getDelayFrameCount(element.delayTime)) % element.loopFrame;
                            frameId = Math.floor(frameId);
                            if (element.active) {
                                element.actionActive = false;
                                this.mergeLerpAttribData(element.curAttrData, element.timelineFrame[frameId]);
                                if (element.actions != undefined) {
                                    element.actionActive = true;
                                    for (let j in element.actions) {
                                        element.actions[j].update(frameId);
                                    }
                                }
                            }
                            element.update();
                            if (element.isCurFrameNeedRefresh(frameId)) {
                                this.updateEffectBatcher(element.effectBatcher, element.curAttrData, element.data.initFrameData, element.startVboIndex);
                            }
                        }
                    }
                    if (this.particles != undefined) {
                        this.particles.update(1 / effectSystem_1.fps);
                    }
                }
            }
            mergeLerpAttribData(realUseCurFrameData, curFrameData) {
                if (curFrameData == undefined)
                    return;
                if (realUseCurFrameData == undefined)
                    return;
                for (let key in curFrameData.attrsData) {
                    if (curFrameData.attrsData[key] != undefined && realUseCurFrameData[key] != undefined) {
                        let val = curFrameData.attrsData.getAttribute(key);
                        if (val == null)
                            continue;
                        if (val instanceof gd3d.math.vector3 || val instanceof gd3d.math.vector2 || typeof (val) === 'number') {
                            if (key != "renderModel")
                                realUseCurFrameData[key] = val;
                        }
                    }
                }
            }
            updateEffectBatcher(effectBatcher, curAttrsData, initFrameData, vertexStartIndex) {
                let mesh = curAttrsData.mesh;
                if (mesh == undefined) {
                    mesh = initFrameData.attrsData.mesh;
                }
                if (mesh == undefined)
                    return;
                if (curAttrsData.meshdataVbo == undefined) {
                    curAttrsData.meshdataVbo = mesh.data.genVertexDataArray(this.vf);
                }
                let vertexCount = mesh.data.pos.length;
                let vertexArr = curAttrsData.meshdataVbo;
                let vertexSize = effectBatcher.vertexSize;
                for (let i = 0; i < vertexCount; i++) {
                    {
                        let vertex = gd3d.math.pool.new_vector3();
                        vertex.x = vertexArr[i * vertexSize + 0];
                        vertex.y = vertexArr[i * vertexSize + 1];
                        vertex.z = vertexArr[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, curAttrsData.matrix, vertex);
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 0] = vertex.x;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 1] = vertex.y;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        let r = vertexArr[i * vertexSize + 9];
                        let g = vertexArr[i * vertexSize + 10];
                        let b = vertexArr[i * vertexSize + 11];
                        let a = vertexArr[i * vertexSize + 12];
                        if (curAttrsData.color != undefined) {
                            r = curAttrsData.color.x;
                            g = curAttrsData.color.y;
                            b = curAttrsData.color.z;
                        }
                        if (curAttrsData.alpha != undefined)
                            a = a * curAttrsData.alpha;
                        if (curAttrsData.colorRate != undefined) {
                            r *= curAttrsData.colorRate;
                            g *= curAttrsData.colorRate;
                            b *= curAttrsData.colorRate;
                            a *= curAttrsData.colorRate;
                        }
                        r = gd3d.math.floatClamp(r, 0, 3);
                        g = gd3d.math.floatClamp(g, 0, 3);
                        b = gd3d.math.floatClamp(b, 0, 3);
                        a = gd3d.math.floatClamp(a, 0, 3);
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 9] = r;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 10] = g;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 11] = b;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 12] = a;
                    }
                    {
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 13] = vertexArr[i * vertexSize + 13] * curAttrsData.tilling.x + curAttrsData.uv.x;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 14] = vertexArr[i * vertexSize + 14] * curAttrsData.tilling.y + curAttrsData.uv.y;
                    }
                }
            }
            render(context, assetmgr, camera) {
                if (!(camera.CullingMask & (1 << this.renderLayer)))
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    context.updateModel(this.gameObject.transform);
                    for (let i in this.effectBatchers) {
                        let subEffectBatcher = this.effectBatchers[i];
                        let mesh = subEffectBatcher.mesh;
                        if (subEffectBatcher.state === framework.EffectBatcherState.NotInitedStateType) {
                            mesh.glMesh.initBuffer(context.webgl, this.vf, subEffectBatcher.curTotalVertexCount);
                            if (mesh.glMesh.ebos.length == 0) {
                                mesh.glMesh.addIndex(context.webgl, subEffectBatcher.dataForEbo.length);
                            }
                            else {
                                mesh.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
                            }
                            mesh.glMesh.uploadIndexData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh.submesh[0].size = subEffectBatcher.dataForEbo.length;
                            subEffectBatcher.state = framework.EffectBatcherState.InitedStateType;
                        }
                        else if (subEffectBatcher.state === framework.EffectBatcherState.ResizeCapacityStateType) {
                            mesh.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
                            mesh.submesh[0].size = subEffectBatcher.dataForEbo.length;
                            mesh.glMesh.uploadIndexData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh.glMesh.resetVboSize(context.webgl, subEffectBatcher.curTotalVertexCount * subEffectBatcher.vertexSize);
                            subEffectBatcher.state = framework.EffectBatcherState.InitedStateType;
                        }
                        mesh.glMesh.uploadVertexData(context.webgl, subEffectBatcher.dataForVbo);
                        if (this.gameObject.getScene().fog) {
                            context.fog = this.gameObject.getScene().fog;
                            subEffectBatcher.mat.draw(context, mesh, mesh.submesh[0], "base_fog");
                        }
                        else {
                            subEffectBatcher.mat.draw(context, mesh, mesh.submesh[0], "base");
                        }
                    }
                    if (this.particles != undefined) {
                        this.particles.render(context, assetmgr, camera);
                    }
                }
            }
            clone() {
                let effect = new effectSystem_1();
                if (this.jsonData)
                    effect.jsonData = this.jsonData;
                if (this.data)
                    effect.data = this.data.clone();
                effect.autoplay = this.autoplay;
                effect.beLoop = this.beLoop;
                return effect;
            }
            play(speed = 1) {
                if (this.state != framework.EffectPlayStateEnum.Pause)
                    this.stop();
                this.speed = speed;
                this.state = framework.EffectPlayStateEnum.Play;
                this.gameObject.visible = true;
                this.gameObject.transform.markDirty();
            }
            pause() {
                this.state = framework.EffectPlayStateEnum.Pause;
            }
            stop() {
                this.reset();
                this.state = framework.EffectPlayStateEnum.Stop;
            }
            reset(restSinglemesh = true, resetParticle = true) {
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.gameObject.visible = false;
                this.playTimer = 0;
                this.resetSingleMesh();
                this.resetparticle();
            }
            resetSingleMesh() {
                for (let i in this.effectBatchers) {
                    let subEffectBatcher = this.effectBatchers[i];
                    for (let key in subEffectBatcher.effectElements) {
                        let element = subEffectBatcher.effectElements[key];
                        element.setActive(true);
                        if (element.data.initFrameData != undefined)
                            element.curAttrData = element.data.initFrameData.attrsData.copyandinit();
                    }
                }
            }
            resetparticle() {
                if (this.particles != undefined)
                    this.particles.dispose();
                for (let name in this.particleElementDic) {
                    let data = this.data.elementDic[name];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    if (data.refFrom == undefined) {
                        if (this.particles == undefined) {
                            this.particles = new framework.Particles(this);
                        }
                        this.particles.addEmission(data);
                    }
                    else {
                        this.refElements.push(data);
                    }
                }
            }
            addElements() {
                for (let name in this.data.elementDic) {
                    let data = this.data.elementDic[name];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    this.addElement(data);
                }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.beLoop = this.data.beLoop;
            }
            addElement(data) {
                if (data.type == framework.EffectElementTypeEnum.EmissionType) {
                    if (this.particles == undefined) {
                        this.particles = new framework.Particles(this);
                    }
                    this.particles.addEmission(data);
                    this.particleElementDic[data.name] = data;
                }
                else if (data.type == framework.EffectElementTypeEnum.SingleMeshType) {
                    this.addInitFrame(data);
                }
            }
            addInitFrame(elementData) {
                let element = new framework.EffectElement(elementData);
                element.transform = this.gameObject.transform;
                let _initFrameData = element.data.initFrameData;
                if (_initFrameData == undefined || _initFrameData.attrsData == undefined || _initFrameData.attrsData.mesh == undefined)
                    return;
                let index = -1;
                if (_initFrameData.attrsData.mat != null) {
                    for (let i = 0; i < this.matDataGroups.length; i++) {
                        if (framework.EffectMatData.beEqual(this.matDataGroups[i], _initFrameData.attrsData.mat)) {
                            index = i;
                            break;
                        }
                    }
                }
                let vertexStartIndex = 0;
                let vertexCount = _initFrameData.attrsData.mesh.data.pos.length;
                let indexCount = _initFrameData.attrsData.mesh.data.genIndexDataArray;
                let subEffectBatcher = null;
                if (index >= 0) {
                    subEffectBatcher = this.effectBatchers[index];
                    vertexStartIndex = subEffectBatcher.curTotalVertexCount;
                    subEffectBatcher.curTotalVertexCount += vertexCount;
                    if (subEffectBatcher.state == framework.EffectBatcherState.InitedStateType)
                        subEffectBatcher.state = framework.EffectBatcherState.ResizeCapacityStateType;
                }
                else {
                    subEffectBatcher = new framework.EffectBatcher(this.vf);
                    subEffectBatcher.curTotalVertexCount = vertexCount;
                    subEffectBatcher.mesh = new framework.mesh();
                    subEffectBatcher.mesh.data = new gd3d.render.meshData();
                    subEffectBatcher.mesh.glMesh = new gd3d.render.glMesh();
                    subEffectBatcher.mat = new framework.material();
                    subEffectBatcher.mesh.submesh = [];
                    {
                        var sm = new framework.subMeshInfo();
                        sm.matIndex = 0;
                        sm.useVertexIndex = 0;
                        sm.start = 0;
                        sm.size = 0;
                        sm.line = false;
                        subEffectBatcher.mesh.submesh.push(sm);
                    }
                    vertexStartIndex = 0;
                    index = 0;
                    if (_initFrameData.attrsData.mat.shader == null) {
                        subEffectBatcher.mat.setShader(framework.sceneMgr.app.getAssetMgr().getShader("diffuse.shader.json"));
                        console.error("特效{0}shader为空", elementData.name);
                    }
                    else {
                        subEffectBatcher.mat.setShader(_initFrameData.attrsData.mat.shader);
                    }
                    if (_initFrameData.attrsData.mat.alphaCut != undefined)
                        subEffectBatcher.mat.setFloat("_AlphaCut", _initFrameData.attrsData.mat.alphaCut);
                    if (_initFrameData.attrsData.mat.diffuseTexture != null)
                        subEffectBatcher.mat.setTexture("_MainTex", _initFrameData.attrsData.mat.diffuseTexture);
                    if (_initFrameData.attrsData.mat.alphaTexture != null)
                        subEffectBatcher.mat.setTexture("_AlphaTex", _initFrameData.attrsData.mat.alphaTexture);
                    this.effectBatchers.push(subEffectBatcher);
                    this.matDataGroups.push(_initFrameData.attrsData.mat);
                }
                element.effectBatcher = subEffectBatcher;
                element.startVboIndex = vertexStartIndex;
                element.curAttrData = elementData.initFrameData.attrsData.copyandinit();
                let vertexSize = subEffectBatcher.vertexSize;
                let vertexArr = _initFrameData.attrsData.mesh.data.genVertexDataArray(this.vf);
                element.update();
                subEffectBatcher.effectElements.push(element);
                for (let i = 0; i < vertexCount; i++) {
                    {
                        let vertex = gd3d.math.pool.new_vector3();
                        vertex.x = vertexArr[i * vertexSize + 0];
                        vertex.y = vertexArr[i * vertexSize + 1];
                        vertex.z = vertexArr[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, element.curAttrData.matrix, vertex);
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 0] = vertex.x;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 1] = vertex.y;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 3] = vertexArr[i * vertexSize + 3];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 4] = vertexArr[i * vertexSize + 4];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 5] = vertexArr[i * vertexSize + 5];
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 6] = vertexArr[i * vertexSize + 6];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 7] = vertexArr[i * vertexSize + 7];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 8] = vertexArr[i * vertexSize + 8];
                    }
                    {
                        let r = gd3d.math.floatClamp(element.curAttrData.color.x, 0, 1);
                        let g = gd3d.math.floatClamp(element.curAttrData.color.y, 0, 1);
                        let b = gd3d.math.floatClamp(element.curAttrData.color.z, 0, 1);
                        let a = gd3d.math.floatClamp(vertexArr[i * vertexSize + 12] * element.curAttrData.alpha, 0, 1);
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 9] = r;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 10] = g;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 11] = b;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 12] = a;
                    }
                    {
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 13] = vertexArr[i * vertexSize + 13] * element.curAttrData.tilling.x;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 14] = vertexArr[i * vertexSize + 14] * element.curAttrData.tilling.y;
                    }
                }
                var indexArray = _initFrameData.attrsData.mesh.data.genIndexDataArray();
                let _startIndex = subEffectBatcher.indexStartIndex;
                element.startEboIndex = _startIndex;
                subEffectBatcher.indexStartIndex += indexArray.length;
                element.endEboIndex = subEffectBatcher.indexStartIndex;
                for (var i = 0; i < indexArray.length; i++) {
                    subEffectBatcher.dataForEbo[_startIndex + i] = indexArray[i] + vertexStartIndex;
                }
            }
            setFrameId(id) {
                if (this.state == framework.EffectPlayStateEnum.Pause && id >= 0 && id < this.totalFrameCount)
                    this.curFrameId = id;
            }
            getDelayFrameCount(delayTime) {
                return delayTime * effectSystem_1.fps;
            }
            checkFrameId() {
                let curid = (effectSystem_1.fps * this.playTimer) | 0;
                if (curid != this.curFrameId) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.curFrameId = curid;
                    this.beExecuteNextFrame = true;
                    return true;
                }
                return false;
            }
            remove() {
                this.state = framework.EffectPlayStateEnum.Dispose;
                if (this.data)
                    this.data.dispose();
                while (this.effectBatchers.length > 0) {
                    this.effectBatchers[0].dispose();
                    this.effectBatchers.splice(0, 1);
                }
                while (this.matDataGroups.length > 0) {
                    this.matDataGroups.splice(0, 1);
                }
                if (this.particles)
                    this.particles.dispose();
                this.curFrameId = -1;
                this.playTimer = 0;
            }
            get leftLifeTime() {
                if (this.data != null) {
                    return this.data.life - this.playTimer;
                }
                else
                    return 9999999999;
            }
        };
        effectSystem.fps = 30;
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], effectSystem.prototype, "autoplay", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], effectSystem.prototype, "beLoop", void 0);
        __decorate([
            gd3d.reflect.Field("textasset"),
            __metadata("design:type", framework.textasset),
            __metadata("design:paramtypes", [framework.textasset])
        ], effectSystem.prototype, "jsonData", null);
        effectSystem = effectSystem_1 = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent
        ], effectSystem);
        framework.effectSystem = effectSystem;
        var effectSystem_1;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let TestEffectSystem = class TestEffectSystem {
            constructor() {
                this.layer = framework.RenderLayerEnum.Transparent;
                this.queue = 0;
                this.autoplay = true;
                this.state = framework.EffectPlayStateEnum.None;
                this.curFrameId = -1;
                this.playTimer = 0;
                this.speed = 1;
                this.parser = new gd3d.framework.EffectParser();
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Normal | gd3d.render.VertexFormatMask.Tangent | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.effectBatchers = [];
                this.matDataGroups = [];
                this.particleElementDic = {};
                this.delayElements = [];
                this.refElements = [];
                this.beExecuteNextFrame = true;
            }
            get renderLayer() { return this.gameObject.layer; }
            set renderLayer(layer) {
                this.gameObject.layer = layer;
            }
            setJsonData(_jsonData) {
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.jsonData = _jsonData;
                this.data = this.parser.Parse(this.jsonData.content, gd3d.framework.sceneMgr.app.getAssetMgr());
            }
            set data(value) {
                this._data = value;
            }
            get data() {
                return this._data;
            }
            init() {
                if (this._data) {
                    this.addElements();
                }
            }
            get totalFrameCount() {
                return this.data.life * framework.effectSystem.fps;
            }
            start() {
                this.init();
            }
            onPlay() {
            }
            update(delta) {
                if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined)
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.playTimer += delta * this.speed;
                    if (!this.beLoop) {
                        if (this.playTimer >= this.data.life) {
                            this.stop();
                        }
                    }
                    this._update(delta);
                }
                else if (this.state == framework.EffectPlayStateEnum.BeReady) {
                    if (this.autoplay) {
                        this.play();
                        this._update(delta);
                    }
                    else {
                        this.gameObject.visible = false;
                        this.gameObject.transform.markDirty();
                    }
                }
            }
            _update(delta) {
                if (this.delayElements.length > 0) {
                    if (this.refElements.length > 0)
                        this.refElements = [];
                    for (let i = this.delayElements.length - 1; i >= 0; i--) {
                        let data = this.delayElements[i];
                        if (data.delayTime <= this.playTimer) {
                            this.addElement(this.delayElements[i]);
                            this.delayElements.splice(i, 1);
                        }
                    }
                }
                if (this.checkFrameId()) {
                    if (this.emissionElement != null) {
                        for (var i = 0; i < this.emissionElement.length; i++) {
                            this.emissionElement[i].update(1 / framework.effectSystem.fps);
                        }
                    }
                }
            }
            render(context, assetmgr, camera) {
                if (!(camera.CullingMask & (1 << this.renderLayer)))
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play) {
                    context.updateModel(this.gameObject.transform);
                    if (this.emissionElement != null) {
                        for (var i = 0; i < this.emissionElement.length; i++) {
                            this.emissionElement[i].render(context, assetmgr, camera);
                        }
                    }
                }
            }
            clone() {
                let effect = new framework.effectSystem();
                effect.data = this.data.clone();
                return effect;
            }
            play(speed = 1) {
                this.speed = speed;
                this.state = framework.EffectPlayStateEnum.Play;
                this.gameObject.visible = true;
                this.gameObject.transform.markDirty();
            }
            pause() {
                this.state = framework.EffectPlayStateEnum.Pause;
            }
            stop() {
                this.reset();
                this.state = framework.EffectPlayStateEnum.Stop;
            }
            reset(restSinglemesh = true, resetParticle = true) {
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.gameObject.visible = false;
                this.playTimer = 0;
                this.resetSingleMesh();
            }
            resetSingleMesh() {
                for (let i in this.effectBatchers) {
                    let subEffectBatcher = this.effectBatchers[i];
                    for (let key in subEffectBatcher.effectElements) {
                        let element = subEffectBatcher.effectElements[key];
                        element.setActive(true);
                        if (element.data.initFrameData != undefined)
                            element.curAttrData = element.data.initFrameData.attrsData.copyandinit();
                    }
                }
            }
            addElements() {
                for (let name in this.data.elementDic) {
                    let data = this.data.elementDic[name];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    this.addElement(data);
                }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.beLoop = this.data.beLoop;
            }
            addElement(data) {
            }
            addEmissionElement(data = null) {
                if (this.emissionElement == null) {
                    this.emissionElement = [];
                }
                var emission = new framework.EffectElementEmission(this, data);
                this.emissionElement.push(emission);
            }
            setFrameId(id) {
                if (this.state == framework.EffectPlayStateEnum.Pause && id >= 0 && id < this.totalFrameCount)
                    this.curFrameId = id;
            }
            getDelayFrameCount(delayTime) {
                return delayTime * framework.effectSystem.fps;
            }
            checkFrameId() {
                let curid = (framework.effectSystem.fps * this.playTimer) | 0;
                if (curid != this.curFrameId) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.curFrameId = curid;
                    this.beExecuteNextFrame = true;
                    return true;
                }
                return false;
            }
            remove() {
                this.state = framework.EffectPlayStateEnum.Dispose;
                if (this.data)
                    this.data.dispose();
                for (let key in this.effectBatchers) {
                    this.effectBatchers[key].dispose();
                }
                if (this.particles)
                    this.particles.dispose();
            }
            get leftLifeTime() {
                if (this.data != null) {
                    return this.data.life - this.playTimer;
                }
                else
                    return 9999999999;
            }
        };
        TestEffectSystem.fps = 30;
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], TestEffectSystem.prototype, "autoplay", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], TestEffectSystem.prototype, "beLoop", void 0);
        __decorate([
            gd3d.reflect.Field("textasset"),
            __metadata("design:type", framework.textasset)
        ], TestEffectSystem.prototype, "jsonData", void 0);
        TestEffectSystem = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent,
            gd3d.reflect.selfClone
        ], TestEffectSystem);
        framework.TestEffectSystem = TestEffectSystem;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let frustumculling = class frustumculling {
            constructor() {
            }
            start() {
            }
            onPlay() {
            }
            update(delta) {
            }
            remove() {
            }
            clone() {
            }
        };
        frustumculling = __decorate([
            gd3d.reflect.nodeComponent,
            __metadata("design:paramtypes", [])
        ], frustumculling);
        framework.frustumculling = frustumculling;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let guidpath = class guidpath {
            constructor() {
                this.speed = 1;
                this.isactived = false;
                this.datasafe = false;
                this.folowindex = 0;
                this.isloop = false;
                this.lookforward = false;
                this.loopCount = 1;
                this.adjustDir = false;
            }
            set pathasset(pathasset) {
                if (this._pathasset) {
                    this._pathasset.unuse();
                }
                this._pathasset = pathasset;
                if (this._pathasset) {
                    this._pathasset.use();
                }
            }
            get pathasset() {
                return this._pathasset;
            }
            play(loopCount = 1) {
                this.isactived = true;
                this.loopCount = loopCount;
            }
            pause() {
                this.isactived = false;
            }
            stop() {
                this.isactived = false;
                this.folowindex = 0;
            }
            replay(loopCount = 1) {
                this.isactived = true;
                this.folowindex = 0;
                this.loopCount = loopCount;
            }
            setpathasset(pathasset, speed = 1, oncomplete = null) {
                this.pathasset = pathasset;
                if (pathasset == null) {
                    console.log(this.gameObject.getName().toString + ":are you sure set the right pathasset（error：null）");
                    return;
                }
                this.paths = pathasset.paths;
                if (this.paths[0] != null) {
                    gd3d.math.vec3Clone(this.paths[0], this.gameObject.transform.localTranslate);
                    this.gameObject.transform.markDirty();
                    this.datasafe = true;
                }
                this.mystrans = this.gameObject.transform;
                this.speed = speed;
                this.oncomplete = oncomplete;
            }
            start() {
            }
            onPlay() {
            }
            update(delta) {
                if (!this.isactived || !this.datasafe)
                    return;
                this.followmove(delta);
            }
            followmove(delta) {
                var dist = gd3d.math.vec3Distance(this.mystrans.localTranslate, this.paths[this.folowindex]);
                if (dist < 0.01) {
                    if (this.folowindex < this.paths.length - 1) {
                        var dir = new gd3d.math.vector3();
                        gd3d.math.vec3Clone(this.paths[this.folowindex], this.mystrans.localTranslate);
                        this.folowindex++;
                        this.adjustDir = true;
                        this.mystrans.markDirty();
                    }
                    else {
                        this.folowindex = 0;
                        if (!this.isloop) {
                            this.loopCount--;
                            if (this.loopCount == 0) {
                                this.isactived = false;
                                this.loopCount = 1;
                                if (this.oncomplete) {
                                    this.oncomplete();
                                }
                            }
                        }
                    }
                }
                else {
                    var dir = new gd3d.math.vector3();
                    gd3d.math.vec3Subtract(this.paths[this.folowindex], this.mystrans.localTranslate, dir);
                    if (this.adjustDir) {
                        var targetpos = this.paths[this.folowindex];
                        var localppos = this.mystrans.localTranslate;
                        var quat = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatLookat(localppos, targetpos, quat);
                        gd3d.math.quatClone(quat, this.mystrans.localRotate);
                        gd3d.math.pool.delete_quaternion(quat);
                        this.adjustDir = false;
                    }
                    var distadd = this.speed * delta;
                    if (distadd > dist)
                        distadd = dist;
                    var lerp = distadd / dist;
                    gd3d.math.vec3SLerp(this.mystrans.localTranslate, this.paths[this.folowindex], lerp, this.mystrans.localTranslate);
                    this.mystrans.markDirty();
                }
            }
            remove() {
                if (this._pathasset) {
                    this._pathasset.unuse();
                }
            }
            clone() {
            }
        };
        guidpath = __decorate([
            gd3d.reflect.nodeComponent
        ], guidpath);
        framework.guidpath = guidpath;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let keyFrameAniPlayer = class keyFrameAniPlayer {
            constructor() {
                this.nowTime = 0;
                this.pathPropertyMap = {};
            }
            get nowFrame() {
                if (!this.nowClip)
                    return 0;
                return Math.floor(this.nowClip.fps * this.nowTime);
            }
            ;
            start() {
                this.init();
            }
            onPlay() {
            }
            update(delta) {
                let clip = this.nowClip;
                if (!clip)
                    return;
                if (this.checkPlayEnd(clip)) {
                    this.nowClip = null;
                    this.nowTime = 0;
                    return;
                }
                this.nowTime += delta;
                let playTime = this.nowTime % this.nowClip.time;
                this.displayByTime(clip, playTime);
            }
            displayByTime(clip, playTime) {
                let curves = this.timeFilterCurves(clip, playTime);
                if (!curves || curves.length < 1)
                    return;
                for (var i = 0; i < curves.length; i++) {
                    let tempc = curves[i];
                    this.refrasCurveProperty(tempc, playTime);
                }
            }
            calcValueByTime(curve, playTime) {
                let kfs = curve.keyFrames;
                if (!kfs || kfs.length < 1)
                    return 0;
                if (kfs.length == 1 && kfs[0])
                    return kfs[0].value;
                let leftKf;
                let rightKf;
                for (var i = 0; i < kfs.length; i++) {
                    rightKf = kfs[i];
                    if (kfs[i].time > playTime) {
                        if (i > 0)
                            leftKf = kfs[i - 1];
                        break;
                    }
                }
                return bezierCurveTool.calcValue(leftKf, rightKf, playTime);
            }
            refrasCurveProperty(curve, playTime) {
                if (playTime < 0 || !curve || curve.keyFrames.length < 2 || framework.StringUtil.isNullOrEmptyObject(curve.propertyName))
                    return;
                let key = `${curve.path}_${curve.type}`;
                let obj = this.pathPropertyMap[key];
                if (!obj)
                    return;
                let sub = obj;
                let strs = curve.propertyName.split(".");
                while (strs.length > 0) {
                    if (strs.length == 1) {
                        sub[strs[0]] = this.calcValueByTime(curve, playTime);
                        if (curve.type == framework.transform["name"]) {
                            if (obj instanceof framework.transform) {
                                obj.markDirty();
                            }
                        }
                        return;
                    }
                    let str = strs.shift();
                    sub = sub[str];
                    if (!sub)
                        return;
                }
            }
            timeFilterCurves(clip, nowTime) {
                if (!clip || clip.curves.length < 1)
                    return;
                let result = [];
                for (var i = 0; i < clip.curves.length; i++) {
                    let curve = clip.curves[i];
                    let kfs = curve.keyFrames;
                    if (kfs.length < 1 || !kfs[kfs.length - 1] || kfs[kfs.length - 1].time < nowTime)
                        continue;
                    result.push(curve);
                }
                return result;
            }
            checkPlayEnd(clip) {
                if (!clip)
                    return true;
                if (clip._wrapMode == framework.WrapMode.Loop || clip._wrapMode == framework.WrapMode.PingPong)
                    return false;
                if (this.nowTime >= clip.time)
                    return true;
            }
            init() {
            }
            isPlaying(ClipName) {
                return (this.nowClip && this.nowClip.getName() == ClipName);
            }
            playByName(ClipName) {
                if (!this.clips || this.clips.length < 1)
                    return;
                for (var i = 0; i < this.clips.length; i++) {
                    let clip = this.clips[i];
                    if (!clip)
                        continue;
                    if (clip.getName() == ClipName) {
                        this.nowClip = clip;
                        this.collectPathPropertyObj(this.nowClip, this.pathPropertyMap);
                    }
                }
            }
            play() {
                if (!this.clips || this.clips.length < 1)
                    return;
                this.nowClip = this.clips[0];
                if (!this.nowClip)
                    return;
                this.collectPathPropertyObj(this.nowClip, this.pathPropertyMap);
            }
            stop() {
                this.nowClip = null;
            }
            rewind() {
                if (!this.nowClip)
                    return;
                this.displayByTime(this.nowClip, 0);
                this.nowTime = 0;
            }
            collectPropertyObj(clip) {
                if (!clip)
                    return;
                for (var i = 0; i < clip.curves.length; i++) {
                    let curve = clip.curves[i];
                    let tran = this.gameObject.transform;
                    if (!framework.StringUtil.isNullOrEmptyObject(curve.path)) {
                        tran = this.pathPropertyMap[curve.path];
                    }
                    let comp = tran;
                    if (curve.type != framework.transform.prototype.name) {
                        comp = tran.gameObject.getComponent(curve.type);
                    }
                    if (!comp)
                        continue;
                }
            }
            collectPathPropertyObj(clip, pathMap) {
                if (!clip || !pathMap)
                    return;
                for (var i = 0; i < clip.curves.length; i++) {
                    let curve = clip.curves[i];
                    let key = "";
                    let tran = this.gameObject.transform;
                    if (!framework.StringUtil.isNullOrEmptyObject(curve.path)) {
                        let strs = curve.path.split("/");
                        for (var j = 0; j < strs.length; j++) {
                            tran = this.serchChild(strs[i], tran);
                            if (!tran)
                                break;
                        }
                        if (!tran)
                            continue;
                    }
                    key = `${curve.path}_${curve.type}`;
                    let comp = tran;
                    if (curve.type != framework.transform["name"]) {
                        comp = tran.gameObject.getComponent(curve.type);
                    }
                    pathMap[key] = comp;
                }
            }
            serchChild(name, trans) {
                if (!trans || !trans.children || trans.children.length < 1)
                    return;
                for (var i = 0; i < trans.children.length; i++) {
                    let child = trans.children[i];
                    if (child && child.name == name)
                        return child;
                }
            }
            clone() {
            }
            remove() {
            }
        };
        __decorate([
            gd3d.reflect.Field("keyFrameAniClip[]"),
            __metadata("design:type", Array)
        ], keyFrameAniPlayer.prototype, "clips", void 0);
        keyFrameAniPlayer = __decorate([
            gd3d.reflect.nodeComponent
        ], keyFrameAniPlayer);
        framework.keyFrameAniPlayer = keyFrameAniPlayer;
        class bezierCurveTool {
            static calcValue(kf_l, kf_r, playTime) {
                if (kf_l.outTangent == Infinity || kf_r.inTangent == Infinity)
                    return kf_l.value;
                let rate = (playTime - kf_l.time) / (kf_r.time - kf_l.time);
                let v2 = bezierCurveTool.converCalc(kf_l.value, kf_r.value, kf_l.time, kf_r.time, kf_l.inTangent, kf_r.outTangent, rate);
                return v2.y;
            }
            static converCalc(inV, outV, inTime, outTime, inTangent, outTangent, t) {
                let p0 = gd3d.math.pool.new_vector2(inTime, inV);
                let p1 = gd3d.math.pool.new_vector2();
                let p2 = gd3d.math.pool.new_vector2();
                let p3 = gd3d.math.pool.new_vector2(outTime, outV);
                let dir1 = gd3d.math.pool.new_vector2(inTangent < 0 ? -1 : 1, Math.sqrt(1 + inTangent * inTangent));
                let dir2 = gd3d.math.pool.new_vector2(outTangent < 0 ? -1 : 1, Math.sqrt(1 + outTangent * outTangent));
                gd3d.math.vec2Add(p0, dir1, p1);
                gd3d.math.vec2Add(p3, dir2, p2);
                bezierCurveTool.calcCurve(t, p0, p1, p2, p3, bezierCurveTool.cupV2);
                gd3d.math.pool.delete_vector2Array([p0, p1, p2, p3, dir1, dir2]);
                return bezierCurveTool.cupV2;
            }
            static calcCurve(t, P0, P1, P2, P3, out) {
                var equation = (t, val0, val1, val2, val3) => {
                    var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                    return res;
                };
                out.x = equation(t, P0.x, P1.x, P2.x, P3.x);
                out.y = equation(t, P0.y, P1.y, P2.y, P3.y);
                return out;
            }
        }
        bezierCurveTool.cupV2 = new gd3d.math.vector2();
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let LightTypeEnum;
        (function (LightTypeEnum) {
            LightTypeEnum[LightTypeEnum["Direction"] = 0] = "Direction";
            LightTypeEnum[LightTypeEnum["Point"] = 1] = "Point";
            LightTypeEnum[LightTypeEnum["Spot"] = 2] = "Spot";
        })(LightTypeEnum = framework.LightTypeEnum || (framework.LightTypeEnum = {}));
        let light = class light {
            constructor() {
                this.spotAngelCos = 0.9;
                this.range = 10;
                this.intensity = 1;
                this.color = new gd3d.math.color(1.0, 1.0, 1.0, 1.0);
                this.cullingMask = framework.CullingMask.everything;
            }
            start() {
            }
            onPlay() {
            }
            update(delta) {
            }
            remove() {
            }
            clone() {
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], light.prototype, "type", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], light.prototype, "range", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], light.prototype, "intensity", void 0);
        __decorate([
            gd3d.reflect.Field("color"),
            __metadata("design:type", gd3d.math.color)
        ], light.prototype, "color", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], light.prototype, "cullingMask", void 0);
        light = __decorate([
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeLight
        ], light);
        framework.light = light;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class spherestruct {
            constructor(_center, _r) {
                this.center = gd3d.math.pool.clone_vector3(_center);
                this.srcradius = _r;
                this.tempScale = new gd3d.math.vector3();
            }
            update(worldmatrix) {
                gd3d.math.matrixGetTranslation(worldmatrix, this.center);
                gd3d.math.matrixGetScale(worldmatrix, this.tempScale);
                if (this.tempScale.x < this.tempScale.y)
                    this.tempScale.x = this.tempScale.y;
                if (this.tempScale.x < this.tempScale.z)
                    this.tempScale.x = this.tempScale.z;
                this.radius = this.srcradius * this.tempScale.x;
            }
            intersects(bound) {
                if (bound instanceof spherestruct) {
                    let dis = gd3d.math.vec3Distance(this.center, bound.center);
                    if (dis > this.radius + bound.radius)
                        return false;
                    return true;
                }
                else if (bound instanceof framework.obb) {
                }
            }
        }
        framework.spherestruct = spherestruct;
        let spherecollider = class spherecollider {
            constructor() {
                this._worldCenter = new gd3d.math.vector3();
                this._colliderVisible = false;
            }
            get worldCenter() {
                gd3d.math.vec3Clone(this.center, this._worldCenter);
                gd3d.math.matrixTransformVector3(this._worldCenter, this.gameObject.transform.getWorldMatrix(), this._worldCenter);
                return this._worldCenter;
            }
            getBound() {
                return this.spherestruct;
            }
            get matrix() {
                if (this.gameObject)
                    return this.gameObject.transform.getWorldMatrix();
                return new gd3d.math.matrix();
            }
            start() {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.build();
            }
            onPlay() {
            }
            update(delta) {
                if (this.spherestruct) {
                    this.spherestruct.update(this.matrix);
                }
            }
            get colliderVisible() {
                return this._colliderVisible;
            }
            set colliderVisible(value) {
                this._colliderVisible = value;
                if (this.subTran) {
                    this.subTran.gameObject.visible = this._colliderVisible;
                }
            }
            caclPlaneInDir(v0, v1, v2) {
                let subv0 = gd3d.math.pool.new_vector3();
                let subv1 = gd3d.math.pool.new_vector3();
                let cro0 = gd3d.math.pool.new_vector3();
                let point = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(v1, v0, subv0);
                gd3d.math.vec3Subtract(v2, v1, subv1);
                gd3d.math.vec3Cross(subv0, subv1, cro0);
                gd3d.math.calPlaneLineIntersectPoint(cro0, v0, cro0, this.worldCenter, point);
                let sublp = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(point, this.worldCenter, sublp);
                let val = gd3d.math.vec3Dot(cro0, sublp);
                gd3d.math.pool.delete_vector3(subv0);
                gd3d.math.pool.delete_vector3(subv1);
                gd3d.math.pool.delete_vector3(cro0);
                if (val <= 0)
                    return true;
                let dis = gd3d.math.vec3Distance(this.worldCenter, point);
                gd3d.math.pool.delete_vector3(point);
                if (dis < this.radius)
                    return true;
                return false;
            }
            intersectsTransform(tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.spherestruct == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.spherestruct.intersects(_obb);
            }
            build() {
                if (this.center && this.radius) {
                    this.spherestruct = new spherestruct(this.center, this.radius);
                }
            }
            buildMesh() {
                this.subTran = new gd3d.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "spherecollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
            }
            getColliderMesh() {
                var _mesh = new framework.mesh();
                return _mesh;
            }
            remove() {
                if (this.subTran) {
                    this.subTran.dispose();
                }
            }
            clone() {
            }
        };
        __decorate([
            gd3d.reflect.Field("vector3"),
            __metadata("design:type", gd3d.math.vector3)
        ], spherecollider.prototype, "center", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], spherecollider.prototype, "radius", void 0);
        spherecollider = __decorate([
            gd3d.reflect.nodeComponent,
            gd3d.reflect.nodeSphereCollider
        ], spherecollider);
        framework.spherecollider = spherecollider;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let starCamCtr = class starCamCtr {
            constructor() {
                this.moveDuration = 1;
                this.minSpeed = 5;
                this.relativelocation = new gd3d.math.vector3(0, 6, 0);
                this.relativeEuler = new gd3d.math.vector3(90, 0, 0);
                this.relativeRot = new gd3d.math.quaternion();
                this.starteCamRot = new gd3d.math.quaternion();
                this.targetCamPos = new gd3d.math.vector3();
                this.targetCamRot = new gd3d.math.quaternion();
                this.movedir = new gd3d.math.vector3();
                this.active = false;
                this.moveDis = new gd3d.math.vector3();
            }
            start() {
            }
            onPlay() {
            }
            update(delta) {
                if (!this.active)
                    return;
                let pos = this.gameObject.transform.localTranslate;
                let rot = this.gameObject.transform.localRotate;
                let distanc = gd3d.math.vec3Distance(pos, this.targetCamPos);
                let movedis = this.moveSpeed * delta;
                if (distanc > movedis) {
                    gd3d.math.vec3ScaleByNum(this.movedir, movedis, this.moveDis);
                    gd3d.math.vec3Add(pos, this.moveDis, this.gameObject.transform.localTranslate);
                    gd3d.math.quatLerp(this.starteCamRot, this.targetCamRot, this.gameObject.transform.localRotate, (this.distance - distanc) / this.distance);
                    this.gameObject.transform.markDirty();
                    this.gameObject.transform.updateWorldTran();
                }
                else {
                    this.active = false;
                }
            }
            remove() {
            }
            clone() {
            }
            moveTo(to) {
                gd3d.math.quatClone(this.gameObject.transform.localRotate, this.starteCamRot);
                gd3d.math.quatFromEulerAngles(this.relativeEuler.x, this.relativeEuler.y, this.relativeEuler.z, this.relativeRot);
                gd3d.math.quatTransformVector(to.localRotate, this.relativelocation, this.targetCamPos);
                gd3d.math.vec3Add(to.localTranslate, this.targetCamPos, this.targetCamPos);
                gd3d.math.quatMultiply(to.localRotate, this.relativeRot, this.targetCamRot);
                let distanc = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(this.targetCamPos, this.gameObject.transform.localTranslate, distanc);
                gd3d.math.vec3Normalize(distanc, this.movedir);
                this.distance = gd3d.math.vec3Length(distanc);
                this.moveSpeed = this.distance / this.moveDuration;
                gd3d.math.pool.delete_vector3(distanc);
                this.active = true;
            }
        };
        starCamCtr = __decorate([
            gd3d.reflect.nodeComponent
        ], starCamCtr);
        framework.starCamCtr = starCamCtr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let trailRender = class trailRender {
            constructor() {
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                this.width = 1.0;
                this.vertexcount = 24;
                this.active = false;
                this.reInit = false;
                this.extenedOneSide = true;
                this.lookAtCamera = false;
                this.speed = 0.5;
            }
            get renderLayer() { return this.gameObject.layer; }
            set renderLayer(layer) {
                this.gameObject.layer = layer;
            }
            start() {
                this.app = this.gameObject.getScene().app;
                this.webgl = this.app.webgl;
                this.initmesh();
            }
            onPlay() {
            }
            update(delta) {
                if (!this.active)
                    return;
                if (this.reInit) {
                    this.intidata();
                    this.reInit = false;
                }
                var targetpos = this.gameObject.transform.getWorldTranslate();
                if (this.lookAtCamera) {
                    this.camerapositon = framework.sceneMgr.app.getScene().mainCamera.gameObject.transform.getWorldTranslate();
                    var camdir = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Subtract(this.camerapositon, this.sticks[0].location, camdir);
                    gd3d.math.vec3Normalize(camdir, camdir);
                    var direction = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Subtract(targetpos, this.sticks[0].location, direction);
                    gd3d.math.vec3Normalize(direction, direction);
                    gd3d.math.vec3Cross(camdir, direction, this.sticks[0].updir);
                    gd3d.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    gd3d.math.pool.delete_vector3(direction);
                }
                gd3d.math.vec3Clone(targetpos, this.sticks[0].location);
                var length = this.sticks.length;
                for (var i = 1; i < length; i++) {
                    gd3d.math.vec3SLerp(this.sticks[i].location, this.sticks[i - 1].location, this.speed, this.sticks[i].location);
                }
                if (this.lookAtCamera) {
                    for (var i = 1; i < length; i++) {
                        var tocamdir = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Subtract(this.camerapositon, this.sticks[i].location, tocamdir);
                        gd3d.math.vec3Normalize(tocamdir, tocamdir);
                        var movedir = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Subtract(this.sticks[i - 1].location, this.sticks[i].location, movedir);
                        gd3d.math.vec3Normalize(movedir, movedir);
                        gd3d.math.vec3Cross(tocamdir, movedir, this.sticks[i].updir);
                        gd3d.math.vec3ScaleByNum(this.sticks[i].updir, this.width, this.sticks[i].updir);
                        gd3d.math.pool.delete_vector3(tocamdir);
                    }
                }
                else {
                    this.gameObject.transform.getUpInWorld(this.sticks[0].updir);
                    gd3d.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    for (var i = 1; i < length; i++) {
                        gd3d.math.vec3SLerp(this.sticks[i].updir, this.sticks[i - 1].updir, this.speed, this.sticks[i].updir);
                    }
                }
                this.updateTrailData();
            }
            set material(material) {
                this._material = material;
                this.layer = this.material.getLayer();
            }
            get material() {
                if (this._material != undefined) {
                    return this._material;
                }
                else {
                    var mat = new gd3d.framework.material();
                    mat.setShader(this.app.getAssetMgr().getShader("shader/def"));
                    this.material = mat;
                    return this._material;
                }
            }
            get color() {
                if (this._color == undefined) {
                    this._color = new gd3d.math.color(1, 1, 1, 1);
                }
                return this._color;
            }
            set color(color) {
                this._color = color;
            }
            setspeed(upspeed) {
                this.speed = upspeed;
            }
            setWidth(Width) {
                this.width = Width;
            }
            play() {
                this.reInit = true;
                this.active = true;
            }
            stop() {
                this.active = false;
            }
            initmesh() {
                this.mesh = new gd3d.framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.dataForVbo = new Float32Array(this.vertexcount * 9);
                this.dataForEbo = new Uint16Array((this.vertexcount / 2 - 1) * 6);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, this.vertexcount, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            }
            intidata() {
                this.sticks = [];
                for (var i = 0; i < this.vertexcount / 2; i++) {
                    var ts = new trailStick();
                    this.sticks.push(ts);
                    ts.location = new gd3d.math.vector3();
                    gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), ts.location);
                    ts.updir = new gd3d.math.vector3();
                    this.gameObject.transform.getUpInWorld(ts.updir);
                    gd3d.math.vec3ScaleByNum(ts.updir, this.width, ts.updir);
                }
                var length = this.vertexcount / 2;
                var updir = gd3d.math.pool.new_vector3();
                this.gameObject.transform.getUpInWorld(updir);
                gd3d.math.vec3ScaleByNum(updir, this.width, updir);
                var pos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), pos);
                var uppos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Add(pos, updir, uppos);
                var downpos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(pos, updir, downpos);
                for (var i = 0; i < length; i++) {
                    this.dataForVbo[i * 2 * 9] = uppos.x;
                    this.dataForVbo[i * 2 * 9 + 1] = uppos.y;
                    this.dataForVbo[i * 2 * 9 + 2] = uppos.z;
                    this.dataForVbo[i * 2 * 9 + 3] = this.color.r;
                    this.dataForVbo[i * 2 * 9 + 4] = this.color.g;
                    this.dataForVbo[i * 2 * 9 + 5] = this.color.b;
                    this.dataForVbo[i * 2 * 9 + 6] = this.color.a;
                    this.dataForVbo[i * 2 * 9 + 7] = i / (length - 1);
                    this.dataForVbo[i * 2 * 9 + 8] = 0;
                    this.dataForVbo[(i * 2 + 1) * 9] = downpos.x;
                    this.dataForVbo[(i * 2 + 1) * 9 + 1] = downpos.y;
                    this.dataForVbo[(i * 2 + 1) * 9 + 2] = downpos.z;
                    this.dataForVbo[(i * 2 + 1) * 9 + 3] = this.color.r;
                    this.dataForVbo[(i * 2 + 1) * 9 + 4] = this.color.g;
                    this.dataForVbo[(i * 2 + 1) * 9 + 5] = this.color.b;
                    this.dataForVbo[(i * 2 + 1) * 9 + 6] = this.color.a;
                    this.dataForVbo[(i * 2 + 1) * 9 + 7] = i / (length - 1);
                    this.dataForVbo[(i * 2 + 1) * 9 + 8] = 1;
                }
                for (var k = 0; k < length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
                this.mesh.glMesh.uploadVertexData(this.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                gd3d.math.pool.delete_vector3(updir);
                gd3d.math.pool.delete_vector3(pos);
                gd3d.math.pool.delete_vector3(uppos);
                gd3d.math.pool.delete_vector3(downpos);
            }
            updateTrailData() {
                var length = this.vertexcount / 2;
                if (this.extenedOneSide) {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
                else {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x - up.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y - up.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z - up.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
            }
            render(context, assetmgr, camera) {
                if (!this.active)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (this.gameObject.getScene().fog) {
                    context.fog = this.gameObject.getScene().fog;
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base_fog");
                }
                else {
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
                }
            }
            clone() {
            }
            remove() {
            }
        };
        trailRender = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent
        ], trailRender);
        framework.trailRender = trailRender;
        class trailStick {
        }
        framework.trailStick = trailStick;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let trailRender_recorde = class trailRender_recorde {
            constructor() {
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                this._startWidth = 1;
                this._endWidth = 0;
                this.lifetime = 0.35;
                this.minStickDistance = 0.1;
                this.maxStickCout = 12;
                this.nodes = [];
                this.interpolate = false;
                this.interpNumber = 3;
                this.interpPath = [];
                this.activeMaxpointlimit = false;
                this.notRender = false;
            }
            get renderLayer() { return this.gameObject.layer; }
            set renderLayer(layer) {
                this.gameObject.layer = layer;
            }
            set material(material) {
                this._material = material;
                this.layer = this._material.getLayer();
            }
            get material() {
                if (this._material != undefined) {
                    return this._material;
                }
                else {
                    var mat = new gd3d.framework.material();
                    mat.setShader(this.app.getAssetMgr().getShader("shader/def"));
                    this._material = mat;
                    return this._material;
                }
            }
            get startColor() {
                if (this._startColor == undefined) {
                    this._startColor = new gd3d.math.color(1, 1, 1, 1);
                }
                return this._startColor;
            }
            set startColor(color) {
                this._startColor = color;
            }
            set endColor(color) {
                this._endColor = color;
            }
            get endColor() {
                if (this._endColor == undefined) {
                    this._endColor = new gd3d.math.color(this.startColor.r, this.startColor.g, this.startColor.b, 0);
                }
                return this._endColor;
            }
            setWidth(startWidth, endWidth = 0) {
                this._startWidth = startWidth;
                this._endWidth = endWidth;
            }
            setMaxpointcontroll(value = false) {
                this.activeMaxpointlimit = value;
            }
            start() {
                this.app = this.gameObject.getScene().app;
                this.webgl = this.app.webgl;
                this.mesh = new gd3d.framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                var vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                if (this.interpolate) {
                    this.maxStickCout *= this.interpNumber;
                    this.targetPath = this.interpPath;
                }
                else {
                    this.targetPath = this.nodes;
                }
            }
            onPlay() {
            }
            update(delta) {
                var _time = this.app.getTotalTime();
                this.refreshTrailNode(_time);
                this.updateTrailData(_time);
            }
            remove() {
            }
            refreshTrailNode(curTime) {
                while (this.targetPath.length > 0 && curTime > this.targetPath[this.targetPath.length - 1].time + this.lifetime) {
                    this.targetPath.pop();
                }
                var pos = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), pos);
                var length = this.targetPath.length;
                if (length != 0) {
                    if (gd3d.math.vec3Distance(pos, this.targetPath[0].location) < this.minStickDistance)
                        return;
                }
                var updir = new gd3d.math.vector3();
                this.gameObject.transform.getUpInWorld(updir);
                var newNode = new trailNode(pos, updir, curTime);
                this.nodes.unshift(newNode);
                if (this.interpolate) {
                    if (this.nodes.length > 2) {
                        var handle1 = new gd3d.math.vector3();
                        gd3d.math.vec3Subtract(this.nodes[2].location, this.nodes[0].location, handle1);
                        gd3d.math.vec3Normalize(handle1, handle1);
                        this.nodes[1].handle = handle1;
                        if (this.nodes[2].handle == undefined) {
                            var handdle = new gd3d.math.vector3();
                            gd3d.math.vec3Subtract(this.nodes[2].location, this.nodes[1].location, handdle);
                            gd3d.math.vec3Normalize(handdle, handdle);
                            this.nodes[2].handle = handdle;
                        }
                        var vec3Distance = gd3d.math.vec3Distance(this.nodes[2].location, this.nodes[1].location);
                        for (var i = 0; i < this.interpNumber; i++) {
                            var lerp = (i + 1) / (this.interpNumber + 1);
                            var inter_pos = new gd3d.math.vector3();
                            var tempRhandle = gd3d.math.pool.new_vector3();
                            var tempLhandle = gd3d.math.pool.new_vector3();
                            tempLhandle.x = -this.nodes[2].handle.x;
                            tempLhandle.y = -this.nodes[2].handle.y;
                            tempLhandle.z = -this.nodes[2].handle.z;
                            gd3d.math.vec3ScaleByNum(tempLhandle, vec3Distance / 2, tempLhandle);
                            gd3d.math.vec3Add(tempLhandle, this.nodes[2].location, tempLhandle);
                            gd3d.math.vec3ScaleByNum(this.nodes[1].handle, vec3Distance / 2, tempRhandle);
                            gd3d.math.vec3Add(tempRhandle, this.nodes[1].location, tempRhandle);
                            gd3d.math.GetPointAlongCurve(this.nodes[2].location, tempLhandle, this.nodes[1].location, tempRhandle, (i + 1) / (this.interpNumber + 1), inter_pos);
                            var inter_updir = new gd3d.math.vector3();
                            gd3d.math.vec3SLerp(this.nodes[1].updir, this.nodes[2].updir, lerp, inter_updir);
                            var inter_node = new trailNode(inter_pos, inter_updir, curTime);
                            this.interpPath.splice(1, 0, inter_node);
                            gd3d.math.pool.delete_vector3(tempRhandle);
                            gd3d.math.pool.delete_vector3(tempLhandle);
                        }
                        this.interpPath.unshift(newNode);
                    }
                }
                if (this.activeMaxpointlimit) {
                    while (this.targetPath.length > this.maxStickCout) {
                        this.targetPath.pop();
                    }
                }
            }
            updateTrailData(curTime) {
                if (this.nodes.length < 2) {
                    this.notRender = true;
                    return;
                }
                else {
                    this.notRender = false;
                }
                this.checkBufferSize();
                for (var i = 0; i < this.targetPath.length; i++) {
                    var curNode = this.targetPath[i];
                    var u = i / this.targetPath.length;
                    var timeAlong = (curTime - curNode.time) / this.lifetime;
                    var _updir = new gd3d.math.vector3();
                    gd3d.math.vec3Clone(curNode.updir, _updir);
                    var _width = this._startWidth + (this._endWidth - this._startWidth) * timeAlong;
                    gd3d.math.vec3ScaleByNum(_updir, _width, _updir);
                    var tempPos = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Add(curNode.location, _updir, tempPos);
                    this.dataForVbo[2 * i * 9 + 0] = tempPos.x;
                    this.dataForVbo[2 * i * 9 + 1] = tempPos.y;
                    this.dataForVbo[2 * i * 9 + 2] = tempPos.z;
                    var tempColor = gd3d.math.pool.new_color();
                    gd3d.math.colorLerp(this.startColor, this.endColor, timeAlong, tempColor);
                    this.dataForVbo[2 * i * 9 + 3] = tempColor.r;
                    this.dataForVbo[2 * i * 9 + 4] = tempColor.g;
                    this.dataForVbo[2 * i * 9 + 5] = tempColor.b;
                    this.dataForVbo[2 * i * 9 + 6] = tempColor.a;
                    this.dataForVbo[2 * i * 9 + 7] = u;
                    this.dataForVbo[2 * i * 9 + 8] = 1.0;
                    this.dataForVbo[(2 * i + 1) * 9 + 0] = curNode.location.x;
                    this.dataForVbo[(2 * i + 1) * 9 + 1] = curNode.location.y;
                    this.dataForVbo[(2 * i + 1) * 9 + 2] = curNode.location.z;
                    this.dataForVbo[(2 * i + 1) * 9 + 3] = tempColor.r;
                    this.dataForVbo[(2 * i + 1) * 9 + 4] = tempColor.g;
                    this.dataForVbo[(2 * i + 1) * 9 + 5] = tempColor.b;
                    this.dataForVbo[(2 * i + 1) * 9 + 6] = tempColor.a;
                    var u = i / this.nodes.length;
                    this.dataForVbo[(2 * i + 1) * 9 + 7] = u;
                    this.dataForVbo[(2 * i + 1) * 9 + 8] = 0;
                    gd3d.math.pool.delete_vector3(tempPos);
                    gd3d.math.pool.delete_color(tempColor);
                }
                for (var k = 0; k < this.nodes.length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
            }
            checkBufferSize() {
                var stickNumber = this.targetPath.length;
                if (stickNumber * 2 * 9 > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    this.dataForVbo = new Float32Array(length * 2);
                }
                if ((stickNumber - 1) * 6 > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    this.dataForEbo = new Uint16Array(length * 2);
                }
            }
            render(context, assetmgr, camera) {
                if (this.notRender)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = (this.targetPath.length - 1) * 6;
                if (this.gameObject.getScene().fog) {
                    context.fog = this.gameObject.getScene().fog;
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base_fog");
                }
                else {
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
                }
            }
            clone() {
            }
        };
        trailRender_recorde = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent
        ], trailRender_recorde);
        framework.trailRender_recorde = trailRender_recorde;
        class trailNode {
            constructor(p, updir, t) {
                this.location = p;
                this.updir = updir;
                this.time = t;
            }
        }
        framework.trailNode = trailNode;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let vignettingCtr = class vignettingCtr {
            constructor() {
                this.tag = "__vignettingtag__";
                this._init = false;
            }
            init() {
                let sh = this.scene.app.getAssetMgr().getShader("vignetting.shader.json");
                if (!sh) {
                    console.warn(`vignetting.shader.json not find`);
                    return;
                }
                let psize = 1024;
                var color = new framework.cameraPostQueue_Color();
                color[this.tag] = true;
                color.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                if (!this.camera.postQueues)
                    this.camera.postQueues = [];
                this.camera.postQueues.push(color);
                var textcolor = new framework.texture("_color");
                textcolor.glTexture = color.renderTarget;
                var texsize = 512;
                var blur_post = new gd3d.framework.cameraPostQueue_Quad();
                blur_post.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, texsize, texsize, true, false);
                blur_post.material.setShader(this.scene.app.getAssetMgr().getShader("separate_blur.shader.json"));
                blur_post.material.setTexture("_MainTex", textcolor);
                blur_post.material.setVector4("sample_offsets", new gd3d.math.vector4(0, 1.0, 0, -1.0));
                blur_post.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1.0 / texsize, 1.0 / texsize, texsize, texsize));
                this.camera.postQueues.push(blur_post);
                var blur0 = new gd3d.framework.texture("_blur0");
                blur0.glTexture = blur_post.renderTarget;
                var blur_post1 = new gd3d.framework.cameraPostQueue_Quad();
                blur_post1.renderTarget = new gd3d.render.glRenderTarget(this.scene.webgl, texsize, texsize, true, false);
                blur_post1.material.setShader(this.scene.app.getAssetMgr().getShader("separate_blur.shader.json"));
                blur_post1.material.setTexture("_MainTex", blur0);
                blur_post1.material.setVector4("sample_offsets", new gd3d.math.vector4(1.0, 0, -1.0, 0));
                blur_post1.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1.0 / texsize, 1.0 / texsize, texsize, texsize));
                this.camera.postQueues.push(blur_post1);
                var blur = new gd3d.framework.texture("_blur0");
                blur.glTexture = blur_post1.renderTarget;
                var post0 = new framework.cameraPostQueue_Quad();
                this.material_1 = post0.material;
                post0.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", blur);
                post0.material.setFloat("_Vignetting", 0.3);
                post0.material.setFloat("_Blurred_Corners", 3.0);
                post0.material.setFloat("_Chromatic_Aberration", 3.0);
                post0.material.setVector4("_MainTex_TexelSize", new gd3d.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                this._init = true;
            }
            start() {
                this.app = this.gameObject.transform.scene.app;
                this.scene = this.app.getScene();
            }
            onPlay() {
            }
            update(delta) {
                if (this._init)
                    return;
                if (!this.camera)
                    this.camera = this.gameObject.getComponent("camera");
                if (this.camera)
                    this.init();
            }
            remove() {
                this._init = false;
                if (this.camera) {
                    let arr = this.camera.postQueues;
                    let dArr = [];
                    for (var i = 0; i < arr.length; i++) {
                        let temp = arr[i];
                        if (temp[this.tag]) {
                            dArr.push(temp);
                        }
                    }
                    dArr.forEach(element => {
                        if (element) {
                            let idx = arr.indexOf(element);
                            if (idx != -1) {
                                arr.splice(idx, 1);
                            }
                        }
                    });
                }
                if (this.material) {
                    this.material.unuse();
                    this.material = null;
                }
                if (this.material_1) {
                    this.material_1.unuse();
                    this.material_1 = null;
                }
                if (this.material_2) {
                    this.material_2.unuse();
                    this.material_2 = null;
                }
                if (this.material_3) {
                    this.material_3.unuse();
                    this.material_3 = null;
                }
            }
            clone() {
            }
        };
        vignettingCtr = __decorate([
            gd3d.reflect.nodeComponent
        ], vignettingCtr);
        framework.vignettingCtr = vignettingCtr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let f14EffectSystem = class f14EffectSystem {
            constructor() {
                this.layer = framework.RenderLayerEnum.Transparent;
                this.queue = 10;
                this.fps = 30;
                this.layers = [];
                this.VF = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this._delayTime = 0;
                this.elements = [];
                this.renderBatch = [];
                this.loopCount = 0;
                this.allTime = 0;
                this.renderActive = false;
                this.beref = false;
                this.mvpMat = new gd3d.math.matrix();
                this.totalTime = 0;
                this.totalFrame = 0;
                this.playRate = 1.0;
                this.enabletimeFlow = false;
                this.enableDraw = false;
            }
            get renderLayer() { return this.gameObject.layer; }
            set renderLayer(layer) {
                this.gameObject.layer = layer;
            }
            start() {
            }
            onPlay() {
            }
            get f14eff() {
                return this._f14eff;
            }
            set f14eff(asset) {
                if (this._f14eff != null) {
                    this._f14eff.unuse();
                }
                this._f14eff = asset;
                this.setData(asset.data);
            }
            get delay() {
                return this._delayTime;
            }
            set delay(deley) {
                this._delayTime = deley;
            }
            setData(data) {
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.data = data;
                for (let i = 0, count = this.data.layers.length; i < count; i++) {
                    let layerdata = this.data.layers[i];
                    this.addF14layer(layerdata.type, layerdata);
                }
                for (let i = 0; i < this.renderBatch.length; i++) {
                    if (this.renderBatch[i].type == framework.F14TypeEnum.SingleMeshType) {
                        this.renderBatch[i].OnEndCollectElement();
                    }
                }
            }
            get root() {
                return this._root || this.gameObject.transform;
            }
            update(deltaTime) {
                if (this.data == null) {
                    this.renderActive = false;
                    return;
                }
                this.renderActive = true;
                if (this.enabletimeFlow) {
                    this.allTime += deltaTime * this.playRate;
                    this.totalTime = this.allTime - this._delayTime;
                    if (this.totalTime <= 0) {
                        this.renderActive = false;
                        return;
                    }
                    this.totalFrame = this.totalTime * this.fps;
                    if (!this.data.beloop && this.totalFrame > this.data.lifeTime) {
                        this.renderActive = false;
                        this.enabletimeFlow = false;
                        if (this.onFinish) {
                            this.onFinish();
                        }
                        return;
                    }
                    this.restartFrame = this.totalFrame % this.data.lifeTime;
                    this.restartFrame = Math.floor(this.restartFrame);
                    let newLoopCount = Math.floor(this.totalFrame / this.data.lifeTime);
                    if (newLoopCount != this.loopCount) {
                        this.OnEndOnceLoop();
                    }
                    this.loopCount = newLoopCount;
                    for (let i = 0; i < this.elements.length; i++) {
                        this.elements[i].update(deltaTime, this.totalFrame, this.fps);
                    }
                }
                else {
                    if (this.totalTime <= 0) {
                        this.renderActive = false;
                        return;
                    }
                    if (!this.data.beloop && this.totalFrame > this.data.lifeTime) {
                        this.renderActive = false;
                        return;
                    }
                }
            }
            OnEndOnceLoop() {
                for (let i = 0; i < this.elements.length; i++) {
                    this.elements[i].OnEndOnceLoop();
                }
            }
            get renderCamera() {
                if (this._renderCamera != null) {
                    return this._renderCamera;
                }
                else {
                    return gd3d.framework.sceneMgr.app.getScene().mainCamera;
                }
            }
            render(context, assetmgr, camera, Effqueue = 0) {
                if (!this.renderActive || !this.enableDraw)
                    return;
                this._renderCamera = camera;
                let curCount = 0;
                context.updateModel(this.root);
                gd3d.math.matrixClone(context.matrixModelViewProject, this.mvpMat);
                for (let i = 0; i < this.renderBatch.length; i++) {
                    this.renderBatch[i].render(context, assetmgr, camera, Effqueue + curCount);
                    curCount += this.renderBatch[i].getElementCount();
                }
            }
            addF14layer(type, layerdata) {
                if (type == framework.F14TypeEnum.SingleMeshType) {
                    let layer = new framework.F14Layer(this, layerdata);
                    let element = new framework.F14SingleMesh(this, layer);
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    let data = layerdata.elementdata;
                    if (this.layers.length > 1 && this.layers[this.layers.length - 2].type == type) {
                        let batch = this.layers[this.layers.length - 2].batch;
                        if (batch.type == framework.F14TypeEnum.SingleMeshType && batch.canBatch(element)) {
                            batch.addElement(element);
                            layer.batch = batch;
                        }
                        else {
                            let _batch = new framework.F14SingleMeshBath(data.material, this);
                            _batch.addElement(element);
                            layer.batch = _batch;
                            this.renderBatch.push(_batch);
                        }
                    }
                    else if (this.layers.length = 1) {
                        let batch = new framework.F14SingleMeshBath(data.material, this);
                        batch.addElement(element);
                        layer.batch = batch;
                        this.renderBatch.push(batch);
                    }
                    return layer;
                }
                else if (type == framework.F14TypeEnum.particlesType) {
                    let layer = new framework.F14Layer(this, layerdata);
                    let element = new framework.F14Emission(this, layer);
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    let batch = new framework.F14EmissionBatch(this, element);
                    layer.batch = batch;
                    this.renderBatch.push(batch);
                    return layer;
                }
                else {
                    let layer = new framework.F14Layer(this, layerdata);
                    let element = new framework.F14RefElement(this, layer);
                    let data = layerdata.elementdata;
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    var refbath = new framework.F14RefElementBatch(this, element);
                    this.renderBatch.push(refbath);
                    layer.batch = refbath;
                    return layer;
                }
            }
            getElementCount() {
                let totalcount = 0;
                for (let i = 0; i < this.layers.length; i++) {
                    if (this.layers[i].type == framework.F14TypeEnum.RefType) {
                        totalcount += this.layers[i].batch.getElementCount();
                    }
                    else {
                        totalcount++;
                    }
                }
                return totalcount;
            }
            play(onFinish = null, PlayRate = 1.0) {
                if (this.allTime > 0) {
                    this.reset();
                }
                this.enabletimeFlow = true;
                this.enableDraw = true;
                this.playRate = PlayRate;
                if (onFinish) {
                    this.onFinish = onFinish;
                }
            }
            stop() {
                this.enabletimeFlow = false;
                this.enableDraw = false;
                this.reset();
            }
            pause() {
                this.enableDraw = true;
                this.enabletimeFlow = false;
            }
            changeColor(newcolor) {
                for (let i = 0; i < this.elements.length; i++) {
                    this.elements[i].changeColor(newcolor);
                }
            }
            reset() {
                this.allTime = 0;
                for (let key in this.elements) {
                    this.elements[key].reset();
                }
            }
            clone() {
            }
            remove() {
                this.data = null;
                this._f14eff = null;
                this.webgl = null;
                this._root = null;
                this._renderCamera = null;
                this.gameObject = null;
                for (let key in this.layers) {
                    this.layers[key].dispose();
                }
                for (let key in this.elements) {
                    this.elements[key].dispose();
                }
                for (let key in this.renderBatch) {
                    this.renderBatch[key].dispose();
                }
                delete this.layers;
                delete this.elements;
                delete this.renderBatch;
            }
        };
        __decorate([
            gd3d.reflect.Field("f14eff"),
            gd3d.reflect.UIStyle("WidgetDragSelect"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [framework.f14eff])
        ], f14EffectSystem.prototype, "f14eff", null);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [Number])
        ], f14EffectSystem.prototype, "delay", null);
        f14EffectSystem = __decorate([
            gd3d.reflect.nodeRender,
            gd3d.reflect.nodeComponent
        ], f14EffectSystem);
        framework.f14EffectSystem = f14EffectSystem;
        let PlayStateEnum;
        (function (PlayStateEnum) {
            PlayStateEnum[PlayStateEnum["play"] = 0] = "play";
            PlayStateEnum[PlayStateEnum["beReady"] = 1] = "beReady";
            PlayStateEnum[PlayStateEnum["pause"] = 2] = "pause";
        })(PlayStateEnum = framework.PlayStateEnum || (framework.PlayStateEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let F14TypeEnum;
        (function (F14TypeEnum) {
            F14TypeEnum[F14TypeEnum["SingleMeshType"] = 0] = "SingleMeshType";
            F14TypeEnum[F14TypeEnum["particlesType"] = 1] = "particlesType";
            F14TypeEnum[F14TypeEnum["RefType"] = 2] = "RefType";
        })(F14TypeEnum = framework.F14TypeEnum || (framework.F14TypeEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class F14Layer {
            constructor(effect, data) {
                this.active = true;
                this.frameList = [];
                this.frames = {};
                this.Attlines = {};
                this.effect = effect;
                this.data = data;
                this.type = data.type;
                for (var ff in this.data.frames) {
                    let framedata = this.data.frames[ff];
                    this.addFrame(framedata.frameindex, framedata);
                }
            }
            addFrame(index, framedata) {
                if (this.frames[index])
                    return this.frames[index];
                let frame = new F14Frame(this, framedata);
                this.frameList.push(index);
                this.frameList.sort((a, b) => { return a - b; });
                this.frames[index] = frame;
                return frame;
            }
            removeFrame(frame) {
                if (this.frames[frame]) {
                    delete this.frames[frame];
                    let index = this.frameList.indexOf(frame);
                    this.frameList.splice(index, 1);
                    delete this.data.frames[frame];
                }
                for (var item in this.Attlines) {
                    this.Attlines[item].remove(frame);
                }
            }
            dispose() {
                this.data = null;
                this.effect = null;
                this.frameList.length = 0;
                this.frames = null;
                this.Attlines = null;
                this.element = null;
                this.batch = null;
            }
        }
        framework.F14Layer = F14Layer;
        class F14Frame {
            constructor(layer, data) {
                this.layer = layer;
                this.data = data;
                this.attDic = this.data.singlemeshAttDic;
                for (let key in this.data.singlemeshAttDic) {
                    this.setdata(key, this.data.singlemeshAttDic[key]);
                }
            }
            setdata(name, obj) {
                if (this.layer.Attlines[name] == null) {
                    if (obj instanceof gd3d.math.vector3) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, gd3d.math.vec3SLerp, gd3d.math.vec3Clone);
                    }
                    else if (obj instanceof gd3d.math.vector4) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, gd3d.math.vec4SLerp, gd3d.math.vec4Clone);
                    }
                    else if (obj instanceof gd3d.math.color) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, gd3d.math.colorLerp, gd3d.math.colorClone);
                    }
                }
                this.layer.Attlines[name].addNode(this.data.frameindex, obj);
                this.attDic[name] = obj;
            }
            removedata(name) {
                delete this.attDic[name];
                if (this.layer.Attlines[name]) {
                    this.layer.Attlines[name].remove(this.data.frameindex);
                }
            }
            getdata(name) {
                return this.attDic[name];
            }
        }
        framework.F14Frame = F14Frame;
        class F14AttTimeLine {
            constructor(name, lerpfunc, clonefunc) {
                this.frameList = [];
                this.line = {};
                this.name = name;
                this.lerpFunc = lerpfunc;
                this.cloneFunc = clonefunc;
            }
            addNode(frame, value) {
                let index = this.frameList.indexOf(frame);
                if (index < 0) {
                    this.frameList.push(frame);
                    this.frameList.sort((a, b) => { return a - b; });
                }
                this.line[frame] = value;
            }
            remove(frame) {
                if (this.line[frame]) {
                    delete this.line[frame];
                    let index = this.frameList.indexOf(frame);
                    this.frameList.splice(index, 1);
                }
            }
            getValue(frame, basedate, out) {
                if (this.frameList.length == 0) {
                    return;
                }
                if (this.line[frame]) {
                    this.cloneFunc(this.line[frame], out);
                    return;
                }
                if (frame < this.frameList[0]) {
                    let toindex = this.frameList[0];
                    let from = basedate[this.name];
                    let to = this.line[toindex];
                    let lerp = (frame - basedate.firtstFrame) / toindex;
                    this.lerpFunc(from, to, lerp, out);
                }
                else if (frame >= this.frameList[this.frameList.length - 1]) {
                    this.cloneFunc(this.line[this.frameList[this.frameList.length - 1]], out);
                }
                else {
                    for (let i = 0; i < this.frameList.length; i++) {
                        if (this.frameList[i] > frame) {
                            let to = this.frameList[i];
                            let from = this.frameList[i - 1];
                            this.lerpFunc(this.line[from], this.line[to], (frame - from) / (to - from), out);
                            return;
                        }
                    }
                }
            }
        }
        framework.F14AttTimeLine = F14AttTimeLine;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class F14EffectData {
            constructor() {
                this.beloop = false;
                this.lifeTime = 100;
                this.layers = [];
            }
            parsejson(json, assetmgr, assetbundle) {
                this.beloop = json.beloop;
                this.lifeTime = json.lifeTime;
                let jsonlayer = json.layers;
                for (let i = 0; i < jsonlayer.length; i++) {
                    let layer = new F14LayerData();
                    layer.parse(jsonlayer[i], assetmgr, assetbundle);
                    this.layers.push(layer);
                }
            }
        }
        framework.F14EffectData = F14EffectData;
        class F14LayerData {
            constructor() {
                this.Name = "newLayer";
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.frames = {};
            }
            parse(json, assetmgr, assetbundle) {
                this.Name = json.Name;
                switch (json.type) {
                    case "particlesType":
                        this.type = framework.F14TypeEnum.particlesType;
                        this.elementdata = new framework.F14EmissionBaseData();
                        this.elementdata.parse(json.emissiondata, assetmgr, assetbundle);
                        break;
                    case "SingleMeshType":
                        this.type = framework.F14TypeEnum.SingleMeshType;
                        this.elementdata = new framework.F14SingleMeshBaseData(json.frames[0].frameindex);
                        this.elementdata.parse(json.singlemeshdata, assetmgr, assetbundle);
                        break;
                    case "RefType":
                        this.type = framework.F14TypeEnum.RefType;
                        this.elementdata = new framework.F14RefBaseData();
                        this.elementdata.parse(json.RefData, assetmgr, assetbundle);
                        break;
                    default:
                        console.log("f14Eff parse layerjson error!");
                        return;
                }
                for (let i = 0; i < json.frames.length; i++) {
                    let framejson = json.frames[i];
                    let frameindex = framejson.frameindex;
                    let frameitem = new F14FrameData(frameindex, this.type);
                    this.frames[frameindex] = frameitem;
                    switch (this.type) {
                        case framework.F14TypeEnum.SingleMeshType:
                            for (let k = 0; k < framejson.vec3Atts.length; k++) {
                                let name = framejson.vec3Atts[k].name;
                                let strValue = framejson.vec3Atts[k].value;
                                let v3 = new gd3d.math.vector3();
                                gd3d.math.vec3FormJson(strValue, v3);
                                frameitem.singlemeshAttDic[name] = v3;
                            }
                            for (let k = 0; k < framejson.vec4Atts.length; k++) {
                                let name = framejson.vec4Atts[k].name;
                                let strValue = framejson.vec4Atts[k].value;
                                let v4 = new gd3d.math.vector4();
                                gd3d.math.vec4FormJson(strValue, v4);
                                frameitem.singlemeshAttDic[name] = v4;
                            }
                            for (let k = 0; k < framejson.colorAtts.length; k++) {
                                let name = framejson.colorAtts[k].name;
                                let strValue = framejson.colorAtts[k].value;
                                let color = new gd3d.math.color();
                                gd3d.math.colorFormJson(strValue, color);
                                frameitem.singlemeshAttDic[name] = color;
                            }
                            break;
                        case framework.F14TypeEnum.particlesType:
                            let data = new framework.F14EmissionBaseData();
                            data.parse(framejson.emissionData, assetmgr, assetbundle);
                            frameitem.EmissionData = data;
                    }
                }
            }
        }
        framework.F14LayerData = F14LayerData;
        class F14FrameData {
            constructor(index, type) {
                this.frameindex = index;
                if (type == framework.F14TypeEnum.SingleMeshType) {
                    this.singlemeshAttDic = {};
                }
                else {
                    this.EmissionData = new framework.F14EmissionBaseData();
                }
            }
        }
        framework.F14FrameData = F14FrameData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class NumberData {
            constructor(value = 0) {
                this.isRandom = false;
                this._value = 0;
                this._valueLimitMin = 0;
                this._valueLimitMax = 0;
                this.beInited = false;
                this._value = value;
            }
            setValue(value) {
                this._value = value;
            }
            setRandomValue(max, min) {
                this._valueLimitMax = max;
                this._valueLimitMin = min;
                this.isRandom = true;
            }
            getValue(reRandom = false) {
                if (this.isRandom) {
                    if (reRandom || !this.beInited) {
                        this.key = Math.random();
                        this._value = this.key * (this._valueLimitMax - this._valueLimitMin) + this._valueLimitMin;
                        this.beInited = true;
                    }
                }
                return this._value;
            }
            static copyto(from, to) {
                to.isRandom = from.isRandom;
                to._value = from._value;
                to._valueLimitMin = from._valueLimitMin;
                to._valueLimitMax = from._valueLimitMax;
            }
            static FormJson(json, data) {
                if (json.indexOf("~") < 0) {
                    data.setValue(Number(json));
                }
                else {
                    let arr = json.split("~");
                    data.setRandomValue(Number(arr[1]), Number(arr[0]));
                }
            }
        }
        framework.NumberData = NumberData;
        class Vector3Data {
            constructor(x = 0, y = 0, z = 0) {
                this.x = new NumberData();
                this.y = new NumberData();
                this.z = new NumberData();
                this.x.setValue(x);
                this.y.setValue(y);
                this.z.setValue(z);
            }
            getValue(reRandom = false) {
                let _out = new gd3d.math.vector3();
                _out.x = this.x.getValue(reRandom);
                _out.y = this.y.getValue(reRandom);
                _out.z = this.z.getValue(reRandom);
                return _out;
            }
            static copyto(from, to) {
                NumberData.copyto(from.x, to.x);
                NumberData.copyto(from.y, to.y);
                NumberData.copyto(from.z, to.z);
            }
            static FormJson(json, data) {
                let arr = json.split(",");
                NumberData.FormJson(arr[0], data.x);
                NumberData.FormJson(arr[1], data.y);
                NumberData.FormJson(arr[2], data.z);
            }
        }
        framework.Vector3Data = Vector3Data;
        class NumberKey {
            constructor(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
        }
        framework.NumberKey = NumberKey;
        class Vector3Key {
            constructor(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
        }
        framework.Vector3Key = Vector3Key;
        class Vector2Key {
            constructor(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
        }
        framework.Vector2Key = Vector2Key;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class F14Emission {
            constructor(effect, layer) {
                this.particlelist = [];
                this.deadParticles = [];
                this.frameLife = 0;
                this.TotalTime = 0;
                this.newStartDataTime = 0;
                this.curTime = 0;
                this.beover = false;
                this.numcount = 0;
                this.localMatrix = new gd3d.math.matrix();
                this._worldMatrix = new gd3d.math.matrix();
                this.localrot = new gd3d.math.quaternion();
                this.worldRot = new gd3d.math.quaternion();
                this.lastFrame = 0;
                this.bursts = [];
                this.type = framework.F14TypeEnum.particlesType;
                this.effect = effect;
                this.layer = layer;
                this.baseddata = layer.data.elementdata;
                this.currentData = this.baseddata;
                this.newStartDataTime = this.baseddata.delayTime;
                this.initBycurrentdata();
                this.vertexCount = this.currentData.mesh.data.pos.length;
                this.posArr = this.currentData.mesh.data.pos;
                this.colorArr = this.currentData.mesh.data.color;
                this.uvArr = this.currentData.mesh.data.uv;
                this.dataforebo = this.currentData.mesh.data.genIndexDataArray();
                this.vertexLength = gd3d.render.meshData.calcByteSize(this.effect.VF) / 4;
                this.dataforvboLen = this.vertexCount * this.vertexLength;
            }
            update(deltaTime, frame, fps) {
                this.TotalTime += deltaTime;
                this.refreshByFrameData(fps);
                this.updateLife();
                for (let i = 0; i < this.particlelist.length; i++) {
                    this.particlelist[i].update(deltaTime);
                }
            }
            refreshByFrameData(fps) {
                this.frameLife = Math.floor(this.baseddata.duration * fps);
                if (this.frameLife == 0)
                    this.frameLife = 1;
                let frame = Math.floor(this.TotalTime * fps) % this.frameLife;
                if (frame != this.lastFrame && this.layer.frames[frame]) {
                    if (frame == this.layer.frameList[0]) {
                        this.currentData = this.baseddata;
                    }
                    if (this.layer.frames[frame].data.EmissionData != this.currentData) {
                        this.changeCurrentBaseData(this.layer.frames[frame].data.EmissionData);
                    }
                }
                this.lastFrame = frame;
            }
            changeCurrentBaseData(data) {
                this.currentData = data;
                this.newStartDataTime = this.TotalTime;
                this.numcount = 0;
                this.initBycurrentdata();
            }
            initBycurrentdata() {
                gd3d.math.quatFromEulerAngles(this.currentData.rotEuler.x, this.currentData.rotEuler.y, this.currentData.rotEuler.z, this.localrot);
                gd3d.math.matrixMakeTransformRTS(this.currentData.rotPosition, this.currentData.rotScale, this.localrot, this.localMatrix);
            }
            getWorldMatrix() {
                let mat = this.effect.root.getWorldMatrix();
                gd3d.math.matrixMultiply(mat, this.localMatrix, this._worldMatrix);
                return this._worldMatrix;
            }
            getWorldRotation() {
                let rot = this.effect.root.getWorldRotate();
                gd3d.math.quatMultiply(rot, this.localrot, this.worldRot);
                return this.worldRot;
            }
            updateLife() {
                if (this.beover)
                    return;
                this.curTime = this.TotalTime - this.baseddata.delayTime;
                if (this.curTime <= 0)
                    return;
                this.updateEmission();
                if (this.curTime > this.baseddata.duration) {
                    if (this.baseddata.beloop) {
                        switch (this.baseddata.loopenum) {
                            case framework.LoopEnum.Restart:
                                this.reInit();
                                break;
                            case framework.LoopEnum.TimeContinue:
                                this.beover = true;
                                break;
                        }
                    }
                    else {
                        this.beover = true;
                    }
                }
            }
            reInit() {
                this.currentData = this.baseddata;
                this.newStartDataTime = this.baseddata.delayTime;
                this.beover = false;
                this.TotalTime = 0;
                this.numcount = 0;
                this.currentData.rateOverTime.getValue(true);
                this.bursts = [];
            }
            updateEmission() {
                let needCount = Math.floor(this.currentData.rateOverTime.getValue() * (this.TotalTime - this.newStartDataTime));
                let realcount = needCount - this.numcount;
                if (realcount > 0) {
                    this.addParticle(realcount);
                }
                this.numcount += realcount;
                if (this.baseddata.bursts.length > 0) {
                    for (let i = 0; i < this.baseddata.bursts.length; i++) {
                        let index = this.bursts.indexOf(this.baseddata.bursts[i].time);
                        if (index < 0 && this.baseddata.bursts[i].time <= this.TotalTime) {
                            let count = this.baseddata.bursts[i].count.getValue(true);
                            this.baseddata.bursts[i].burst();
                            this.bursts.push(this.baseddata.bursts[i].time);
                            this.addParticle(count);
                        }
                    }
                }
            }
            addParticle(count = 1) {
                for (let i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        let pp = this.deadParticles.pop();
                        pp.initByEmissionData(this.currentData);
                    }
                    else {
                        let pp = new framework.F14Particle(this, this.currentData);
                        this.particlelist.push(pp);
                    }
                }
            }
            reset() {
                this.reInit();
                for (let i = 0; i < this.particlelist.length; i++) {
                    if (this.particlelist[i].actived) {
                        this.particlelist[i].actived = false;
                        this.deadParticles.push(this.particlelist[i]);
                    }
                }
            }
            changeColor(value) {
                this.currentData.startColor = new framework.Vector3Data(value.r, value.g, value.b);
                this.currentData.startAlpha = new framework.NumberData(value.a);
            }
            OnEndOnceLoop() {
            }
            dispose() {
                this.effect = null;
                this.baseddata = null;
                this.currentData = null;
                delete this.dataforebo;
                delete this.posArr;
                delete this.colorArr;
                delete this.uvArr;
                delete this.bursts;
                for (let key in this.particlelist) {
                    this.particlelist[key].dispose();
                }
                for (let key in this.deadParticles) {
                    this.deadParticles[key].dispose();
                }
            }
        }
        framework.F14Emission = F14Emission;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let RenderModelEnum;
        (function (RenderModelEnum) {
            RenderModelEnum[RenderModelEnum["None"] = 0] = "None";
            RenderModelEnum[RenderModelEnum["BillBoard"] = 1] = "BillBoard";
            RenderModelEnum[RenderModelEnum["StretchedBillBoard"] = 2] = "StretchedBillBoard";
            RenderModelEnum[RenderModelEnum["HorizontalBillBoard"] = 3] = "HorizontalBillBoard";
            RenderModelEnum[RenderModelEnum["VerticalBillBoard"] = 4] = "VerticalBillBoard";
            RenderModelEnum[RenderModelEnum["Mesh"] = 5] = "Mesh";
        })(RenderModelEnum = framework.RenderModelEnum || (framework.RenderModelEnum = {}));
        class F14EmissionBaseData {
            constructor() {
                this.loopenum = framework.LoopEnum.Restart;
                this.rotPosition = new gd3d.math.vector3();
                this.rotScale = new gd3d.math.vector3(1, 1, 1);
                this.rotEuler = new gd3d.math.vector3();
                this.rendermodel = RenderModelEnum.Mesh;
                this.beloop = true;
                this.lifeTime = new framework.NumberData(20);
                this.simulateInLocalSpace = true;
                this.startScaleRate = new framework.NumberData(1);
                this.startScale = new framework.Vector3Data(1, 1, 1);
                this.startEuler = new framework.Vector3Data();
                this.startColor = new framework.Vector3Data(1, 1, 1);
                this.startAlpha = new framework.NumberData(1);
                this.colorRate = 1;
                this.simulationSpeed = new framework.NumberData(1);
                this.start_tex_st = new gd3d.math.vector4(1, 1, 0, 0);
                this.delayTime = 0;
                this.duration = 10;
                this.rateOverTime = new framework.NumberData(1);
                this.bursts = [];
                this.shapeType = framework.ParticleSystemShape.NORMAL;
                this.emitFrom = framework.emitfromenum.base;
                this.enableVelocityOverLifetime = false;
                this.moveSpeed = new framework.Vector3Data(0);
                this.enableSizeOverLifetime = false;
                this.sizeNodes = [];
                this.enableRotOverLifeTime = false;
                this.angleSpeed = new framework.NumberData(0);
                this.enableColorOverLifetime = false;
                this.colorNodes = [];
                this.alphaNodes = [];
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
            }
            parse(json, assetmgr, assetbundle) {
                switch (json.loopenum) {
                    case "Restart":
                        this.loopenum = framework.LoopEnum.Restart;
                        break;
                    case "TimeContinue":
                        this.loopenum = framework.LoopEnum.TimeContinue;
                        break;
                }
                this.mesh = assetmgr.getAssetByName(json.mesh, assetbundle);
                this.material = assetmgr.getAssetByName(json.material, assetbundle);
                gd3d.math.vec3FormJson(json.rotPosition, this.rotPosition);
                gd3d.math.vec3FormJson(json.rotScale, this.rotScale);
                gd3d.math.vec3FormJson(json.rotEuler, this.rotEuler);
                switch (json.rendermodel) {
                    default:
                    case "BillBoard":
                        this.rendermodel = RenderModelEnum.BillBoard;
                        break;
                    case "HorizontalBillBoard":
                        this.rendermodel = RenderModelEnum.HorizontalBillBoard;
                        break;
                    case "Mesh":
                        this.rendermodel = RenderModelEnum.Mesh;
                        break;
                    case "StretchedBillBoard":
                        this.rendermodel = RenderModelEnum.StretchedBillBoard;
                        break;
                    case "VerticalBillBoard":
                        this.rendermodel = RenderModelEnum.VerticalBillBoard;
                        break;
                    case "None":
                        this.rendermodel = RenderModelEnum.None;
                        break;
                }
                this.beloop = json.beloop;
                framework.NumberData.FormJson(json.lifeTime, this.lifeTime);
                this.simulateInLocalSpace = json.simulateInLocalSpace;
                framework.NumberData.FormJson(json.startScaleRate, this.startScaleRate);
                framework.Vector3Data.FormJson(json.startScale, this.startScale);
                framework.Vector3Data.FormJson(json.startEuler, this.startEuler);
                framework.Vector3Data.FormJson(json.startColor, this.startColor);
                framework.NumberData.FormJson(json.startAlpha, this.startAlpha);
                this.colorRate = json.colorRate;
                framework.NumberData.FormJson(json.simulationSpeed, this.simulationSpeed);
                gd3d.math.vec4FormJson(json.start_tex_st, this.start_tex_st);
                this.delayTime = json.delayTime;
                this.duration = json.duration;
                framework.NumberData.FormJson(json.rateOverTime, this.rateOverTime);
                for (let i = 0; i < json.bursts.length; i++) {
                    let item = json.bursts[i];
                    let info = busrtInfo.CreatformJson(item);
                    this.bursts.push(info);
                }
                switch (json.shapeType) {
                    case "NORMAL":
                        this.shapeType = framework.ParticleSystemShape.NORMAL;
                        break;
                    case "BOX":
                        this.shapeType = framework.ParticleSystemShape.BOX;
                        this.width = json.width;
                        this.height = json.height;
                        this.depth = json.depth;
                        break;
                    case "SPHERE":
                        this.shapeType = framework.ParticleSystemShape.SPHERE;
                        this.radius = json.radius;
                        break;
                    case "HEMISPHERE":
                        this.shapeType = framework.ParticleSystemShape.HEMISPHERE;
                        this.radius = json.radius;
                        break;
                    case "CONE":
                        this.shapeType = framework.ParticleSystemShape.CONE;
                        this.height = json.height;
                        this.angle = json.angle;
                        this.radius = json.radius;
                        switch (json.emitFrom) {
                            case "base_":
                                this.emitFrom = framework.emitfromenum.base;
                                break;
                            case "volume":
                                this.emitFrom = framework.emitfromenum.volume;
                                break;
                        }
                        break;
                    case "CIRCLE":
                        this.shapeType = framework.ParticleSystemShape.CIRCLE;
                        break;
                    case "EDGE":
                        this.shapeType = framework.ParticleSystemShape.EDGE;
                        break;
                }
                this.enableVelocityOverLifetime = json.enableVelocityOverLifetime;
                if (this.enableVelocityOverLifetime) {
                    framework.Vector3Data.FormJson(json.moveSpeed, this.moveSpeed);
                }
                this.enableSizeOverLifetime = json.enableSizeOverLifetime;
                if (this.enableSizeOverLifetime) {
                    for (let i = 0; i < json.sizeNodes.length; i++) {
                        let jsonitem = json.sizeNodes[i];
                        let item = new framework.NumberKey(jsonitem.key, jsonitem.value);
                        this.sizeNodes.push(item);
                    }
                }
                this.enableRotOverLifeTime = json.enableRotOverLifeTime;
                if (this.enableRotOverLifeTime) {
                    framework.NumberData.FormJson(json.angleSpeed, this.angleSpeed);
                }
                this.enableColorOverLifetime = json.enableColorOverLifetime;
                if (this.enableColorOverLifetime) {
                    for (let i = 0; i < json.colorNodes.length; i++) {
                        let jsonitem = json.colorNodes[i];
                        let v3 = new gd3d.math.vector3();
                        gd3d.math.vec3FormJson(jsonitem.value, v3);
                        let item = new framework.Vector3Key(jsonitem.key, v3);
                        this.colorNodes.push(item);
                    }
                    for (let i = 0; i < json.alphaNodes.length; i++) {
                        let jsonitem = json.alphaNodes[i];
                        let item = new framework.NumberKey(jsonitem.key, jsonitem.value);
                        this.alphaNodes.push(item);
                    }
                }
                this.enableTexAnimation = json.enableTexAnimation;
                if (this.enableTexAnimation) {
                    switch (json.uvType) {
                        case "UVRoll":
                            this.uvType = framework.UVTypeEnum.UVRoll;
                            this.uSpeed = json.uSpeed;
                            this.vSpeed = json.vSpeed;
                            break;
                        case "UVSprite":
                            this.uvType = framework.UVTypeEnum.UVSprite;
                            this.row = json.row;
                            this.column = json.column;
                            this.count = json.count;
                            break;
                        case "NONE":
                            this.uvType = framework.UVTypeEnum.NONE;
                            break;
                    }
                }
            }
            static getRandomDirAndPosByZEmission(emission, outDir, outPos) {
                switch (emission.shapeType) {
                    case framework.ParticleSystemShape.NORMAL:
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_zero, outPos);
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_up, outDir);
                        break;
                    case framework.ParticleSystemShape.SPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        var radius = Math.random() * emission.radius;
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.HEMISPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI * 0.5;
                        var radius = Math.random() * emission.radius;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.BOX:
                        outPos.x = framework.ValueData.RandomRange(-emission.width / 2, emission.width / 2);
                        outPos.y = framework.ValueData.RandomRange(-emission.height / 2, emission.height / 2);
                        outPos.z = framework.ValueData.RandomRange(-emission.depth / 2, emission.depth / 2);
                        gd3d.math.vec3Normalize(outPos, outDir);
                        break;
                    case framework.ParticleSystemShape.CONE:
                        var randomAngle = Math.random() * Math.PI * 2;
                        var randomHeight = Math.random() * emission.height;
                        var upradius = randomHeight * Math.tan(emission.angle * Math.PI / 180) + emission.radius;
                        var radomRadius = Math.random() * upradius;
                        var bottompos = gd3d.math.pool.new_vector3();
                        bottompos.x = emission.radius * Math.cos(randomAngle);
                        bottompos.y = 0;
                        bottompos.z = emission.radius * Math.sin(randomAngle);
                        if (emission.emitFrom == framework.emitfromenum.base) {
                            gd3d.math.vec3Clone(bottompos, outPos);
                        }
                        else if (emission.emitFrom == framework.emitfromenum.volume) {
                            outPos.x = radomRadius * Math.cos(randomAngle);
                            outPos.z = radomRadius * Math.sin(randomAngle);
                            outPos.y = randomHeight;
                        }
                        outDir.x = Math.cos(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.z = Math.sin(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.y = Math.cos(emission.angle * Math.PI / 180);
                        break;
                }
            }
        }
        framework.F14EmissionBaseData = F14EmissionBaseData;
        class busrtInfo {
            constructor() {
                this.time = 0;
                this.count = new framework.NumberData(10);
                this._beburst = false;
            }
            beburst() {
                return this._beburst;
            }
            burst(bebusrt = true) {
                this._beburst = bebusrt;
            }
            static CreatformJson(json) {
                let info = new busrtInfo();
                info.time = json.time;
                framework.NumberData.FormJson(json.count, info.count);
                return info;
            }
        }
        framework.busrtInfo = busrtInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class F14EmissionBatch {
            constructor(effect, element) {
                this.curRealVboCount = 0;
                this.curVertexcount = 0;
                this.curIndexCount = 0;
                this.vertexLength = 0;
                this.type = framework.F14TypeEnum.particlesType;
                this.effect = effect;
                this.emission = element;
                this.mesh = this.emission.baseddata.mesh;
                this.mat = this.emission.baseddata.material;
                this.vertexLength = gd3d.render.meshData.calcByteSize(this.effect.VF) / 4;
                let maxParticlesCount = this.getMaxParticleCount();
                let particleVertexCount = this.mesh.data.pos.length;
                let particleIndexCount = this.mesh.data.trisindex.length;
                let totalVertex = maxParticlesCount * particleVertexCount;
                let totalIndex = maxParticlesCount * particleIndexCount;
                this.dataForVbo = new Float32Array(totalVertex * this.vertexLength);
                this.dataForEbo = new Uint16Array(totalIndex);
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, totalVertex, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            }
            getMaxParticleCount() {
                let maxrate;
                let basrat = this.emission.baseddata.rateOverTime;
                maxrate = basrat.isRandom ? basrat._valueLimitMax : basrat._value;
                let liftime = this.emission.baseddata.lifeTime;
                let maxlife = liftime.isRandom ? liftime._valueLimitMax : liftime._value;
                if (!this.emission.baseddata.beloop) {
                    let duration = this.emission.baseddata.duration;
                    if (duration < maxlife) {
                        maxlife = duration;
                    }
                }
                for (let item in this.emission.layer.frameList) {
                    let frame = this.emission.layer.frameList[item];
                    let framerate = this.emission.layer.frames[frame].data.EmissionData.rateOverTime;
                    let rate = framerate.isRandom ? framerate._valueLimitMax : framerate._value;
                    if (rate > maxrate) {
                        maxrate = rate;
                    }
                }
                let burstCount = 0;
                for (let i = 0; i < this.emission.baseddata.bursts.length; i++) {
                    let info = this.emission.baseddata.bursts[i];
                    let Count = info.count.isRandom ? info.count._valueLimitMax : info.count._value;
                    burstCount += Count;
                }
                return Math.floor(maxrate * maxlife + burstCount + 2);
            }
            render(context, assetmgr, camera, Effqueue) {
                if (this.emission.baseddata.simulateInLocalSpace) {
                    gd3d.math.matrixClone(this.effect.mvpMat, context.matrixModelViewProject);
                }
                else {
                    context.updateModeTrail();
                }
                this.mat.setQueue(Effqueue);
                this.curIndexCount = 0;
                this.curVertexcount = 0;
                this.curRealVboCount = 0;
                for (let i = 0, len = this.emission.particlelist.length; i < len; i++) {
                    this.emission.particlelist[i].uploadMeshdata();
                }
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
                this.mat.draw(context, this.mesh, this.mesh.submesh[0]);
            }
            unRender() {
            }
            getElementCount() {
                return 1;
            }
            dispose() {
                this.effect = null;
                this.emission = null;
                this.mesh = null;
                this.mat = null;
                delete this.dataForEbo;
                delete this.dataForVbo;
            }
        }
        framework.F14EmissionBatch = F14EmissionBatch;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class F14Particle {
            constructor(element, data) {
                this.StartPos = new gd3d.math.vector3();
                this.speedDir = new gd3d.math.vector3();
                this.tex_ST = new gd3d.math.vector4();
                this.rotationByEuler = new gd3d.math.quaternion();
                this.rotationByShape = new gd3d.math.quaternion();
                this.startRotation = new gd3d.math.quaternion();
                this.rotAngle = 0;
                this.localMatrix = new gd3d.math.matrix();
                this.localTranslate = new gd3d.math.vector3();
                this.localRotation = new gd3d.math.quaternion();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.color = new gd3d.math.vector3(1, 1, 1);
                this.alpha = 1;
                this.Color = new gd3d.math.color();
                this.life01 = 0;
                this.actived = false;
                this.tempos = gd3d.math.pool.new_vector3();
                this.temcolor = gd3d.math.pool.new_color();
                this.temUv = gd3d.math.pool.new_vector2();
                this.transformVertex = new gd3d.math.matrix();
                this.angleRot = new gd3d.math.quaternion();
                this.worldpos = new gd3d.math.vector3();
                this.tarWorldpos = new gd3d.math.vector3();
                this.worldspeeddir = new gd3d.math.vector3();
                this.lookDir = new gd3d.math.vector3();
                this.temptx = new gd3d.math.vector3();
                this.worldRotation = new gd3d.math.quaternion();
                this.invParWorldRot = new gd3d.math.quaternion();
                this.worldStartPos = new gd3d.math.vector3();
                this.data = data;
                this.element = element;
                this.initByEmissionData(data);
            }
            getEmissionMatToWorld() {
                if (this.data.simulateInLocalSpace) {
                    return this.element.getWorldMatrix();
                }
                else {
                    return this.emissionMatToWorld;
                }
            }
            getemissionWorldRotation() {
                if (this.data.simulateInLocalSpace) {
                    return this.element.getWorldRotation();
                }
                else {
                    return this.emissionWorldRotation;
                }
            }
            initByEmissionData(data) {
                this.actived = true;
                this.curLife = 0;
                this.totalLife = data.lifeTime.getValue(true);
                this.simulateInLocalSpace = data.simulateInLocalSpace;
                this.simulationSpeed = data.simulationSpeed.getValue(true);
                this.startScaleRate = data.startScaleRate.getValue(true);
                this.startScale = data.startScale.getValue(true);
                gd3d.math.vec3ScaleByNum(this.startScale, this.startScaleRate, this.startScale);
                this.Starteuler = data.startEuler.getValue(true);
                this.startColor = data.startColor.getValue(true);
                this.startAlpha = data.startAlpha.getValue(true);
                this.colorRate = data.colorRate;
                this.starTex_ST = data.start_tex_st;
                this.movespeed = data.moveSpeed.getValue(true);
                this.sizeNodes = data.sizeNodes;
                this.eulerSpeed = data.angleSpeed.getValue(true);
                this.colorNodes = data.colorNodes;
                this.alphaNodes = data.alphaNodes;
                this.uvType = data.uvType;
                this.getCurTex_ST(data);
                framework.F14EmissionBaseData.getRandomDirAndPosByZEmission(data, this.speedDir, this.StartPos);
                gd3d.math.quatFromEulerAngles(this.Starteuler.x, this.Starteuler.y, this.Starteuler.z, this.rotationByEuler);
                this.rotAngle = 0;
                gd3d.math.vec3Clone(this.startScale, this.localScale);
                gd3d.math.vec3Clone(this.startColor, this.color);
                this.alpha = this.startAlpha;
                gd3d.math.vec4Clone(this.starTex_ST, this.tex_ST);
                if (!data.simulateInLocalSpace) {
                    this.emissionMatToWorld = new gd3d.math.matrix();
                    this.emissionWorldRotation = new gd3d.math.quaternion();
                    gd3d.math.matrixClone(this.element.getWorldMatrix(), this.emissionMatToWorld);
                    gd3d.math.quatClone(this.element.getWorldRotation(), this.emissionWorldRotation);
                }
                if (data.rendermodel == framework.RenderModelEnum.StretchedBillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    gd3d.math.matrixTransformNormal(this.speedDir, this.emissionMatToWorld, this.worldspeeddir);
                    gd3d.math.vec3Normalize(this.worldspeeddir, this.worldspeeddir);
                    gd3d.math.matrixTransformVector3(this.StartPos, this.emissionMatToWorld, this.worldStartPos);
                }
            }
            update(deltaTime) {
                if (!this.actived)
                    return;
                this.curLife += deltaTime;
                this.life01 = this.curLife / this.totalLife;
                if (this.life01 > 1) {
                    this.actived = false;
                    this.element.deadParticles.push(this);
                    return;
                }
                this.updatePos();
                this.updateSize();
                this.updateEuler();
                this.updateRot();
                this.updateLocalMatrix();
                this.updateColor();
                this.updateUV();
            }
            uploadMeshdata() {
                if (this.actived) {
                    let batch = this.element.layer.batch;
                    for (let i = 0; i < this.element.vertexCount; i++) {
                        gd3d.math.matrixTransformVector3(this.element.posArr[i], this.transformVertex, this.tempos);
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 0] = this.tempos.x;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 1] = this.tempos.y;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 2] = this.tempos.z;
                        if (this.element.colorArr) {
                            gd3d.math.colorMultiply(this.element.colorArr[i], this.Color, this.temcolor);
                        }
                        else {
                            gd3d.math.colorClone(this.Color, this.temcolor);
                        }
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 3] = this.temcolor.r;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 4] = this.temcolor.g;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 5] = this.temcolor.b;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 6] = this.temcolor.a;
                        this.temUv.x = this.element.uvArr[i].x * this.tex_ST.x + this.tex_ST.z;
                        this.temUv.y = this.element.uvArr[i].y * this.tex_ST.y + this.tex_ST.w;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 7] = this.temUv.x;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 8] = this.temUv.y;
                    }
                    for (let i = 0; i < this.element.dataforebo.length; i++) {
                        batch.dataForEbo[i + batch.curIndexCount] = this.element.dataforebo[i] + batch.curVertexcount;
                    }
                    batch.curRealVboCount += this.element.dataforvboLen;
                    batch.curIndexCount += this.element.dataforebo.length;
                    batch.curVertexcount += this.element.vertexCount;
                }
            }
            updateLocalMatrix() {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.data.simulateInLocalSpace) {
                    gd3d.math.matrixMultiply(this.element.localMatrix, this.localMatrix, this.transformVertex);
                }
                else {
                    gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            }
            updatePos() {
                gd3d.math.vec3ScaleByNum(this.speedDir, this.simulationSpeed * this.curLife, this.localTranslate);
                gd3d.math.vec3Add(this.localTranslate, this.StartPos, this.localTranslate);
                if (this.data.enableVelocityOverLifetime) {
                    let moved = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3ScaleByNum(this.movespeed, this.curLife, moved);
                    gd3d.math.vec3Add(this.localTranslate, moved, this.localTranslate);
                    gd3d.math.pool.delete_vector3(moved);
                }
            }
            updateSize() {
                if (this.data.enableSizeOverLifetime && this.sizeNodes.length > 0) {
                    if (this.sizeNodes[0].key > this.life01) {
                        let tar = gd3d.math.numberLerp(1, this.sizeNodes[0].value, this.life01 / this.sizeNodes[0].key);
                        gd3d.math.vec3ScaleByNum(this.startScale, tar, this.localScale);
                        return;
                    }
                    for (let i = 0; i < this.sizeNodes.length - 1; i++) {
                        if (this.sizeNodes[i].key <= this.life01 && this.sizeNodes[i + 1].key >= this.life01) {
                            let tar = gd3d.math.numberLerp(this.sizeNodes[i].value, this.sizeNodes[i + 1].value, (this.life01 - this.sizeNodes[i].key) / (this.sizeNodes[i + 1].key - this.sizeNodes[i].key));
                            gd3d.math.vec3ScaleByNum(this.startScale, tar, this.localScale);
                            break;
                        }
                    }
                }
            }
            updateEuler() {
                if (this.data.enableRotOverLifeTime) {
                    this.rotAngle = this.eulerSpeed * this.curLife;
                }
            }
            updateRot() {
                if (this.data.rendermodel == framework.RenderModelEnum.Mesh) {
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_up, this.rotAngle, this.angleRot);
                    gd3d.math.quatMultiply(this.rotationByEuler, this.angleRot, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.BillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    this.tarWorldpos = this.element.effect.renderCamera.gameObject.transform.getWorldTranslate();
                    gd3d.math.quatLookat(this.worldpos, this.tarWorldpos, this.worldRotation);
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.HorizontalBillBoard) {
                    this.worldRotation.x = -0.5;
                    this.worldRotation.y = 0.5;
                    this.worldRotation.z = 0.5;
                    this.worldRotation.w = 0.5;
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.VerticalBillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    let campos = this.element.effect.renderCamera.gameObject.transform.getWorldTranslate();
                    gd3d.math.vec3Clone(campos, this.tarWorldpos);
                    this.tarWorldpos.y = this.worldpos.y;
                    gd3d.math.quatLookat(this.worldpos, this.tarWorldpos, this.worldRotation);
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.StretchedBillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    gd3d.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    let campos = this.element.effect.renderCamera.gameObject.transform.getWorldTranslate();
                    gd3d.math.vec3Subtract(campos, this.worldpos, this.lookDir);
                    gd3d.math.vec3Normalize(this.lookDir, this.lookDir);
                    gd3d.math.vec3Cross(this.worldspeeddir, this.lookDir, this.temptx);
                    gd3d.math.vec3Cross(this.temptx, this.worldspeeddir, this.lookDir);
                    gd3d.math.unitxyzToRotation(this.temptx, this.worldspeeddir, this.lookDir, this.worldRotation);
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    gd3d.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    gd3d.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                }
            }
            updateColor() {
                if (this.data.enableColorOverLifetime) {
                    if (this.colorNodes.length > 0) {
                        if (this.colorNodes[0].key > this.life01) {
                            gd3d.math.vec3SLerp(this.startColor, this.colorNodes[0].value, this.life01 / this.colorNodes[0].key, this.color);
                        }
                        else {
                            for (let i = 0; i < this.colorNodes.length - 1; i++) {
                                if (this.colorNodes[i].key <= this.life01 && this.colorNodes[i + 1].key >= this.life01) {
                                    gd3d.math.vec3SLerp(this.colorNodes[i].value, this.colorNodes[i + 1].value, (this.life01 - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key), this.color);
                                    break;
                                }
                            }
                        }
                    }
                    if (this.alphaNodes.length > 0) {
                        if (this.alphaNodes[0].key > this.life01) {
                            this.alpha = gd3d.math.numberLerp(this.startAlpha, this.alphaNodes[0].value, this.life01 / this.alphaNodes[0].key);
                        }
                        else {
                            for (let i = 0; i < this.alphaNodes.length - 1; i++) {
                                if (this.alphaNodes[i].key <= this.life01 && this.alphaNodes[i + 1].key >= this.life01) {
                                    this.alpha = gd3d.math.numberLerp(this.alphaNodes[i].value, this.alphaNodes[i + 1].value, (this.life01 - this.alphaNodes[i].key) / (this.alphaNodes[i + 1].key - this.alphaNodes[i].key));
                                    break;
                                }
                            }
                        }
                    }
                }
                this.Color.r = this.color.x;
                this.Color.g = this.color.y;
                this.Color.b = this.color.z;
                this.Color.a = this.alpha;
            }
            updateUV() {
                this.getCurTex_ST(this.data);
            }
            getCurTex_ST(data) {
                if (!data.enableTexAnimation)
                    return;
                if (data.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.x = 1;
                    this.tex_ST.y = 1;
                    this.tex_ST.z = data.uSpeed * this.curLife;
                    this.tex_ST.w = data.vSpeed * this.curLife;
                }
                else {
                    let index = Math.floor(this.life01 * data.count);
                    if (index >= data.count)
                        index = data.count - 1;
                    gd3d.math.spriteAnimation(data.row, data.column, index, this.tex_ST);
                }
            }
            dispose() {
                this.data = null;
                this.element = null;
                delete this.sizeNodes;
                delete this.colorNodes;
                delete this.alphaNodes;
            }
        }
        framework.F14Particle = F14Particle;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class F14RefElementBatch {
            constructor(effect, element) {
                this.type = framework.F14TypeEnum.RefType;
                this.effect = effect;
                this.element = element;
            }
            unRender() {
            }
            getElementCount() {
                return this.element.RefEffect.getElementCount();
            }
            render(context, assetmgr, camera, Effqueue) {
                if (this.element.drawActive) {
                    this.element.RefEffect.render(context, assetmgr, camera, Effqueue);
                }
                else {
                }
            }
            dispose() {
                this.effect = null;
                this.element = null;
            }
        }
        framework.F14RefElementBatch = F14RefElementBatch;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class F14RefBaseData {
            constructor() {
                this.beLoop = false;
                this.localPos = new gd3d.math.vector3();
                this.localEuler = new gd3d.math.vector3();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
            }
            parse(json, assetmgr, assetbundle) {
                this.beLoop = json.beLoop;
                this.refdataName = json.F14EffectData;
                gd3d.math.vec3FormJson(json.localPos, this.localPos);
                gd3d.math.vec3FormJson(json.localEuler, this.localEuler);
                gd3d.math.vec3FormJson(json.localScale, this.localScale);
            }
        }
        framework.F14RefBaseData = F14RefBaseData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class F14RefElement {
            constructor(effect, layer) {
                this.type = framework.F14TypeEnum.RefType;
                this.effect = effect;
                this.baseddata = layer.data.elementdata;
                this.layer = layer;
                this.refreshStartEndFrame();
                this.RefEffect = new framework.f14EffectSystem();
                this.RefEffect._root = new framework.transform();
                this.RefEffect.enableDraw = true;
                this.RefEffect.gameObject = this.RefEffect._root.gameObject;
                let data = layer.data.elementdata;
                gd3d.math.vec3Clone(data.localPos, this.RefEffect._root.localTranslate);
                gd3d.math.vec3Clone(data.localScale, this.RefEffect._root.localScale);
                gd3d.math.quatFromEulerAngles(data.localEuler.x, data.localEuler.y, data.localEuler.z, this.RefEffect._root.localRotate);
                this.RefEffect._root.markDirty();
                this.RefEffect.beref = true;
                this.baseddata.refData = framework.sceneMgr.app.getAssetMgr().getAssetByName(this.baseddata.refdataName).data;
                this.RefEffect.setData(this.baseddata.refData);
            }
            reset() {
                this.RefEffect.reset();
            }
            refreshStartEndFrame() {
                if (this.layer.frameList.length == 0) {
                    this.startFrame = 0;
                }
                else {
                    this.startFrame = this.layer.frameList[0];
                }
                if (this.layer.frameList.length > 1) {
                    this.endFrame = this.layer.frameList[this.layer.frameList.length - 1];
                }
                else {
                    this.endFrame = this.effect.data.lifeTime;
                }
            }
            update(deltaTime, frame, fps) {
                if (this.RefEffect._root.parent == null) {
                    this.effect.gameObject.transform.addChild(this.RefEffect._root);
                    this.RefEffect._root.markDirty();
                    this.RefEffect._root.updateWorldTran();
                }
                if (this.layer.frameList.length == 0) {
                    this.drawActive = false;
                    return;
                }
                if (this.effect.data.beloop) {
                    frame = this.effect.restartFrame;
                }
                if (frame < this.startFrame || frame > this.endFrame) {
                    this.drawActive = false;
                    this.RefEffect["playState"] = framework.PlayStateEnum.beReady;
                    return;
                }
                else {
                    this.drawActive = true;
                    this.RefEffect.enabletimeFlow = true;
                }
                this.RefEffect.update(deltaTime);
            }
            OnEndOnceLoop() {
            }
            changeColor(value) {
                this.RefEffect.changeColor(value);
            }
            dispose() {
                this.baseddata = null;
                this.RefEffect.remove();
                this.RefEffect = null;
            }
        }
        framework.F14RefElement = F14RefElement;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class F14SingleMesh {
            constructor(effect, layer) {
                this.position = new gd3d.math.vector3();
                this.scale = new gd3d.math.vector3();
                this.euler = new gd3d.math.vector3();
                this.color = new gd3d.math.color();
                this.tex_ST = new gd3d.math.vector4();
                this.localRotate = new gd3d.math.quaternion();
                this.targetMat = new gd3d.math.matrix();
                this.tempos = gd3d.math.pool.new_vector3();
                this.temColor = gd3d.math.pool.new_color();
                this.temUv = gd3d.math.pool.new_vector2();
                this.eulerRot = new gd3d.math.quaternion();
                this.worldpos = new gd3d.math.vector3();
                this.worldRot = new gd3d.math.quaternion();
                this.inverseRot = new gd3d.math.quaternion();
                this.lookDir = new gd3d.math.vector3();
                this.worldDirx = new gd3d.math.vector3();
                this.worldDiry = new gd3d.math.vector3();
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.effect = effect;
                this.layer = layer;
                this.baseddata = layer.data.elementdata;
                gd3d.math.vec3Clone(this.baseddata.position, this.position);
                gd3d.math.vec3Clone(this.baseddata.scale, this.scale);
                gd3d.math.vec3Clone(this.baseddata.euler, this.euler);
                gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.localRotate);
                gd3d.math.colorClone(this.baseddata.color, this.color);
                gd3d.math.vec4Clone(this.baseddata.tex_ST, this.tex_ST);
                this.refreshStartEndFrame();
                this.posArr = this.baseddata.mesh.data.pos;
                this.colorArr = this.baseddata.mesh.data.color;
                this.uvArr = this.baseddata.mesh.data.uv;
                this.vertexCount = this.posArr.length;
                this.dataforvbo = this.baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                this.dataforebo = this.baseddata.mesh.data.genIndexDataArray();
            }
            refreshStartEndFrame() {
                if (this.layer.frameList.length == 0) {
                    this.startFrame = 0;
                }
                else {
                    this.startFrame = this.layer.frameList[0];
                }
                if (this.layer.frameList.length > 1) {
                    this.endFrame = this.layer.frameList[this.layer.frameList.length - 1];
                }
                else {
                    this.endFrame = this.effect.data.lifeTime;
                }
            }
            update(deltaTime, frame, fps) {
                if (this.layer.frameList.length == 0) {
                    this.drawActive = false;
                    return;
                }
                if (this.effect.data.beloop) {
                    switch (this.baseddata.loopenum) {
                        case framework.LoopEnum.Restart:
                            frame = this.effect.restartFrame;
                            break;
                        case framework.LoopEnum.TimeContinue:
                            break;
                    }
                }
                if (frame < this.startFrame || frame > this.endFrame) {
                    this.drawActive = false;
                    return;
                }
                else {
                    this.drawActive = true;
                }
                for (var item in this.layer.Attlines) {
                    let att = this.layer.Attlines[item];
                    att.getValue(frame, this.baseddata, this[item]);
                }
                if (this.baseddata.enableTexAnimation) {
                    this.refreshCurTex_ST(frame, deltaTime, fps);
                }
                this.updateRotByBillboard();
                this.refreshTargetMatrix();
            }
            OnEndOnceLoop() {
                this.reset();
            }
            refreshTargetMatrix() {
                gd3d.math.matrixMakeTransformRTS(this.position, this.scale, this.localRotate, this.targetMat);
            }
            uploadMeshdata() {
                let batch = this.layer.batch;
                for (let i = 0; i < this.vertexCount; i++) {
                    gd3d.math.matrixTransformVector3(this.posArr[i], this.targetMat, this.tempos);
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 0] = this.tempos.x;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 1] = this.tempos.y;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 2] = this.tempos.z;
                    if (this.colorArr) {
                        gd3d.math.colorMultiply(this.colorArr[i], this.color, this.temColor);
                    }
                    else {
                        gd3d.math.colorClone(this.color, this.temColor);
                    }
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 3] = this.temColor.r;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 4] = this.temColor.g;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 5] = this.temColor.b;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 6] = this.temColor.a;
                    this.temUv.x = this.uvArr[i].x * this.tex_ST.x + this.tex_ST.z;
                    this.temUv.y = this.uvArr[i].y * this.tex_ST.y + this.tex_ST.w;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 7] = this.temUv.x;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 8] = this.temUv.y;
                }
                for (let i = 0; i < this.dataforebo.length; i++) {
                    batch.dataForEbo[i + batch.curIndexCount] = this.dataforebo[i] + batch.curVertexcount;
                }
                batch.curRealVboCount += this.dataforvbo.length;
                batch.curIndexCount += this.dataforebo.length;
                batch.curVertexcount += this.vertexCount;
            }
            refreshCurTex_ST(curframe, detalTime, fps) {
                if (this.baseddata.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.z += this.baseddata.uSpeed * detalTime;
                    this.tex_ST.w += this.baseddata.vSpeed * detalTime;
                }
                else if (this.baseddata.uvType == framework.UVTypeEnum.UVSprite) {
                    let lerp = (curframe - this.startFrame) / (this.endFrame + 1 - this.startFrame);
                    let spritindex = Math.floor(lerp * this.baseddata.count);
                    gd3d.math.spriteAnimation(this.baseddata.row, this.baseddata.column, spritindex, this.tex_ST);
                }
            }
            updateRotByBillboard() {
                if (this.baseddata.beBillboard) {
                    if (this.baseddata.bindAxis == framework.BindAxis.NONE) {
                        let mat = this.effect.root.getWorldMatrix();
                        gd3d.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        let targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        gd3d.math.quatLookat(this.worldpos, targetpos, this.worldRot);
                        let parentRot = this.effect.root.getWorldRotate();
                        gd3d.math.quatInverse(parentRot, this.inverseRot);
                        gd3d.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                        gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.euler.z, this.eulerRot);
                        gd3d.math.quatMultiply(this.localRotate, this.eulerRot, this.localRotate);
                    }
                    else if (this.baseddata.bindAxis == framework.BindAxis.X) {
                        let mat = this.effect.root.getWorldMatrix();
                        gd3d.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        let targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        gd3d.math.vec3Subtract(targetpos, this.worldpos, this.lookDir);
                        gd3d.math.vec3Normalize(this.lookDir, this.lookDir);
                        gd3d.math.matrixMakeTransformRTS(this.baseddata.position, this.baseddata.scale, this.localRotate, this.targetMat);
                        gd3d.math.matrixMultiply(mat, this.targetMat, this.targetMat);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_right, this.targetMat, this.worldDirx);
                        gd3d.math.vec3Normalize(this.worldDirx, this.worldDirx);
                        gd3d.math.vec3Cross(this.lookDir, this.worldDirx, this.worldDiry);
                        gd3d.math.vec3Cross(this.worldDirx, this.worldDiry, this.lookDir);
                        gd3d.math.unitxyzToRotation(this.worldDirx, this.worldDiry, this.lookDir, this.worldRot);
                        let parentRot = this.effect.root.getWorldRotate();
                        gd3d.math.quatInverse(parentRot, this.inverseRot);
                        gd3d.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                    }
                    else {
                        let mat = this.effect.root.getWorldMatrix();
                        gd3d.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        let targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        gd3d.math.vec3Subtract(targetpos, this.worldpos, this.lookDir);
                        gd3d.math.vec3Normalize(this.lookDir, this.lookDir);
                        gd3d.math.matrixMakeTransformRTS(this.position, this.scale, this.localRotate, this.targetMat);
                        gd3d.math.matrixMultiply(mat, this.targetMat, this.targetMat);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_up, this.targetMat, this.worldDiry);
                        gd3d.math.vec3Normalize(this.worldDiry, this.worldDiry);
                        gd3d.math.vec3Cross(this.worldDiry, this.lookDir, this.worldDirx);
                        gd3d.math.vec3Cross(this.worldDirx, this.worldDiry, this.lookDir);
                        gd3d.math.unitxyzToRotation(this.worldDirx, this.worldDiry, this.lookDir, this.worldRot);
                        let parentRot = this.effect.root.getWorldRotate();
                        gd3d.math.quatInverse(parentRot, this.inverseRot);
                        gd3d.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                    }
                }
                else {
                    gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.localRotate);
                }
            }
            reset() {
                gd3d.math.vec3Clone(this.baseddata.position, this.position);
                gd3d.math.vec3Clone(this.baseddata.scale, this.scale);
                gd3d.math.vec3Clone(this.baseddata.euler, this.euler);
                gd3d.math.colorClone(this.baseddata.color, this.color);
                gd3d.math.vec4Clone(this.baseddata.tex_ST, this.tex_ST);
            }
            changeColor(value) {
                this.color = value;
            }
            dispose() {
                this.layer = null;
                this.RenderBatch = null;
                this.baseddata = null;
                this.effect = null;
                delete this.posArr;
                delete this.colorArr;
                delete this.uvArr;
                delete this.dataforvbo;
                delete this.dataforebo;
            }
        }
        framework.F14SingleMesh = F14SingleMesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class F14SingleMeshBath {
            constructor(mat, effect) {
                this.meshlist = [];
                this.activemeshlist = [];
                this.mesh = new framework.mesh();
                this.indices = [];
                this.vertices = [];
                this.colors = [];
                this.uv = [];
                this.curRealVboCount = 0;
                this.curVertexcount = 0;
                this.curIndexCount = 0;
                this.vertexLength = 0;
                this.noBatch = false;
                this.mat = new gd3d.math.matrix();
                this.defST = new gd3d.math.vector4(1, 1, 0, 0);
                this.temptColorv4 = new gd3d.math.vector4();
                this.uploadData = false;
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.effect = effect;
                this.ElementMat = mat;
            }
            OnEndCollectElement() {
                this.vertexLength = gd3d.render.meshData.calcByteSize(this.effect.VF) / 4;
                if (this.meshlist.length == 1) {
                    this.noBatch = true;
                    this.mesh.glMesh = new gd3d.render.glMesh();
                    this.dataForVbo = this.meshlist[0].baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                    this.dataForEbo = this.meshlist[0].baseddata.mesh.data.genIndexDataArray();
                    this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, this.meshlist[0].baseddata.mesh.data.pos.length, gd3d.render.MeshTypeEnum.Static);
                    this.mesh.glMesh.uploadVertexData(this.effect.webgl, this.dataForVbo);
                    this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                    this.mesh.glMesh.uploadIndexData(this.effect.webgl, 0, this.dataForEbo);
                    this.mesh.submesh = [];
                    {
                        var sm = new framework.subMeshInfo();
                        sm.matIndex = 0;
                        sm.useVertexIndex = 0;
                        sm.start = 0;
                        sm.size = this.dataForEbo.length;
                        sm.line = false;
                        this.mesh.submesh.push(sm);
                    }
                    return;
                }
                let totalVertexCount = 0;
                let toltalIndexCount = 0;
                for (let i = 0, len = this.meshlist.length; i < len; i++) {
                    totalVertexCount += this.meshlist[i].baseddata.mesh.data.pos.length;
                    toltalIndexCount += this.meshlist[i].baseddata.mesh.data.trisindex.length;
                }
                this.dataForVbo = new Float32Array(totalVertexCount * this.vertexLength);
                this.dataForEbo = new Uint16Array(toltalIndexCount);
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, totalVertexCount, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            }
            reInit(mat, effect) {
                this.effect = effect;
                this.ElementMat = mat;
                this.meshlist.length = 0;
            }
            addElement(mesh, insert = false) {
                this.meshlist.push(mesh);
                mesh.layer.batch = this;
            }
            canBatch(mesh) {
                if (this.ElementMat != mesh.baseddata.material) {
                    return false;
                }
                if (this.ElementMat.getShader().getName().indexOf("mask") > 0) {
                    return false;
                }
                return true;
            }
            getElementCount() {
                return this.meshlist.length;
            }
            render(context, assetmgr, camera, Effqueue) {
                if (this.meshlist.length == 0)
                    return;
                this.activemeshlist.length = 0;
                for (let i = 0, len = this.meshlist.length; i < len; i++) {
                    if (this.meshlist[i].drawActive) {
                        this.activemeshlist.push(this.meshlist[i]);
                    }
                }
                if (this.activemeshlist.length < 1)
                    return;
                this.ElementMat.setQueue(Effqueue);
                if (this.noBatch) {
                    gd3d.math.matrixMultiply(this.effect.mvpMat, this.activemeshlist[0].targetMat, context.matrixModelViewProject);
                    if (!this.uploadData) {
                        this.dataForVbo = this.activemeshlist[0].baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                        this.dataForEbo = this.activemeshlist[0].baseddata.mesh.data.genIndexDataArray();
                        this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                        this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                        this.mesh.submesh[0].size = this.dataForEbo.length;
                    }
                    this.temptColorv4.x = this.activemeshlist[0].color.r;
                    this.temptColorv4.y = this.activemeshlist[0].color.g;
                    this.temptColorv4.z = this.activemeshlist[0].color.b;
                    this.temptColorv4.w = this.activemeshlist[0].color.a;
                    this.ElementMat.setVector4("_Main_Color", this.temptColorv4);
                    this.ElementMat.setVector4("_Main_Tex_ST", this.activemeshlist[0].tex_ST);
                    this.ElementMat.draw(context, this.mesh, this.mesh.submesh[0]);
                }
                else {
                    gd3d.math.matrixClone(this.effect.mvpMat, context.matrixModelViewProject);
                    this.curIndexCount = 0;
                    this.curVertexcount = 0;
                    this.curRealVboCount = 0;
                    for (let i = 0, len = this.activemeshlist.length; i < len; i++) {
                        this.activemeshlist[i].uploadMeshdata();
                    }
                    this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                    this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                    this.mesh.submesh[0].size = this.curIndexCount;
                    this.ElementMat.setVector4("_Main_Color", new gd3d.math.vector4(1, 1, 1, 1));
                    this.ElementMat.setVector4("_Main_Tex_ST", new gd3d.math.vector4(1, 1, 0, 0));
                    this.ElementMat.draw(context, this.mesh, this.mesh.submesh[0]);
                }
            }
            unRender() {
            }
            dispose() {
                this.effect = null;
                this.ElementMat = null;
                delete this.meshlist;
                delete this.activemeshlist;
                this.mesh.dispose();
                delete this.mesh;
                delete this.indices;
                delete this.vertices;
                delete this.colors;
                delete this.uv;
                delete this.dataForEbo;
                delete this.dataForVbo;
            }
        }
        framework.F14SingleMeshBath = F14SingleMeshBath;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let LoopEnum;
        (function (LoopEnum) {
            LoopEnum[LoopEnum["Restart"] = 0] = "Restart";
            LoopEnum[LoopEnum["TimeContinue"] = 1] = "TimeContinue";
        })(LoopEnum = framework.LoopEnum || (framework.LoopEnum = {}));
        let BindAxis;
        (function (BindAxis) {
            BindAxis[BindAxis["X"] = 0] = "X";
            BindAxis[BindAxis["Y"] = 1] = "Y";
            BindAxis[BindAxis["NONE"] = 2] = "NONE";
        })(BindAxis = framework.BindAxis || (framework.BindAxis = {}));
        class F14SingleMeshBaseData {
            constructor(firstFrame) {
                this.loopenum = LoopEnum.Restart;
                this.position = new gd3d.math.vector3();
                this.scale = new gd3d.math.vector3(1, 1, 1);
                this.euler = new gd3d.math.vector3();
                this.color = new gd3d.math.color(1, 1, 1, 1);
                this.tex_ST = new gd3d.math.vector4();
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
                this.beBillboard = false;
                this.bindAxis = BindAxis.NONE;
                this.firtstFrame = 0;
                this.firtstFrame = firstFrame;
                this.mesh = gd3d.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
                this.material = gd3d.framework.sceneMgr.app.getAssetMgr().getDefParticleMat();
            }
            parse(json, assetmgr, assetbundle) {
                switch (json.loopenum) {
                    case "Restart":
                        this.loopenum = LoopEnum.Restart;
                        break;
                    case "TimeContinue":
                        this.loopenum = LoopEnum.TimeContinue;
                        break;
                }
                this.mesh = assetmgr.getAssetByName(json.mesh, assetbundle);
                this.material = assetmgr.getAssetByName(json.material, assetbundle);
                gd3d.math.vec3FormJson(json.position, this.position);
                gd3d.math.vec3FormJson(json.scale, this.scale);
                gd3d.math.vec3FormJson(json.euler, this.euler);
                gd3d.math.colorFormJson(json.color, this.color);
                gd3d.math.vec4FormJson(json.tex_ST, this.tex_ST);
                this.enableTexAnimation = json.enableTexAnimation;
                if (this.enableTexAnimation) {
                    switch (json.uvType) {
                        case "UVRoll":
                            this.uvType = framework.UVTypeEnum.UVRoll;
                            this.uSpeed = json.uSpeed;
                            this.vSpeed = json.vSpeed;
                            break;
                        case "UVSprite":
                            this.uvType = framework.UVTypeEnum.UVSprite;
                            this.row = json.row;
                            this.column = json.column;
                            this.count = json.count;
                            break;
                        case "NONE":
                            this.uvType = framework.UVTypeEnum.NONE;
                            break;
                    }
                }
                if (json.beBillboard != null) {
                    this.beBillboard = json.beBillboard;
                    switch (json.bindAxis) {
                        case "NONE":
                            this.bindAxis = BindAxis.NONE;
                            break;
                        case "X":
                            this.bindAxis = BindAxis.X;
                            break;
                        case "Y":
                            this.bindAxis = BindAxis.Y;
                            break;
                    }
                }
            }
        }
        framework.F14SingleMeshBaseData = F14SingleMeshBaseData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class pointinfo {
            constructor() {
                this.touch = false;
            }
        }
        framework.pointinfo = pointinfo;
        class inputMgr {
            constructor(app) {
                this.inputlast = null;
                this.point = new pointinfo();
                this.touches = {};
                this.keyboardMap = {};
                this.rMtr_90 = new gd3d.math.matrix3x2();
                this.rMtr_n90 = new gd3d.math.matrix3x2();
                this.app = app;
                gd3d.math.matrix3x2MakeRotate(Math.PI * 90 / 180, this.rMtr_90);
                gd3d.math.matrix3x2MakeRotate(Math.PI * -90 / 180, this.rMtr_n90);
                app.webgl.canvas.addEventListener("touchstart", (ev) => {
                    this.CalcuPoint(ev.touches[0].clientX, ev.touches[0].clientY);
                    this.point.touch = true;
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (this.touches[id] == null) {
                            this.touches[id] = new pointinfo();
                            this.touches[id].id = id;
                        }
                        this.touches[id].touch = true;
                        this.touches[id].x = touch.clientX;
                        this.touches[id].y = touch.clientY;
                    }
                });
                app.webgl.canvas.addEventListener("touchmove", (ev) => {
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (this.touches[id] == null) {
                            this.touches[id] = new pointinfo();
                            this.touches[id].id = id;
                        }
                        this.touches[id].touch = true;
                        this.touches[id].x = touch.clientX;
                        this.touches[id].y = touch.clientY;
                    }
                    var count = 0;
                    var x = 0;
                    var y = 0;
                    for (var key in this.touches) {
                        if (this.touches[key].touch == true) {
                            x += this.touches[key].x;
                            y += this.touches[key].y;
                            count++;
                        }
                    }
                    this.CalcuPoint(x / count, y / count);
                });
                app.webgl.canvas.addEventListener("touchend", (ev) => {
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (this.touches[id] == null) {
                            this.touches[id] = new pointinfo();
                            this.touches[id].id = id;
                        }
                        this.touches[id].touch = false;
                    }
                    for (var key in this.touches) {
                        if (this.touches[key].touch == true)
                            return;
                    }
                    this.point.touch = false;
                });
                app.webgl.canvas.addEventListener("touchcancel", (ev) => {
                    for (var i = 0; i < ev.changedTouches.length; i++) {
                        var touch = ev.changedTouches[i];
                        var id = touch.identifier;
                        if (this.touches[id] == null) {
                            this.touches[id] = new pointinfo();
                            this.touches[id].id = id;
                        }
                        this.touches[id].touch = false;
                    }
                    for (var key in this.touches) {
                        if (this.touches[key].touch == true)
                            return;
                    }
                    this.point.touch = false;
                });
                app.webgl.canvas.addEventListener("mousedown", (ev) => {
                    this.CalcuPoint(ev.offsetX, ev.offsetY);
                    this.point.touch = true;
                });
                app.webgl.canvas.addEventListener("mouseup", (ev) => {
                    this.point.touch = false;
                });
                app.webgl.canvas.addEventListener("mousemove", (ev) => {
                    this.CalcuPoint(ev.offsetX, ev.offsetY);
                });
                app.webgl.canvas.addEventListener("keydown", (ev) => {
                    this.keyboardMap[ev.keyCode] = true;
                }, false);
                app.webgl.canvas.addEventListener("keyup", (ev) => {
                    this.keyboardMap[ev.keyCode] = false;
                }, false);
                app.webgl.canvas.addEventListener("blur", (ev) => {
                    this.point.touch = false;
                }, false);
            }
            anyKey() {
                if (this.point.touch)
                    return true;
                for (const key in this.keyboardMap) {
                    if (this.keyboardMap.hasOwnProperty(key)) {
                        const element = this.keyboardMap[key];
                        if (element == true)
                            return true;
                    }
                }
                return false;
            }
            GetKeyDown(value) {
                if (typeof (value) === "number") {
                    if (this.keyboardMap[value] != null)
                        return this.keyboardMap[value];
                }
                else if (typeof (value) === "string") {
                    let id = framework.KeyCode[value];
                    if (id != null && this.keyboardMap[id] != null)
                        return this.keyboardMap[id];
                }
                return false;
            }
            GetKeyUP(value) {
                if (typeof (value) === "number") {
                    if (this.keyboardMap[value] != null)
                        return !this.keyboardMap[value];
                }
                else if (typeof (value) === "string") {
                    let id = framework.KeyCode[value];
                    if (id != null && this.keyboardMap[id] != null)
                        return !this.keyboardMap[id];
                }
                return false;
            }
            CalcuPoint(clientX, clientY) {
                if (!this.app || isNaN(clientX) || isNaN(clientY))
                    return;
                if (!this.tempV2_0)
                    this.tempV2_0 = gd3d.math.pool.new_vector2();
                if (!this.tempV2_1)
                    this.tempV2_1 = gd3d.math.pool.new_vector2();
                this.tempV2_0.x = clientX / this.app.scaleFromPandding;
                this.tempV2_0.y = clientY / this.app.scaleFromPandding;
                gd3d.math.vec2Clone(this.tempV2_0, this.tempV2_1);
                if (this.app.shouldRotate) {
                    switch (this.app.orientation) {
                        case gd3d.framework.OrientationMode.PORTRAIT:
                            gd3d.math.matrix3x2TransformVector2(this.rMtr_90, this.tempV2_0, this.tempV2_1);
                            this.point.x = this.tempV2_1.x + this.app.webgl.canvas.width;
                            this.point.y = this.tempV2_1.y;
                            break;
                        case gd3d.framework.OrientationMode.LANDSCAPE:
                            gd3d.math.matrix3x2TransformVector2(this.rMtr_n90, this.tempV2_0, this.tempV2_1);
                            this.point.x = this.tempV2_1.x;
                            this.point.y = this.tempV2_1.y + this.app.webgl.canvas.height;
                            break;
                        case gd3d.framework.OrientationMode.LANDSCAPE_FLIPPED:
                            gd3d.math.matrix3x2TransformVector2(this.rMtr_90, this.tempV2_0, this.tempV2_1);
                            this.point.x = this.tempV2_1.x + this.app.webgl.canvas.width;
                            this.point.y = this.tempV2_1.y;
                            break;
                    }
                }
                else {
                    this.point.x = this.tempV2_0.x;
                    this.point.y = this.tempV2_0.y;
                }
            }
        }
        framework.inputMgr = inputMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let KeyCode;
        (function (KeyCode) {
            KeyCode[KeyCode["None"] = 0] = "None";
            KeyCode[KeyCode["Backspace"] = 8] = "Backspace";
            KeyCode[KeyCode["Tab"] = 9] = "Tab";
            KeyCode[KeyCode["Clear"] = 12] = "Clear";
            KeyCode[KeyCode["Return"] = 13] = "Return";
            KeyCode[KeyCode["Pause"] = 19] = "Pause";
            KeyCode[KeyCode["Escape"] = 27] = "Escape";
            KeyCode[KeyCode["Space"] = 32] = "Space";
            KeyCode[KeyCode["Exclaim"] = 33] = "Exclaim";
            KeyCode[KeyCode["DoubleQuote"] = 34] = "DoubleQuote";
            KeyCode[KeyCode["Hash"] = 35] = "Hash";
            KeyCode[KeyCode["Dollar"] = 36] = "Dollar";
            KeyCode[KeyCode["Ampersand"] = 38] = "Ampersand";
            KeyCode[KeyCode["Quote"] = 39] = "Quote";
            KeyCode[KeyCode["LeftParen"] = 40] = "LeftParen";
            KeyCode[KeyCode["RightParen"] = 41] = "RightParen";
            KeyCode[KeyCode["Asterisk"] = 42] = "Asterisk";
            KeyCode[KeyCode["Plus"] = 43] = "Plus";
            KeyCode[KeyCode["Comma"] = 44] = "Comma";
            KeyCode[KeyCode["Minus"] = 45] = "Minus";
            KeyCode[KeyCode["Period"] = 46] = "Period";
            KeyCode[KeyCode["Slash"] = 47] = "Slash";
            KeyCode[KeyCode["Alpha0"] = 48] = "Alpha0";
            KeyCode[KeyCode["Alpha1"] = 49] = "Alpha1";
            KeyCode[KeyCode["Alpha2"] = 50] = "Alpha2";
            KeyCode[KeyCode["Alpha3"] = 51] = "Alpha3";
            KeyCode[KeyCode["Alpha4"] = 52] = "Alpha4";
            KeyCode[KeyCode["Alpha5"] = 53] = "Alpha5";
            KeyCode[KeyCode["Alpha6"] = 54] = "Alpha6";
            KeyCode[KeyCode["Alpha7"] = 55] = "Alpha7";
            KeyCode[KeyCode["Alpha8"] = 56] = "Alpha8";
            KeyCode[KeyCode["Alpha9"] = 57] = "Alpha9";
            KeyCode[KeyCode["Colon"] = 58] = "Colon";
            KeyCode[KeyCode["Semicolon"] = 59] = "Semicolon";
            KeyCode[KeyCode["Less"] = 60] = "Less";
            KeyCode[KeyCode["Equals"] = 61] = "Equals";
            KeyCode[KeyCode["Greater"] = 62] = "Greater";
            KeyCode[KeyCode["Question"] = 63] = "Question";
            KeyCode[KeyCode["At"] = 64] = "At";
            KeyCode[KeyCode["LeftBracket"] = 91] = "LeftBracket";
            KeyCode[KeyCode["Backslash"] = 92] = "Backslash";
            KeyCode[KeyCode["RightBracket"] = 93] = "RightBracket";
            KeyCode[KeyCode["Caret"] = 94] = "Caret";
            KeyCode[KeyCode["Underscore"] = 95] = "Underscore";
            KeyCode[KeyCode["BackQuote"] = 96] = "BackQuote";
            KeyCode[KeyCode["A"] = 97] = "A";
            KeyCode[KeyCode["B"] = 98] = "B";
            KeyCode[KeyCode["C"] = 99] = "C";
            KeyCode[KeyCode["D"] = 100] = "D";
            KeyCode[KeyCode["E"] = 101] = "E";
            KeyCode[KeyCode["F"] = 102] = "F";
            KeyCode[KeyCode["G"] = 103] = "G";
            KeyCode[KeyCode["H"] = 104] = "H";
            KeyCode[KeyCode["I"] = 105] = "I";
            KeyCode[KeyCode["J"] = 106] = "J";
            KeyCode[KeyCode["K"] = 107] = "K";
            KeyCode[KeyCode["L"] = 108] = "L";
            KeyCode[KeyCode["M"] = 109] = "M";
            KeyCode[KeyCode["N"] = 110] = "N";
            KeyCode[KeyCode["O"] = 111] = "O";
            KeyCode[KeyCode["P"] = 112] = "P";
            KeyCode[KeyCode["Q"] = 113] = "Q";
            KeyCode[KeyCode["R"] = 114] = "R";
            KeyCode[KeyCode["S"] = 115] = "S";
            KeyCode[KeyCode["T"] = 116] = "T";
            KeyCode[KeyCode["U"] = 117] = "U";
            KeyCode[KeyCode["V"] = 118] = "V";
            KeyCode[KeyCode["W"] = 119] = "W";
            KeyCode[KeyCode["X"] = 120] = "X";
            KeyCode[KeyCode["Y"] = 121] = "Y";
            KeyCode[KeyCode["Z"] = 122] = "Z";
            KeyCode[KeyCode["Delete"] = 127] = "Delete";
            KeyCode[KeyCode["Keypad0"] = 256] = "Keypad0";
            KeyCode[KeyCode["Keypad1"] = 257] = "Keypad1";
            KeyCode[KeyCode["Keypad2"] = 258] = "Keypad2";
            KeyCode[KeyCode["Keypad3"] = 259] = "Keypad3";
            KeyCode[KeyCode["Keypad4"] = 260] = "Keypad4";
            KeyCode[KeyCode["Keypad5"] = 261] = "Keypad5";
            KeyCode[KeyCode["Keypad6"] = 262] = "Keypad6";
            KeyCode[KeyCode["Keypad7"] = 263] = "Keypad7";
            KeyCode[KeyCode["Keypad8"] = 264] = "Keypad8";
            KeyCode[KeyCode["Keypad9"] = 265] = "Keypad9";
            KeyCode[KeyCode["KeypadPeriod"] = 266] = "KeypadPeriod";
            KeyCode[KeyCode["KeypadDivide"] = 267] = "KeypadDivide";
            KeyCode[KeyCode["KeypadMultiply"] = 268] = "KeypadMultiply";
            KeyCode[KeyCode["KeypadMinus"] = 269] = "KeypadMinus";
            KeyCode[KeyCode["KeypadPlus"] = 270] = "KeypadPlus";
            KeyCode[KeyCode["KeypadEnter"] = 271] = "KeypadEnter";
            KeyCode[KeyCode["KeypadEquals"] = 272] = "KeypadEquals";
            KeyCode[KeyCode["UpArrow"] = 273] = "UpArrow";
            KeyCode[KeyCode["DownArrow"] = 274] = "DownArrow";
            KeyCode[KeyCode["RightArrow"] = 275] = "RightArrow";
            KeyCode[KeyCode["LeftArrow"] = 276] = "LeftArrow";
            KeyCode[KeyCode["Insert"] = 277] = "Insert";
            KeyCode[KeyCode["Home"] = 278] = "Home";
            KeyCode[KeyCode["End"] = 279] = "End";
            KeyCode[KeyCode["PageUp"] = 280] = "PageUp";
            KeyCode[KeyCode["PageDown"] = 281] = "PageDown";
            KeyCode[KeyCode["F1"] = 282] = "F1";
            KeyCode[KeyCode["F2"] = 283] = "F2";
            KeyCode[KeyCode["F3"] = 284] = "F3";
            KeyCode[KeyCode["F4"] = 285] = "F4";
            KeyCode[KeyCode["F5"] = 286] = "F5";
            KeyCode[KeyCode["F6"] = 287] = "F6";
            KeyCode[KeyCode["F7"] = 288] = "F7";
            KeyCode[KeyCode["F8"] = 289] = "F8";
            KeyCode[KeyCode["F9"] = 290] = "F9";
            KeyCode[KeyCode["F10"] = 291] = "F10";
            KeyCode[KeyCode["F11"] = 292] = "F11";
            KeyCode[KeyCode["F12"] = 293] = "F12";
            KeyCode[KeyCode["F13"] = 294] = "F13";
            KeyCode[KeyCode["F14"] = 295] = "F14";
            KeyCode[KeyCode["F15"] = 296] = "F15";
            KeyCode[KeyCode["Numlock"] = 300] = "Numlock";
            KeyCode[KeyCode["CapsLock"] = 301] = "CapsLock";
            KeyCode[KeyCode["ScrollLock"] = 302] = "ScrollLock";
            KeyCode[KeyCode["RightShift"] = 303] = "RightShift";
            KeyCode[KeyCode["LeftShift"] = 304] = "LeftShift";
            KeyCode[KeyCode["RightControl"] = 305] = "RightControl";
            KeyCode[KeyCode["LeftControl"] = 306] = "LeftControl";
            KeyCode[KeyCode["RightAlt"] = 307] = "RightAlt";
            KeyCode[KeyCode["LeftAlt"] = 308] = "LeftAlt";
            KeyCode[KeyCode["RightCommand"] = 309] = "RightCommand";
            KeyCode[KeyCode["RightApple"] = 309] = "RightApple";
            KeyCode[KeyCode["LeftCommand"] = 310] = "LeftCommand";
            KeyCode[KeyCode["LeftApple"] = 310] = "LeftApple";
            KeyCode[KeyCode["LeftWindows"] = 311] = "LeftWindows";
            KeyCode[KeyCode["RightWindows"] = 312] = "RightWindows";
            KeyCode[KeyCode["AltGr"] = 313] = "AltGr";
            KeyCode[KeyCode["Help"] = 315] = "Help";
            KeyCode[KeyCode["Print"] = 316] = "Print";
            KeyCode[KeyCode["SysReq"] = 317] = "SysReq";
            KeyCode[KeyCode["Break"] = 318] = "Break";
            KeyCode[KeyCode["Menu"] = 319] = "Menu";
            KeyCode[KeyCode["Mouse0"] = 323] = "Mouse0";
            KeyCode[KeyCode["Mouse1"] = 324] = "Mouse1";
            KeyCode[KeyCode["Mouse2"] = 325] = "Mouse2";
            KeyCode[KeyCode["Mouse3"] = 326] = "Mouse3";
            KeyCode[KeyCode["Mouse4"] = 327] = "Mouse4";
            KeyCode[KeyCode["Mouse5"] = 328] = "Mouse5";
            KeyCode[KeyCode["Mouse6"] = 329] = "Mouse6";
            KeyCode[KeyCode["JoystickButton0"] = 330] = "JoystickButton0";
            KeyCode[KeyCode["JoystickButton1"] = 331] = "JoystickButton1";
            KeyCode[KeyCode["JoystickButton2"] = 332] = "JoystickButton2";
            KeyCode[KeyCode["JoystickButton3"] = 333] = "JoystickButton3";
            KeyCode[KeyCode["JoystickButton4"] = 334] = "JoystickButton4";
            KeyCode[KeyCode["JoystickButton5"] = 335] = "JoystickButton5";
            KeyCode[KeyCode["JoystickButton6"] = 336] = "JoystickButton6";
            KeyCode[KeyCode["JoystickButton7"] = 337] = "JoystickButton7";
            KeyCode[KeyCode["JoystickButton8"] = 338] = "JoystickButton8";
            KeyCode[KeyCode["JoystickButton9"] = 339] = "JoystickButton9";
            KeyCode[KeyCode["JoystickButton10"] = 340] = "JoystickButton10";
            KeyCode[KeyCode["JoystickButton11"] = 341] = "JoystickButton11";
            KeyCode[KeyCode["JoystickButton12"] = 342] = "JoystickButton12";
            KeyCode[KeyCode["JoystickButton13"] = 343] = "JoystickButton13";
            KeyCode[KeyCode["JoystickButton14"] = 344] = "JoystickButton14";
            KeyCode[KeyCode["JoystickButton15"] = 345] = "JoystickButton15";
            KeyCode[KeyCode["JoystickButton16"] = 346] = "JoystickButton16";
            KeyCode[KeyCode["JoystickButton17"] = 347] = "JoystickButton17";
            KeyCode[KeyCode["JoystickButton18"] = 348] = "JoystickButton18";
            KeyCode[KeyCode["JoystickButton19"] = 349] = "JoystickButton19";
            KeyCode[KeyCode["Joystick1Button0"] = 350] = "Joystick1Button0";
            KeyCode[KeyCode["Joystick1Button1"] = 351] = "Joystick1Button1";
            KeyCode[KeyCode["Joystick1Button2"] = 352] = "Joystick1Button2";
            KeyCode[KeyCode["Joystick1Button3"] = 353] = "Joystick1Button3";
            KeyCode[KeyCode["Joystick1Button4"] = 354] = "Joystick1Button4";
            KeyCode[KeyCode["Joystick1Button5"] = 355] = "Joystick1Button5";
            KeyCode[KeyCode["Joystick1Button6"] = 356] = "Joystick1Button6";
            KeyCode[KeyCode["Joystick1Button7"] = 357] = "Joystick1Button7";
            KeyCode[KeyCode["Joystick1Button8"] = 358] = "Joystick1Button8";
            KeyCode[KeyCode["Joystick1Button9"] = 359] = "Joystick1Button9";
            KeyCode[KeyCode["Joystick1Button10"] = 360] = "Joystick1Button10";
            KeyCode[KeyCode["Joystick1Button11"] = 361] = "Joystick1Button11";
            KeyCode[KeyCode["Joystick1Button12"] = 362] = "Joystick1Button12";
            KeyCode[KeyCode["Joystick1Button13"] = 363] = "Joystick1Button13";
            KeyCode[KeyCode["Joystick1Button14"] = 364] = "Joystick1Button14";
            KeyCode[KeyCode["Joystick1Button15"] = 365] = "Joystick1Button15";
            KeyCode[KeyCode["Joystick1Button16"] = 366] = "Joystick1Button16";
            KeyCode[KeyCode["Joystick1Button17"] = 367] = "Joystick1Button17";
            KeyCode[KeyCode["Joystick1Button18"] = 368] = "Joystick1Button18";
            KeyCode[KeyCode["Joystick1Button19"] = 369] = "Joystick1Button19";
            KeyCode[KeyCode["Joystick2Button0"] = 370] = "Joystick2Button0";
            KeyCode[KeyCode["Joystick2Button1"] = 371] = "Joystick2Button1";
            KeyCode[KeyCode["Joystick2Button2"] = 372] = "Joystick2Button2";
            KeyCode[KeyCode["Joystick2Button3"] = 373] = "Joystick2Button3";
            KeyCode[KeyCode["Joystick2Button4"] = 374] = "Joystick2Button4";
            KeyCode[KeyCode["Joystick2Button5"] = 375] = "Joystick2Button5";
            KeyCode[KeyCode["Joystick2Button6"] = 376] = "Joystick2Button6";
            KeyCode[KeyCode["Joystick2Button7"] = 377] = "Joystick2Button7";
            KeyCode[KeyCode["Joystick2Button8"] = 378] = "Joystick2Button8";
            KeyCode[KeyCode["Joystick2Button9"] = 379] = "Joystick2Button9";
            KeyCode[KeyCode["Joystick2Button10"] = 380] = "Joystick2Button10";
            KeyCode[KeyCode["Joystick2Button11"] = 381] = "Joystick2Button11";
            KeyCode[KeyCode["Joystick2Button12"] = 382] = "Joystick2Button12";
            KeyCode[KeyCode["Joystick2Button13"] = 383] = "Joystick2Button13";
            KeyCode[KeyCode["Joystick2Button14"] = 384] = "Joystick2Button14";
            KeyCode[KeyCode["Joystick2Button15"] = 385] = "Joystick2Button15";
            KeyCode[KeyCode["Joystick2Button16"] = 386] = "Joystick2Button16";
            KeyCode[KeyCode["Joystick2Button17"] = 387] = "Joystick2Button17";
            KeyCode[KeyCode["Joystick2Button18"] = 388] = "Joystick2Button18";
            KeyCode[KeyCode["Joystick2Button19"] = 389] = "Joystick2Button19";
            KeyCode[KeyCode["Joystick3Button0"] = 390] = "Joystick3Button0";
            KeyCode[KeyCode["Joystick3Button1"] = 391] = "Joystick3Button1";
            KeyCode[KeyCode["Joystick3Button2"] = 392] = "Joystick3Button2";
            KeyCode[KeyCode["Joystick3Button3"] = 393] = "Joystick3Button3";
            KeyCode[KeyCode["Joystick3Button4"] = 394] = "Joystick3Button4";
            KeyCode[KeyCode["Joystick3Button5"] = 395] = "Joystick3Button5";
            KeyCode[KeyCode["Joystick3Button6"] = 396] = "Joystick3Button6";
            KeyCode[KeyCode["Joystick3Button7"] = 397] = "Joystick3Button7";
            KeyCode[KeyCode["Joystick3Button8"] = 398] = "Joystick3Button8";
            KeyCode[KeyCode["Joystick3Button9"] = 399] = "Joystick3Button9";
            KeyCode[KeyCode["Joystick3Button10"] = 400] = "Joystick3Button10";
            KeyCode[KeyCode["Joystick3Button11"] = 401] = "Joystick3Button11";
            KeyCode[KeyCode["Joystick3Button12"] = 402] = "Joystick3Button12";
            KeyCode[KeyCode["Joystick3Button13"] = 403] = "Joystick3Button13";
            KeyCode[KeyCode["Joystick3Button14"] = 404] = "Joystick3Button14";
            KeyCode[KeyCode["Joystick3Button15"] = 405] = "Joystick3Button15";
            KeyCode[KeyCode["Joystick3Button16"] = 406] = "Joystick3Button16";
            KeyCode[KeyCode["Joystick3Button17"] = 407] = "Joystick3Button17";
            KeyCode[KeyCode["Joystick3Button18"] = 408] = "Joystick3Button18";
            KeyCode[KeyCode["Joystick3Button19"] = 409] = "Joystick3Button19";
            KeyCode[KeyCode["Joystick4Button0"] = 410] = "Joystick4Button0";
            KeyCode[KeyCode["Joystick4Button1"] = 411] = "Joystick4Button1";
            KeyCode[KeyCode["Joystick4Button2"] = 412] = "Joystick4Button2";
            KeyCode[KeyCode["Joystick4Button3"] = 413] = "Joystick4Button3";
            KeyCode[KeyCode["Joystick4Button4"] = 414] = "Joystick4Button4";
            KeyCode[KeyCode["Joystick4Button5"] = 415] = "Joystick4Button5";
            KeyCode[KeyCode["Joystick4Button6"] = 416] = "Joystick4Button6";
            KeyCode[KeyCode["Joystick4Button7"] = 417] = "Joystick4Button7";
            KeyCode[KeyCode["Joystick4Button8"] = 418] = "Joystick4Button8";
            KeyCode[KeyCode["Joystick4Button9"] = 419] = "Joystick4Button9";
            KeyCode[KeyCode["Joystick4Button10"] = 420] = "Joystick4Button10";
            KeyCode[KeyCode["Joystick4Button11"] = 421] = "Joystick4Button11";
            KeyCode[KeyCode["Joystick4Button12"] = 422] = "Joystick4Button12";
            KeyCode[KeyCode["Joystick4Button13"] = 423] = "Joystick4Button13";
            KeyCode[KeyCode["Joystick4Button14"] = 424] = "Joystick4Button14";
            KeyCode[KeyCode["Joystick4Button15"] = 425] = "Joystick4Button15";
            KeyCode[KeyCode["Joystick4Button16"] = 426] = "Joystick4Button16";
            KeyCode[KeyCode["Joystick4Button17"] = 427] = "Joystick4Button17";
            KeyCode[KeyCode["Joystick4Button18"] = 428] = "Joystick4Button18";
            KeyCode[KeyCode["Joystick4Button19"] = 429] = "Joystick4Button19";
            KeyCode[KeyCode["Joystick5Button0"] = 430] = "Joystick5Button0";
            KeyCode[KeyCode["Joystick5Button1"] = 431] = "Joystick5Button1";
            KeyCode[KeyCode["Joystick5Button2"] = 432] = "Joystick5Button2";
            KeyCode[KeyCode["Joystick5Button3"] = 433] = "Joystick5Button3";
            KeyCode[KeyCode["Joystick5Button4"] = 434] = "Joystick5Button4";
            KeyCode[KeyCode["Joystick5Button5"] = 435] = "Joystick5Button5";
            KeyCode[KeyCode["Joystick5Button6"] = 436] = "Joystick5Button6";
            KeyCode[KeyCode["Joystick5Button7"] = 437] = "Joystick5Button7";
            KeyCode[KeyCode["Joystick5Button8"] = 438] = "Joystick5Button8";
            KeyCode[KeyCode["Joystick5Button9"] = 439] = "Joystick5Button9";
            KeyCode[KeyCode["Joystick5Button10"] = 440] = "Joystick5Button10";
            KeyCode[KeyCode["Joystick5Button11"] = 441] = "Joystick5Button11";
            KeyCode[KeyCode["Joystick5Button12"] = 442] = "Joystick5Button12";
            KeyCode[KeyCode["Joystick5Button13"] = 443] = "Joystick5Button13";
            KeyCode[KeyCode["Joystick5Button14"] = 444] = "Joystick5Button14";
            KeyCode[KeyCode["Joystick5Button15"] = 445] = "Joystick5Button15";
            KeyCode[KeyCode["Joystick5Button16"] = 446] = "Joystick5Button16";
            KeyCode[KeyCode["Joystick5Button17"] = 447] = "Joystick5Button17";
            KeyCode[KeyCode["Joystick5Button18"] = 448] = "Joystick5Button18";
            KeyCode[KeyCode["Joystick5Button19"] = 449] = "Joystick5Button19";
            KeyCode[KeyCode["Joystick6Button0"] = 450] = "Joystick6Button0";
            KeyCode[KeyCode["Joystick6Button1"] = 451] = "Joystick6Button1";
            KeyCode[KeyCode["Joystick6Button2"] = 452] = "Joystick6Button2";
            KeyCode[KeyCode["Joystick6Button3"] = 453] = "Joystick6Button3";
            KeyCode[KeyCode["Joystick6Button4"] = 454] = "Joystick6Button4";
            KeyCode[KeyCode["Joystick6Button5"] = 455] = "Joystick6Button5";
            KeyCode[KeyCode["Joystick6Button6"] = 456] = "Joystick6Button6";
            KeyCode[KeyCode["Joystick6Button7"] = 457] = "Joystick6Button7";
            KeyCode[KeyCode["Joystick6Button8"] = 458] = "Joystick6Button8";
            KeyCode[KeyCode["Joystick6Button9"] = 459] = "Joystick6Button9";
            KeyCode[KeyCode["Joystick6Button10"] = 460] = "Joystick6Button10";
            KeyCode[KeyCode["Joystick6Button11"] = 461] = "Joystick6Button11";
            KeyCode[KeyCode["Joystick6Button12"] = 462] = "Joystick6Button12";
            KeyCode[KeyCode["Joystick6Button13"] = 463] = "Joystick6Button13";
            KeyCode[KeyCode["Joystick6Button14"] = 464] = "Joystick6Button14";
            KeyCode[KeyCode["Joystick6Button15"] = 465] = "Joystick6Button15";
            KeyCode[KeyCode["Joystick6Button16"] = 466] = "Joystick6Button16";
            KeyCode[KeyCode["Joystick6Button17"] = 467] = "Joystick6Button17";
            KeyCode[KeyCode["Joystick6Button18"] = 468] = "Joystick6Button18";
            KeyCode[KeyCode["Joystick6Button19"] = 469] = "Joystick6Button19";
            KeyCode[KeyCode["Joystick7Button0"] = 470] = "Joystick7Button0";
            KeyCode[KeyCode["Joystick7Button1"] = 471] = "Joystick7Button1";
            KeyCode[KeyCode["Joystick7Button2"] = 472] = "Joystick7Button2";
            KeyCode[KeyCode["Joystick7Button3"] = 473] = "Joystick7Button3";
            KeyCode[KeyCode["Joystick7Button4"] = 474] = "Joystick7Button4";
            KeyCode[KeyCode["Joystick7Button5"] = 475] = "Joystick7Button5";
            KeyCode[KeyCode["Joystick7Button6"] = 476] = "Joystick7Button6";
            KeyCode[KeyCode["Joystick7Button7"] = 477] = "Joystick7Button7";
            KeyCode[KeyCode["Joystick7Button8"] = 478] = "Joystick7Button8";
            KeyCode[KeyCode["Joystick7Button9"] = 479] = "Joystick7Button9";
            KeyCode[KeyCode["Joystick7Button10"] = 480] = "Joystick7Button10";
            KeyCode[KeyCode["Joystick7Button11"] = 481] = "Joystick7Button11";
            KeyCode[KeyCode["Joystick7Button12"] = 482] = "Joystick7Button12";
            KeyCode[KeyCode["Joystick7Button13"] = 483] = "Joystick7Button13";
            KeyCode[KeyCode["Joystick7Button14"] = 484] = "Joystick7Button14";
            KeyCode[KeyCode["Joystick7Button15"] = 485] = "Joystick7Button15";
            KeyCode[KeyCode["Joystick7Button16"] = 486] = "Joystick7Button16";
            KeyCode[KeyCode["Joystick7Button17"] = 487] = "Joystick7Button17";
            KeyCode[KeyCode["Joystick7Button18"] = 488] = "Joystick7Button18";
            KeyCode[KeyCode["Joystick7Button19"] = 489] = "Joystick7Button19";
            KeyCode[KeyCode["Joystick8Button0"] = 490] = "Joystick8Button0";
            KeyCode[KeyCode["Joystick8Button1"] = 491] = "Joystick8Button1";
            KeyCode[KeyCode["Joystick8Button2"] = 492] = "Joystick8Button2";
            KeyCode[KeyCode["Joystick8Button3"] = 493] = "Joystick8Button3";
            KeyCode[KeyCode["Joystick8Button4"] = 494] = "Joystick8Button4";
            KeyCode[KeyCode["Joystick8Button5"] = 495] = "Joystick8Button5";
            KeyCode[KeyCode["Joystick8Button6"] = 496] = "Joystick8Button6";
            KeyCode[KeyCode["Joystick8Button7"] = 497] = "Joystick8Button7";
            KeyCode[KeyCode["Joystick8Button8"] = 498] = "Joystick8Button8";
            KeyCode[KeyCode["Joystick8Button9"] = 499] = "Joystick8Button9";
            KeyCode[KeyCode["Joystick8Button10"] = 500] = "Joystick8Button10";
            KeyCode[KeyCode["Joystick8Button11"] = 501] = "Joystick8Button11";
            KeyCode[KeyCode["Joystick8Button12"] = 502] = "Joystick8Button12";
            KeyCode[KeyCode["Joystick8Button13"] = 503] = "Joystick8Button13";
            KeyCode[KeyCode["Joystick8Button14"] = 504] = "Joystick8Button14";
            KeyCode[KeyCode["Joystick8Button15"] = 505] = "Joystick8Button15";
            KeyCode[KeyCode["Joystick8Button16"] = 506] = "Joystick8Button16";
            KeyCode[KeyCode["Joystick8Button17"] = 507] = "Joystick8Button17";
            KeyCode[KeyCode["Joystick8Button18"] = 508] = "Joystick8Button18";
            KeyCode[KeyCode["Joystick8Button19"] = 509] = "Joystick8Button19";
        })(KeyCode = framework.KeyCode || (framework.KeyCode = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        class converter {
            static getApplyFun(value) {
                return Array.prototype.concat.apply([], value);
            }
            static ULongToArray(value, target = null, offset = 0) {
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                converter.dataView.setUint32(0, uint1, true);
                converter.dataView.setUint32(4, uint2, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 8));
            }
            static LongToArray(value, t = null, offset = 0) {
                let target = t;
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                converter.dataView.setInt32(0, uint1, true);
                converter.dataView.setInt32(4, uint2, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 8));
            }
            static Float64ToArray(value, target = null, offset = 0) {
                converter.dataView.setFloat64(0, value, false);
                return new Uint8Array(converter.dataBuffer.subarray(0, 8));
            }
            static Float32ToArray(value, target = null, offset = 0) {
                converter.dataView.setFloat32(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 4));
            }
            static Int32ToArray(value, target = null, offset = 0) {
                converter.dataView.setInt32(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 4));
            }
            static Int16ToArray(value, target = null, offset = 0) {
                converter.dataView.setInt16(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 2));
            }
            static Uint32toArray(value, target = null, offset = 0) {
                converter.dataView.setInt32(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 4));
            }
            static Uint16ToArray(value, target = null, offset = 0) {
                converter.dataView.setUint16(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 2));
            }
            static StringToUtf8Array(str) {
                var bstr = [];
                for (var i = 0, len = str.length; i < len; ++i) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return new Uint8Array(bstr);
            }
            static ArrayToLong(buf, offset = 0) {
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                var n1 = converter.dataView.getInt32(0, true);
                converter.dataBuffer.set(buf.subarray(offset + 4, offset + 8));
                var n2 = converter.dataView.getInt32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            }
            static ArrayToULong(buf, offset = 0) {
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                var n1 = converter.dataView.getUint32(0, true);
                converter.dataBuffer.set(buf.subarray(offset + 4, offset + 8));
                var n2 = converter.dataView.getUint32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            }
            static ArrayToFloat64(buf, offset = 0) {
                converter.dataBuffer.set(buf.subarray(offset, offset + 8));
                return converter.dataView.getFloat64(0, true);
            }
            static ArrayToFloat32(buf, offset = 0) {
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                return converter.dataView.getFloat32(0, true);
            }
            static ArrayToInt32(buf, offset = 0) {
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                return converter.dataView.getInt32(0, true);
            }
            static ArrayToInt16(buf, offset = 0) {
                converter.dataBuffer.set(buf.subarray(offset, offset + 2));
                return converter.dataView.getInt16(0, true);
            }
            static ArrayToInt8(buf, offset = 0) {
                return buf[offset];
            }
            static ArrayToUint32(buf, offset = 0) {
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                return converter.dataView.getUint32(0, true);
            }
            static ArrayToUint16(buf, offset = 0) {
                for (var i = 0; i < 2; i++) {
                    converter.dataView.setUint8(i, buf[offset + i]);
                }
                return converter.dataView.getUint16(0, true);
            }
            static ArrayToString(buf, offset = 0) {
                var ret = [];
                for (var i = 0; i < buf.length; i++) {
                    var cc = buf[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = buf[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        console.warn("InvalidCharacterError");
                        return "";
                    }
                    else {
                        ret.push(String.fromCharCode(buf[i]));
                    }
                }
                return ret.join('');
            }
        }
        converter.dataBuffer = new Uint8Array(8);
        converter.dataView = new DataView(converter.dataBuffer.buffer);
        io.converter = converter;
        class binTool {
            constructor(size = undefined) {
                this.r_offset = 0;
                this.w_offset = 0;
                this.buffer = memoryPool.Insance.newUint8Array();
            }
            readSingle() {
                let ret = converter.ArrayToFloat32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            }
            readLong() {
                let ret = converter.ArrayToLong(this.buffer, this.r_offset);
                this.r_offset += 8;
                return ret;
            }
            readULong() {
                let ret = converter.ArrayToULong(this.buffer, this.r_offset);
                this.r_offset += 8;
                return ret;
            }
            readDouble() {
                let ret = converter.ArrayToFloat64(this.buffer, this.r_offset);
                this.r_offset += 8;
                return ret;
            }
            readInt8() {
                let ret = this.buffer[this.r_offset];
                this.r_offset += 1;
                return ret;
            }
            readUInt8() {
                let ret = this.buffer[this.r_offset];
                this.r_offset += 1;
                return ret;
            }
            readInt16() {
                let ret = converter.ArrayToInt16(this.buffer, this.r_offset);
                this.r_offset += 2;
                return ret;
            }
            readUInt16() {
                let ret = converter.ArrayToUint16(this.buffer, this.r_offset);
                this.r_offset += 2;
                return ret;
            }
            readInt32() {
                let ret = converter.ArrayToInt32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            }
            readUInt32() {
                let ret = converter.ArrayToUint32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            }
            readBoolean() {
                let ret = this.buffer[this.r_offset] != 0;
                this.r_offset += 1;
                return ret;
            }
            readByte() {
                return this.readUInt8();
            }
            readUnsignedShort() {
                return this.readUInt16();
            }
            readUnsignedInt() {
                let ret = converter.ArrayToUint32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            }
            readFloat() {
                return this.readSingle();
            }
            readSymbolByte() {
                return this.readInt8();
            }
            readShort() {
                return this.readInt16();
            }
            readInt() {
                return this.readInt32();
            }
            readBytes(length) {
                let array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return array;
            }
            readStringUtf8() {
                let length = this.readInt8();
                let array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return converter.ArrayToString(array);
            }
            readStringUtf8FixLength(length) {
                let array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return converter.ArrayToString(array);
            }
            readUTFBytes(length) {
                let array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return converter.ArrayToString(array);
            }
            readStringAnsi() {
                let slen = this.readUInt8();
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this.readByte());
                }
                return bs;
            }
            getLength() {
                return this.w_offset;
            }
            getBytesAvailable() {
                return this.w_offset;
            }
            get length() {
                return this.w_offset;
            }
            writeInt8(num) {
                this.write(num);
            }
            writeUInt8(num) {
                this.write(num);
            }
            writeInt16(num) {
                this.write(converter.Int16ToArray(num));
            }
            writeUInt16(num) {
                this.write(converter.Uint16ToArray(num));
            }
            writeInt32(num) {
                this.write(converter.Int32ToArray(num));
            }
            writeUInt32(num) {
                this.write(converter.Uint32toArray(num));
            }
            writeSingle(num) {
                this.write(converter.Float32ToArray(num));
            }
            writeLong(num) {
                this.write(converter.LongToArray(num));
            }
            writeULong(num) {
                this.write(converter.ULongToArray(num));
            }
            writeDouble(num) {
                this.write(converter.Float64ToArray(num));
            }
            writeStringAnsi(str) {
                var slen = str.length;
                this.writeUInt8(slen);
                for (var i = 0; i < slen; i++)
                    this.writeUInt8(str.charCodeAt(i));
            }
            writeStringUtf8(str) {
                var bstr = converter.StringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.write(bstr);
            }
            writeStringUtf8DataOnly(str) {
                var bstr = converter.StringToUtf8Array(str);
                this.write(bstr);
            }
            writeByte(num) {
                this.write(num);
            }
            writeBytes(array, offset = 0, length = -1) {
                this.write(array, offset, length);
            }
            writeUint8Array(array, offset = 0, length = -1) {
                this.write(array, offset, length);
            }
            writeUnsignedShort(num) {
                this.write(converter.Uint16ToArray(num));
            }
            writeUnsignedInt(num) {
                this.write(converter.Uint32toArray(num));
            }
            writeFloat(num) {
                this.write(converter.Float32ToArray(num));
            }
            writeUTFBytes(str) {
                this.write(converter.StringToUtf8Array(str));
            }
            writeSymbolByte(num) {
                this.write(num);
            }
            writeShort(num) {
                this.write(converter.Int16ToArray(num));
            }
            writeInt(num) {
                this.write(converter.Int32ToArray(num));
            }
            write(array, offset = 0, length = -1) {
                if (array instanceof Uint8Array) {
                    if (this.buffer.byteLength < array.length)
                        this.buffer = array;
                    else {
                        if (this.buffer.length > (array.length + this.w_offset))
                            this.buffer.set(array, this.w_offset);
                        else {
                            let buf = new Uint8Array((array.length + this.w_offset));
                            buf.set(this.buffer);
                            buf.set(array, this.w_offset);
                            this.buffer = buf;
                        }
                    }
                    this.w_offset += array.byteLength;
                }
                else if (array instanceof Array) {
                    if (this.buffer.byteLength < array.length)
                        this.buffer = new Uint8Array(array);
                    else {
                        if (this.buffer.length > (array.length + this.w_offset))
                            this.buffer.set(array, this.w_offset);
                        else {
                            let buf = new Uint8Array((array.length + this.w_offset));
                            buf.set(this.buffer);
                            buf.set(array, this.w_offset);
                            this.buffer = buf;
                        }
                    }
                    this.w_offset += array.length;
                }
                else {
                    this.buffer[this.w_offset] = array;
                    this.w_offset += 1;
                }
            }
            dispose() {
                if (this.buffer.byteLength == 1024)
                    memoryPool.Insance.deleteUint8Array(this.buffer);
                this.buffer = null;
            }
            getBuffer() {
                return this.buffer.subarray(0, this.w_offset);
            }
            getUint8Array() {
                return this.buffer.subarray(0, this.w_offset);
            }
        }
        io.binTool = binTool;
        class memoryPool {
            constructor() {
                this.pool = new Array();
            }
            static get Insance() {
                if (!this.instnace)
                    this.instnace = new memoryPool();
                return memoryPool.instnace;
            }
            ;
            newUint8Array() {
                if (this.pool.length > 0)
                    return this.pool.shift();
                return new Uint8Array(1024);
            }
            deleteUint8Array(array) {
                this.pool.push(array);
            }
        }
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        function cloneObj(instanceObj, clonedObj = undefined) {
            io.referenceInfo.oldmap = {};
            clonedObj = _cloneObj(instanceObj, clonedObj);
            io.referenceInfo.oldmap[instanceObj["insId"].getInsID()] = clonedObj;
            fillCloneReference(instanceObj, clonedObj);
            return clonedObj;
        }
        io.cloneObj = cloneObj;
        function fillCloneReference(instanceObj, clonedObj) {
            let _flag = gd3d.framework.HideFlags.None;
            let _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.DontSaveInBuild) || (_flag & gd3d.framework.HideFlags.DontSaveInEditor) || (_flag & gd3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            for (let key in instanceObj["__gdmeta__"]) {
                let t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                let valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        io.fillCloneReference = fillCloneReference;
        function fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    fillCloneReferenceType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    for (var newkey in instanceObj[key]) {
                        let field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            let _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                            }
                            else {
                                fillCloneReferenceType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                    }
                    if (clonedObj["waitDelArray"]) {
                        let children = clonedObj[key];
                        for (let index of clonedObj["waitDelArray"])
                            children.splice(index, 1);
                        delete clonedObj["waitDelArray"];
                    }
                }
            }
        }
        io.fillCloneReferenceTypeOrArray = fillCloneReferenceTypeOrArray;
        function fillCloneReferenceType(instanceObj, clonedObj, key, instanceParent = null, clonedParent = null, instanceKey = "") {
            let _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                let isArray = instanceObj instanceof Array;
                let type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                }
                else {
                    let isreference = false;
                    let insid = -1;
                    let instance;
                    if ((isArray && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid].gameObject.getComponent(type);
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid].getComponent(type);
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid];
                        }
                    }
                    if (isreference) {
                        if (isArray) {
                            clonedObj.push(instance);
                        }
                        else {
                            clonedObj[key] = instance;
                        }
                    }
                    else {
                        if (clonedObj[key])
                            fillCloneReference(instanceObj[key], clonedObj[key]);
                        else {
                            if (!clonedParent["waitDelArray"])
                                clonedParent["waitDelArray"] = [];
                            clonedParent["waitDelArray"].push(parseInt(key));
                        }
                    }
                }
            }
        }
        io.fillCloneReferenceType = fillCloneReferenceType;
        function _cloneObj(instanceObj, clonedObj = undefined) {
            if (clonedObj == undefined) {
                let insid = -1;
                clonedObj = gd3d.reflect.createInstance(instanceObj, null);
                if (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"]) {
                    insid = instanceObj["gameObject"]["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]) {
                    insid = instanceObj["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["typename"] == "transform" || instanceObj["__gdmeta__"]["class"]["typename"] == "transform2D") {
                    insid = instanceObj["insId"].getInsID();
                    io.referenceInfo.oldmap[insid] = clonedObj;
                }
            }
            for (let key in instanceObj["__gdmeta__"]) {
                let t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                let valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        clonedObj[key] = instanceObj[key];
                        break;
                    default:
                        cloneOtherTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        io._cloneObj = _cloneObj;
        function cloneOtherTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    cloneOtherType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    let isArray = instanceObj[key] instanceof Array;
                    if (isArray)
                        clonedObj[key] = [];
                    else
                        clonedObj[key] = {};
                    for (var newkey in instanceObj[key]) {
                        let field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            let _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                            }
                            else {
                                cloneOtherType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                let baseType = typeof (field);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        if (isArray) {
                                            clonedObj[key].push(field);
                                        }
                                        else {
                                            clonedObj[key][newkey] = field;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        io.cloneOtherTypeOrArray = cloneOtherTypeOrArray;
        function cloneOtherType(instanceObj, clonedObj, key, instanceParent = null, clonedParent = null, instanceKey = "") {
            let _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                let isArray = instanceObj instanceof Array;
                let type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                    let _defaultAsset = instanceObj[key].defaultAsset;
                    if (instanceObj[key].use) {
                        instanceObj[key].use();
                    }
                    if (isArray) {
                        clonedObj.push(instanceObj[key]);
                    }
                    else {
                        clonedObj[key] = instanceObj[key];
                    }
                }
                else {
                    let isreference = false;
                    if ((isArray && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"] || type == "transform" || type == "transform2D") {
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray) {
                        }
                        else {
                        }
                    }
                    else {
                        let _clonedObj;
                        if (_meta["class"]["custom"]["selfclone"]) {
                            _clonedObj = instanceObj[key].clone();
                        }
                        else {
                            _clonedObj = _cloneObj(instanceObj[key], clonedObj[key]);
                        }
                        if (_clonedObj != null) {
                            if (isArray) {
                                if (type == "nodeComponent" && instanceKey == "components" && gd3d.reflect.getClassName(instanceParent) == "gameObject") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "transform" && instanceKey == "children" && gd3d.reflect.getClassName(instanceParent) == "transform") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else if (type == "C2DComponent" && instanceKey == "components" && gd3d.reflect.getClassName(instanceParent) == "transform2D") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "transform2D" && instanceKey == "children" && gd3d.reflect.getClassName(instanceParent) == "transform2D") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else {
                                    clonedObj.push(_clonedObj);
                                }
                            }
                            else {
                                clonedObj[key] = _clonedObj;
                            }
                        }
                        else if (isArray) {
                            clonedObj.push(null);
                        }
                    }
                }
            }
        }
        io.cloneOtherType = cloneOtherType;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        function stringToBlob(content) {
            var u8 = new Uint8Array(stringToUtf8Array(content));
            var blob = new Blob([u8]);
            return blob;
        }
        io.stringToBlob = stringToBlob;
        function stringToUtf8Array(str) {
            var bstr = [];
            for (var i = 0; i < str.length; i++) {
                var c = str.charAt(i);
                var cc = c.charCodeAt(0);
                if (cc > 0xFFFF) {
                    throw new Error("InvalidCharacterError");
                }
                if (cc > 0x80) {
                    if (cc < 0x07FF) {
                        var c1 = (cc >>> 6) | 0xC0;
                        var c2 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2);
                    }
                    else {
                        var c1 = (cc >>> 12) | 0xE0;
                        var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                        var c3 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2, c3);
                    }
                }
                else {
                    bstr.push(cc);
                }
            }
            return bstr;
        }
        io.stringToUtf8Array = stringToUtf8Array;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        let SaveAssetType;
        (function (SaveAssetType) {
            SaveAssetType[SaveAssetType["FullUrl"] = 0] = "FullUrl";
            SaveAssetType[SaveAssetType["NameAndContent"] = 1] = "NameAndContent";
            SaveAssetType[SaveAssetType["DefaultAssets"] = 2] = "DefaultAssets";
        })(SaveAssetType = io.SaveAssetType || (io.SaveAssetType = {}));
        class SerializeDependent {
            static GetAssetContent(asset) {
                let data = {};
                if (asset instanceof gd3d.framework.material)
                    return { "name": asset.getName() + ".mat.json", "value": asset.save(), "type": SaveAssetType.NameAndContent };
            }
            static GetAssetUrl(asset, assetMgr) {
                if (!assetMgr || !asset)
                    return;
                let url = assetMgr.getAssetUrl(asset);
                if (url)
                    SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                else
                    SerializeDependent.resourseDatas.push(SerializeDependent.GetAssetContent(asset));
                if (asset instanceof gd3d.framework.material) {
                    let ass = asset;
                    for (let newKey in ass.statedMapUniforms) {
                        if (!ass.statedMapUniforms[newKey])
                            continue;
                        if (ass.defaultMapUniform[newKey].type != gd3d.render.UniformTypeEnum.Texture)
                            continue;
                        let _texture = ass.statedMapUniforms[newKey];
                        if (!_texture)
                            continue;
                        url = assetMgr.getAssetUrl(_texture);
                        if (url)
                            SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                        else {
                            if (_texture.defaultAsset == true)
                                continue;
                            let content = SerializeDependent.GetAssetContent(_texture);
                            if (content)
                                SerializeDependent.resourseDatas.push(content);
                            continue;
                        }
                        if (url.indexOf(".imgdesc.json") < 0)
                            continue;
                        if (!_texture.realName)
                            continue;
                        url = url.replace(_texture.getName(), _texture.realName);
                        SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                    }
                }
            }
        }
        SerializeDependent.resourseDatas = [];
        io.SerializeDependent = SerializeDependent;
        function SerializeForInspector(obj) {
            var str = JSON.stringify(serializeObjForInspector(obj, false));
            return str;
        }
        io.SerializeForInspector = SerializeForInspector;
        function serializeObjForInspector(instanceObj, beComponent, serializedObj = undefined) {
            let _flag = gd3d.framework.HideFlags.None;
            let _type;
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform" && instanceObj["gameObject"]) {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.HideInInspector)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = {};
            }
            for (let key in instanceObj["__gdmeta__"]) {
                if (key == "children")
                    continue;
                let t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                let valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        let info = new inspectorValueInfo(instanceObj[key], valueType);
                        if (t["custom"]["FieldUIStyle"])
                            info.UIStyle = t["custom"]["FieldUIStyle"];
                        if (t["custom"]["defvalue"])
                            info.defvalue = t["custom"]["defvalue"];
                        if (t["custom"]["min"])
                            info.min = t["custom"]["min"];
                        if (t["custom"]["max"])
                            info.max = t["custom"]["max"];
                        serializedObj[key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObjForInspector = serializeObjForInspector;
        function serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent) {
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent);
                }
                else if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    let isArray = instanceObj[key] instanceof Array;
                    if (isArray)
                        serializedObj[key] = new inspectorValueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    else
                        serializedObj[key] = new inspectorValueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey] == null || instanceObj[key][newkey] == undefined) {
                            continue;
                        }
                        if (instanceObj[key][newkey]["__gdmeta__"]) {
                            let _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                            }
                            else {
                                serializeOtherTypeForInspector(instanceObj[key], serializedObj[key]["value"], newkey, beComponent, instanceObj);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                let baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        if (boolInNull(serializedObj[key]["value"])) {
                                            continue;
                                        }
                                        let info = new inspectorValueInfo(instanceObj[key][newkey], baseType);
                                        if (isArray) {
                                            serializedObj[key]["value"].push(info);
                                        }
                                        else {
                                            serializedObj[key]["value"][newkey] = info;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            else {
                let isArray = instanceObj instanceof Array;
                if (instanceObj["__gdmeta__"]) {
                    if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"]) {
                        let custom = instanceObj["__gdmeta__"][key]["custom"];
                        if (custom["valueType"]) {
                            var info = new inspectorValueInfo(null, custom["valueType"]);
                            if (custom["FieldUIStyle"])
                                info.UIStyle = custom["FieldUIStyle"];
                            if (custom["defvalue"])
                                info.defvalue = custom["defvalue"];
                            if (custom["min"])
                                info.min = custom["min"];
                            if (custom["max"])
                                info.max = custom["max"];
                            if (isArray) {
                                serializedObj.push(info);
                            }
                            else {
                                serializedObj[key] = info;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeOrArrayForInspector = serializeOtherTypeOrArrayForInspector;
        function serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent, arrayInst = null) {
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj[key]) || boolInNull(instanceObj[key]["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            let _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                let isArray = instanceObj instanceof Array;
                let type = _meta["class"]["typename"];
                if (isAssetInspector(type)) {
                    let _defaultAsset = instanceObj[key].defaultAsset;
                    let _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        var info = new inspectorValueInfo(_assetName, type);
                        if (isArray) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                }
                else {
                    let isreference = false;
                    let insid = -1;
                    if ((isArray && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        beComponent = true;
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (!referenceInfo.isRegType(type)) {
                            return;
                        }
                    }
                    if (isreference) {
                        var info = new inspectorValueInfo(insid, type, "reference");
                        if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                            let custom = instanceObj["__gdmeta__"][key]["custom"];
                            info.UIStyle = instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"];
                            if (custom["defvalue"])
                                info.defvalue = custom;
                            if (custom["min"])
                                info.min = custom["min"];
                            if (custom["max"])
                                info.max = custom["max"];
                        }
                        if (isArray) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                    else {
                        if (!referenceInfo.isRegType(type) && beComponent)
                            return;
                        let _serializeObj = serializeObjForInspector(instanceObj[key], beComponent, serializedObj[key]);
                        if (_serializeObj != null) {
                            var info = new inspectorValueInfo(_serializeObj, type);
                            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                                let custom = instanceObj["__gdmeta__"][key]["custom"];
                                info.UIStyle = custom["FieldUIStyle"];
                                if (custom["defvalue"])
                                    info.defvalue = custom;
                                if (custom["min"])
                                    info.min = custom["min"];
                                if (custom["max"])
                                    info.max = custom["max"];
                            }
                            if (isArray) {
                                serializedObj.push(info);
                            }
                            else {
                                serializedObj[key] = info;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeForInspector = serializeOtherTypeForInspector;
        function Serialize(obj, assetMgr = null) {
            return JSON.stringify(serializeObj(obj, null, assetMgr));
        }
        io.Serialize = Serialize;
        function serializeObj(instanceObj, serializedObj = undefined, assetMgr = null) {
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            let _flag = gd3d.framework.HideFlags.None;
            let _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = gd3d.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & gd3d.framework.HideFlags.DontSaveInBuild) || (_flag & gd3d.framework.HideFlags.DontSaveInEditor) || (_flag & gd3d.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = new valueInfo({}, _type);
                if (instanceObj["insId"] != undefined) {
                    serializedObj["insid"] = instanceObj["insId"].getInsID();
                }
            }
            for (let key in instanceObj["__gdmeta__"]) {
                let t = instanceObj["__gdmeta__"][key];
                if (t == null) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                let valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        let info = new valueInfo(instanceObj[key], valueType);
                        serializedObj["value"][key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArray(instanceObj, serializedObj["value"], key, assetMgr);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObj = serializeObj;
        function serializeOtherTypeOrArray(instanceObj, serializedObj, key, assetMgr = null) {
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherType(instanceObj, serializedObj, key, null, assetMgr);
                }
                else if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    let isArray = instanceObj[key] instanceof Array;
                    if (isArray)
                        serializedObj[key] = new valueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    else
                        serializedObj[key] = new valueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey] && instanceObj[key][newkey]["__gdmeta__"]) {
                            let _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                            }
                            else {
                                serializeOtherType(instanceObj[key], serializedObj[key]["value"], newkey, instanceObj, assetMgr);
                            }
                        }
                        else {
                            if (!instanceObj[key]["__gdmeta__"]) {
                                if (instanceObj[key][newkey] == null || instanceObj[key][newkey] == undefined) {
                                    continue;
                                }
                                let baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        let info = new valueInfo(instanceObj[key][newkey], baseType);
                                        if (serializedObj[key]["value"]) {
                                            if (isArray) {
                                                serializedObj[key]["value"].push(info);
                                            }
                                            else {
                                                serializedObj[key]["value"][newkey] = info;
                                            }
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeOrArray = serializeOtherTypeOrArray;
        function serializeOtherType(instanceObj, serializedObj, key, arrayInst = null, assetMgr = null) {
            if (boolInNull(instanceObj || boolInNull(serializedObj))) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj[key]) || boolInNull(instanceObj[key]["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            let _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                let isArray = instanceObj instanceof Array;
                let type = _meta["class"]["typename"];
                if (isAsset(type)) {
                    let _defaultAsset = instanceObj[key].defaultAsset;
                    let _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        else {
                            if (assetMgr) {
                                SerializeDependent.GetAssetUrl(instanceObj[key], assetMgr);
                            }
                        }
                        if (isArray) {
                            serializedObj.push(new valueInfo(_assetName, type));
                        }
                        else {
                            serializedObj[key] = new valueInfo(_assetName, type);
                        }
                    }
                }
                else {
                    let isreference = false;
                    let insid = -1;
                    if ((isArray && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "transform" || type == "transform2D") {
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray) {
                            serializedObj.push(new valueInfo(insid, type, "reference"));
                        }
                        else {
                            serializedObj[key] = new valueInfo(insid, type, "reference");
                        }
                    }
                    else {
                        let _serializeObj = serializeObj(instanceObj[key], serializedObj[key], assetMgr);
                        if (_serializeObj != null) {
                            if (isArray) {
                                serializedObj.push(_serializeObj);
                            }
                            else {
                                serializedObj[key] = _serializeObj;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherType = serializeOtherType;
        function deSerialize(serializedObj, instanceObj, assetMgr, bundlename = null) {
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            referenceInfo.oldmap = {};
            deSerializeObj(serializedObj["value"], instanceObj, assetMgr, bundlename);
            let insid = serializedObj["insid"];
            if (!insid) {
            }
            else
                referenceInfo.oldmap[insid] = instanceObj;
            fillReference(serializedObj["value"], instanceObj);
        }
        io.deSerialize = deSerialize;
        function fillReference(serializedObj, instanceObj) {
            if (boolInNull(instanceObj) || boolInNull(instanceObj["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            for (let key in instanceObj["__gdmeta__"]) {
                let t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                let valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        dofillReferenceOrArray(serializedObj, instanceObj, key);
                        break;
                }
            }
        }
        io.fillReference = fillReference;
        function dofillReferenceOrArray(serializedObj, instanceObj, key) {
            if (boolInNull(serializedObj) || boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (serializedObj[key]) {
                let type = serializedObj[key].type;
                if (isArrayOrDic(type.toLowerCase())) {
                    let _isArray = serializedObj[key].value instanceof Array;
                    if (!instanceObj[key]) {
                        if (_isArray)
                            instanceObj[key] = [];
                        else
                            instanceObj[key] = {};
                    }
                    let arrayObj = null;
                    if (boolInNull(instanceObj["__gdmeta__"]) && boolInNull(instanceObj["__gdmeta__"][key]) && boolInNull(instanceObj["__gdmeta__"][key]["custom"])
                        && instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("反序列化失败，类型不匹配：" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        if (boolInNull(arrayObj[newkey])) {
                            continue;
                        }
                        let baseType = arrayObj[newkey].type;
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                break;
                            default:
                                dofillReference(serializedObj[key]["value"], instanceObj[key], newkey);
                                break;
                        }
                    }
                }
                else {
                    dofillReference(serializedObj, instanceObj, key);
                }
            }
        }
        io.dofillReferenceOrArray = dofillReferenceOrArray;
        function dofillReference(serializedObj, instanceObj, key) {
            if (boolInNull(instanceObj) || boolInNull(serializedObj) || boolInNull(serializedObj[key])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            let _isArray = instanceObj instanceof Array;
            let type = serializedObj[key].type;
            let _parentType = typeof (instanceObj);
            if (isAsset(type)) {
            }
            else {
                if (serializedObj[key].parse == "reference") {
                    let instance = referenceInfo.oldmap[serializedObj[key].value];
                    if (type == "transform" || type == "transform2D") {
                    }
                    else {
                        if (instance instanceof gd3d.framework.transform2D) {
                            instance = instance.getComponent(type);
                        }
                        else if (instance instanceof gd3d.framework.transform) {
                            instance = instance.gameObject.getComponent(type);
                        }
                    }
                    if (_isArray) {
                        instanceObj.push(instance);
                    }
                    else {
                        instanceObj[key] = instance;
                    }
                }
                else {
                    if (!instanceObj[key])
                        return console.warn(`${serializedObj[key].value.comp.type} 填充值失败`);
                    fillReference(serializedObj[key].value, instanceObj[key]);
                }
            }
        }
        io.dofillReference = dofillReference;
        function deSerializeObj(serializedObj, instanceObj, assetMgr, bundlename = null) {
            if (instanceObj == undefined) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            for (let key in instanceObj["__gdmeta__"]) {
                let t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                let valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        if (serializedObj[key] == undefined || valueType != serializedObj[key].type) {
                            continue;
                        }
                        else {
                            instanceObj[key] = serializedObj[key].value;
                        }
                        break;
                    default:
                        deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, assetMgr, bundlename);
                        break;
                }
            }
        }
        io.deSerializeObj = deSerializeObj;
        function deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, assetMgr, bundlename = null) {
            if (boolInNull(serializedObj) || boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (serializedObj[key]) {
                let type = serializedObj[key].type;
                if (type == null) {
                    throw new Error("必须传入一个实例，用来赋值");
                }
                if (isArrayOrDic(type.toLowerCase())) {
                    let _isArray = serializedObj[key].value instanceof Array;
                    if (!instanceObj[key]) {
                        if (_isArray)
                            instanceObj[key] = [];
                        else
                            instanceObj[key] = {};
                    }
                    let arrayObj = null;
                    if (boolInNull(instanceObj["__gdmeta__"]) && boolInNull(instanceObj["__gdmeta__"][key]) && boolInNull(instanceObj["__gdmeta__"][key]["custom"])
                        && instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("反序列化失败，类型不匹配：" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        let baseType = arrayObj[newkey].type;
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                if (baseType != serializedObj[key]["value"][newkey].type) {
                                    throw new Error("反序列化失败，类型不匹配：" + baseType + " as " + serializedObj[key]["value"][newkey].type);
                                }
                                if (_isArray) {
                                    instanceObj[key].push(serializedObj[key]["value"][newkey].value);
                                }
                                else {
                                    instanceObj[key][newkey] = serializedObj[key]["value"][newkey].value;
                                }
                                break;
                            default:
                                if (baseType == "nodeComponent" && key == "components" && gd3d.reflect.getClassName(instanceObj) == "gameObject") {
                                    let _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, assetMgr, bundlename);
                                    if (_nodeComponent[0].comp)
                                        instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "transform" && key == "children" && gd3d.reflect.getClassName(instanceObj) == "transform") {
                                    let _transforms = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms, newkey, assetMgr, bundlename);
                                    instanceObj.addChild(_transforms[0]);
                                }
                                else if (baseType == "C2DComponent" && key == "components" && gd3d.reflect.getClassName(instanceObj) == "transform2D") {
                                    let _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, assetMgr, bundlename);
                                    if (_nodeComponent[0].comp)
                                        instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "transform2D" && key == "children" && gd3d.reflect.getClassName(instanceObj) == "transform2D") {
                                    let _transforms2D = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms2D, newkey, assetMgr, bundlename);
                                    instanceObj.addChild(_transforms2D[0]);
                                }
                                else {
                                    deSerializeOtherType(serializedObj[key]["value"], instanceObj[key], newkey, assetMgr, bundlename);
                                }
                                break;
                        }
                    }
                }
                else {
                    deSerializeOtherType(serializedObj, instanceObj, key, assetMgr, bundlename);
                }
            }
        }
        io.deSerializeOtherTypeOrArray = deSerializeOtherTypeOrArray;
        function deSerializeOtherType(serializedObj, instanceObj, key, assetMgr, bundlename = null) {
            if (boolInNull(serializedObj) || boolInNull(instanceObj) || boolInNull(serializedObj[key])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            let _isArray = instanceObj instanceof Array;
            let type = serializedObj[key].type;
            let _parentType = typeof (instanceObj);
            if (isAsset(type)) {
                let assetName = serializedObj[key].value;
                let _asset;
                if (assetName.indexOf("SystemDefaultAsset-") >= 0) {
                    assetName = assetName.replace("SystemDefaultAsset-", "");
                    if (type == "mesh") {
                        assetName = assetName.replace(".mesh.bin", "");
                        _asset = assetMgr.getDefaultMesh(assetName);
                    }
                    else if (type == "texture") {
                        _asset = assetMgr.getDefaultTexture(assetName);
                    }
                }
                else {
                    _asset = assetMgr.getAssetByName(assetName, bundlename);
                }
                if (_asset == null && type == "animationClip") {
                    _asset = assetMgr.getAssetByName(assetName);
                    if (!_asset) {
                        _asset = new gd3d.framework.animationClip(assetName);
                        _asset.use();
                    }
                }
                {
                    if (instanceObj instanceof Array) {
                        instanceObj.push(_asset);
                    }
                    else {
                        instanceObj[key] = _asset;
                    }
                }
            }
            else {
                if (serializedObj[key].parse == "reference") {
                }
                else {
                    let _newInstance;
                    let componentType = gd3d.gd3d_reflect_root["__gdmeta__"][type];
                    if (!componentType) {
                        console.warn(instanceObj);
                        return console.warn(`无法找到组件:${gd3d.gd3d_reflect_root["__gdmeta__"][type]}`);
                    }
                    if (type == "gameObject" && key == "gameObject" && gd3d.reflect.getClassName(instanceObj) == "transform") {
                        _newInstance = instanceObj.gameObject;
                    }
                    else if (type == "transform2D" && key == "rootNode" && gd3d.reflect.getClassName(instanceObj) == "canvas") {
                        _newInstance = gd3d.reflect.createInstance(componentType, null);
                        instanceObj.rootNode = _newInstance;
                        _newInstance.canvas = instanceObj;
                    }
                    else {
                        _newInstance = gd3d.reflect.createInstance(componentType, null);
                        if (_isArray)
                            instanceObj.push(_newInstance);
                        else
                            instanceObj[key] = _newInstance;
                    }
                    deSerializeObj(serializedObj[key].value, _newInstance, assetMgr, bundlename);
                    let insid = serializedObj[key].insid;
                    if (!insid) {
                    }
                    else
                        referenceInfo.oldmap[insid] = _newInstance;
                }
            }
        }
        io.deSerializeOtherType = deSerializeOtherType;
        function isArray(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0) {
                return true;
            }
            return false;
        }
        io.isArray = isArray;
        function isArrayOrDic(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0 || type.indexOf("dic") >= 0) {
                return true;
            }
            return false;
        }
        io.isArrayOrDic = isArrayOrDic;
        function isAsset(type) {
            if (type == "mesh" || type == "texture" || type == "shader" ||
                type == "material" || type == "animationClip" || type == "atlas" || type == "keyFrameAniClip" ||
                type == "font" || type == "prefab" || type == "sprite" || type == "textasset" || type == "f14eff")
                return true;
            return false;
        }
        io.isAsset = isAsset;
        function isAssetInspector(type) {
            if (type == "prefab")
                return true;
        }
        io.isAssetInspector = isAssetInspector;
        class valueInfo {
            constructor(value, type, _parse = "direct") {
                if (isAsset(type)) {
                    _parse = "nameonly";
                    if (type == "material") {
                        if (value.lastIndexOf(".mat.json") < 0)
                            value += ".mat.json";
                    }
                }
                this.value = value;
                this.type = type;
                this.parse = _parse;
            }
        }
        class inspectorValueInfo {
            constructor(_value, _type, _parse = "direct") {
                this.value = _value;
                this.type = _type;
                if (isAssetInspector(_type)) {
                    _parse = "nameonly";
                }
                this.parse = _parse;
            }
        }
        class referenceInfo {
            static regDefaultType() {
                referenceInfo.regType("vector3");
                referenceInfo.regType("vector4");
                referenceInfo.regType("color");
                referenceInfo.regType("border");
                referenceInfo.regType("quaternion");
                referenceInfo.regType("material");
                referenceInfo.regType("gameObject");
                referenceInfo.regType("transform2D");
                referenceInfo.regType("shader");
                referenceInfo.regType("atlas");
                referenceInfo.regType("font");
                referenceInfo.regType("sprite");
                referenceInfo.regType("texture");
                referenceInfo.regType("mesh");
                referenceInfo.regType("animationclip");
                referenceInfo.regType("keyFrameAniClip");
                referenceInfo.regType("constText");
                referenceInfo.regType("UniformData");
                referenceInfo.regType("f14eff");
            }
            static regType(type) {
                referenceInfo.regtypelist.push(type);
            }
            static isRegType(type) {
                return this.regtypelist.indexOf(type) >= 0;
            }
        }
        referenceInfo.oldmap = {};
        referenceInfo.regtypelist = [];
        io.referenceInfo = referenceInfo;
        class enumMgr {
        }
        enumMgr.enumMap = {};
        io.enumMgr = enumMgr;
        function boolInNull(obj) {
            if (obj == null || obj == undefined) {
                return true;
            }
            return false;
        }
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        class binReader {
            constructor(buf, seek = 0) {
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            seek(seek) {
                this._seek = seek;
            }
            peek() {
                return this._seek;
            }
            length() {
                return this._data.byteLength;
            }
            canread() {
                return this._data.byteLength - this._seek;
            }
            readStringAnsi() {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            }
            static utf8ArrayToString(array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            }
            readStringUtf8() {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return binReader.utf8ArrayToString(arr);
            }
            readStringUtf8FixLength(length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return binReader.utf8ArrayToString(arr);
            }
            readSingle() {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            }
            readDouble() {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            }
            readInt8() {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            }
            readUInt8() {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            }
            readInt16() {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            }
            readUInt16() {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            }
            readInt32() {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            }
            readUInt32() {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            }
            readUint8Array(target = null, offset = 0, length = -1) {
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            }
            readUint8ArrayByOffset(target, offset, length = 0) {
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            }
            set position(value) {
                this.seek(value);
            }
            get position() {
                return this.peek();
            }
            readBoolean() {
                return this.readUInt8() > 0;
            }
            readByte() {
                return this.readUInt8();
            }
            readBytes(target = null, offset = 0, length = -1) {
                return this.readUint8Array(target, offset, length);
            }
            readUnsignedShort() {
                return this.readUInt16();
            }
            readUnsignedInt() {
                return this.readUInt32();
            }
            readFloat() {
                return this.readSingle();
            }
            readUTFBytes(length) {
                var arry = new Uint8Array(length);
                return binReader.utf8ArrayToString(this.readUint8Array(arry));
            }
            readSymbolByte() {
                return this.readInt8();
            }
            readShort() {
                return this.readInt16();
            }
            readInt() {
                return this.readInt32();
            }
        }
        io.binReader = binReader;
        class binWriter {
            constructor() {
                {
                    var buf = new ArrayBuffer(1024);
                    this._length = 0;
                }
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            sureData(addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            }
            getLength() {
                return length;
            }
            getBuffer() {
                return this._buf.buffer.slice(0, this._length);
            }
            seek(seek) {
                this._seek = seek;
            }
            peek() {
                return this._seek;
            }
            writeInt8(num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            }
            writeUInt8(num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            }
            writeInt16(num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            }
            writeUInt16(num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            }
            writeInt32(num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            }
            writeUInt32(num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            }
            writeSingle(num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            }
            writeDouble(num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            }
            writeStringAnsi(str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            }
            writeStringUtf8(str) {
                var bstr = binWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            }
            static stringToUtf8Array(str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            }
            writeStringUtf8DataOnly(str) {
                var bstr = binWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            }
            writeUint8Array(array, offset = 0, length = -1) {
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            }
            get length() {
                return this._seek;
            }
            writeByte(num) {
                this.writeUInt8(num);
            }
            writeBytes(array, offset = 0, length = 0) {
                this.writeUint8Array(array, offset, length);
            }
            writeUnsignedShort(num) {
                this.writeUInt16(num);
            }
            writeUnsignedInt(num) {
                this.writeUInt32(num);
            }
            writeFloat(num) {
                this.writeSingle(num);
            }
            writeUTFBytes(str) {
                var strArray = binWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            }
            writeSymbolByte(num) {
                this.writeInt8(num);
            }
            writeShort(num) {
                this.writeInt16(num);
            }
            writeInt(num) {
                this.writeInt32(num);
            }
        }
        io.binWriter = binWriter;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function colorSet_White(out) {
            out.r = 1;
            out.g = 1;
            out.b = 1;
            out.a = 1;
        }
        math.colorSet_White = colorSet_White;
        function colorSet_Black(out) {
            out.r = 0;
            out.g = 0;
            out.b = 0;
            out.a = 1;
        }
        math.colorSet_Black = colorSet_Black;
        function colorSet_Gray(out) {
            out.r = 0.5;
            out.g = 0.5;
            out.b = 0.5;
            out.a = 1;
        }
        math.colorSet_Gray = colorSet_Gray;
        function colorMultiply(srca, srcb, out) {
            out.r = srca.r * srcb.r;
            out.g = srca.g * srcb.g;
            out.b = srca.b * srcb.b;
            out.a = srca.a * srcb.a;
        }
        math.colorMultiply = colorMultiply;
        function scaleToRef(src, scale, out) {
            out.r = src.r * scale;
            out.g = src.g * scale;
            out.b = src.b * scale;
            out.a = src.a * scale;
        }
        math.scaleToRef = scaleToRef;
        function colorClone(src, out) {
            out.rawData.set(src.rawData);
        }
        math.colorClone = colorClone;
        function colorLerp(srca, srcb, t, out) {
            out.a = t * (srcb.a - srca.a) + srca.a;
            out.r = t * (srcb.r - srca.r) + srca.r;
            out.g = t * (srcb.g - srca.g) + srca.g;
            out.b = t * (srcb.b - srca.b) + srca.b;
        }
        math.colorLerp = colorLerp;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
            var vp1 = planeVector.x;
            var vp2 = planeVector.y;
            var vp3 = planeVector.z;
            var n1 = planePoint.x;
            var n2 = planePoint.y;
            var n3 = planePoint.z;
            var v1 = lineVector.x;
            var v2 = lineVector.y;
            var v3 = lineVector.z;
            var m1 = linePoint.x;
            var m2 = linePoint.y;
            var m3 = linePoint.z;
            var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
            if (vpt === 0) {
                out = null;
            }
            else {
                var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                out.x = m1 + v1 * t;
                out.y = m2 + v2 * t;
                out.z = m3 + v3 * t;
            }
        }
        math.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
        function isContain(p1, p2, p3, p4, mp) {
            if (Multiply(mp, p1, p2) * Multiply(mp, p4, p3) <= 0 && Multiply(mp, p4, p1) * Multiply(mp, p3, p2) <= 0)
                return true;
            return false;
        }
        math.isContain = isContain;
        function Multiply(p1, p2, p0) {
            return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
        }
        math.Multiply = Multiply;
        function getPointByTwoline(index, p2, dir2, outpoint) {
            var matrix = new gd3d.math.matrix();
            var dir1;
            if (index == 1) {
                dir1 = new gd3d.math.vector3(1, 0, 0);
                matrix.rawData[0] = 1;
            }
            else if (index == 2) {
                dir1 = new gd3d.math.vector3(0, 1, 0);
                matrix.rawData[0] = 0;
                matrix.rawData[1] = 1;
            }
            else if (index == 3) {
                dir1 = new gd3d.math.vector3(0, 0, 1);
                matrix.rawData[0] = 0;
                matrix.rawData[2] = 1;
            }
            var dirBt = new gd3d.math.vector3();
            gd3d.math.vec3Cross(dir1, dir2, dirBt);
            matrix.rawData[4] = dirBt.x;
            matrix.rawData[5] = dirBt.y;
            matrix.rawData[6] = dirBt.z;
            matrix.rawData[8] = -dir2.x;
            matrix.rawData[9] = -dir2.y;
            matrix.rawData[10] = -dir2.z;
            gd3d.math.matrixInverse(matrix, matrix);
            var outnode = new gd3d.math.vector3();
            gd3d.math.matrixTransformVector3(p2, matrix, outnode);
            if (index == 1) {
                outpoint = new gd3d.math.vector3(outnode.x, 0, 0);
            }
            else if (index == 2) {
                outpoint = new gd3d.math.vector3(0, outnode.y, 0);
            }
            else if (index == 3) {
                outpoint = new gd3d.math.vector3(0, 0, outnode.z);
            }
        }
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function matrixGetTranslation(src, out) {
            out.x = src.rawData[12];
            out.y = src.rawData[13];
            out.z = src.rawData[14];
        }
        math.matrixGetTranslation = matrixGetTranslation;
        function matrixTranspose(src, out) {
            out.rawData[1] = src.rawData[4];
            out.rawData[2] = src.rawData[8];
            out.rawData[3] = src.rawData[12];
            out.rawData[4] = src.rawData[1];
            out.rawData[6] = src.rawData[9];
            out.rawData[7] = src.rawData[13];
            out.rawData[8] = src.rawData[2];
            out.rawData[9] = src.rawData[6];
            out.rawData[11] = src.rawData[14];
            out.rawData[12] = src.rawData[3];
            out.rawData[13] = src.rawData[7];
            out.rawData[14] = src.rawData[11];
        }
        math.matrixTranspose = matrixTranspose;
        function matrixDecompose(src, scale, rotation, translation) {
            translation.x = src.rawData[12];
            translation.y = src.rawData[13];
            translation.z = src.rawData[14];
            var xs = math.sign(src.rawData[0] * src.rawData[1] * src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[4] * src.rawData[5] * src.rawData[6] * src.rawData[7]) < 0 ? -1 : 1;
            var zs = math.sign(src.rawData[8] * src.rawData[9] * src.rawData[10] * src.rawData[11]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            scale.y = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            scale.z = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
            if (scale.x === 0 || scale.y === 0 || scale.z === 0) {
                rotation.x = 0;
                rotation.y = 0;
                rotation.z = 0;
                rotation.w = 1;
                return false;
            }
            var mat = math.pool.new_matrix();
            mat.rawData[0] = src.rawData[0] / scale.x;
            mat.rawData[1] = src.rawData[1] / scale.x;
            mat.rawData[2] = src.rawData[2] / scale.x;
            mat.rawData[3] = 0;
            mat.rawData[4] = src.rawData[4] / scale.y;
            mat.rawData[5] = src.rawData[5] / scale.y;
            mat.rawData[6] = src.rawData[6] / scale.y;
            mat.rawData[7] = 0;
            mat.rawData[8] = src.rawData[8] / scale.z;
            mat.rawData[9] = src.rawData[9] / scale.z;
            mat.rawData[10] = src.rawData[10] / scale.z;
            mat.rawData[11] = 0;
            matrix2Quaternion(mat, rotation);
            return true;
        }
        math.matrixDecompose = matrixDecompose;
        class angelref {
        }
        math.angelref = angelref;
        function matrix3x2Decompose(src, scale, rotation, translation) {
            translation.x = src.rawData[4];
            translation.y = src.rawData[5];
            scale.x = Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1]);
            scale.y = Math.sqrt(src.rawData[2] * src.rawData[2] + src.rawData[3] * src.rawData[3]);
            if (scale.x === 0 || scale.y === 0) {
                rotation.v = 0;
                return false;
            }
            var sx = src.rawData[0] / scale.x;
            var r1 = Math.acos(sx);
            var sxs = src.rawData[1] / scale.x;
            var r2 = Math.asin(sxs);
            if (sxs < 0) {
                r1 = 2 * Math.PI - r1;
            }
            rotation.v = r1;
            return true;
        }
        math.matrix3x2Decompose = matrix3x2Decompose;
        function matrix2Quaternion(matrix, result) {
            var data = matrix.rawData;
            var m11 = data[0], m12 = data[4], m13 = data[8];
            var m21 = data[1], m22 = data[5], m23 = data[9];
            var m31 = data[2], m32 = data[6], m33 = data[10];
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                result.w = 0.25 / s;
                result.x = (m32 - m23) * s;
                result.y = (m13 - m31) * s;
                result.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                result.w = (m32 - m23) / s;
                result.x = 0.25 * s;
                result.y = (m12 + m21) / s;
                result.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                result.w = (m13 - m31) / s;
                result.x = (m12 + m21) / s;
                result.y = 0.25 * s;
                result.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                result.w = (m21 - m12) / s;
                result.x = (m13 + m31) / s;
                result.y = (m23 + m32) / s;
                result.z = 0.25 * s;
            }
        }
        math.matrix2Quaternion = matrix2Quaternion;
        function unitxyzToRotation(xAxis, yAxis, zAxis, out) {
            var m11 = xAxis.x, m12 = yAxis.x, m13 = zAxis.x;
            var m21 = xAxis.y, m22 = yAxis.y, m23 = zAxis.y;
            var m31 = xAxis.z, m32 = yAxis.z, m33 = zAxis.z;
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                out.w = 0.25 / s;
                out.x = (m32 - m23) * s;
                out.y = (m13 - m31) * s;
                out.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                out.w = (m32 - m23) / s;
                out.x = 0.25 * s;
                out.y = (m12 + m21) / s;
                out.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                out.w = (m13 - m31) / s;
                out.x = (m12 + m21) / s;
                out.y = 0.25 * s;
                out.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                out.w = (m21 - m12) / s;
                out.x = (m13 + m31) / s;
                out.y = (m23 + m32) / s;
                out.z = 0.25 * s;
            }
        }
        math.unitxyzToRotation = unitxyzToRotation;
        function matrixClone(src, out) {
            out.rawData.set(src.rawData);
        }
        math.matrixClone = matrixClone;
        function matrix3x2Clone(src, out) {
            out.rawData.set(src.rawData);
        }
        math.matrix3x2Clone = matrix3x2Clone;
        function matrixMakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = 1;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = 1;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeIdentity = matrixMakeIdentity;
        function matrix3x2MakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 1;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeIdentity = matrix3x2MakeIdentity;
        function matrixInverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l3 = src.rawData[2];
            var l4 = src.rawData[3];
            var l5 = src.rawData[4];
            var l6 = src.rawData[5];
            var l7 = src.rawData[6];
            var l8 = src.rawData[7];
            var l9 = src.rawData[8];
            var l10 = src.rawData[9];
            var l11 = src.rawData[10];
            var l12 = src.rawData[11];
            var l13 = src.rawData[12];
            var l14 = src.rawData[13];
            var l15 = src.rawData[14];
            var l16 = src.rawData[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            out.rawData[0] = l23 * l27;
            out.rawData[4] = l24 * l27;
            out.rawData[8] = l25 * l27;
            out.rawData[12] = l26 * l27;
            out.rawData[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            out.rawData[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            out.rawData[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            out.rawData[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            out.rawData[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            out.rawData[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            out.rawData[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            out.rawData[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            out.rawData[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            out.rawData[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            out.rawData[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            out.rawData[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
        }
        math.matrixInverse = matrixInverse;
        function matrix3x2Inverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l5 = src.rawData[2];
            var l6 = src.rawData[3];
            var l13 = src.rawData[4];
            var l14 = src.rawData[5];
            var l26 = -(((l5 * -l14) - (l6 * -l13)));
            var l27 = 1.0 / ((((l1 * l6) + (l2 * -l5))));
            out.rawData[0] = l6 * l27;
            out.rawData[2] = -l5 * l27;
            out.rawData[4] = l26 * l27;
            out.rawData[1] = -(((l2))) * l27;
            out.rawData[3] = (((l1))) * l27;
            out.rawData[5] = (((l1 * -l14) - (l2 * -l13))) * l27;
        }
        math.matrix3x2Inverse = matrix3x2Inverse;
        function matrixMakeTransformRTS(pos, scale, rot, out) {
            var matS = gd3d.math.pool.new_matrix();
            matrixMakeScale(scale.x, scale.y, scale.z, matS);
            var matR = gd3d.math.pool.new_matrix();
            math.quatToMatrix(rot, matR);
            matrixMultiply(matR, matS, out);
            out.rawData[12] = pos.x;
            out.rawData[13] = pos.y;
            out.rawData[14] = pos.z;
            out.rawData[15] = 1;
            gd3d.math.pool.delete_matrix(matS);
            gd3d.math.pool.delete_matrix(matR);
        }
        math.matrixMakeTransformRTS = matrixMakeTransformRTS;
        function matrix3x2MakeTransformRTS(pos, scale, rot, out) {
            var matS = gd3d.math.pool.new_matrix3x2();
            matrix3x2MakeScale(scale.x, scale.y, matS);
            var matR = gd3d.math.pool.new_matrix3x2();
            matrix3x2MakeRotate(rot, matR);
            matrix3x2Multiply(matR, matS, out);
            out.rawData[4] = pos.x;
            out.rawData[5] = pos.y;
            gd3d.math.pool.delete_matrix3x2(matS);
            gd3d.math.pool.delete_matrix3x2(matR);
        }
        math.matrix3x2MakeTransformRTS = matrix3x2MakeTransformRTS;
        function matrixMakeTranslate(x, y, z, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0;
            out.rawData[4] = 0.0;
            out.rawData[5] = 1.0;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = 1.0;
            out.rawData[11] = 0.0;
            out.rawData[12] = x;
            out.rawData[13] = y;
            out.rawData[14] = z;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeTranslate = matrixMakeTranslate;
        function matrix3x2MakeTranslate(x, y, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 1.0;
            out.rawData[4] = x;
            out.rawData[5] = y;
        }
        math.matrix3x2MakeTranslate = matrix3x2MakeTranslate;
        function matrixGetScale(src, scale) {
            scale.x = src.rawData[0];
            scale.y = src.rawData[5];
            scale.z = src.rawData[10];
        }
        math.matrixGetScale = matrixGetScale;
        function matrixMakeScale(xScale, yScale, zScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0.0;
            out.rawData[4] = 0.0;
            out.rawData[5] = yScale;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = zScale;
            out.rawData[11] = 0.0;
            out.rawData[12] = 0.0;
            out.rawData[13] = 0.0;
            out.rawData[14] = 0.0;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeScale = matrixMakeScale;
        function matrix3x2TransformVector2(mat, inp, out) {
            let x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2] + mat.rawData[4];
            let y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3] + mat.rawData[5];
            out.x = x;
            out.y = y;
        }
        math.matrix3x2TransformVector2 = matrix3x2TransformVector2;
        function matrix3x2TransformNormal(mat, inp, out) {
            let x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2];
            let y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3];
            out.x = x;
            out.y = y;
        }
        math.matrix3x2TransformNormal = matrix3x2TransformNormal;
        function matrix3x2MakeScale(xScale, yScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = yScale;
            out.rawData[4] = 0.0;
            out.rawData[5] = 0.0;
        }
        math.matrix3x2MakeScale = matrix3x2MakeScale;
        function matrixMakeRotateAxisAngle(axis, angle, out) {
            var x = axis.x, y = axis.y, z = axis.z;
            var length = Math.sqrt(x * x + y * y + z * z);
            if (!length)
                return;
            if (length !== 1) {
                length = 1 / length;
                x *= length;
                y *= length;
                z *= length;
            }
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var t = 1.0 - c;
            var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
            out.rawData[0] = b00;
            out.rawData[1] = b01;
            out.rawData[2] = b02;
            out.rawData[3] = 0;
            out.rawData[4] = b10;
            out.rawData[5] = b11;
            out.rawData[6] = b12;
            out.rawData[7] = 0;
            out.rawData[8] = b20;
            out.rawData[9] = b21;
            out.rawData[10] = b22;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeRotateAxisAngle = matrixMakeRotateAxisAngle;
        function matrix3x2MakeRotate(angle, out) {
            var x = 0, y = 0, z = 1;
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            out.rawData[0] = c;
            out.rawData[1] = s;
            out.rawData[2] = -s;
            out.rawData[3] = c;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeRotate = matrix3x2MakeRotate;
        function matrixMultiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = lhs.rawData[2], a03 = lhs.rawData[3];
            var a10 = lhs.rawData[4], a11 = lhs.rawData[5], a12 = lhs.rawData[6], a13 = lhs.rawData[7];
            var a20 = lhs.rawData[8], a21 = lhs.rawData[9], a22 = lhs.rawData[10], a23 = lhs.rawData[11];
            var a30 = lhs.rawData[12], a31 = lhs.rawData[13], a32 = lhs.rawData[14], a33 = lhs.rawData[15];
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b2 = rhs.rawData[2], b3 = rhs.rawData[3];
            out.rawData[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b2 = rhs.rawData[6];
            b3 = rhs.rawData[7];
            out.rawData[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[8];
            b1 = rhs.rawData[9];
            b2 = rhs.rawData[10];
            b3 = rhs.rawData[11];
            out.rawData[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[12];
            b1 = rhs.rawData[13];
            b2 = rhs.rawData[14];
            b3 = rhs.rawData[15];
            out.rawData[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
        }
        math.matrixMultiply = matrixMultiply;
        function matrix3x2Multiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = 0;
            var a10 = lhs.rawData[2], a11 = lhs.rawData[3], a12 = 0;
            var a30 = lhs.rawData[4], a31 = lhs.rawData[5], a32 = 1;
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b3 = 0;
            let temp_0 = b0 * a00 + b1 * a10 + b3 * a30;
            let temp_1 = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[2];
            b1 = rhs.rawData[3];
            b3 = 0;
            let temp_2 = b0 * a00 + b1 * a10 + b3 * a30;
            let temp_3 = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b3 = 1;
            let temp_4 = b0 * a00 + b1 * a10 + b3 * a30;
            let temp_5 = b0 * a01 + b1 * a11 + b3 * a31;
            out.rawData[0] = temp_0;
            out.rawData[1] = temp_1;
            out.rawData[2] = temp_2;
            out.rawData[3] = temp_3;
            out.rawData[4] = temp_4;
            out.rawData[5] = temp_5;
        }
        math.matrix3x2Multiply = matrix3x2Multiply;
        function matrixProject_PerspectiveLH(fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = -zfar / (znear - zfar);
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = (znear * zfar) / (znear - zfar);
        }
        math.matrixProject_PerspectiveLH = matrixProject_PerspectiveLH;
        function matrixProject_OrthoLH(width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 2.0 / (zfar - znear);
            var nid = (zfar + znear) / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
        }
        math.matrixProject_OrthoLH = matrixProject_OrthoLH;
        function matrixLookatLH(forward, up, out) {
            var z = new math.vector3(-forward.x, -forward.y, -forward.z);
            math.vec3Normalize(z, z);
            var y = new math.vector3();
            math.vec3Clone(up, y);
            math.vec3Normalize(y, y);
            var x = new math.vector3();
            math.vec3Cross(y, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            var y = new math.vector3();
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixLookatLH = matrixLookatLH;
        function matrixViewLookatLH(eye, forward, up, out) {
            var z = new math.vector3(forward.x, forward.y, forward.z);
            math.vec3Normalize(z, z);
            var y = new math.vector3();
            math.vec3Clone(up, y);
            math.vec3Normalize(y, y);
            var x = new math.vector3();
            math.vec3Cross(y, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            var y = new math.vector3();
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            var ex = -math.vec3Dot(x, eye);
            var ey = -math.vec3Dot(y, eye);
            var ez = -math.vec3Dot(z, eye);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = ex;
            out.rawData[13] = ey;
            out.rawData[14] = ez;
            out.rawData[15] = 1;
        }
        math.matrixViewLookatLH = matrixViewLookatLH;
        function matrixLerp(left, right, v, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = left.rawData[i] * (1 - v) + right.rawData[i] * v;
            }
        }
        math.matrixLerp = matrixLerp;
        function matrixTransformVector3(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]) + transformation.rawData[12];
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]) + transformation.rawData[13];
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]) + transformation.rawData[14];
            var w = (vector.x * transformation.rawData[3]) + (vector.y * transformation.rawData[7]) + (vector.z * transformation.rawData[11]) + transformation.rawData[15];
            result.x = x / w;
            result.y = y / w;
            result.z = z / w;
        }
        math.matrixTransformVector3 = matrixTransformVector3;
        function matrixTransformNormal(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]);
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]);
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]);
            result.x = x;
            result.y = y;
            result.z = z;
        }
        math.matrixTransformNormal = matrixTransformNormal;
        function matrixGetVector3ByOffset(src, offset, result) {
            result.x = src.rawData[offset];
            result.y = src.rawData[offset + 1];
            result.z = src.rawData[offset + 2];
        }
        math.matrixGetVector3ByOffset = matrixGetVector3ByOffset;
        function matrixReset(mat) {
            mat.rawData[0] = 1;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 1;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 1;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixReset = matrixReset;
        function matrixZero(mat) {
            mat.rawData[0] = 0;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 0;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 0;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixZero = matrixZero;
        function matrixScaleByNum(value, mat) {
            mat.rawData[0] *= value;
            mat.rawData[1] *= value;
            mat.rawData[2] *= value;
            mat.rawData[3] *= value;
            mat.rawData[4] *= value;
            mat.rawData[5] *= value;
            mat.rawData[6] *= value;
            mat.rawData[7] *= value;
            mat.rawData[8] *= value;
            mat.rawData[9] *= value;
            mat.rawData[10] *= value;
            mat.rawData[11] *= value;
            mat.rawData[12] *= value;
            mat.rawData[13] *= value;
            mat.rawData[14] *= value;
            mat.rawData[15] *= value;
        }
        math.matrixScaleByNum = matrixScaleByNum;
        function matrixAdd(left, right, out) {
            out.rawData[0] = left.rawData[0] + right.rawData[0];
            out.rawData[1] = left.rawData[1] + right.rawData[1];
            out.rawData[2] = left.rawData[2] + right.rawData[2];
            out.rawData[3] = left.rawData[3] + right.rawData[3];
            out.rawData[4] = left.rawData[4] + right.rawData[4];
            out.rawData[5] = left.rawData[5] + right.rawData[5];
            out.rawData[6] = left.rawData[6] + right.rawData[6];
            out.rawData[7] = left.rawData[7] + right.rawData[7];
            out.rawData[8] = left.rawData[8] + right.rawData[8];
            out.rawData[9] = left.rawData[9] + right.rawData[9];
            out.rawData[10] = left.rawData[10] + right.rawData[10];
            out.rawData[11] = left.rawData[11] + right.rawData[11];
            out.rawData[12] = left.rawData[12] + right.rawData[12];
            out.rawData[13] = left.rawData[13] + right.rawData[13];
            out.rawData[14] = left.rawData[14] + right.rawData[14];
            out.rawData[15] = left.rawData[15] + right.rawData[15];
        }
        math.matrixAdd = matrixAdd;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function floatClamp(v, min = 0, max = 1) {
            if (v < min)
                return min;
            else if (v > max)
                return max;
            else
                return v;
        }
        math.floatClamp = floatClamp;
        function sign(value) {
            value = +value;
            if (value === 0 || isNaN(value))
                return value;
            return value > 0 ? 1 : -1;
        }
        math.sign = sign;
        function getKeyCodeByAscii(ev) {
            if (ev.shiftKey) {
                return ev.keyCode - 32;
            }
            else {
                return ev.keyCode;
            }
        }
        math.getKeyCodeByAscii = getKeyCodeByAscii;
        function numberLerp(fromV, toV, v) {
            return fromV * (1 - v) + toV * v;
        }
        math.numberLerp = numberLerp;
        function x_AXIS() {
            return commonStatic.x_axis;
        }
        math.x_AXIS = x_AXIS;
        function y_AXIS() {
            return commonStatic.y_axis;
        }
        math.y_AXIS = y_AXIS;
        function z_AXIS() {
            return commonStatic.z_axis;
        }
        math.z_AXIS = z_AXIS;
        class commonStatic {
        }
        commonStatic.x_axis = new gd3d.math.vector3(1, 0, 0);
        commonStatic.y_axis = new gd3d.math.vector3(0, 1, 0);
        commonStatic.z_axis = new gd3d.math.vector3(0, 0, 1);
        math.commonStatic = commonStatic;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function quatIdentity(src) {
            src.x = 0;
            src.y = 0;
            src.z = 0;
            src.w = 1;
        }
        math.quatIdentity = quatIdentity;
        function quatNormalize(src, out) {
            var mag = 1 / Math.sqrt(src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w);
            out.x *= mag;
            out.y *= mag;
            out.z *= mag;
            out.w *= mag;
        }
        math.quatNormalize = quatNormalize;
        function quatTransformVector(src, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            w1 = -src.x * x2 - src.y * y2 - src.z * z2;
            x1 = src.w * x2 + src.y * z2 - src.z * y2;
            y1 = src.w * y2 - src.x * z2 + src.z * x2;
            z1 = src.w * z2 + src.x * y2 - src.y * x2;
            out.x = -w1 * src.x + x1 * src.w - y1 * src.z + z1 * src.y;
            out.y = -w1 * src.y + x1 * src.z + y1 * src.w - z1 * src.x;
            out.z = -w1 * src.z - x1 * src.y + y1 * src.x + z1 * src.w;
        }
        math.quatTransformVector = quatTransformVector;
        function quatTransformVectorDataAndQuat(src, srcseek, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            var srcx = src[srcseek];
            var srcy = src[srcseek + 1];
            var srcz = src[srcseek + 2];
            var srcw = src[srcseek + 3];
            w1 = -srcx * x2 - srcy * y2 - srcz * z2;
            x1 = srcw * x2 + srcy * z2 - srcz * y2;
            y1 = srcw * y2 - srcx * z2 + srcz * x2;
            z1 = srcw * z2 + srcx * y2 - srcy * x2;
            out.x = -w1 * srcx + x1 * srcw - y1 * srcz + z1 * srcy;
            out.y = -w1 * srcy + x1 * srcz + y1 * srcw - z1 * srcx;
            out.z = -w1 * srcz - x1 * srcy + y1 * srcx + z1 * srcw;
        }
        math.quatTransformVectorDataAndQuat = quatTransformVectorDataAndQuat;
        function quatMagnitude(src) {
            return Math.sqrt(src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z);
        }
        math.quatMagnitude = quatMagnitude;
        function quatClone(src, out) {
            out.rawData.set(src.rawData);
        }
        math.quatClone = quatClone;
        function quatEqual(quat, quat2, threshold = 0.00001) {
            if (Math.abs(quat.x - quat2.x) > threshold)
                return false;
            if (Math.abs(quat.y - quat2.y) > threshold)
                return false;
            if (Math.abs(quat.z - quat2.z) > threshold)
                return false;
            if (Math.abs(quat.w - quat2.w) > threshold)
                return false;
            return true;
        }
        math.quatEqual = quatEqual;
        function quatToMatrix(src, out) {
            var xy2 = 2.0 * src.x * src.y, xz2 = 2.0 * src.x * src.z, xw2 = 2.0 * src.x * src.w;
            var yz2 = 2.0 * src.y * src.z, yw2 = 2.0 * src.y * src.w, zw2 = 2.0 * src.z * src.w;
            var xx = src.x * src.x, yy = src.y * src.y, zz = src.z * src.z, ww = src.w * src.w;
            out.rawData[0] = xx - yy - zz + ww;
            out.rawData[4] = xy2 - zw2;
            out.rawData[8] = xz2 + yw2;
            out.rawData[12] = 0;
            out.rawData[1] = xy2 + zw2;
            out.rawData[5] = -xx + yy - zz + ww;
            out.rawData[9] = yz2 - xw2;
            out.rawData[13] = 0;
            out.rawData[2] = xz2 - yw2;
            out.rawData[6] = yz2 + xw2;
            out.rawData[10] = -xx - yy + zz + ww;
            out.rawData[14] = 0;
            out.rawData[3] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[11] = 0;
            out.rawData[15] = 1;
        }
        math.quatToMatrix = quatToMatrix;
        function quatInverse(src, out) {
            var norm = src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z;
            if (norm > 0.0) {
                var invNorm = 1.0 / norm;
                out.w = src.w * invNorm;
                out.x = -src.x * invNorm;
                out.y = -src.y * invNorm;
                out.z = -src.z * invNorm;
            }
        }
        math.quatInverse = quatInverse;
        function quatFromYawPitchRoll(yaw, pitch, roll, result) {
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            result.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            result.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            result.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            result.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }
        math.quatFromYawPitchRoll = quatFromYawPitchRoll;
        function quatMultiply(srca, srcb, out) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
        }
        math.quatMultiply = quatMultiply;
        function quatMultiplyDataAndQuat(srca, srcaseek, srcb, out) {
            var w1 = srca[srcaseek + 3], x1 = srca[srcaseek + 0], y1 = srca[srcaseek + 1], z1 = srca[srcaseek + 2];
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
        }
        math.quatMultiplyDataAndQuat = quatMultiplyDataAndQuat;
        function quatMultiplyVector(vector, scr, out) {
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            out.w = -scr.x * x2 - scr.y * y2 - scr.z * z2;
            out.x = scr.w * x2 + scr.y * z2 - scr.z * y2;
            out.y = scr.w * y2 - scr.x * z2 + scr.z * x2;
            out.z = scr.w * z2 + scr.x * y2 - scr.y * x2;
        }
        math.quatMultiplyVector = quatMultiplyVector;
        function quatLerp(srca, srcb, out, t) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            out.w = w1 + t * (w2 - w1);
            out.x = x1 + t * (x2 - x1);
            out.y = y1 + t * (y2 - y1);
            out.z = z1 + t * (z2 - z1);
            var len = 1.0 / Math.sqrt(out.w * out.w + out.x * out.x + out.y * out.y + out.z * out.z);
            out.w *= len;
            out.x *= len;
            out.y *= len;
            out.z *= len;
        }
        math.quatLerp = quatLerp;
        function quatFromAxisAngle(axis, angle, out) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            out.w = Math.cos(halfAngle);
            out.x = axis.x * sin_a;
            out.y = axis.y * sin_a;
            out.z = axis.z * sin_a;
            math.quatNormalize(out, out);
        }
        math.quatFromAxisAngle = quatFromAxisAngle;
        function quatToAxisAngle(src, axis) {
            var sqrLength = src.x * src.x + src.y * src.y + src.z * src.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(src.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = src.x * sqrLength;
                axis.y = src.y * sqrLength;
                axis.z = src.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        }
        math.quatToAxisAngle = quatToAxisAngle;
        function quatFromEulerAngles(ax, ay, az, out) {
            ax *= Math.PI / 180;
            ay *= Math.PI / 180;
            az *= Math.PI / 180;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            out.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            out.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
            out.y = cosX * sinY * cosZ - sinX * cosY * sinZ;
            out.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            math.quatNormalize(out, out);
        }
        math.quatFromEulerAngles = quatFromEulerAngles;
        function quatToEulerAngles(src, out) {
            var temp = 2.0 * (src.w * src.x - src.y * src.z);
            temp = math.floatClamp(temp, -1.0, 1.0);
            out.x = Math.asin(temp);
            out.y = Math.atan2(2.0 * (src.w * src.y + src.z * src.x), 1.0 - 2.0 * (src.y * src.y + src.x * src.x));
            out.z = Math.atan2(2.0 * (src.w * src.z + src.y * src.x), 1.0 - 2.0 * (src.x * src.x + src.z * src.z));
            out.x /= Math.PI / 180;
            out.y /= Math.PI / 180;
            out.z /= Math.PI / 180;
        }
        math.quatToEulerAngles = quatToEulerAngles;
        function quatReset(src) {
            src.x = 0;
            src.y = 0;
            src.z = 0;
            src.w = 1;
        }
        math.quatReset = quatReset;
        function quatLookat(pos, targetpos, out) {
            var dir = new math.vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dirxz = new math.vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            var dirxz1 = new math.vector3(dir.x, 0, dir.z);
            let v3length = math.vec3Length(dirxz1);
            if (v3length > 0.999)
                v3length = 1;
            if (v3length < -0.999)
                v3length = -1;
            var pitch = Math.acos(v3length);
            if (dir.y > 0) {
                pitch = -pitch;
            }
            quatFromYawPitchRoll(yaw, pitch, 0, out);
            math.quatNormalize(out, out);
        }
        math.quatLookat = quatLookat;
        function quat2Lookat(pos, targetpos, out, updir = gd3d.math.pool.vector3_up) {
            var dir = gd3d.math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dot = gd3d.math.vec3Dot(gd3d.math.pool.vector3_forward, dir);
            dot = gd3d.math.floatClamp(dot, -1, 1);
            var rotangle = Math.acos(dot) * 180 / Math.PI;
            if (rotangle < 0.01) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
                return;
            }
            if (rotangle > 179.9) {
                gd3d.math.quatFromAxisAngle(updir, 180, out);
                return;
            }
            var rotAxis = gd3d.math.pool.new_vector3();
            gd3d.math.vec3Cross(gd3d.math.pool.vector3_forward, dir, rotAxis);
            gd3d.math.vec3Normalize(rotAxis, rotAxis);
            gd3d.math.quatFromAxisAngle(rotAxis, rotangle, out);
        }
        math.quat2Lookat = quat2Lookat;
        function quat2LookRotation(pos, targetpos, upwards, out) {
            let dir = gd3d.math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.quatLookRotation(dir, upwards, out);
        }
        math.quat2LookRotation = quat2LookRotation;
        function quatLookRotation(dir, upwards, out) {
            math.vec3Normalize(dir, dir);
            let ab = math.vec3Dot(dir, gd3d.math.pool.vector3_forward);
            let an_dz = Math.acos(ab);
            let cdz = gd3d.math.pool.new_vector3();
            math.vec3Cross(dir, gd3d.math.pool.vector3_forward, cdz);
            math.vec3Normalize(cdz, cdz);
            if (math.vec3Dot(cdz, gd3d.math.pool.vector3_forward) < 0) {
                an_dz = 2 * Math.PI - an_dz;
            }
            an_dz = 180 / Math.PI * an_dz;
            quatFromAxisAngle(cdz, -an_dz, out);
            let y = gd3d.math.pool.new_vector3();
            quatTransformVector(out, gd3d.math.pool.vector3_up, y);
            let cyw = cdz;
            math.vec3Cross(dir, upwards, cyw);
            math.vec3Normalize(y, y);
            math.vec3Normalize(cyw, cyw);
            let cos2Y = math.vec3Dot(cyw, y);
            let sin2Y = Math.sqrt(1 - cos2Y * cos2Y);
            console.log(math.vec3Dot(y, upwards));
            if (math.vec3Dot(y, upwards) <= 0) {
                sin2Y = -sin2Y;
            }
            let siny = Math.sqrt((1 - sin2Y) / 2);
            let cosy = -Math.sqrt((sin2Y + 1) / 2);
            console.log(cos2Y);
            if (cos2Y < 0) {
                cosy = -cosy;
            }
            let yq = gd3d.math.pool.new_quaternion();
            yq.x = 0;
            yq.y = 0;
            yq.z = siny;
            yq.w = cosy;
            quatMultiply(out, yq, out);
            gd3d.math.pool.delete_vector3(dir);
            gd3d.math.pool.delete_vector3(cdz);
        }
        math.quatLookRotation = quatLookRotation;
        function quatYAxis(pos, targetpos, out) {
            var dir = new math.vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dirxz = new math.vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            quatFromYawPitchRoll(yaw, 0, 0, out);
            math.quatNormalize(out, out);
        }
        math.quatYAxis = quatYAxis;
        function rotationTo(from, to, out) {
            var tmpvec3 = new math.vector3();
            var xUnitVec3 = math.pool.vector3_right;
            var yUnitVec3 = math.pool.vector3_up;
            let dot = math.vec3Dot(from, to);
            if (dot < -0.999999) {
                math.vec3Cross(xUnitVec3, from, tmpvec3);
                if (math.vec3Length(tmpvec3) < 0.000001) {
                    math.vec3Cross(yUnitVec3, from, tmpvec3);
                }
                math.vec3Normalize(tmpvec3, tmpvec3);
                quatFromAxisAngle(tmpvec3, 180, out);
            }
            else if (dot > 0.999999) {
                out[0] = 0;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
            }
            else {
                math.vec3Cross(from, to, tmpvec3);
                out[0] = tmpvec3[0];
                out[1] = tmpvec3[1];
                out[2] = tmpvec3[2];
                out[3] = 1 + dot;
                quatNormalize(out, out);
            }
        }
        math.rotationTo = rotationTo;
        function myLookRotation(dir, out, up = math.pool.vector3_up) {
            if (math.vec3Equal(dir, math.pool.vector3_zero)) {
                console.log("Zero direction in MyLookRotation");
                quatIdentity(out);
                return;
            }
            if (!math.vec3Equal(dir, up)) {
                let tempv = new math.vector3();
                math.vec3ScaleByNum(up, math.vec3Dot(up, dir), tempv);
                math.vec3Subtract(dir, tempv, tempv);
                let qu = new math.quaternion();
                this.rotationTo(math.pool.vector3_forward, tempv, qu);
                let qu2 = new math.quaternion();
                this.rotationTo(tempv, dir, qu2);
                quatMultiply(qu, qu2, out);
            }
            else {
                this.rotationTo(math.pool.vector3_forward, dir, out);
            }
        }
        math.myLookRotation = myLookRotation;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function rectSet_One(out) {
            out.x = 0;
            out.y = 0;
            out.w = 1;
            out.h = 1;
        }
        math.rectSet_One = rectSet_One;
        function rectSet_Zero(out) {
            out.x = 0;
            out.y = 0;
            out.w = 0;
            out.h = 0;
        }
        math.rectSet_Zero = rectSet_Zero;
        function rectEqul(src1, src2) {
            return !((src1.x != src2.x) ||
                (src1.y != src2.y) ||
                (src1.w != src2.w) ||
                (src1.h != src2.h));
        }
        math.rectEqul = rectEqul;
        function rectInner(x, y, src) {
            if (x < src.x || x > src.x + src.w ||
                y < src.y || y > src.y + src.h) {
                return false;
            }
            return true;
        }
        math.rectInner = rectInner;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function caclStringByteLength(value) {
            let total = 0;
            for (let i = 0; i < value.length; i++) {
                let charCode = value.charCodeAt(i);
                if (charCode <= 0x007f) {
                    total += 1;
                }
                else if (charCode <= 0x07ff) {
                    total += 2;
                }
                else if (charCode <= 0xffff) {
                    total += 3;
                }
                else {
                    total += 4;
                }
            }
            return total;
        }
        math.caclStringByteLength = caclStringByteLength;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function spriteAnimation(row, column, index, out) {
            var width = 1.0 / column;
            var height = 1.0 / row;
            var offsetx = width * (index % column);
            var offsety = height * row - height * (Math.floor(index / column) + 1);
            out.x = width;
            out.y = height;
            out.z = offsetx;
            out.w = offsety;
        }
        math.spriteAnimation = spriteAnimation;
        function GetPointAlongCurve(curveStart, curveStartHandle, curveEnd, curveEndHandle, t, out, crease = 0.3) {
            var oneMinT = 1 - t;
            var oneMinTPow3 = Math.pow(oneMinT, 3);
            var oneMinTPow2 = Math.pow(oneMinT, 2);
            var oneMinCrease = 1 - crease;
            var tempt1 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveStart, oneMinTPow3 * oneMinCrease, tempt1);
            var tempt2 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveStartHandle, 3 * oneMinTPow2 * t * crease, tempt2);
            var tempt3 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveEndHandle, 3 * oneMinT * Math.pow(t, 2) * crease, tempt3);
            var tempt4 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3ScaleByNum(curveEnd, Math.pow(t, 3) * oneMinCrease, tempt4);
            var tempt5 = gd3d.math.pool.new_vector3();
            gd3d.math.vec3Add(tempt1, tempt2, tempt5);
            gd3d.math.vec3Add(tempt5, tempt3, tempt5);
            gd3d.math.vec3Add(tempt5, tempt4, tempt5);
            gd3d.math.vec3ScaleByNum(tempt5, 1 / (oneMinTPow3 * oneMinCrease + 3 * oneMinTPow2 * t * crease + 3 * oneMinT * Math.pow(t, 2) * crease + Math.pow(t, 3) * oneMinCrease), out);
            gd3d.math.pool.delete_vector3(tempt1);
            gd3d.math.pool.delete_vector3(tempt2);
            gd3d.math.pool.delete_vector3(tempt3);
            gd3d.math.pool.delete_vector3(tempt4);
            gd3d.math.pool.delete_vector3(tempt5);
        }
        math.GetPointAlongCurve = GetPointAlongCurve;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function vec2Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
        }
        math.vec2Subtract = vec2Subtract;
        function vec2Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
        }
        math.vec2Add = vec2Add;
        function vec2Clone(from, to) {
            to.rawData.set(from.rawData);
        }
        math.vec2Clone = vec2Clone;
        function vec2Distance(a, b) {
            var out = math.pool.new_vector2();
            vec2Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y);
            math.pool.delete_vector2(out);
            return result;
        }
        math.vec2Distance = vec2Distance;
        function vec2ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
        }
        math.vec2ScaleByNum = vec2ScaleByNum;
        function vec2ScaleByVec2(from, scale, out) {
            out.x = from.x * scale.x;
            out.y = from.y * scale.y;
        }
        math.vec2ScaleByVec2 = vec2ScaleByVec2;
        function vec4Clone(from, to) {
            to.rawData.set(from.rawData);
        }
        math.vec4Clone = vec4Clone;
        function vec2Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y);
        }
        math.vec2Length = vec2Length;
        function vec2SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
        }
        math.vec2SLerp = vec2SLerp;
        function vec4SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
            out.z = vector.z * (1 - v) + vector2.z * v;
            out.w = vector.w * (1 - v) + vector2.w * v;
        }
        math.vec4SLerp = vec4SLerp;
        function vec2Normalize(from, out) {
            var num = vec2Length(from);
            if (num > Number.MIN_VALUE) {
                out.x = from.x / num;
                out.y = from.y / num;
            }
            else {
                out.x = 0;
                out.y = 0;
            }
        }
        math.vec2Normalize = vec2Normalize;
        function vec2Multiply(a, b) {
            return a.x * b.x + a.y * b.y;
        }
        math.vec2Multiply = vec2Multiply;
        function vec2Dot(lhs, rhs) {
            return lhs.x * rhs.x + lhs.y * rhs.y;
        }
        math.vec2Dot = vec2Dot;
        function vec2Equal(vector, vector2, threshold = 0.00001) {
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            return true;
        }
        math.vec2Equal = vec2Equal;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        function vec3Clone(from, to) {
            to.rawData.set(from.rawData);
        }
        math.vec3Clone = vec3Clone;
        function vec3ToString(result) {
            result = this.x + "," + this.y + "," + this.z;
        }
        math.vec3ToString = vec3ToString;
        function vec3Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
        }
        math.vec3Add = vec3Add;
        function vec3Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            out.z = a.z - b.z;
        }
        math.vec3Subtract = vec3Subtract;
        function vec3Minus(a, out) {
            out.x = -a.x;
            out.y = -a.y;
            out.z = -a.z;
        }
        math.vec3Minus = vec3Minus;
        function vec3Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
        }
        math.vec3Length = vec3Length;
        function vec3SqrLength(value) {
            return value.x * value.x + value.y * value.y + value.z * value.z;
        }
        math.vec3SqrLength = vec3SqrLength;
        function vec3Set_One(value) {
            value.x = value.y = value.z = 1;
        }
        math.vec3Set_One = vec3Set_One;
        function vec3Set_Forward(value) {
            value.x = value.y = 0;
            value.z = 1;
        }
        math.vec3Set_Forward = vec3Set_Forward;
        function vec3Set_Back(value) {
            value.x = value.y = 0;
            value.z = -1;
        }
        math.vec3Set_Back = vec3Set_Back;
        function vec3Set_Up(value) {
            value.x = value.z = 0;
            value.y = 1;
        }
        math.vec3Set_Up = vec3Set_Up;
        function vec3Set_Down(value) {
            value.x = value.z = 0;
            value.y = -1;
        }
        math.vec3Set_Down = vec3Set_Down;
        function vec3Set_Left(value) {
            value.x = -1;
            value.y = value.z = 0;
        }
        math.vec3Set_Left = vec3Set_Left;
        function vec3Set_Right(value) {
            value.x = 1;
            value.y = value.z = 0;
        }
        math.vec3Set_Right = vec3Set_Right;
        function vec3Normalize(value, out) {
            var num = vec3Length(value);
            if (num > Number.MIN_VALUE) {
                out.x = value.x / num;
                out.y = value.y / num;
                out.z = value.z / num;
            }
            else {
                out.x = 0;
                out.y = 0;
                out.z = 0;
            }
        }
        math.vec3Normalize = vec3Normalize;
        function vec3ScaleByVec3(from, scale, out) {
            out.x = from.x * scale.x;
            out.y = from.y * scale.y;
            out.z = from.z * scale.z;
        }
        math.vec3ScaleByVec3 = vec3ScaleByVec3;
        function vec3ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
            out.z = from.z * scale;
        }
        math.vec3ScaleByNum = vec3ScaleByNum;
        function vec3Product(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
        }
        math.vec3Product = vec3Product;
        function vec3Cross(lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
        }
        math.vec3Cross = vec3Cross;
        function vec3Reflect(inDirection, inNormal, out) {
            var v1 = 0;
            v1 = vec3Dot(inNormal, inDirection);
            vec3ScaleByNum(out, v1 * -2, out);
            vec3Add(out, inDirection, out);
        }
        math.vec3Reflect = vec3Reflect;
        function vec3Dot(lhs, rhs) {
            return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
        }
        math.vec3Dot = vec3Dot;
        function vec3Project(vector, onNormal, out) {
            var num = 0;
            num = vec3Dot(onNormal, onNormal);
            if (num < Number.MIN_VALUE) {
                out.x = out.y = out.z = 0;
            }
            else {
                let num2 = 0;
                num2 = vec3Dot(vector, onNormal);
                vec3ScaleByNum(onNormal, num2 / num, out);
            }
        }
        math.vec3Project = vec3Project;
        function vec3ProjectOnPlane(vector, planeNormal, out) {
            vec3Project(vector, planeNormal, out);
            vec3Subtract(vector, out, out);
        }
        math.vec3ProjectOnPlane = vec3ProjectOnPlane;
        function vec3Exclude(excludeThis, fromThat, out) {
            vec3Project(fromThat, excludeThis, out);
            vec3Subtract(fromThat, out, out);
        }
        math.vec3Exclude = vec3Exclude;
        function vec3Angle(from, to) {
            var out1 = math.pool.new_vector3();
            var out2 = math.pool.new_vector3();
            vec3Normalize(from, out1);
            vec3Normalize(to, out2);
            var result = vec3Dot(out1, out2);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result) * 57.29578;
            math.pool.delete_vector3(out1);
            math.pool.delete_vector3(out1);
            return result;
        }
        math.vec3Angle = vec3Angle;
        function vec3Distance(a, b) {
            var out = math.pool.new_vector3();
            vec3Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y + out.z * out.z);
            math.pool.delete_vector3(out);
            return result;
        }
        math.vec3Distance = vec3Distance;
        function vec3ClampLength(vector, maxLength, out) {
            let val = 0;
            val = vec3SqrLength(vector);
            if (val > maxLength * maxLength) {
                vec3Normalize(vector, out);
                vec3ScaleByNum(out, maxLength, out);
            }
            out = vector;
        }
        math.vec3ClampLength = vec3ClampLength;
        function vec3Min(lhs, rhs, out) {
            out.x = Math.min(lhs.x, rhs.x);
            out.y = Math.min(lhs.y, rhs.y);
            out.z = Math.min(lhs.z, rhs.z);
        }
        math.vec3Min = vec3Min;
        function vec3Max(lhs, rhs, out) {
            out.x = Math.max(lhs.x, rhs.x);
            out.y = Math.max(lhs.y, rhs.y);
            out.z = Math.max(lhs.z, rhs.z);
        }
        math.vec3Max = vec3Max;
        function vec3AngleBetween(from, to) {
            vec3Normalize(from, from);
            vec3Normalize(to, to);
            var result = vec3Dot(from, to);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result);
            return result;
        }
        math.vec3AngleBetween = vec3AngleBetween;
        function vec3Reset(val) {
            val.x = 0;
            val.y = 0;
            val.z = 0;
        }
        math.vec3Reset = vec3Reset;
        function vec3SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
            out.z = vector.z * (1 - v) + vector2.z * v;
        }
        math.vec3SLerp = vec3SLerp;
        function vec3SetByFloat(x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
        }
        math.vec3SetByFloat = vec3SetByFloat;
        function vec3Format(vector, maxDot, out) {
            out.x = floatFormat(vector.x, maxDot);
            out.y = floatFormat(vector.y, maxDot);
            out.z = floatFormat(vector.z, maxDot);
        }
        math.vec3Format = vec3Format;
        function quaternionFormat(vector, maxDot, out) {
            out.x = floatFormat(vector.x, maxDot);
            out.y = floatFormat(vector.y, maxDot);
            out.z = floatFormat(vector.z, maxDot);
            out.w = floatFormat(vector.w, maxDot);
        }
        math.quaternionFormat = quaternionFormat;
        function floatFormat(num, maxDot) {
            var vv = Math.pow(10, maxDot);
            return Math.round(num * vv) / vv;
        }
        math.floatFormat = floatFormat;
        function vec3Equal(vector, vector2, threshold = 0.00001) {
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            if (Math.abs(vector.z - vector2.z) > threshold)
                return false;
            return true;
        }
        math.vec3Equal = vec3Equal;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class navVec3 {
            constructor() {
                this.x = 0;
                this.y = 0;
                this.z = 0;
            }
            clone() {
                var navVec = new navVec3();
                navVec.x = this.x;
                navVec.y = this.y;
                navVec.z = this.z;
                return navVec;
            }
            static DistAZ(start, end) {
                var num = end.x - start.x;
                var num2 = end.z - start.z;
                return Math.sqrt(num * num + num2 * num2);
            }
            static NormalAZ(start, end) {
                var num = end.x - start.x;
                var num2 = end.z - start.z;
                var num3 = Math.sqrt(num * num + num2 * num2);
                var navVec = new navVec3();
                navVec.x = num / num3;
                navVec.y = 0.0;
                navVec.z = num2 / num3;
                return navVec;
            }
            static Cross(start, end) {
                var navVec = new navVec3();
                navVec.x = start.y * end.z - start.z * end.y;
                navVec.y = start.z * end.x - start.x * end.z;
                navVec.z = start.x * end.y - start.y * end.x;
                return navVec;
            }
            static DotAZ(start, end) {
                return start.x * end.x + start.z * end.z;
            }
            static Angle(start, end) {
                var d = start.x * end.x + start.z * end.z;
                var navVec = navVec3.Cross(start, end);
                var num = Math.acos(d);
                var flag = navVec.y < 0.0;
                if (flag) {
                    num = -num;
                }
                return num;
            }
            static Border(start, end, dist) {
                var navVec = navVec3.NormalAZ(start, end);
                var navVec2 = new navVec3();
                navVec2.x = start.x + navVec.x * dist;
                navVec2.y = start.y + navVec.y * dist;
                navVec2.z = start.z + navVec.z * dist;
                return navVec2;
            }
        }
        framework.navVec3 = navVec3;
        class navNode {
            constructor() {
                this.nodeID = 0;
                this.poly = null;
                this.borderByPoly = null;
                this.borderByPoint = null;
                this.center = null;
            }
            genBorder() {
                var list = [];
                for (var i = 0; i < this.poly.length; i = i + 1) {
                    var num = i;
                    var num2 = i + 1;
                    var flag = num2 >= this.poly.length;
                    if (flag) {
                        num2 = 0;
                    }
                    var num3 = this.poly[num];
                    var num4 = this.poly[num2];
                    var flag2 = num3 < num4;
                    if (flag2) {
                        list.push(num3 + "-" + num4);
                    }
                    else {
                        list.push(num4 + "-" + num3);
                    }
                }
                this.borderByPoint = list;
            }
            isLinkTo(info, nid) {
                var flag = this.nodeID === nid;
                var result;
                if (flag) {
                    result = null;
                }
                else {
                    var flag2 = nid < 0;
                    if (flag2) {
                        result = null;
                    }
                    else {
                        var array = this.borderByPoly;
                        for (var i = 0; i < array.length; i = i + 1) {
                            var text = array[i];
                            var flag3 = (info.borders[text] == undefined);
                            if (!flag3) {
                                var flag4 = info.borders[text].nodeA === nid || info.borders[text].nodeB === nid;
                                if (flag4) {
                                    result = text;
                                    return result;
                                }
                            }
                        }
                        result = null;
                    }
                }
                return result;
            }
            getLinked(info) {
                var list = [];
                var array = this.borderByPoly;
                for (var i = 0; i < array.length; i = i + 1) {
                    var key = array[i];
                    var flag = (info.borders[key] == undefined);
                    if (!flag) {
                        var flag2 = info.borders[key].nodeA === this.nodeID;
                        var num;
                        if (flag2) {
                            num = info.borders[key].nodeB;
                        }
                        else {
                            num = info.borders[key].nodeA;
                        }
                        var flag3 = num >= 0;
                        if (flag3) {
                            list.push(num);
                        }
                    }
                }
                return list;
            }
            genCenter(info) {
                this.center = new navVec3();
                this.center.x = 0.0;
                this.center.y = 0.0;
                this.center.z = 0.0;
                var array = this.poly;
                for (var i = 0; i < array.length; i = i + 1) {
                    var num = array[i];
                    this.center.x += info.vecs[num].x;
                    this.center.y += info.vecs[num].y;
                    this.center.z += info.vecs[num].z;
                }
                this.center.x /= this.poly.length;
                this.center.y /= this.poly.length;
                this.center.z /= this.poly.length;
            }
        }
        framework.navNode = navNode;
        class navBorder {
            constructor() {
                this.borderName = null;
                this.nodeA = 0;
                this.nodeB = 0;
                this.pointA = 0;
                this.pointB = 0;
                this.length = 0;
                this.center = null;
            }
        }
        framework.navBorder = navBorder;
        class navMeshInfo {
            constructor() {
                this.vecs = null;
                this.nodes = null;
                this.borders = null;
                this.min = null;
                this.max = null;
            }
            calcBound() {
                this.min = new navVec3();
                this.max = new navVec3();
                this.min.x = 1.7976931348623157E+308;
                this.min.y = 1.7976931348623157E+308;
                this.min.z = 1.7976931348623157E+308;
                this.max.x = -1.7976931348623157E+308;
                this.max.y = -1.7976931348623157E+308;
                this.max.z = -1.7976931348623157E+308;
                for (var i = 0; i < this.vecs.length; i = i + 1) {
                    var flag = this.vecs[i].x < this.min.x;
                    if (flag) {
                        this.min.x = this.vecs[i].x;
                    }
                    var flag2 = this.vecs[i].y < this.min.y;
                    if (flag2) {
                        this.min.y = this.vecs[i].y;
                    }
                    var flag3 = this.vecs[i].z < this.min.z;
                    if (flag3) {
                        this.min.z = this.vecs[i].z;
                    }
                    var flag4 = this.vecs[i].x > this.max.x;
                    if (flag4) {
                        this.max.x = this.vecs[i].x;
                    }
                    var flag5 = this.vecs[i].y > this.max.y;
                    if (flag5) {
                        this.max.y = this.vecs[i].y;
                    }
                    var flag6 = this.vecs[i].z > this.max.z;
                    if (flag6) {
                        this.max.z = this.vecs[i].z;
                    }
                }
            }
            static cross(p0, p1, p2) {
                return (p1.x - p0.x) * (p2.z - p0.z) - (p2.x - p0.x) * (p1.z - p0.z);
            }
            inPoly(p, poly) {
                var num = 0;
                var flag = poly.length < 3;
                var result;
                if (flag) {
                    result = false;
                }
                else {
                    var flag2 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[1]]) < (-num);
                    if (flag2) {
                        result = false;
                    }
                    else {
                        var flag3 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[poly.length - 1]]) > num;
                        if (flag3) {
                            result = false;
                        }
                        else {
                            var i = 2;
                            var num2 = poly.length - 1;
                            var num3 = -1;
                            while (i <= num2) {
                                var num4 = i + num2 >> 1;
                                var flag4 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[num4]]) < (-num);
                                if (flag4) {
                                    num3 = num4;
                                    num2 = num4 - 1;
                                }
                                else {
                                    i = num4 + 1;
                                }
                            }
                            var num5 = navMeshInfo.cross(this.vecs[poly[num3 - 1]], p, this.vecs[poly[num3]]);
                            result = (num5 > num);
                        }
                    }
                }
                return result;
            }
            genBorder() {
                var __border = {};
                for (var i0 = 0; i0 < this.nodes.length; i0 = i0 + 1) {
                    var n = this.nodes[i0];
                    for (var i1 = 0; i1 < n.borderByPoint.length; i1 = i1 + 1) {
                        var b = n.borderByPoint[i1];
                        if (__border[b] == undefined) {
                            __border[b] = new navBorder();
                            __border[b].borderName = b;
                            __border[b].nodeA = n.nodeID;
                            __border[b].nodeB = -1;
                            __border[b].pointA = -1;
                        }
                        else {
                            __border[b].nodeB = n.nodeID;
                            if (__border[b].nodeA > __border[b].nodeB) {
                                __border[b].nodeB = __border[b].nodeA;
                                __border[b].nodeB = n.nodeID;
                            }
                            var na = this.nodes[__border[b].nodeA];
                            var nb = this.nodes[__border[b].nodeB];
                            for (var i2 = 0; i2 < na.poly.length; i2 = i2 + 1) {
                                var i = na.poly[i2];
                                if (nb.poly.indexOf(i) >= 0) {
                                    if (__border[b].pointA == -1)
                                        __border[b].pointA = i;
                                    else
                                        __border[b].pointB = i;
                                }
                            }
                            var left = __border[b].pointA;
                            var right = __border[b].pointB;
                            var xd = this.vecs[left].x - this.vecs[right].x;
                            var yd = this.vecs[left].y - this.vecs[right].y;
                            var zd = this.vecs[left].z - this.vecs[right].z;
                            __border[b].length = Math.sqrt(xd * xd + yd * yd + zd * zd);
                            __border[b].center = new navVec3();
                            __border[b].center.x = this.vecs[left].x * 0.5 + this.vecs[right].x * 0.5;
                            __border[b].center.y = this.vecs[left].y * 0.5 + this.vecs[right].y * 0.5;
                            __border[b].center.z = this.vecs[left].z * 0.5 + this.vecs[right].z * 0.5;
                            __border[b].borderName = __border[b].nodeA + "-" + __border[b].nodeB;
                        }
                    }
                }
                var namechange = {};
                for (var key in __border) {
                    if (__border[key].nodeB < 0) {
                    }
                    else {
                        namechange[key] = __border[key].borderName;
                    }
                }
                this.borders = {};
                for (var key in __border) {
                    if (namechange[key] != undefined) {
                        this.borders[namechange[key]] = __border[key];
                    }
                }
                for (var m = 0; m < this.nodes.length; m = m + 1) {
                    var v = this.nodes[m];
                    var newborder = [];
                    for (var nnn = 0; nnn < v.borderByPoint.length; nnn = nnn + 1) {
                        var b = v.borderByPoint[nnn];
                        if (namechange[b] != undefined) {
                            newborder.push(namechange[b]);
                        }
                    }
                    v.borderByPoly = newborder;
                }
            }
            static LoadMeshInfo(s) {
                var j = JSON.parse(s);
                var info = new navMeshInfo();
                var listVec = [];
                for (var jsonid in j["v"]) {
                    var v3 = new navVec3();
                    v3.x = j["v"][jsonid][0];
                    v3.y = j["v"][jsonid][1];
                    v3.z = j["v"][jsonid][2];
                    listVec.push(v3);
                }
                info.vecs = listVec;
                var polys = [];
                var list = j["p"];
                for (var i = 0; i < list.length; i++) {
                    var json = list[i];
                    var node = new navNode();
                    node.nodeID = i;
                    var poly = [];
                    for (var tt in json) {
                        poly.push(json[tt]);
                    }
                    node.poly = poly;
                    node.genBorder();
                    node.genCenter(info);
                    polys.push(node);
                }
                info.nodes = polys;
                info.calcBound();
                info.genBorder();
                return info;
            }
        }
        framework.navMeshInfo = navMeshInfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class Navigate {
            constructor(navinfo, navindexmap) {
                this.navinfo = navinfo;
                this.navindexmap = navindexmap;
            }
            pathPoints(start, end, startIndex, endIndex) {
                var startVec = new framework.navVec3();
                startVec.x = start.x;
                startVec.y = start.y;
                startVec.z = start.z;
                var endVec = new framework.navVec3();
                endVec.x = end.x;
                endVec.y = end.y;
                endVec.z = end.z;
                var startPoly = this.navindexmap[startIndex];
                var endPoly = this.navindexmap[endIndex];
                if (startPoly >= 0 && endPoly >= 0) {
                    var polyPath = gd3d.framework.pathFinding.calcAStarPolyPath(this.navinfo, startPoly, endPoly, endVec, 0.3);
                }
                if (polyPath) {
                    var wayPoints = gd3d.framework.pathFinding.calcWayPoints(this.navinfo, startVec, endVec, polyPath);
                    var navmeshWayPoints = [];
                    for (var i = 0; i < wayPoints.length; i++) {
                        navmeshWayPoints[i] = new gd3d.math.vector3(wayPoints[i].x, wayPoints[i].y, wayPoints[i].z);
                    }
                    return navmeshWayPoints;
                }
                else {
                    return null;
                }
            }
            dispose() {
                this.navinfo = null;
                this.navindexmap = null;
            }
        }
        framework.Navigate = Navigate;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class NavMeshLoadManager {
            constructor() {
                this.navMeshVertexOffset = new gd3d.math.vector3(0, 0, 0);
                this._navmeshJson = "";
            }
            get navmeshJson() { return this._navmeshJson; }
            loadNavMesh(navMeshUrl, app, onstate) {
                if (!app)
                    return;
                this.app = app;
                if (this.navTrans)
                    this.navTrans.parent.removeChild(this.navTrans);
                app.getAssetMgr().load(navMeshUrl, gd3d.framework.AssetTypeEnum.Auto, (s) => {
                    if (s.isfinish) {
                        let data = app.getAssetMgr().getAssetByName(navMeshUrl.substring(navMeshUrl.lastIndexOf("/") + 1));
                        this.navmeshLoaded(data.content, () => {
                            if (onstate) {
                                onstate(s);
                            }
                        });
                    }
                    else if (s.iserror) {
                        if (onstate) {
                            onstate(s);
                        }
                    }
                });
            }
            loadNavMeshByDate(dataStr, app, callback) {
                if (!app)
                    return;
                this.app = app;
                this.navmeshLoaded(dataStr, callback);
            }
            navmeshLoaded(dataStr, callback) {
                console.warn("navmeshLoaded");
                if (dataStr == null || dataStr == "")
                    return;
                this._navmeshJson = dataStr;
                if (this.navTrans != null) {
                    if (this.navTrans.parent)
                        this.navTrans.parent.removeChild(this.navTrans);
                    this.navTrans.dispose();
                }
                this.navTrans = new gd3d.framework.transform();
                this.navTrans.name = "navMesh";
                this.navTrans.gameObject.hideFlags = gd3d.framework.HideFlags.HideInHierarchy;
                var meshD = new gd3d.render.meshData();
                meshD.pos = [];
                meshD.trisindex = [];
                var navinfo = gd3d.framework.navMeshInfo.LoadMeshInfo(dataStr);
                for (var i = 0; i < navinfo.vecs.length; i++) {
                    var v = navinfo.vecs[i];
                    let X = v.x - this.navMeshVertexOffset.x;
                    let Y = v.y - this.navMeshVertexOffset.y;
                    let Z = v.z - this.navMeshVertexOffset.z;
                    meshD.pos[i] = new gd3d.math.vector3(X, Y, Z);
                }
                var navindexmap = {};
                let indexDatas = [];
                for (var i = 0; i < navinfo.nodes.length; i++) {
                    var poly = navinfo.nodes[i].poly;
                    for (var fc = 0; fc < poly.length - 2; fc++) {
                        var sindex = indexDatas.length / 3;
                        navindexmap[sindex] = i;
                        indexDatas.push(poly[0]);
                        indexDatas.push(poly[fc + 2]);
                        indexDatas.push(poly[fc + 1]);
                    }
                }
                meshD.trisindex = indexDatas;
                let meshFiter = this.navTrans.gameObject.addComponent("meshFilter");
                this.navMesh = this.createMesh(meshD, this.app.webgl);
                meshFiter.mesh = this.navMesh;
                this.app.getScene().addChild(this.navTrans);
                this.navTrans.markDirty();
                this.navigate = new gd3d.framework.Navigate(navinfo, navindexmap);
                callback();
            }
            createMesh(meshData, webgl) {
                var _mesh = new gd3d.framework.mesh();
                _mesh.data = meshData;
                var vf = gd3d.render.VertexFormatMask.Position;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArray();
                _mesh.glMesh = new gd3d.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                _mesh.glMesh.uploadVertexSubData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                _mesh.submesh = [];
                {
                    var sm = new gd3d.framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = false;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            }
            showNavmesh(isshow, material = null) {
                if (this.navTrans) {
                    this.navTrans.gameObject.visible = isshow;
                    if (!isshow) {
                        this.navTrans.localTranslate = new gd3d.math.vector3(0, 0, 0);
                        this.navTrans.markDirty();
                        return;
                    }
                    let compent = this.navTrans.gameObject.getComponent("meshRenderer");
                    if (compent == null) {
                        compent = this.navTrans.gameObject.addComponent("meshRenderer");
                        if (material) {
                            compent.materials = [];
                            compent.materials[0] = material;
                        }
                    }
                    this.navTrans.localTranslate = new gd3d.math.vector3(0, 0, 0);
                    this.navTrans.markDirty();
                }
            }
            dispose() {
                if (this.navTrans) {
                    this.navTrans.parent.removeChild(this.navTrans);
                    this.navTrans.dispose();
                    this.navTrans = null;
                    this.navMesh.dispose();
                    this.navMesh = null;
                    this.navigate.dispose();
                    this.navigate = null;
                }
            }
            static get Instance() {
                if (NavMeshLoadManager._instance == null)
                    NavMeshLoadManager._instance = new NavMeshLoadManager();
                return NavMeshLoadManager._instance;
            }
            moveToPoints(startPos, endPos) {
                let navTrans = NavMeshLoadManager.Instance.navTrans;
                let nav = NavMeshLoadManager.Instance.navigate;
                if (!nav)
                    return;
                let StratIndex = NavMeshLoadManager.findtriIndex(startPos, navTrans);
                if (StratIndex == undefined) {
                    let dir = new gd3d.math.vector3();
                    let direc = new gd3d.math.vector3();
                    gd3d.math.vec3Subtract(endPos, startPos, dir);
                    gd3d.math.vec3Normalize(dir, dir);
                    for (let i = 0; i < 5; i++) {
                        gd3d.math.vec3Clone(dir, direc);
                        gd3d.math.vec3ScaleByNum(direc, (i + 1) * 2, direc);
                        let pos = new gd3d.math.vector3();
                        gd3d.math.vec3Add(startPos, direc, pos);
                        StratIndex = NavMeshLoadManager.findtriIndex(pos, navTrans);
                        if (StratIndex != undefined)
                            break;
                    }
                }
                let endIndex = NavMeshLoadManager.findtriIndex(endPos, navTrans);
                let points = nav.pathPoints(startPos, endPos, StratIndex, endIndex);
                return points;
            }
            static findtriIndex(point, trans) {
                let result = -1;
                var ray = new gd3d.framework.ray(new gd3d.math.vector3(point.x, point.y + 500, point.z), new gd3d.math.vector3(0, -1, 0));
                var mesh;
                var meshFilter = trans.gameObject.getComponent("meshFilter");
                if (meshFilter != null) {
                    mesh = meshFilter.getMeshOutput();
                }
                if (!mesh)
                    return;
                var tempInfo = gd3d.math.pool.new_pickInfo();
                if (mesh.intersects(ray, trans.getWorldMatrix(), tempInfo))
                    result = tempInfo.faceId;
                gd3d.math.pool.delete_pickInfo(tempInfo);
                return result;
            }
        }
        framework.NavMeshLoadManager = NavMeshLoadManager;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class FindNode {
            constructor() {
                this.nodeid = 0;
                this.pathSessionId = 0;
                this.ParentID = -1;
                this.Open = false;
                this.HValue = 0;
                this.GValue = 0;
                this.ArrivalWall = 0;
            }
            CalcHeuristic(info, endPos) {
                var center = info.nodes[this.nodeid].center;
                var num = Math.abs(center.x - endPos.x);
                var num2 = Math.abs(center.z - endPos.z);
                this.HValue = Math.sqrt(num * num + num2 * num2);
            }
            GetCost(info, neighborID) {
                var bc = info.nodes[neighborID].center;
                var nc = info.nodes[this.nodeid].center;
                var xd = bc.x - nc.x;
                var yd = bc.y - nc.y;
                var zd = bc.z - nc.z;
                var d = Math.sqrt(xd * xd + yd * yd + zd * zd);
                return d;
            }
        }
        class pathFinding {
            static calcAStarPolyPath(info, startPoly, endPoly, endPos = null, offset = 0.1) {
                var nodeFind = [];
                var nodes = info.nodes;
                for (var i = 0; i < nodes.length; i = i + 1) {
                    var navNode = nodes[i];
                    var findNode = new FindNode();
                    findNode.nodeid = navNode.nodeID;
                    nodeFind.push(findNode);
                }
                var flag = endPos === null;
                if (flag) {
                    endPos = info.nodes[endPoly].center.clone();
                }
                var findNode2 = nodeFind[startPoly];
                findNode2.nodeid = startPoly;
                var num = 1;
                var flag2 = false;
                var openList = [];
                var list2 = [];
                findNode2.pathSessionId = num;
                openList.push(startPoly);
                var sortfun = (x, y) => {
                    var xFvalue = nodeFind[x].HValue + nodeFind[x].GValue;
                    var yFvalue = nodeFind[y].HValue + nodeFind[y].GValue;
                    if (xFvalue < yFvalue - 0.001)
                        return 1;
                    if (xFvalue > yFvalue + 0.001)
                        return -1;
                    return 0;
                };
                while (openList.length > 0) {
                    var findNode3 = nodeFind[openList[openList.length - 1]];
                    openList.splice(openList.length - 1, 1);
                    list2.push(findNode3.nodeid);
                    var flag3 = findNode3.nodeid === endPoly;
                    if (flag3) {
                        flag2 = true;
                        break;
                    }
                    var linked = info.nodes[findNode3.nodeid].getLinked(info);
                    for (var j = 0; j < linked.length; j = j + 1) {
                        var num2 = linked[j];
                        var flag4 = num2 < 0;
                        if (!flag4) {
                            var findNode4 = nodeFind[num2];
                            var flag5 = findNode4 === null || findNode4.nodeid !== num2;
                            if (flag5) {
                                return null;
                            }
                            var flag6 = findNode4.pathSessionId !== num;
                            if (flag6) {
                                var text = info.nodes[findNode4.nodeid].isLinkTo(info, findNode3.nodeid);
                                var flag7 = text !== null && info.borders[text].length >= offset * 2;
                                if (flag7) {
                                    findNode4.pathSessionId = num;
                                    findNode4.ParentID = findNode3.nodeid;
                                    findNode4.Open = true;
                                    findNode4.CalcHeuristic(info, endPos);
                                    findNode4.GValue = findNode3.GValue + findNode3.GetCost(info, findNode4.nodeid);
                                    openList.push(findNode4.nodeid);
                                    openList.sort(sortfun);
                                    findNode4.ArrivalWall = findNode3.nodeid;
                                }
                            }
                            else {
                                var open = findNode4.Open;
                                if (open) {
                                    var flag8 = findNode4.GValue + findNode4.GetCost(info, findNode3.nodeid) < findNode3.GValue;
                                    if (flag8) {
                                        findNode3.GValue = findNode4.GValue + findNode4.GetCost(info, findNode3.nodeid);
                                        findNode3.ParentID = findNode4.nodeid;
                                        findNode3.ArrivalWall = findNode4.nodeid;
                                    }
                                }
                            }
                        }
                    }
                }
                var list3 = [];
                var flag9 = list2.length > 0;
                if (flag9) {
                    var findNode5 = nodeFind[list2[list2.length - 1]];
                    list3.push(findNode5.nodeid);
                    while (findNode5.ParentID !== -1) {
                        list3.push(findNode5.ParentID);
                        findNode5 = nodeFind[findNode5.ParentID];
                    }
                }
                return list3;
            }
            static NearAngle(a, b) {
                var num = a;
                var flag = a >= 180.0;
                if (flag) {
                    num = 360.0 - a;
                }
                var num2 = b;
                var flag2 = b >= 180.0;
                if (flag2) {
                    num2 = 360.0 - b;
                }
                var flag3 = num < num2;
                var result;
                if (flag3) {
                    result = a;
                }
                else {
                    result = b;
                }
                return result;
            }
            static FindPath(info, startPos, endPos, offset = 0.1) {
                var startPoly = -1;
                var endPoly = -1;
                for (var i = 0; i < info.nodes.length; i = i + 1) {
                    var flag = info.inPoly(startPos, info.nodes[i].poly);
                    if (flag) {
                        startPoly = i;
                    }
                    var flag2 = info.inPoly(startPos, info.nodes[i].poly);
                    if (flag2) {
                        endPoly = i;
                    }
                }
                var polyPath = pathFinding.calcAStarPolyPath(info, startPoly, endPoly, endPos, offset);
                return pathFinding.calcWayPoints(info, startPos, endPos, polyPath, offset);
            }
            static calcWayPoints(info, startPos, endPos, polyPath, offset = 0.1) {
                var wayPoints = [];
                if (polyPath.length == 0 || startPos == null || endPos == null) {
                    return null;
                }
                var triPathList = polyPath.reverse();
                wayPoints.push(startPos);
                var ipoly = 0;
                var dirLeft = null;
                var ipolyLeft = -1;
                var dirRight = null;
                var ipolyRight = -1;
                var breakDir = 0;
                var posLeft = null;
                var posRight = null;
                var posNow = startPos.clone();
                for (var c = 0; c < 100; c++) {
                    for (var i = ipoly; i < triPathList.length; i++) {
                        if (i === triPathList.length - 1) {
                            if (dirLeft == null || dirRight == null) {
                                breakDir = 0;
                                break;
                            }
                            else {
                                var dirFinal = gd3d.framework.navVec3.NormalAZ(posNow, endPos);
                                var a1 = gd3d.framework.navVec3.Angle(dirLeft, dirFinal);
                                var b1 = gd3d.framework.navVec3.Angle(dirRight, dirFinal);
                                var flag4 = a1 * b1 > 0.0;
                                if (a1 * b1 > 0.0) {
                                    if (a1 > 0.0) {
                                        breakDir = 1;
                                    }
                                    else {
                                        breakDir = -1;
                                    }
                                }
                                else {
                                    breakDir = 0;
                                    break;
                                }
                            }
                        }
                        else {
                            var n1 = triPathList[i];
                            var n2 = triPathList[i + 1];
                            var bname = n1 + "-" + n2;
                            if (n2 < n1) {
                                bname = n2 + "-" + n1;
                            }
                            var border = info.borders[bname];
                            var pointA = gd3d.framework.navVec3.Border(info.vecs[border.pointA], info.vecs[border.pointB], offset);
                            var pointB = gd3d.framework.navVec3.Border(info.vecs[border.pointB], info.vecs[border.pointA], offset);
                            var dist1 = gd3d.framework.navVec3.DistAZ(posNow, pointA);
                            var dist2 = gd3d.framework.navVec3.DistAZ(posNow, pointB);
                            if (dist1 < 0.001 || dist2 < 0.001) {
                                continue;
                            }
                            if (dirLeft == null) {
                                dirLeft = gd3d.framework.navVec3.NormalAZ(posNow, pointA);
                                posLeft = pointA.clone();
                                ipolyLeft = i;
                            }
                            if (dirRight == null) {
                                dirRight = gd3d.framework.navVec3.NormalAZ(posNow, pointB);
                                posRight = pointB.clone();
                                ipolyRight = i;
                            }
                            var adir = gd3d.framework.navVec3.Angle(dirLeft, dirRight);
                            if (adir < 0.0) {
                                var navVec7 = dirLeft;
                                var navVec8 = posLeft;
                                var num12 = ipolyLeft;
                                dirLeft = dirRight;
                                posLeft = posRight;
                                ipolyLeft = ipolyRight;
                                dirRight = navVec7;
                                posRight = navVec8;
                                ipolyRight = num12;
                            }
                            if (ipolyLeft != i || ipolyRight != i) {
                                var ndirLeft = gd3d.framework.navVec3.NormalAZ(posNow, pointA);
                                var ndirRight = gd3d.framework.navVec3.NormalAZ(posNow, pointB);
                                var nadir = gd3d.framework.navVec3.Angle(ndirLeft, ndirRight);
                                if (nadir < 0.0) {
                                    var navVec11 = ndirLeft;
                                    var navVec12 = pointA;
                                    ndirLeft = ndirRight;
                                    pointA = pointB;
                                    ndirRight = navVec11;
                                    pointB = navVec12;
                                }
                                var aLL = gd3d.framework.navVec3.Angle(dirLeft, ndirLeft);
                                var aRL = gd3d.framework.navVec3.Angle(dirRight, ndirLeft);
                                var aLR = gd3d.framework.navVec3.Angle(dirLeft, ndirRight);
                                var aRR = gd3d.framework.navVec3.Angle(dirRight, ndirRight);
                                if ((aLL < 0 && aLR < 0)) {
                                    breakDir = -1;
                                    break;
                                }
                                if (aRL > 0.0 && aRR > 0.0) {
                                    breakDir = 1;
                                    break;
                                }
                                if (aLL > 0.0 && aRL < 0.0) {
                                    dirLeft = ndirLeft;
                                    posLeft = pointA;
                                    ipolyLeft = i;
                                }
                                if (aLR > 0.0 && aRR < 0.0) {
                                    dirRight = ndirRight;
                                    posRight = pointB;
                                    ipolyRight = i;
                                }
                            }
                        }
                    }
                    if (breakDir == 0) {
                        break;
                    }
                    else {
                        if (breakDir == -1) {
                            wayPoints.push(posLeft.clone());
                            posNow = posLeft;
                            ipoly = ipolyLeft;
                        }
                        else {
                            wayPoints.push(posRight.clone());
                            posNow = posRight;
                            ipoly = ipolyRight;
                        }
                        dirLeft = null;
                        dirRight = null;
                        ipolyLeft = -1;
                        ipolyRight = -1;
                    }
                }
                wayPoints.push(endPos);
                return wayPoints;
            }
        }
        framework.pathFinding = pathFinding;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class RVOManager {
            constructor() {
                this.sim = new RVO.Simulator(1, 60, 20, 20, 5, 1.0, 0.1, [0, 0]);
                this.transforms = [];
                this.goals = [];
                this.radius = [];
                this.attackRanges = [];
                this.speeds = [];
                this.map = {};
                this.isRunning = false;
                this.currMoveDir = new gd3d.math.vector2();
                this._RoadPoints = [];
            }
            setRoadPoints(goalQueue) {
                if (!goalQueue || goalQueue.length < 1)
                    return;
                this._RoadPoints.forEach(sub => {
                    if (sub && sub != this.lastGoal)
                        gd3d.math.pool.delete_vector3(sub);
                });
                this._RoadPoints.length = 0;
                for (var i = 0; i < goalQueue.length; i++) {
                    let v3 = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Clone(goalQueue[i], v3);
                    this._RoadPoints.push(v3);
                }
                this.currGoal = this._RoadPoints.pop();
                this.goals[0][0] = this.currGoal.x;
                this.goals[0][1] = this.currGoal.z;
            }
            addAgent(key, transform, radius, attackRanges, speed) {
                let index = this.sim.agents.length;
                let current_position = [transform.localTranslate.x, transform.localTranslate.z];
                this.transforms.push(transform);
                this.attackRanges.push(attackRanges);
                this.radius.push(radius);
                this.speeds.push(speed);
                this.goals.push(current_position);
                this.sim.addAgent(current_position);
                this.sim.agents[index].id = key;
                this.sim.agents[index].radius = radius;
                this.sim.agents[index].maxSpeed = speed;
                this.map[key] = index;
                if (index == 0) {
                    this.sim.agents[0].neighborDist = 0;
                }
                this.isRunning = true;
            }
            removeAgent(key) {
                let offset = this.map[key];
                this.transforms.splice(offset, 1);
                this.attackRanges.splice(offset, 1);
                this.radius.splice(offset, 1);
                this.speeds.splice(offset, 1);
                this.goals.splice(offset, 1);
                this.sim.agents.splice(offset, 1);
                this.reBuildHashMap();
            }
            reBuildHashMap() {
                for (let i = 0; i < this.sim.agents.length; i++) {
                    this.map[this.sim.agents[i].id] = i;
                }
                this.sim.kdTree.agents = [];
                this.sim.kdTree.agentTree = [];
                this.sim.kdTree.obstacleTree = 0;
            }
            getTransformByKey(key) {
                let offset = this.map[key];
                return this.transforms[offset];
            }
            setRadius(id, value) {
                let i = this.map[id];
                this.sim.agents[i].radius = value;
            }
            setSpeed(id, value) {
                let i = this.map[id];
                this.sim.agents[i].maxSpeed = value;
            }
            setAttackRange(id, value) {
                let i = this.map[id];
                this.attackRanges[i] = value;
            }
            disable() {
                this.isRunning = false;
            }
            enable() {
                this.isRunning = true;
                for (let i in this.transforms) {
                    this.sim.agents[i].position = [this.transforms[i].localTranslate.x, this.transforms[i].localTranslate.z];
                }
            }
            update() {
                if (this.isRunning && (this.transforms.length >= 1)) {
                    this.RVO_check(this.sim, this.goals);
                    this.RVO_walking(this.sim, this.goals);
                    this.updateTransform(this.sim);
                }
            }
            isAlmostStatic() {
                let threshold = 0.1;
                let amount = 0;
                for (let i = 0; i < this.sim.agents.length; i++) {
                    if (this.sim.agents[i].prefVelocity != null) {
                        if (this.sim.agents[i].prefVelocity[0] < 0.01 && this.sim.agents[i].prefVelocity[1] < 0.01) {
                            amount++;
                        }
                    }
                }
                if (amount / this.sim.agents.length >= threshold) {
                    return true;
                }
                return false;
            }
            RVO_walking(sim, goals) {
                for (var i = 0, len = sim.agents.length; i < len; i++) {
                    if (sim.agents[i] != null) {
                        var goalVector = RVO.Vector.subtract(goals[i], sim.agents[i].position);
                        if (RVO.Vector.absSq(goalVector) > 1) {
                            goalVector = RVO.Vector.normalize(goalVector);
                        }
                        sim.agents[i].prefVelocity = goalVector;
                    }
                }
                sim.doStep();
            }
            updateTransform(sim) {
                for (let i = 0; i < sim.agents.length; i++) {
                    this.transforms[i].localTranslate.x = sim.agents[i].position[0];
                    this.transforms[i].localTranslate.z = sim.agents[i].position[1];
                    if (i == 0 && this.currGoal && this.lastGoal) {
                        let pos = this.transforms[i].localTranslate;
                        let nowDir = gd3d.math.pool.new_vector2();
                        this.cal2dDir(this.lastGoal, pos, nowDir);
                        let nowLen = gd3d.math.vec2Length(nowDir);
                        let tLen = gd3d.math.vec2Length(this.currMoveDir);
                        let y = gd3d.math.numberLerp(this.lastGoal.y, this.currGoal.y, nowLen / tLen);
                        if (!isNaN(y)) {
                            pos.y = gd3d.math.numberLerp(this.lastGoal.y, this.currGoal.y, nowLen / tLen);
                        }
                        gd3d.math.pool.delete_vector2(nowDir);
                    }
                    this.transforms[i].markDirty();
                }
            }
            RVO_check(sim, goals) {
                if (this.currGoal) {
                    let player = this.transforms[0];
                    let v2_0 = gd3d.math.pool.new_vector2();
                    v2_0.x = player.localTranslate.x;
                    v2_0.y = player.localTranslate.z;
                    let v2_1 = gd3d.math.pool.new_vector2();
                    v2_1.x = this.currGoal.x;
                    v2_1.y = this.currGoal.z;
                    let dis = gd3d.math.vec2Distance(v2_0, v2_1);
                    if (dis < 0.01) {
                        if (this.currGoal) {
                            if (this.lastGoal)
                                gd3d.math.pool.delete_vector3(this.lastGoal);
                            this.lastGoal = this.currGoal;
                            this.currGoal = null;
                            goals[0] = sim.agents[0].position;
                            sim.agents[0].radius = this.radius[0];
                        }
                        if (this._RoadPoints && this._RoadPoints.length > 0) {
                            this.currGoal = this._RoadPoints.pop();
                            this.cal2dDir(this.lastGoal, this.currGoal, this.currMoveDir);
                            goals[0] = [this.currGoal.x, this.currGoal.z];
                            sim.agents[0].radius = 0.1;
                        }
                    }
                }
                else if (this._RoadPoints && this._RoadPoints.length > 0) {
                    this.currGoal = this._RoadPoints.pop();
                    goals[0] = [this.currGoal.x, this.currGoal.z];
                    sim.agents[0].radius = 0.1;
                }
                for (var i = 1, len = sim.agents.length; i < len; i++) {
                    let range = RVO.Vector.absSq(RVO.Vector.subtract(sim.agents[i].position, sim.agents[0].position));
                    if (range < this.attackRanges[i]) {
                        goals[i] = sim.agents[i].position;
                        sim.agents[i].neighborDist = 0;
                    }
                    else {
                        goals[i] = sim.agents[0].position;
                        sim.agents[i].neighborDist = sim.agentDefaults.neighborDist;
                    }
                }
            }
            cal2dDir(oPos, tPos, out) {
                if (!oPos || !tPos || !out)
                    return;
                let ov2 = gd3d.math.pool.new_vector2();
                ov2.x = oPos.x;
                ov2.y = oPos.z;
                let tv2 = gd3d.math.pool.new_vector2();
                tv2.x = tPos.x;
                tv2.y = tPos.z;
                gd3d.math.vec2Subtract(tv2, ov2, out);
                gd3d.math.pool.delete_vector2(ov2);
                gd3d.math.pool.delete_vector2(tv2);
            }
        }
        framework.RVOManager = RVOManager;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class EffectSystemData {
            constructor() {
                this.beLoop = false;
                this.elementDic = {};
            }
            clone() {
                let data = new EffectSystemData();
                data.life = this.life;
                data.beLoop = this.beLoop;
                for (let key in this.elementDic) {
                    data.elementDic[key] = this.elementDic[key].clone();
                }
                return data;
            }
            dispose() {
                for (let key in this.elementDic) {
                    this.elementDic[key].dispose();
                    delete this.elementDic[key];
                }
            }
        }
        framework.EffectSystemData = EffectSystemData;
        class EffectElement {
            constructor(_data) {
                this.startVboIndex = 0;
                this.startEboIndex = 0;
                this.endEboIndex = 0;
                this.delayTime = 0;
                this.actionActive = false;
                this.loopFrame = Number.MAX_VALUE;
                this.active = true;
                this.data = _data;
                this.name = this.data.name;
                this.timelineFrame = {};
                this.delayTime = _data.delayTime;
                this.initActions();
                this.recordElementLerpAttributes();
            }
            recordElementLerpAttributes() {
                if (this.data.timelineFrame != undefined) {
                    for (let i in this.data.timelineFrame) {
                        let frameData = this.data.timelineFrame[i];
                        if (frameData.frameIndex != -1) {
                            if (frameData.lerpDatas != undefined && frameData.lerpDatas.length != 0) {
                                this.recordLerpValues(frameData);
                            }
                            else if (frameData.attrsData != undefined) {
                                if (this.timelineFrame[frameData.frameIndex] == undefined) {
                                    this.timelineFrame[frameData.frameIndex] = new EffectFrameData();
                                    this.timelineFrame[frameData.frameIndex].attrsData = new EffectAttrsData();
                                    this.timelineFrame[frameData.frameIndex].frameIndex = frameData.frameIndex;
                                }
                                for (let k in frameData.attrsData) {
                                    this.timelineFrame[frameData.frameIndex].attrsData.setLerpAttribute(k, frameData.attrsData.getAttribute(k));
                                }
                            }
                        }
                    }
                }
            }
            recordLerpValues(effectFrameData) {
                for (let i in effectFrameData.lerpDatas) {
                    if (effectFrameData.lerpDatas[i].type == EffectLerpTypeEnum.Linear) {
                        for (let key in effectFrameData.lerpDatas[i].attrsList) {
                            let attrname = effectFrameData.lerpDatas[i].attrsList[key];
                            this.recordLerp(effectFrameData, effectFrameData.lerpDatas[i], attrname);
                        }
                    }
                }
            }
            recordLerp(effectFrameData, lerpData, key) {
                let fromFrame = lerpData.fromFrame;
                let toFrame = lerpData.toFrame.getValue();
                let toVal = lerpData.attrsData.getAttribute(key);
                if (effectFrameData.attrsData[key] == undefined) {
                    effectFrameData.attrsData.initAttribute(key);
                }
                let fromVal = effectFrameData.attrsData.getAttribute(key);
                for (let i = fromFrame + 1; i <= toFrame; i++) {
                    let outVal;
                    if (fromVal instanceof gd3d.math.vector3) {
                        outVal = new gd3d.math.vector3();
                        gd3d.math.vec3SLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame), outVal);
                    }
                    else if (fromVal instanceof gd3d.math.vector2) {
                        outVal = new gd3d.math.vector2();
                        gd3d.math.vec2SLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame), outVal);
                    }
                    else if (typeof (fromVal) === 'number') {
                        outVal = gd3d.math.numberLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame));
                    }
                    let newFrameData = this.timelineFrame[i];
                    if (newFrameData == undefined) {
                        newFrameData = new EffectFrameData();
                        newFrameData.attrsData = new EffectAttrsData();
                        newFrameData.frameIndex = i;
                        this.timelineFrame[i] = newFrameData;
                    }
                    newFrameData.attrsData.setLerpAttribute(key, outVal);
                }
            }
            initActions() {
                this.actions = [];
                let action;
                for (let key in this.data.actionData) {
                    let actiondata = this.data.actionData[key];
                    switch (actiondata.actionType) {
                        case "linear":
                            action = new framework.LinearAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "loop":
                            action = new framework.LoopAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "rotation":
                            action = new framework.RotationAction();
                            break;
                        case "breath":
                            action = new framework.BreathAction();
                            break;
                        case "uvroll":
                            action = new framework.UVRollAction();
                            break;
                        case "uvsprite":
                            action = new framework.UVSpriteAnimationAction();
                            break;
                        case "rosepath":
                            action = new framework.RoseCurveAction();
                            break;
                        case "trail":
                            action = new framework.TrailAction();
                            break;
                    }
                    action.init(actiondata.startFrame, actiondata.endFrame, actiondata.params, this);
                    this.actions.push(action);
                }
            }
            update() {
                if (this.curAttrData == undefined || this.curAttrData == null)
                    return;
                if (this.active) {
                    if (this.curAttrData.euler != undefined) {
                        gd3d.math.quatFromEulerAngles(this.curAttrData.euler.x, this.curAttrData.euler.y, this.curAttrData.euler.z, this.curAttrData.rotationByEuler);
                    }
                    this.updateElementRotation();
                    gd3d.math.matrixMakeTransformRTS(this.curAttrData.pos, this.curAttrData.scale, this.curAttrData.localRotation, this.curAttrData.matrix);
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            }
            updateElementRotation() {
                let cameraTransform = gd3d.framework.sceneMgr.app.getScene().mainCamera.gameObject.transform;
                let worldRotation = gd3d.math.pool.new_quaternion();
                let localRotation = gd3d.math.pool.new_quaternion();
                if (this.curAttrData.renderModel != RenderModel.None) {
                    let invTransformRotation = gd3d.math.pool.new_quaternion();
                    let worldTranslation = gd3d.math.pool.new_vector3();
                    let translation = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Clone(this.curAttrData.pos, translation);
                    if (this.transform != undefined) {
                        gd3d.math.matrixTransformVector3(translation, this.transform.getWorldMatrix(), worldTranslation);
                    }
                    if (this.curAttrData.renderModel == RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    else if (this.curAttrData.renderModel == RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.curAttrData.renderModel == RenderModel.VerticalBillBoard) {
                        let forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(cameraTransform.getWorldTranslate(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.curAttrData.renderModel == RenderModel.StretchedBillBoard) {
                        gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                        let lookRot = new gd3d.math.quaternion();
                        gd3d.math.quatClone(this.transform.getWorldRotate(), invTransformRotation);
                        gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                        gd3d.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        let inverRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatInverse(this.curAttrData.localRotation, inverRot);
                        gd3d.math.quatMultiply(inverRot, lookRot, lookRot);
                        let angle = gd3d.math.pool.new_vector3();
                        gd3d.math.quatToEulerAngles(lookRot, angle);
                        gd3d.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        gd3d.math.quatMultiply(this.curAttrData.localRotation, lookRot, this.curAttrData.localRotation);
                        gd3d.math.pool.delete_quaternion(inverRot);
                        gd3d.math.pool.delete_vector3(angle);
                        gd3d.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.curAttrData.renderModel == RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, worldRotation);
                    gd3d.math.quatClone(this.transform.gameObject.transform.getWorldRotate(), invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.curAttrData.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                }
                gd3d.math.pool.delete_quaternion(localRotation);
                gd3d.math.pool.delete_quaternion(worldRotation);
            }
            isCurFrameNeedRefresh(frameIndex) {
                if (this.timelineFrame[frameIndex] != undefined) {
                    return true;
                }
                if (this.curAttrData != undefined && this.curAttrData.renderModel != RenderModel.None) {
                    return true;
                }
                return this.actionActive;
            }
            setActive(_active) {
                if (this.active == _active)
                    return;
                this.active = _active;
                if (this.active) {
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            }
            dispose() {
                this.data.dispose();
                this.curAttrData = null;
                this.actions.length = 0;
                delete this.timelineFrame;
            }
        }
        framework.EffectElement = EffectElement;
        class EffectElementData {
            constructor() {
                this.delayTime = 0;
            }
            clone() {
                let elementdata = new EffectElementData();
                elementdata.name = this.name;
                elementdata.type = this.type;
                elementdata.refFrom = this.refFrom;
                elementdata.beloop = this.beloop;
                elementdata.actionData = [];
                elementdata.timelineFrame = [];
                if (this.initFrameData)
                    elementdata.initFrameData = this.initFrameData.clone();
                if (this.emissionData) {
                    elementdata.emissionData = this.emissionData.clone();
                }
                for (let key in this.timelineFrame) {
                    if (this.timelineFrame[key]) {
                        elementdata.timelineFrame[key] = this.timelineFrame[key].clone();
                    }
                }
                for (let key in this.actionData) {
                    if (this.actionData[key]) {
                        elementdata.actionData[key] = this.actionData[key].clone();
                    }
                }
                return elementdata;
            }
            dispose() {
                if (this.actionData)
                    this.actionData.length = 0;
                if (this.initFrameData)
                    this.initFrameData.dispose();
                for (let key in this.timelineFrame) {
                    this.timelineFrame[key].dispose();
                }
                delete this.timelineFrame;
            }
        }
        framework.EffectElementData = EffectElementData;
        class EffectAttrsData {
            constructor() {
                this.uv = new gd3d.math.vector2(1, 1);
                this.renderModel = RenderModel.None;
                this.matrix = new gd3d.math.matrix();
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localRotation = new gd3d.math.quaternion();
            }
            setLerpAttribute(attribute, val) {
                switch (attribute) {
                    case "pos":
                        this.pos = val;
                        break;
                    case "scale":
                        this.scale = val;
                        break;
                    case "euler":
                        this.euler = val;
                        break;
                    case "alpha":
                        this.alpha = val;
                        break;
                    case "uv":
                        this.uv = val;
                        break;
                    case "color":
                        this.color = val;
                        break;
                    case "tilling":
                        console.log("tilling 逻辑上不需要插值");
                        break;
                }
            }
            getAttribute(attribute) {
                switch (attribute) {
                    case "pos":
                        return gd3d.math.pool.clone_vector3(this.pos);
                    case "scale":
                        return gd3d.math.pool.clone_vector3(this.scale);
                    case "euler":
                        return gd3d.math.pool.clone_vector3(this.euler);
                    case "alpha":
                        return this.alpha;
                    case "color":
                        return gd3d.math.pool.clone_vector3(this.color);
                    case "tilling":
                        return gd3d.math.pool.clone_vector2(this.tilling);
                    case "uv":
                        return gd3d.math.pool.clone_vector2(this.uv);
                    case "mat":
                        return this.mat.clone();
                    case "renderModel":
                        return this.renderModel;
                    case "rotationByEuler":
                        return gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                    case "localRotation":
                        return gd3d.math.pool.clone_quaternion(this.localRotation);
                    case "matrix":
                        return gd3d.math.pool.clone_matrix(this.matrix);
                    case "colorRate":
                        return this.colorRate;
                }
            }
            initAttribute(attribute) {
                switch (attribute) {
                    case "pos":
                        this.pos = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "scale":
                        this.scale = new gd3d.math.vector3(1, 1, 1);
                        break;
                    case "euler":
                        this.euler = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "alpha":
                        this.alpha = 0;
                        break;
                    case "color":
                        this.color = new gd3d.math.vector3(0, 0, 0);
                        break;
                    case "uv":
                        this.uv = new gd3d.math.vector2(0, 0);
                        break;
                    case "tilling":
                        this.tilling = new gd3d.math.vector2(1, 1);
                        break;
                    case "colorRate":
                        this.colorRate = 1;
                        break;
                    default:
                        console.log("不支持的属性：" + attribute);
                        break;
                }
            }
            resetMatrix() {
                gd3d.math.matrixZero(this.matrix);
            }
            copyandinit() {
                let data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = gd3d.math.pool.clone_vector3(this.pos);
                else
                    data.initAttribute("pos");
                if (this.euler != undefined)
                    data.euler = gd3d.math.pool.clone_vector3(this.euler);
                else
                    data.initAttribute("euler");
                if (this.color != undefined)
                    data.color = gd3d.math.pool.clone_vector3(this.color);
                else
                    data.initAttribute("color");
                if (this.scale != undefined)
                    data.scale = gd3d.math.pool.clone_vector3(this.scale);
                else
                    data.initAttribute("scale");
                if (this.uv != undefined)
                    data.uv = gd3d.math.pool.clone_vector2(this.uv);
                else
                    data.initAttribute("uv");
                if (this.tilling != undefined)
                    data.tilling = gd3d.math.pool.clone_vector2(this.tilling);
                else
                    data.initAttribute("tilling");
                if (this.colorRate != undefined)
                    data.colorRate = this.colorRate;
                else
                    data.initAttribute("colorRate");
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = gd3d.math.pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo;
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            }
            clone() {
                let data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = gd3d.math.pool.clone_vector3(this.pos);
                if (this.euler != undefined)
                    data.euler = gd3d.math.pool.clone_vector3(this.euler);
                if (this.color != undefined)
                    data.color = gd3d.math.pool.clone_vector3(this.color);
                if (this.scale != undefined)
                    data.scale = gd3d.math.pool.clone_vector3(this.scale);
                if (this.tilling != undefined)
                    data.tilling = gd3d.math.pool.clone_vector2(this.tilling);
                if (this.colorRate != undefined)
                    data.colorRate = this.colorRate;
                if (this.uv != undefined)
                    data.uv = gd3d.math.pool.clone_vector2(this.uv);
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = gd3d.math.pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = gd3d.math.pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo;
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            }
        }
        framework.EffectAttrsData = EffectAttrsData;
        class EffectFrameData {
            clone() {
                let framedata = new EffectFrameData();
                framedata.frameIndex = this.frameIndex;
                framedata.attrsData = this.attrsData.clone();
                framedata.lerpDatas = [];
                for (let key in this.lerpDatas) {
                    framedata.lerpDatas[key] = this.lerpDatas[key].clone();
                }
                return framedata;
            }
            dispose() {
                this.attrsData = null;
                if (this.lerpDatas)
                    this.lerpDatas.length = 0;
            }
        }
        framework.EffectFrameData = EffectFrameData;
        class EffectLerpData {
            constructor() {
                this.attrsList = [];
            }
            clone() {
                let lerpdata = new EffectLerpData();
                lerpdata.type = this.type;
                lerpdata.fromFrame = this.fromFrame;
                lerpdata.toFrame = this.toFrame;
                lerpdata.attrsData = this.attrsData.clone();
                for (let key in this.attrsList) {
                    lerpdata.attrsList[key] = this.attrsList[key];
                }
                return lerpdata;
            }
        }
        framework.EffectLerpData = EffectLerpData;
        class EffectActionData {
            clone() {
                let actiondata = new EffectActionData();
                actiondata.actionType = this.actionType;
                actiondata.startFrame = this.startFrame;
                actiondata.endFrame = this.endFrame;
                actiondata.params = [];
                for (let key in this.params) {
                    actiondata.params[key] = this.params[key];
                }
                return actiondata;
            }
        }
        framework.EffectActionData = EffectActionData;
        class EffectMatData {
            static beEqual(data0, data1) {
                return data0.alphaCut === data1.alphaCut && data0.diffuseTexture === data1.diffuseTexture && data0.shader === data1.shader && data0.alphaTexture === data1.alphaTexture;
            }
            clone() {
                let data = new EffectMatData();
                data.shader = this.shader;
                data.diffuseTexture = this.diffuseTexture;
                data.alphaTexture = this.alphaTexture;
                data.alphaCut = this.alphaCut;
                return data;
            }
        }
        framework.EffectMatData = EffectMatData;
        let EffectBatcherState;
        (function (EffectBatcherState) {
            EffectBatcherState[EffectBatcherState["NotInitedStateType"] = 0] = "NotInitedStateType";
            EffectBatcherState[EffectBatcherState["InitedStateType"] = 1] = "InitedStateType";
            EffectBatcherState[EffectBatcherState["ResizeCapacityStateType"] = 2] = "ResizeCapacityStateType";
        })(EffectBatcherState = framework.EffectBatcherState || (framework.EffectBatcherState = {}));
        class EffectBatcher {
            constructor(formate) {
                this.state = EffectBatcherState.NotInitedStateType;
                this.effectElements = [];
                this._totalVertexCount = 0;
                this._indexStartIndex = 0;
                this._vbosize = 0;
                this.vertexSize = 0;
                this.vertexSize = gd3d.render.meshData.calcByteSize(formate) / 4;
            }
            get curTotalVertexCount() {
                return this._totalVertexCount;
            }
            set curTotalVertexCount(val) {
                this._totalVertexCount = val;
                this.resizeVboSize(this._totalVertexCount * this.vertexSize);
            }
            get indexStartIndex() {
                return this._indexStartIndex;
            }
            set indexStartIndex(value) {
                this._indexStartIndex = value;
                if (this.dataForEbo != null) {
                    let ebo = new Uint16Array(this._indexStartIndex);
                    ebo.set(this.dataForEbo, 0);
                    this.dataForEbo = ebo;
                }
                else {
                    this.dataForEbo = new Uint16Array(this._indexStartIndex);
                }
            }
            resizeVboSize(value) {
                if (this._vbosize > value)
                    return;
                this._vbosize = value;
                if (this.dataForVbo != null) {
                    let vbo = new Float32Array(this._vbosize);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                else {
                    this.dataForVbo = new Float32Array(this._vbosize);
                }
            }
            dispose() {
                this.mesh.dispose();
                this.mat.dispose();
                this.dataForVbo = null;
                this.dataForEbo = null;
                for (let key in this.effectElements) {
                    this.effectElements[key].dispose();
                }
            }
        }
        framework.EffectBatcher = EffectBatcher;
        let EffectPlayStateEnum;
        (function (EffectPlayStateEnum) {
            EffectPlayStateEnum[EffectPlayStateEnum["None"] = 0] = "None";
            EffectPlayStateEnum[EffectPlayStateEnum["BeReady"] = 1] = "BeReady";
            EffectPlayStateEnum[EffectPlayStateEnum["Play"] = 2] = "Play";
            EffectPlayStateEnum[EffectPlayStateEnum["Pause"] = 3] = "Pause";
            EffectPlayStateEnum[EffectPlayStateEnum["Stop"] = 4] = "Stop";
            EffectPlayStateEnum[EffectPlayStateEnum["Dispose"] = 5] = "Dispose";
        })(EffectPlayStateEnum = framework.EffectPlayStateEnum || (framework.EffectPlayStateEnum = {}));
        let EffectElementTypeEnum;
        (function (EffectElementTypeEnum) {
            EffectElementTypeEnum[EffectElementTypeEnum["SingleMeshType"] = 0] = "SingleMeshType";
            EffectElementTypeEnum[EffectElementTypeEnum["EmissionType"] = 1] = "EmissionType";
            EffectElementTypeEnum[EffectElementTypeEnum["MultiMeshType"] = 2] = "MultiMeshType";
        })(EffectElementTypeEnum = framework.EffectElementTypeEnum || (framework.EffectElementTypeEnum = {}));
        let EffectLerpTypeEnum;
        (function (EffectLerpTypeEnum) {
            EffectLerpTypeEnum[EffectLerpTypeEnum["Linear"] = 0] = "Linear";
        })(EffectLerpTypeEnum = framework.EffectLerpTypeEnum || (framework.EffectLerpTypeEnum = {}));
        let RenderModel;
        (function (RenderModel) {
            RenderModel[RenderModel["None"] = 0] = "None";
            RenderModel[RenderModel["BillBoard"] = 1] = "BillBoard";
            RenderModel[RenderModel["StretchedBillBoard"] = 2] = "StretchedBillBoard";
            RenderModel[RenderModel["HorizontalBillBoard"] = 3] = "HorizontalBillBoard";
            RenderModel[RenderModel["VerticalBillBoard"] = 4] = "VerticalBillBoard";
            RenderModel[RenderModel["Mesh"] = 5] = "Mesh";
        })(RenderModel = framework.RenderModel || (framework.RenderModel = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let ParticleEmissionType;
        (function (ParticleEmissionType) {
            ParticleEmissionType[ParticleEmissionType["burst"] = 0] = "burst";
            ParticleEmissionType[ParticleEmissionType["continue"] = 1] = "continue";
        })(ParticleEmissionType = framework.ParticleEmissionType || (framework.ParticleEmissionType = {}));
        class EmissionData {
            constructor() {
                this.type = ParticleEmissionType.burst;
            }
        }
        framework.EmissionData = EmissionData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class Emission {
            constructor() {
                this.simulateInLocalSpace = true;
                this.renderModel = framework.RenderModel.Mesh;
                this.particleStartData = new gd3d.framework.ParticleStartData();
            }
            getVboData(vf) {
                if (this.dataForVbo == undefined) {
                    this.dataForVbo = this.mesh.data.genVertexDataArray(vf);
                }
                return this.dataForVbo;
            }
            clone() {
                let emission = new Emission();
                if (this.emissionType != undefined)
                    emission.emissionType = this.emissionType;
                emission.simulateInLocalSpace = this.simulateInLocalSpace;
                if (this.rootpos != undefined) {
                    emission.rootpos = gd3d.math.pool.clone_vector3(this.rootpos);
                }
                if (this.rootRotAngle != undefined) {
                    emission.rootRotAngle = gd3d.math.pool.clone_vector3(this.rootRotAngle);
                }
                if (this.rootScale != undefined) {
                    emission.rootScale = gd3d.math.pool.clone_vector3(this.rootScale);
                }
                if (this.maxEmissionCount != undefined)
                    emission.maxEmissionCount = this.maxEmissionCount;
                if (this.emissionCount != undefined)
                    emission.emissionCount = this.emissionCount;
                if (this.time != undefined)
                    emission.time = this.time;
                if (this.simulationSpeed != undefined) {
                    emission.simulationSpeed = this.simulationSpeed.clone();
                }
                if (this.moveSpeed != undefined)
                    emission.moveSpeed = this.moveSpeed.clone();
                if (this.gravity != undefined)
                    emission.gravity = this.gravity;
                if (this.euler != undefined)
                    emission.euler = this.euler.clone();
                if (this.eulerNodes != undefined)
                    emission.eulerNodes = this.cloneParticleNodeArray(this.eulerNodes);
                if (this.eulerSpeed != undefined)
                    emission.eulerSpeed = this.eulerSpeed.clone();
                if (this.scale != undefined)
                    emission.scale = this.scale.clone();
                if (this.scaleNodes != undefined)
                    emission.scaleNodes = this.cloneParticleNodeNumberArray(this.scaleNodes);
                if (this.scaleSpeed != undefined)
                    emission.scaleSpeed = this.scaleSpeed.clone();
                if (this.color != undefined)
                    emission.color = this.color.clone();
                if (this.colorRate != undefined)
                    emission.colorRate = this.colorRate;
                if (this.colorNodes != undefined)
                    emission.colorNodes = this.cloneParticleNodeArray(this.colorNodes);
                if (this.colorSpeed != undefined)
                    emission.colorSpeed = this.colorSpeed.clone();
                if (this.simulationSpeed != undefined)
                    emission.simulationSpeed = this.simulationSpeed.clone();
                if (this.alpha != undefined)
                    emission.alpha = this.alpha.clone();
                if (this.alphaNodes != undefined)
                    emission.alphaNodes = this.cloneParticleNodeNumberArray(this.alphaNodes);
                if (this.alphaSpeed != undefined)
                    emission.alphaSpeed = this.alphaSpeed.clone();
                if (this.uv != undefined)
                    emission.uv = this.uv.clone();
                if (this.uvType != undefined)
                    emission.uvType = this.uvType;
                if (this.uvRoll != undefined)
                    emission.uvRoll = this.uvRoll.clone();
                if (this.uvSprite != undefined)
                    emission.uvSprite = this.uvSprite.clone();
                if (this.mat != undefined)
                    emission.mat = this.mat.clone();
                if (this.life != undefined)
                    emission.life = this.life.clone();
                if (this.renderModel != undefined)
                    emission.renderModel = this.renderModel;
                if (this.mesh != undefined)
                    emission.mesh = this.mesh;
                if (this.dataForVbo != undefined)
                    emission.dataForVbo = this.dataForVbo;
                if (this.particleStartData != undefined)
                    emission.particleStartData = this.particleStartData.clone();
                return emission;
            }
            getworldRotation() {
            }
            cloneParticleNodeArray(_array) {
                let array = new Array();
                for (let i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            }
            cloneParticleNodeNumberArray(_array) {
                let array = new Array();
                for (let i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            }
        }
        framework.Emission = Emission;
        class UVSprite {
            clone() {
                let sprite = new UVSprite();
                sprite.row = this.row;
                sprite.column = this.column;
                sprite.totalCount = this.totalCount;
                return sprite;
            }
        }
        framework.UVSprite = UVSprite;
        class UVRoll {
            clone() {
                let roll = new UVRoll();
                if (this.uvSpeed != undefined)
                    roll.uvSpeed = this.uvSpeed;
                if (this.uvSpeedNodes != undefined) {
                    let array = new Array();
                    for (let i in this.uvSpeedNodes) {
                        array.push(this.uvSpeedNodes[i].clone());
                    }
                    roll.uvSpeedNodes = array;
                }
                return roll;
            }
        }
        framework.UVRoll = UVRoll;
        let UVTypeEnum;
        (function (UVTypeEnum) {
            UVTypeEnum[UVTypeEnum["NONE"] = 0] = "NONE";
            UVTypeEnum[UVTypeEnum["UVRoll"] = 1] = "UVRoll";
            UVTypeEnum[UVTypeEnum["UVSprite"] = 2] = "UVSprite";
        })(UVTypeEnum = framework.UVTypeEnum || (framework.UVTypeEnum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class ParticleNode {
            constructor() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
                this.z = new framework.ValueData();
            }
            getValue() {
                return new gd3d.math.vector3(this.x.getValue(), this.y.getValue(), this.z.getValue());
            }
            getValueRandom() {
                return new gd3d.math.vector3(this.x.getValueRandom(), this.y.getValueRandom(), this.z.getValueRandom());
            }
            clone() {
                let node = new ParticleNode();
                if (this.x != undefined)
                    node.x = this.x.clone();
                if (this.y != undefined)
                    node.y = this.y.clone();
                if (this.z != undefined)
                    node.z = this.z.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            }
        }
        framework.ParticleNode = ParticleNode;
        class AlphaNode {
            constructor() {
                this.alpha = new framework.ValueData();
            }
            getValue() {
                return this.alpha.getValue();
            }
        }
        framework.AlphaNode = AlphaNode;
        class UVSpeedNode {
            constructor() {
                this.u = new framework.ValueData();
                this.v = new framework.ValueData();
            }
            getValue() {
                return new gd3d.math.vector2(this.u.getValue(), this.v.getValue());
            }
            getValueRandom() {
                return new gd3d.math.vector2(this.u.getValueRandom(), this.v.getValueRandom());
            }
            clone() {
                let node = new UVSpeedNode();
                node.u = this.u.clone();
                node.v = this.v.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            }
        }
        framework.UVSpeedNode = UVSpeedNode;
        class ParticleNodeVec2 {
            constructor() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
            }
            getValue() {
                return new gd3d.math.vector2(this.x.getValue(), this.y.getValue());
            }
            getValueRandom() {
                return new gd3d.math.vector2(this.x.getValueRandom(), this.y.getValueRandom());
            }
            clone() {
                let vec = new ParticleNodeVec2();
                vec.x = this.x.clone();
                vec.y = this.y.clone();
                if (this.key != undefined)
                    vec.key = this.key;
                return vec;
            }
        }
        framework.ParticleNodeVec2 = ParticleNodeVec2;
        class ParticleNodeNumber {
            constructor() {
                this.num = new framework.ValueData();
            }
            getValue() {
                return this.num.getValue();
            }
            getValueRandom() {
                return this.num.getValueRandom();
            }
            clone() {
                let num = new ParticleNodeNumber();
                num.num = this.num.clone();
                if (this.key != undefined) {
                    num.key = this.key;
                }
                return num;
            }
        }
        framework.ParticleNodeNumber = ParticleNodeNumber;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let ParticleSystemShape;
        (function (ParticleSystemShape) {
            ParticleSystemShape[ParticleSystemShape["NORMAL"] = 0] = "NORMAL";
            ParticleSystemShape[ParticleSystemShape["BOX"] = 1] = "BOX";
            ParticleSystemShape[ParticleSystemShape["SPHERE"] = 2] = "SPHERE";
            ParticleSystemShape[ParticleSystemShape["HEMISPHERE"] = 3] = "HEMISPHERE";
            ParticleSystemShape[ParticleSystemShape["CONE"] = 4] = "CONE";
            ParticleSystemShape[ParticleSystemShape["EDGE"] = 5] = "EDGE";
            ParticleSystemShape[ParticleSystemShape["CIRCLE"] = 6] = "CIRCLE";
        })(ParticleSystemShape = framework.ParticleSystemShape || (framework.ParticleSystemShape = {}));
        class ParticleStartData {
            constructor() {
                this.shapeType = ParticleSystemShape.NORMAL;
                this._position = new gd3d.math.vector3(0, 0, 0);
                this._direction = new gd3d.math.vector3(0, 1, 0);
                this._width = 0;
                this._height = 0;
                this.depth = 0;
                this._radius = 0;
                this._angle = 0;
                this.emitFrom = emitfromenum.base;
            }
            set position(_pos) {
                gd3d.math.vec3Clone(_pos, this._position);
            }
            get position() {
                return this._position;
            }
            set direction(_dir) {
                gd3d.math.vec3Clone(_dir, this._direction);
            }
            get direction() {
                return this._direction;
            }
            set width(_w) {
                this._width = _w;
            }
            get width() {
                return this._width;
            }
            set height(_h) {
                this._height = _h;
            }
            get height() {
                return this._height;
            }
            set radius(_r) {
                this._radius = _r;
            }
            get radius() {
                return this._radius;
            }
            set angle(_a) {
                this._angle = _a;
            }
            get angle() {
                return this._angle;
            }
            get randomDirection() {
                switch (this.shapeType) {
                    case ParticleSystemShape.BOX:
                        return this.boxDirection;
                    case ParticleSystemShape.SPHERE:
                        return this.sphereDirection;
                    case ParticleSystemShape.HEMISPHERE:
                        return this.hemisphereDirection;
                    case ParticleSystemShape.CONE:
                        return this.coneDirection;
                    case ParticleSystemShape.CIRCLE:
                        return this.circleDirection;
                    case ParticleSystemShape.EDGE:
                        return this.edgeDirection;
                    default:
                        return this.direction;
                }
            }
            get boxDirection() {
                this.position.x = framework.ValueData.RandomRange(-this.width / 2, this.width / 2);
                this.position.y = framework.ValueData.RandomRange(-this.height / 2, this.height / 2);
                this.position.z = framework.ValueData.RandomRange(-this.depth / 2, this.depth / 2);
                gd3d.math.vec3Normalize(this.position, this.direction);
                return this.direction;
            }
            get sphereDirection() {
                let θ = Math.random() * Math.PI * 2;
                let φ = Math.random() * Math.PI;
                let radius = Math.random() * this.radius;
                this.direction.x = Math.sin(φ) * Math.cos(θ);
                this.direction.y = Math.cos(φ);
                this.direction.z = Math.sin(φ) * Math.sin(θ);
                gd3d.math.vec3ScaleByNum(this.direction, radius, this.position);
                return this.direction;
            }
            get hemisphereDirection() {
                let θ = Math.random() * Math.PI * 2;
                let φ = Math.random() * Math.PI * 0.5;
                let radius = Math.random() * this.radius;
                this.direction.x = Math.sin(φ) * Math.cos(θ);
                this.direction.y = Math.cos(φ);
                this.direction.z = Math.sin(φ) * Math.sin(θ);
                gd3d.math.vec3ScaleByNum(this.direction, radius, this.position);
                return this.direction;
            }
            get coneDirection() {
                var randomAngle = Math.random() * Math.PI * 2;
                var randomHeight = Math.random() * this.height;
                var upradius = randomHeight * Math.tan(this.angle * Math.PI / 180) + this.radius;
                var radomRadius = Math.random() * upradius;
                var bottompos = gd3d.math.pool.new_vector3();
                bottompos.x = this.radius * Math.cos(randomAngle);
                bottompos.y = 0;
                bottompos.z = this.radius * Math.sin(randomAngle);
                if (this.emitFrom == emitfromenum.base) {
                    gd3d.math.vec3Clone(bottompos, this.position);
                }
                else if (this.emitFrom == emitfromenum.volume) {
                    this.position.x = radomRadius * Math.cos(randomAngle);
                    this.position.z = radomRadius * Math.sin(randomAngle);
                    this.position.y = randomHeight;
                }
                this.direction.x = Math.cos(randomAngle) * Math.sin(this.angle * Math.PI / 180);
                this.direction.z = Math.sin(randomAngle) * Math.sin(this.angle * Math.PI / 180);
                this.direction.y = Math.cos(this.angle * Math.PI / 180);
                return this.direction;
            }
            get circleDirection() {
                let _arc = this.angle * (Math.PI / 180);
                let a = framework.ValueData.RandomRange(-_arc / 2, _arc / 2);
                let _radius = framework.ValueData.RandomRange(0, this.radius);
                this.direction.x = _radius * Math.cos(a);
                this.direction.z = _radius * Math.sin(a);
                this.direction.y = 0;
                let length = gd3d.math.vec3Length(this.direction);
                gd3d.math.vec3Normalize(this.direction, this.direction);
                framework.EffectUtil.RotateVector3(this.direction, this.direction, this.direction);
                this.getposition(this.direction, length);
                return this.direction;
            }
            get edgeDirection() {
                let edgePos = new gd3d.math.vector3(0, 0, 0);
                edgePos.y += framework.ValueData.RandomRange(-this.radius / 2, this.radius / 2);
                let lenght = gd3d.math.vec3Length(edgePos);
                framework.EffectUtil.RotateVector3(edgePos, this.direction, edgePos);
                gd3d.math.vec3Clone(this.direction, this.direction);
                this.getposition(edgePos, length);
                return this.direction;
            }
            getposition(dir, length) {
                gd3d.math.vec3ScaleByNum(dir, length, dir);
                this.position.x = dir.x;
                this.position.y = dir.y;
                this.position.z = dir.z;
            }
            clone() {
                let data = new ParticleStartData();
                data.shapeType = this.shapeType;
                data._position = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._position, data._position);
                data._direction = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this._direction, data._direction);
                data._width = this._width;
                data._height = this._height;
                data.depth = this.depth;
                data._radius = this._radius;
                data._angle = this._angle;
                data.position = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.position, data.position);
                data.direction = new gd3d.math.vector3();
                gd3d.math.vec3Clone(this.direction, data.direction);
                return data;
            }
        }
        framework.ParticleStartData = ParticleStartData;
        let emitfromenum;
        (function (emitfromenum) {
            emitfromenum[emitfromenum["base"] = 0] = "base";
            emitfromenum[emitfromenum["volume"] = 1] = "volume";
        })(emitfromenum = framework.emitfromenum || (framework.emitfromenum = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class ValueData {
            constructor() {
                this.isRandom = true;
                this._value = 0;
                this._valueLimitMin = 0;
                this._valueLimitMax = 0;
                this.beInited = false;
            }
            set value(_v) {
                this._value = _v;
                this.isRandom = false;
            }
            set valueLimitMin(_v) {
                this._valueLimitMin = _v;
                this.isRandom = true;
            }
            set valueLimitMax(_v) {
                this._valueLimitMax = _v;
                this.isRandom = true;
            }
            clone() {
                let valu = new ValueData();
                valu.isRandom = this.isRandom;
                valu._value = this._value;
                valu._valueLimitMin = this._valueLimitMin;
                valu._valueLimitMax = this._valueLimitMax;
                return valu;
            }
            getValue() {
                if (this.isRandom) {
                    if (!this.beInited) {
                        this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                        this.beInited = true;
                    }
                }
                return this._value;
            }
            getValueRandom() {
                if (this.isRandom) {
                    this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                }
                return this._value;
            }
            static RandomRange(min, max, isInteger = false) {
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            }
        }
        framework.ValueData = ValueData;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let Vector3AttributeData = class Vector3AttributeData {
            constructor() {
                this.init();
            }
            init() {
                this.data = {};
                this.frameIndexs = [];
                let keyPoint = new FrameKeyPointData(0, new gd3d.math.vector3());
                this.addFramePoint(keyPoint);
            }
            addFramePoint(data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            }
            removeFramePoint(frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            }
            updateFramePoint(data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            }
        };
        Vector3AttributeData = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [])
        ], Vector3AttributeData);
        framework.Vector3AttributeData = Vector3AttributeData;
        let Vector2AttributeData = class Vector2AttributeData {
            constructor() {
                this.init();
            }
            init() {
                this.data = {};
                this.frameIndexs = [];
                let keyPoint = new FrameKeyPointData(0, new gd3d.math.vector2());
                this.addFramePoint(keyPoint);
            }
            addFramePoint(data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            }
            removeFramePoint(frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            }
            updateFramePoint(data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            }
        };
        Vector2AttributeData = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [])
        ], Vector2AttributeData);
        framework.Vector2AttributeData = Vector2AttributeData;
        let NumberAttributeData = class NumberAttributeData {
            constructor() {
                this.init();
            }
            init() {
                this.data = {};
                this.frameIndexs = [];
                let keyPoint = new FrameKeyPointData(0, 0);
                this.addFramePoint(keyPoint, null);
            }
            addFramePoint(data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            }
            removeFramePoint(frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            }
            updateFramePoint(data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            }
        };
        NumberAttributeData = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [])
        ], NumberAttributeData);
        framework.NumberAttributeData = NumberAttributeData;
        let AttributeUIState;
        (function (AttributeUIState) {
            AttributeUIState[AttributeUIState["None"] = 0] = "None";
            AttributeUIState[AttributeUIState["Show"] = 1] = "Show";
            AttributeUIState[AttributeUIState["Hide"] = 2] = "Hide";
        })(AttributeUIState = framework.AttributeUIState || (framework.AttributeUIState = {}));
        let AttributeUIType;
        (function (AttributeUIType) {
            AttributeUIType[AttributeUIType["Number"] = 0] = "Number";
            AttributeUIType[AttributeUIType["Vector2"] = 1] = "Vector2";
            AttributeUIType[AttributeUIType["Vector3"] = 2] = "Vector3";
            AttributeUIType[AttributeUIType["Vector4"] = 3] = "Vector4";
        })(AttributeUIType = framework.AttributeUIType || (framework.AttributeUIType = {}));
        let AttributeValType;
        (function (AttributeValType) {
            AttributeValType[AttributeValType["FixedValType"] = 0] = "FixedValType";
            AttributeValType[AttributeValType["LerpType"] = 1] = "LerpType";
        })(AttributeValType = framework.AttributeValType || (framework.AttributeValType = {}));
        class FrameKeyPointData {
            constructor(frameIndex, val) {
                this.frameIndex = frameIndex;
                this.val = val;
            }
        }
        framework.FrameKeyPointData = FrameKeyPointData;
        class AttributeUtil {
            static addFrameIndex(datas, index) {
                for (let i = 0; i < datas.length - 1; i++) {
                    if (index > datas[i] && index <= datas[i + 1]) {
                        datas.splice(i, 0, index);
                        return;
                    }
                }
                datas.push(index);
            }
        }
        framework.AttributeUtil = AttributeUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let AttributeType;
        (function (AttributeType) {
            AttributeType[AttributeType["PositionType"] = 1] = "PositionType";
            AttributeType[AttributeType["EulerType"] = 2] = "EulerType";
            AttributeType[AttributeType["ScaleType"] = 3] = "ScaleType";
            AttributeType[AttributeType["ColorType"] = 4] = "ColorType";
            AttributeType[AttributeType["ColorRateType"] = 5] = "ColorRateType";
            AttributeType[AttributeType["AlphaType"] = 6] = "AlphaType";
            AttributeType[AttributeType["TillingType"] = 7] = "TillingType";
        })(AttributeType = framework.AttributeType || (framework.AttributeType = {}));
        let EffectElementSingleMesh = class EffectElementSingleMesh {
            constructor(sys, data = null) {
                this.elementType = gd3d.framework.EffectElementTypeEnum.SingleMeshType;
                this.beloop = false;
                this.delayTime = 0;
                this.life = 5;
                this.colorRate = 1;
                this.renderModel = gd3d.framework.RenderModel.Mesh;
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
                this.position = [];
                this.euler = [];
                this.scale = [];
                this.color = [];
                this.alpha = [];
                this.loopFrame = Number.MAX_VALUE;
                this.active = true;
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localRotation = new gd3d.math.quaternion();
                this.effectSys = sys;
                if (data != null) {
                    this.initByElementdata(data);
                }
                else {
                    this.initByDefData();
                }
            }
            initByElementdata(data) {
            }
            initByDefData() {
                this.mesh = this.mgr.getDefaultMesh("quad");
                var shader = this.mgr.getShader("diffuse.shader.json");
                this.mat.setShader(shader);
            }
            writeToJson(obj) {
            }
            update() {
                if (this.active) {
                    if (this.curAttrData.euler != undefined) {
                        gd3d.math.quatFromEulerAngles(this.curAttrData.euler.x, this.curAttrData.euler.y, this.curAttrData.euler.z, this.curAttrData.rotationByEuler);
                    }
                    this.updateElementRotation();
                    gd3d.math.matrixMakeTransformRTS(this.curAttrData.pos, this.curAttrData.scale, this.curAttrData.localRotation, this.curAttrData.matrix);
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            }
            updateElementRotation() {
                let cameraTransform = gd3d.framework.sceneMgr.app.getScene().mainCamera.gameObject.transform;
                let worldRotation = gd3d.math.pool.new_quaternion();
                let localRotation = gd3d.math.pool.new_quaternion();
                if (this.curAttrData.renderModel != framework.RenderModel.None) {
                    let invTransformRotation = gd3d.math.pool.new_quaternion();
                    let worldTranslation = gd3d.math.pool.new_vector3();
                    let translation = gd3d.math.pool.new_vector3();
                    gd3d.math.vec3Clone(this.curAttrData.pos, translation);
                    if (this.transform != undefined) {
                        gd3d.math.matrixTransformVector3(translation, this.transform.getWorldMatrix(), worldTranslation);
                    }
                    if (this.curAttrData.renderModel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.VerticalBillBoard) {
                        let forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(cameraTransform.getWorldTranslate(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                        gd3d.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                        let lookRot = new gd3d.math.quaternion();
                        gd3d.math.quatClone(this.transform.getWorldRotate(), invTransformRotation);
                        gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                        gd3d.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        let inverRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatInverse(this.curAttrData.localRotation, inverRot);
                        gd3d.math.quatMultiply(inverRot, lookRot, lookRot);
                        let angle = gd3d.math.pool.new_vector3();
                        gd3d.math.quatToEulerAngles(lookRot, angle);
                        gd3d.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        gd3d.math.quatMultiply(this.curAttrData.localRotation, lookRot, this.curAttrData.localRotation);
                        gd3d.math.pool.delete_quaternion(inverRot);
                        gd3d.math.pool.delete_vector3(angle);
                        gd3d.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, worldRotation);
                    gd3d.math.quatClone(this.transform.gameObject.transform.getWorldRotate(), invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.curAttrData.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    gd3d.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                }
                gd3d.math.pool.delete_quaternion(localRotation);
                gd3d.math.pool.delete_quaternion(worldRotation);
            }
            dispose() {
            }
        };
        EffectElementSingleMesh = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [framework.TestEffectSystem, framework.EffectElementData])
        ], EffectElementSingleMesh);
        framework.EffectElementSingleMesh = EffectElementSingleMesh;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let EffectElementEmission = class EffectElementEmission {
            constructor(sys, data = null) {
                this.active = true;
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.maxVertexCount = 2048;
                this.rotTranslate = new gd3d.math.vector3();
                this.rotScale = new gd3d.math.vector3(1, 1, 1);
                this.rotRotation = new gd3d.math.vector3();
                this.rotQuta = new gd3d.math.quaternion();
                this.elementType = framework.EffectElementTypeEnum.EmissionType;
                this.delayTime = 0;
                this.beloop = true;
                this.lifeTime = new framework.NumberData(5);
                this.simulateInLocalSpace = true;
                this.startScale = new framework.Vector3Data(1, 1, 1);
                this.startEuler = new framework.Vector3Data();
                this.startColor = new gd3d.math.color(1, 1, 1, 1);
                this.colorRate = 1;
                this.duration = new framework.NumberData();
                this.emissionCount = new framework.NumberData();
                this.emissionType = framework.ParticleEmissionType.burst;
                this.shapeType = framework.ParticleSystemShape.NORMAL;
                this.simulationSpeed = new framework.NumberData();
                this.emitFrom = framework.emitfromenum.base;
                this.rendermodel = framework.RenderModel.BillBoard;
                this.enableVelocityOverLifetime = false;
                this.enableSizeOverLifetime = false;
                this.enableRotOverLifeTime = false;
                this.enableColorOverLifetime = false;
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
                this.beBurst = false;
                this.beover = false;
                this.worldRotation = new gd3d.math.quaternion();
                this.matToObj = new gd3d.math.matrix();
                this.matToWorld = new gd3d.math.matrix();
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.effectSys = sys;
                this.gameObject = sys.gameObject;
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.vf) / 4;
                if (data == null) {
                    this.initDefparticleData();
                }
                else {
                    this.initByEmissonData(data);
                }
                this.perVertexCount = this.mesh.data.pos.length;
                this.perIndexxCount = this.mesh.data.trisindex.length;
                if (this.emissionType == framework.ParticleEmissionType.continue) {
                    this._continueSpaceTime = this.duration.getValue() / this.emissionCount.getValue();
                }
                this.getmatrixToObj();
                this.emissionBatchers = [];
                this.deadParticles = [];
                this.curTime = 0;
                this.numcount = 0;
                this.addBatcher();
            }
            initDefparticleData() {
                this.duration.setValue(2.0);
                this.emissionCount.setValue(10);
                this.shapeType = framework.ParticleSystemShape.CONE;
                this.simulationSpeed.setValue(0.1);
                this.radius = 1.0;
                this.angle = 45;
                this.height = 1.0;
                this.mat = framework.sceneMgr.app.getAssetMgr().getDefParticleMat();
                this.mesh = framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
            }
            initByEmissonData(data) {
            }
            getWorldRotation() {
                var parRot = this.gameObject.transform.getWorldRotate();
                gd3d.math.quatMultiply(parRot, this.rotQuta, this.worldRotation);
                return this.worldRotation;
            }
            getmatrixToObj() {
                gd3d.math.quatFromEulerAngles(this.rotRotation.x, this.rotRotation.y, this.rotRotation.z, this.rotQuta);
                gd3d.math.matrixMakeTransformRTS(this.rotTranslate, this.rotScale, this.rotQuta, this.matToObj);
            }
            getmatrixToWorld() {
                var mat = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixMultiply(mat, this.matToObj, this.matToWorld);
                return this.matToWorld;
            }
            update(delta) {
                this.updateLife(delta);
                this.updateBatcher(delta);
            }
            updateBatcher(delta) {
                for (let key in this.emissionBatchers) {
                    this.emissionBatchers[key].update(delta);
                }
            }
            updateLife(delta) {
                if (this.beover)
                    return;
                this.curTime += delta;
                this.updateEmission();
                if (this.curTime > this.lifeTime.getValue()) {
                    if (this.beloop) {
                        this.reInit();
                    }
                    else {
                        this.beover = true;
                    }
                }
            }
            reInit() {
                this.beover = false;
                this.curTime = 0;
                this.beBurst = false;
            }
            updateEmission() {
                if (this.emissionType == framework.ParticleEmissionType.continue) {
                    var rate = this.curTime / this.duration.getValue();
                    rate = gd3d.math.floatClamp(rate, 0, 1);
                    var needCount = Math.floor(rate * this.emissionCount.getValue());
                    needCount = needCount - this.numcount;
                    for (var i = 0; i < needCount; i++) {
                        this.addParticle();
                        this.numcount++;
                    }
                }
                else if (this.emissionType == framework.ParticleEmissionType.burst && !this.beBurst) {
                    this.addParticle(this.emissionCount.getValue());
                    this.beBurst = true;
                }
            }
            addParticle(count = 1) {
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var particle = this.deadParticles.pop();
                        particle.initByData();
                        particle.actived = true;
                    }
                    else {
                        var total = this.curbatcher.curVerCount + this.perVertexCount;
                        if (total <= this.maxVertexCount) {
                            this.curbatcher.addParticle();
                        }
                        else {
                            this.addBatcher();
                            this.curbatcher.addParticle();
                        }
                    }
                }
            }
            addBatcher() {
                var batcher = new framework.EmissionBatcher_new(this);
                this.emissionBatchers.push(batcher);
                this.curbatcher = batcher;
            }
            get renderCamera() {
                if (this._renderCamera != null) {
                    return this._renderCamera;
                }
                else {
                    return gd3d.framework.sceneMgr.app.getScene().mainCamera;
                }
            }
            render(context, assetmgr, camera) {
                this._renderCamera = camera;
                if (this.simulateInLocalSpace) {
                    context.updateModel(this.gameObject.transform);
                }
                else {
                    context.updateModeTrail();
                }
                for (let key in this.emissionBatchers) {
                    this.emissionBatchers[key].render(context, assetmgr, camera);
                }
            }
            dispose() {
                for (let key in this.emissionBatchers) {
                    this.emissionBatchers[key].dispose();
                }
                this.emissionBatchers.length = 0;
            }
            getMesh() {
                if (this.rendermodel == framework.RenderModel.Mesh) {
                    return this.mesh;
                }
                else if (this.rendermodel == framework.RenderModel.StretchedBillBoard) {
                    this.mesh = gd3d.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad_particle");
                }
                else {
                    this.mesh = gd3d.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
                }
            }
            cloneMeshVBO() {
                if (this.vbo == null) {
                    this.vbo = this.mesh.data.genVertexDataArray(this.vf);
                }
                return new Float32Array(this.vbo);
            }
            cloneMeshEBO() {
                if (this.ebo == null) {
                    this.ebo = this.mesh.data.genIndexDataArray();
                }
                return new Uint16Array(this.ebo);
            }
            writeToJson(obj) {
                throw new Error("Method not implemented.");
            }
        };
        EffectElementEmission = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [framework.TestEffectSystem, framework.EffectElementData])
        ], EffectElementEmission);
        framework.EffectElementEmission = EffectElementEmission;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class EmissionBatcher_new {
            constructor(emissionElement) {
                this.particles = [];
                this.curVerCount = 0;
                this.curIndexCount = 0;
                this.emission = emissionElement;
                this.webgl = emissionElement.webgl;
                this.mat = this.emission.mat;
                this.initMesh();
            }
            initMesh() {
                this.mesh = new framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = 0;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                this.mesh.glMesh.initBuffer(this.webgl, this.emission.vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
            }
            addParticle() {
                this.refreshBuffer();
                let p = new framework.Particle_new(this);
                for (let i = 0; i < p.dataForEbo.length; i++) {
                    this.dataForEbo[this.curIndexCount + i] = p.dataForEbo[i] + this.curVerCount;
                }
                this.particles.push(p);
                this.curVerCount += this.emission.perVertexCount;
                this.curIndexCount += this.emission.perIndexxCount;
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
            }
            refreshBuffer() {
                var needvercount = this.curVerCount + this.emission.perVertexCount;
                var needIndexCount = this.curIndexCount + this.emission.perIndexxCount;
                if (needvercount * this.emission.vertexSize > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    let vbo = new Float32Array(length * 2);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                if (needIndexCount > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    let ebo = new Uint16Array(length * 2);
                    ebo.set(this.dataForEbo, 0);
                    this.dataForEbo = ebo;
                }
            }
            update(delta) {
                for (let key in this.particles) {
                    this.particles[key].update(delta);
                    this.particles[key].uploadData(this.dataForVbo);
                }
            }
            render(context, assetmgr, camera) {
                let mesh = this.mesh;
                mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (assetmgr.app.getScene().fog) {
                    context.fog = assetmgr.app.getScene().fog;
                    this.mat.draw(context, mesh, mesh.submesh[0], "base_fog");
                }
                else {
                    this.mat.draw(context, mesh, mesh.submesh[0], "base");
                }
            }
            dispose() {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.mesh.dispose();
                this.mat.dispose();
                for (let key in this.particles) {
                    this.particles[key].dispose();
                }
            }
        }
        framework.EmissionBatcher_new = EmissionBatcher_new;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class effTools {
            static getRandomDirAndPosByZEmission(emission, outDir, outPos) {
                switch (emission.shapeType) {
                    case framework.ParticleSystemShape.NORMAL:
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_zero, outPos);
                        gd3d.math.vec3Clone(gd3d.math.pool.vector3_up, outDir);
                        break;
                    case framework.ParticleSystemShape.SPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        var radius = Math.random() * emission.radius;
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.HEMISPHERE:
                        var θ = Math.random() * Math.PI * 2;
                        var φ = Math.random() * Math.PI * 0.5;
                        var radius = Math.random() * emission.radius;
                        outDir.x = Math.sin(φ) * Math.cos(θ);
                        outDir.y = Math.cos(φ);
                        outDir.z = Math.sin(φ) * Math.sin(θ);
                        gd3d.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.BOX:
                        outPos.x = framework.ValueData.RandomRange(-emission.width / 2, emission.width / 2);
                        outPos.y = framework.ValueData.RandomRange(-emission.height / 2, emission.height / 2);
                        outPos.z = framework.ValueData.RandomRange(-emission.depth / 2, emission.depth / 2);
                        gd3d.math.vec3Normalize(outPos, outDir);
                        break;
                    case framework.ParticleSystemShape.CONE:
                        var randomAngle = Math.random() * Math.PI * 2;
                        var randomHeight = Math.random() * emission.height;
                        var upradius = randomHeight * Math.tan(emission.angle * Math.PI / 180) + emission.radius;
                        var radomRadius = Math.random() * upradius;
                        var bottompos = gd3d.math.pool.new_vector3();
                        bottompos.x = emission.radius * Math.cos(randomAngle);
                        bottompos.y = 0;
                        bottompos.z = emission.radius * Math.sin(randomAngle);
                        if (emission.emitFrom == framework.emitfromenum.base) {
                            gd3d.math.vec3Clone(bottompos, outPos);
                        }
                        else if (emission.emitFrom == framework.emitfromenum.volume) {
                            outPos.x = radomRadius * Math.cos(randomAngle);
                            outPos.z = radomRadius * Math.sin(randomAngle);
                            outPos.y = randomHeight;
                        }
                        outDir.x = Math.cos(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.z = Math.sin(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.y = Math.cos(emission.angle * Math.PI / 180);
                        break;
                }
            }
            static getTex_ST(emission, out_St) {
                if (emission.uvType != framework.UVTypeEnum.UVSprite) {
                    out_St.x = 1;
                    out_St.y = 1;
                    out_St.z = 0;
                    out_St.w = 0;
                }
                else {
                    gd3d.math.spriteAnimation(emission.row, emission.column, 0, out_St);
                }
            }
        }
        framework.effTools = effTools;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class Particle_new {
            constructor(batcher) {
                this.startScale = new gd3d.math.vector3();
                this.startRotation = new gd3d.math.quaternion();
                this.rotationByShape = new gd3d.math.quaternion();
                this.rotAngle = 0;
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localMatrix = new gd3d.math.matrix();
                this.localTranslate = new gd3d.math.vector3();
                this.localRotation = new gd3d.math.quaternion();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.color = new gd3d.math.vector3(1, 1, 1);
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
                this.curLife = 0;
                this.life = 0;
                this.speedDir = new gd3d.math.vector3(0, 0, 0);
                this.actived = true;
                this.transformVertex = new gd3d.math.matrix();
                this.matToworld = new gd3d.math.matrix();
                this.batcher = batcher;
                this.emisson = batcher.emission;
                this.gameObject = this.emisson.gameObject;
                this.vertexStartIndex = batcher.curVerCount;
                this.dataForVbo = this.emisson.cloneMeshVBO();
                this.dataForEbo = this.emisson.cloneMeshEBO();
                this.sourceVbo = this.emisson.vbo;
                this.initByData();
            }
            uploadData(array) {
                array.set(this.dataForVbo, this.vertexStartIndex * this.emisson.vertexSize);
            }
            initByData() {
                this.totalLife = this.emisson.lifeTime.getValue();
                framework.effTools.getRandomDirAndPosByZEmission(this.emisson, this.speedDir, this.localTranslate);
                this.simulationSpeed = this.emisson.simulationSpeed.getValue();
                this.Starteuler = this.emisson.startEuler.getValue();
                gd3d.math.quatFromEulerAngles(this.Starteuler.x, this.Starteuler.y, this.Starteuler.z, this.rotationByEuler);
                this.localScale = this.emisson.startScale.getValue();
                this.startColor = this.emisson.startColor;
                this.sizeNodes = this.emisson.sizeNodes;
                this.colorNodes = this.emisson.colorNodes;
                this.alphaNodes = this.emisson.alphaNodes;
                if (this.emisson.enableVelocityOverLifetime) {
                    this.movespeed = this.emisson.moveSpeed.getValue();
                }
                if (this.emisson.enableRotOverLifeTime) {
                    this.eulerSpeed = this.emisson.angleSpeed.getValue();
                }
                if (this.emisson.rendermodel == framework.RenderModel.StretchedBillBoard) {
                    let localOrgin = gd3d.math.pool.vector3_zero;
                    gd3d.math.quatLookat(localOrgin, this.speedDir, this.rotationByShape);
                    let initRot = gd3d.math.pool.new_quaternion();
                    gd3d.math.quatFromEulerAngles(90, 0, 90, initRot);
                    gd3d.math.quatMultiply(this.rotationByShape, initRot, this.rotationByShape);
                    gd3d.math.quatClone(this.rotationByShape, this.localRotation);
                    gd3d.math.pool.delete_quaternion(initRot);
                }
                if (!this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = new gd3d.math.matrix();
                    var mat = this.emisson.getmatrixToWorld();
                    gd3d.math.matrixClone(mat, this.emissionMatToWorld);
                    this.emissionWorldRotation = new gd3d.math.quaternion();
                    var quat = this.emisson.getWorldRotation();
                    gd3d.math.quatClone(quat, this.emissionWorldRotation);
                }
            }
            update(delta) {
                if (!this.actived)
                    return;
                this.curLife += delta;
                this.life = this.curLife / this.totalLife;
                gd3d.math.floatClamp(this.life, 0, 1);
                if (this.curLife >= this.totalLife) {
                    gd3d.math.matrixZero(this.transformVertex);
                    this._updateVBO();
                    this.emisson.deadParticles.push(this);
                    this.curLife = 0;
                    this.actived = false;
                    return;
                }
                this._updatePos(delta);
                this._updateScale(delta);
                this._updateEuler(delta);
                this._updateRotation(delta);
                this._updateLocalMatrix(delta);
                this._updateColor(delta);
                this._updateUV(delta);
                this._updateVBO();
            }
            _updateLocalMatrix(delta) {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.emisson.simulateInLocalSpace) {
                    gd3d.math.matrixMultiply(this.emisson.matToObj, this.localMatrix, this.transformVertex);
                }
                else {
                    gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            }
            refreshEmissionData() {
                if (this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = this.emisson.getmatrixToWorld();
                    this.emissionWorldRotation = this.emisson.getWorldRotation();
                }
            }
            _updateRotation(delta) {
                if (this.emisson.rendermodel == framework.RenderModel.Mesh) {
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_up, this.rotAngle, this.rotationByEuler);
                    gd3d.math.quatClone(this.rotationByEuler, this.localRotation);
                }
                else {
                    gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_forward, this.rotAngle, this.rotationByEuler);
                    this.refreshEmissionData();
                    let translation = gd3d.math.pool.new_vector3();
                    let worldTranslation = gd3d.math.pool.new_vector3();
                    let worldRotation = gd3d.math.pool.new_quaternion();
                    let invTransformRotation = gd3d.math.pool.new_quaternion();
                    gd3d.math.vec3Clone(this.localTranslate, translation);
                    var cam = this.emisson.renderCamera;
                    var camPosInWorld = cam.gameObject.transform.getWorldTranslate();
                    gd3d.math.matrixTransformVector3(translation, this.emissionMatToWorld, worldTranslation);
                    if (this.emisson.rendermodel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, camPosInWorld, worldRotation);
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.VerticalBillBoard) {
                        let forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(camPosInWorld, forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                        gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.matToworld);
                        var xaxis = gd3d.math.pool.new_vector3();
                        var yaxis = gd3d.math.pool.new_vector3();
                        var zaxis = gd3d.math.pool.new_vector3();
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_right, this.matToworld, xaxis);
                        gd3d.math.vec3Normalize(xaxis, xaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_up, this.matToworld, yaxis);
                        gd3d.math.vec3Normalize(yaxis, yaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_forward, this.matToworld, zaxis);
                        gd3d.math.vec3Normalize(zaxis, zaxis);
                        framework.EffectUtil.lookatbyXAxis(worldTranslation, xaxis, yaxis, zaxis, camPosInWorld, worldRotation);
                        gd3d.math.quatMultiply(this.localRotation, worldRotation, this.localRotation);
                        gd3d.math.pool.delete_quaternion(worldRotation);
                        gd3d.math.pool.delete_vector3(translation);
                        gd3d.math.pool.delete_quaternion(invTransformRotation);
                        gd3d.math.pool.delete_vector3(xaxis);
                        gd3d.math.pool.delete_vector3(yaxis);
                        gd3d.math.pool.delete_vector3(zaxis);
                        return;
                    }
                    gd3d.math.quatClone(this.emissionWorldRotation, invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.localRotation);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(worldRotation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
            }
            _updatePos(delta) {
                let currentTranslate = framework.EffectUtil.vecMuliNum(this.speedDir, this.simulationSpeed);
                gd3d.math.vec3Add(this.localTranslate, currentTranslate, this.localTranslate);
                if (this.emisson.enableVelocityOverLifetime) {
                    this.localTranslate.x += this.movespeed.x * delta;
                    this.localTranslate.y += this.movespeed.y * delta;
                    this.localTranslate.z += this.movespeed.z * delta;
                }
            }
            _updateEuler(delta) {
                if (this.emisson.enableRotOverLifeTime) {
                    this.rotAngle = this.eulerSpeed * this.curLife;
                }
            }
            _updateScale(delta) {
                if (this.emisson.enableSizeOverLifetime) {
                    for (var i = 0; i < this.sizeNodes.length - 1; i++) {
                        if (this.sizeNodes[i].key <= this.life && this.sizeNodes[i + 1].key >= this.life) {
                            var target = gd3d.math.numberLerp(this.sizeNodes[i].value, this.sizeNodes[i + 1].value, (this.life - this.sizeNodes[i].key) / (this.sizeNodes[i + 1].key - this.sizeNodes[i].key));
                            gd3d.math.vec3ScaleByNum(this.startScale, target, this.localScale);
                            break;
                        }
                    }
                }
            }
            _updateColor(delta) {
                if (this.emisson.enableColorOverLifetime) {
                    if (this.colorNodes != null) {
                        for (var i = 0; i < this.colorNodes.length - 1; i++) {
                            if (this.colorNodes[i].key <= this.life && this.colorNodes[i + 1].key >= this.life) {
                                gd3d.math.vec3SLerp(this.colorNodes[i].value, this.colorNodes[i + 1].value, (this.life - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key), this.color);
                                break;
                            }
                        }
                    }
                    if (this.alphaNodes != null) {
                        for (var i = 0; i < this.alphaNodes.length - 1; i++) {
                            if (this.alphaNodes[i].key <= this.life && this.alphaNodes[i + 1].key >= this.life) {
                                this.alpha = gd3d.math.numberLerp(this.alphaNodes[i].value, this.alphaNodes[i + 1].value, (this.life - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key));
                                break;
                            }
                        }
                    }
                }
            }
            _updateUV(delta) {
                if (this.emisson.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.z = this.emisson.uSpeed * this.curLife;
                    this.tex_ST.w = this.emisson.vSpeed * this.curLife;
                }
                else if (this.emisson.uvType == framework.UVTypeEnum.UVSprite) {
                    var spriteindex = Math.floor(this.life * this.emisson.count);
                    gd3d.math.spriteAnimation(this.emisson.row, this.emisson.column, spriteindex, this.tex_ST);
                }
            }
            _updateVBO() {
                let vertexSize = this.emisson.vertexSize;
                for (let i = 0; i < this.emisson.perVertexCount; i++) {
                    {
                        let vertex = gd3d.math.pool.new_vector3();
                        vertex.x = this.sourceVbo[i * vertexSize + 0];
                        vertex.y = this.sourceVbo[i * vertexSize + 1];
                        vertex.z = this.sourceVbo[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, this.transformVertex, vertex);
                        this.dataForVbo[i * vertexSize + 0] = vertex.x;
                        this.dataForVbo[i * vertexSize + 1] = vertex.y;
                        this.dataForVbo[i * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        let r = this.sourceVbo[i * vertexSize + 3] * this.startColor.r;
                        let g = this.sourceVbo[i * vertexSize + 4] * this.startColor.g;
                        let b = this.sourceVbo[i * vertexSize + 5] * this.startColor.b;
                        let a = this.sourceVbo[i * vertexSize + 6] * this.startColor.a;
                        if (this.colorNodes != null) {
                            r = this.color.x;
                            g = this.color.y;
                            b = this.color.z;
                        }
                        if (this.alphaNodes != null) {
                            a = this.alpha;
                        }
                        r *= this.emisson.colorRate;
                        g *= this.emisson.colorRate;
                        b *= this.emisson.colorRate;
                        a *= this.emisson.colorRate;
                        r = gd3d.math.floatClamp(r, 0, 3);
                        g = gd3d.math.floatClamp(g, 0, 3);
                        b = gd3d.math.floatClamp(b, 0, 3);
                        a = gd3d.math.floatClamp(a, 0, 3);
                        this.dataForVbo[i * this.emisson.vertexSize + 3] = r;
                        this.dataForVbo[i * this.emisson.vertexSize + 4] = g;
                        this.dataForVbo[i * this.emisson.vertexSize + 5] = b;
                        this.dataForVbo[i * this.emisson.vertexSize + 6] = a;
                    }
                    {
                        this.dataForVbo[i * vertexSize + 7] = this.sourceVbo[i * vertexSize + 7] * this.tex_ST.x + this.tex_ST.z;
                        this.dataForVbo[i * vertexSize + 8] = this.sourceVbo[i * vertexSize + 8] * this.tex_ST.y + this.tex_ST.w;
                    }
                }
            }
            dispose() {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.startRotation = null;
                this.localRotation = null;
                this.rotationByEuler = null;
                this.rotationByShape = null;
                this.tex_ST = null;
                this.localMatrix = null;
                this.localTranslate = null;
                this.Starteuler = null;
                this.localScale = null;
                this.color = null;
            }
        }
        framework.Particle_new = Particle_new;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class Curve3 {
            constructor(points, nbPoints) {
                this._beizerPoints = points;
                this._bezierPointNum = nbPoints;
            }
            get beizerPoints() {
                return this._beizerPoints;
            }
            set beizerPoints(value) {
                this._beizerPoints = value;
            }
            get bezierPointNum() {
                return this._bezierPointNum;
            }
            set bezierPointNum(value) {
                this._bezierPointNum = value;
            }
            static CreateLinearBezier(start, end, indices) {
                indices = indices > 2 ? indices : 3;
                let bez = new Array();
                let equation = (t, va10, va11) => {
                    let res = (1.0 - t) * va10 + t * va11;
                    return res;
                };
                bez.push(start);
                for (let i = 1; i <= indices; i++) {
                    bez.push(new gd3d.math.vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
                }
                return new Curve3(bez, indices);
            }
            static GetLerpBezier(nodes) {
                let beizerPoint = new Array();
                for (let n = 0; n < nodes.length; n++) {
                    beizerPoint.push(nodes[n].getValue());
                }
                return new Curve3(beizerPoint, nodes.length);
            }
            static CreateQuadraticBezier(v0, v1, v2, bezierPointNum) {
                bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
                let beizerPoint = new Array();
                var equation = (t, val0, val1, val2) => {
                    var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new gd3d.math.vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            }
            static CreateCubicBezier(v0, v1, v2, v3, bezierPointNum) {
                bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
                var beizerPoint = new Array();
                var equation = (t, val0, val1, val2, val3) => {
                    var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new gd3d.math.vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            }
            getPoints() {
                return this._beizerPoints;
            }
        }
        framework.Curve3 = Curve3;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class LinearAction {
            init(_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.attrival = framework.EffectUtil.parseEffectVec3(this.params["value"]);
                            break;
                        case "uv":
                            this.attrival = framework.EffectUtil.parseEffectUVSpeed(this.params["value"]);
                            break;
                        case "alpha":
                            this.attrival = this.params["value"];
                            break;
                    }
                }
            }
            update(frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                let baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos.x = baseValue.pos.x + this.attrival.x.getValue();
                        baseValue.pos.y = baseValue.pos.y + this.attrival.y.getValue();
                        baseValue.pos.z = baseValue.pos.z + this.attrival.z.getValue();
                        break;
                    case "scale":
                        baseValue.scale.x = baseValue.scale.x + this.attrival.x.getValue();
                        baseValue.scale.y = baseValue.scale.y + this.attrival.y.getValue();
                        baseValue.scale.z = baseValue.scale.z + this.attrival.z.getValue();
                        break;
                    case "euler":
                        baseValue.euler.x = baseValue.euler.x + this.attrival.x.getValue();
                        baseValue.euler.y = baseValue.euler.y + this.attrival.y.getValue();
                        baseValue.euler.z = baseValue.euler.z + this.attrival.z.getValue();
                        break;
                    case "color":
                        baseValue.color.x = baseValue.color.x + this.attrival.x.getValue();
                        baseValue.color.y = baseValue.color.y + this.attrival.y.getValue();
                        baseValue.color.z = baseValue.color.z + this.attrival.z.getValue();
                        break;
                    case "uv":
                        baseValue.uv.x = baseValue.uv.x + this.attrival.u.getValue();
                        baseValue.uv.y = baseValue.uv.y + this.attrival.v.getValue();
                        break;
                    case "alpha":
                        baseValue.alpha = baseValue.alpha + this.attrival;
                        break;
                }
            }
        }
        framework.LinearAction = LinearAction;
        class DestroyAction {
            init(_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            }
            update(frameIndex) {
                if (frameIndex >= this.startFrame) {
                    this.elements.setActive(false);
                }
            }
        }
        framework.DestroyAction = DestroyAction;
        class LoopAction {
            init(_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            }
            update(frameIndex) {
                if (frameIndex == this.startFrame) {
                    this.elements.loopFrame = this.startFrame + 1;
                    this.elements.curAttrData = this.elements.data.initFrameData.attrsData.copyandinit();
                }
            }
        }
        framework.LoopAction = LoopAction;
        class UVRollAction {
            constructor() {
                this.speedu = 0;
                this.speedv = 0;
                this.startu = 0;
                this.startv = 0;
            }
            init(_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["speedu"] != undefined) {
                    this.speedu = this.params["speedu"];
                }
                if (this.params["speedv"] != undefined) {
                    this.speedv = this.params["speedv"];
                }
                if (this.params["startu"] != undefined) {
                    this.startu = this.params["startu"];
                }
                if (this.params["startv"] != undefined) {
                    this.startv = this.params["startv"];
                }
            }
            update(frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                if (this.startFrame == frameIndex) {
                    this.elements.curAttrData.uv.x = this.startu;
                    this.elements.curAttrData.uv.y = this.startv;
                    return;
                }
                this.elements.curAttrData.uv.x += this.speedu;
                this.elements.curAttrData.uv.y += this.speedv;
            }
        }
        framework.UVRollAction = UVRollAction;
        class UVSpriteAnimationAction {
            constructor() {
                this.fps = 30;
                this.row = 1;
                this.colum = 1;
                this.totalCount = 1;
                this.frameInternal = 1;
                this.spriteIndex = 0;
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
            }
            init(_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["row"] != undefined) {
                    this.row = this.params["row"];
                }
                if (this.params["colum"] != undefined) {
                    this.colum = this.params["colum"];
                }
                if (this.params["count"] != undefined) {
                    this.totalCount = this.params["count"];
                }
            }
            update(frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                var spriteindex = Math.floor((frameIndex - this.startFrame) / (this.endFrame - this.startFrame) * this.totalCount);
                gd3d.math.spriteAnimation(this.row, this.colum, spriteindex, this.tex_ST);
                this.elements.curAttrData.uv.x = this.tex_ST.z;
                this.elements.curAttrData.uv.y = this.tex_ST.w;
                this.elements.curAttrData.tilling.x = this.tex_ST.x;
                this.elements.curAttrData.tilling.y = this.tex_ST.y;
            }
        }
        framework.UVSpriteAnimationAction = UVSpriteAnimationAction;
        class RotationAction {
            init(_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["velocity"] != undefined) {
                    this.velocity = framework.EffectUtil.parseEffectVec3(this.params["velocity"]);
                }
                this.frameInternal = 1 / framework.effectSystem.fps;
            }
            update(frameIndex) {
                this.elements.curAttrData.euler.z = this.elements.curAttrData.euler.z + (this.velocity.z.getValue()) * this.frameInternal;
                if (this.elements.curAttrData.renderModel == framework.RenderModel.None) {
                    this.elements.curAttrData.euler.x = this.elements.curAttrData.euler.x + (this.velocity.x.getValue()) * this.frameInternal;
                    this.elements.curAttrData.euler.y = this.elements.curAttrData.euler.y + (this.velocity.y.getValue()) * this.frameInternal;
                }
            }
        }
        framework.RotationAction = RotationAction;
        class RoseCurveAction {
            init(_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["radius"] != undefined) {
                    this.radius = this.params["radius"];
                }
                if (this.params["level"] != undefined) {
                    this.level = this.params["radius"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["polar"] != undefined) {
                    this.polar = framework.EffectUtil.parseEffectVec3(this.params["polar"]);
                }
                this.frameInternal = 1 / framework.effectSystem.fps;
            }
            update(frameIndex) {
                let initFrameDataPos = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.elements.data.initFrameData.attrsData.pos, initFrameDataPos);
                let radius = this.radius;
                let curFrame = frameIndex % 360;
                let x = this.polar.x.getValue();
                let y = this.polar.y.getValue();
                let z = this.polar.z.getValue();
                {
                    let theta = frameIndex * this.speed;
                    this.elements.curAttrData.pos.x = initFrameDataPos.x + radius * Math.cos(3 * theta + x) * Math.cos(theta);
                    this.elements.curAttrData.pos.z = initFrameDataPos.z + radius * Math.cos(3 * theta + x) * Math.sin(theta);
                    this.elements.curAttrData.pos.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                }
                {
                    let deltaTheta = frameIndex * this.speed + 0.001;
                    let targetPoint = gd3d.math.pool.new_vector3();
                    targetPoint.x = initFrameDataPos.x + radius * Math.cos(3 * deltaTheta + x) * Math.cos(deltaTheta);
                    targetPoint.z = initFrameDataPos.z + radius * Math.cos(3 * deltaTheta + x) * Math.sin(deltaTheta);
                    targetPoint.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                    let rotation = gd3d.math.pool.new_quaternion();
                    gd3d.math.quatLookat(this.elements.curAttrData.pos, targetPoint, rotation);
                    gd3d.math.quatToEulerAngles(rotation, this.elements.curAttrData.euler);
                    gd3d.math.pool.delete_vector3(targetPoint);
                    gd3d.math.pool.delete_quaternion(rotation);
                }
                gd3d.math.pool.delete_vector3(initFrameDataPos);
            }
        }
        framework.RoseCurveAction = RoseCurveAction;
        class TrailAction {
            constructor() {
                this.offsetTransalte = new gd3d.math.vector3();
            }
            init(_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["pos"] != undefined) {
                    this.position = framework.EffectUtil.parseEffectVec3(this.params["pos"]);
                }
                this.offsetTransalte.x = this.position.x.getValue();
                this.offsetTransalte.y = this.position.y.getValue();
                this.offsetTransalte.z = this.position.z.getValue();
                if (this.params["eular"] != undefined) {
                    this.eular = framework.EffectUtil.parseEffectVec3(this.params["eular"]);
                }
                if (this.params["color"] != undefined) {
                    this.color = framework.EffectUtil.parseEffectVec3(this.params["color"]);
                }
                if (this.params["width"] != undefined) {
                    this.width = this.params["width"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["alpha"] != undefined) {
                    this.alpha = this.params["alpha"];
                }
                let mat = new gd3d.framework.material();
                let shader = new gd3d.framework.shader();
                let texture = new gd3d.framework.texture();
                if (this.params["shader"] != undefined)
                    shader = framework.sceneMgr.app.getAssetMgr().getShader(this.params["shader"]);
                else
                    shader = framework.sceneMgr.app.getAssetMgr().getShader("shader/def");
                mat.setShader(shader);
                if (this.params["diffuseTexture"] != undefined)
                    texture = framework.sceneMgr.app.getAssetMgr().getAssetByName(this.params["diffuseTexture"]);
                mat.setTexture("_MainTex", texture);
                this.frameInternal = 1 / framework.effectSystem.fps;
                this.transform = new gd3d.framework.transform();
                framework.sceneMgr.scene.addChild(this.transform);
                let curAttrData = this.elements.data.initFrameData.attrsData.clone();
                let worldTranslate = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    gd3d.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                gd3d.math.vec3Clone(worldTranslate, this.transform.localTranslate);
                gd3d.math.pool.delete_vector3(worldTranslate);
                let trailTransform = new gd3d.framework.transform();
                this.transform.addChild(trailTransform);
                let x = this.eular.x.getValue();
                let y = this.eular.y.getValue();
                let z = this.eular.z.getValue();
                this.startRotation = new gd3d.math.quaternion();
                gd3d.math.quatFromEulerAngles(x, y, z, this.startRotation);
                gd3d.math.quatMultiply(this.startRotation, curAttrData.localRotation, this.transform.localRotate);
                this.transform.markDirty();
                trailTransform.markDirty();
                let trailrender = trailTransform.gameObject.addComponent("trailRender");
                trailrender.color = new gd3d.math.color(this.color.x.getValue(), this.color.y.getValue(), this.color.z.getValue(), this.alpha);
                trailrender.setspeed(this.speed);
                trailrender.setWidth(this.width);
                trailrender.material = mat;
            }
            update(frameIndex) {
                let worldTranslate = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Clone(this.elements.curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    gd3d.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                gd3d.math.vec3Clone(worldTranslate, this.transform.localTranslate);
                gd3d.math.vec3Add(this.transform.localTranslate, this.offsetTransalte, this.transform.localTranslate);
                gd3d.math.pool.delete_vector3(worldTranslate);
                gd3d.math.quatMultiply(this.startRotation, this.elements.curAttrData.localRotation, this.transform.localRotate);
                this.transform.markDirty();
            }
        }
        framework.TrailAction = TrailAction;
        class BreathAction {
            init(_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    this.loopframe = this.params["loopframe"];
                    this.halfloopframe = this.loopframe / 2;
                    this.curTargetFrame = this.startFrame + this.halfloopframe;
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.startvalue = framework.EffectUtil.parseEffectVec3(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectVec3(this.params["targetvalue"]).getValue();
                            break;
                        case "uv":
                            this.startvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["targetvalue"]).getValue();
                            break;
                        case "alpha":
                            this.startvalue = this.params["startvalue"];
                            this.targetvalue = this.params["targetvalue"];
                            break;
                    }
                }
            }
            update(frameIndex) {
                if (this.startFrame > frameIndex)
                    return;
                if (frameIndex >= this.curTargetFrame) {
                    this.swap();
                    this.curTargetFrame += this.halfloopframe;
                }
                let baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos = this.getLerpValue(frameIndex);
                        break;
                    case "scale":
                        baseValue.scale = this.getLerpValue(frameIndex);
                        break;
                    case "euler":
                        baseValue.euler = this.getLerpValue(frameIndex);
                        break;
                    case "color":
                        baseValue.color = this.getLerpValue(frameIndex);
                        break;
                    case "uv":
                        baseValue.uv = this.getLerpValue(frameIndex);
                        break;
                    case "alpha":
                        baseValue.alpha = this.getLerpValue(frameIndex);
                        break;
                }
            }
            swap() {
                let temp;
                if (this.startvalue instanceof gd3d.math.vector3) {
                    temp = gd3d.math.pool.clone_vector3(this.startvalue);
                    this.startvalue = gd3d.math.pool.clone_vector3(this.targetvalue);
                    this.targetvalue = temp;
                }
                else if (this.startvalue instanceof gd3d.math.vector2) {
                    temp = gd3d.math.pool.clone_vector2(this.startvalue);
                    this.startvalue = gd3d.math.pool.clone_vector2(this.targetvalue);
                    this.targetvalue = temp;
                }
                else {
                    temp = this.startvalue;
                    this.startvalue = this.targetvalue;
                    this.targetvalue = temp;
                }
            }
            getLerpValue(frameIndex) {
                let curframe = (frameIndex - this.startFrame) % this.halfloopframe;
                let outVal;
                if (this.startvalue instanceof gd3d.math.vector3) {
                    outVal = new gd3d.math.vector3();
                    gd3d.math.vec3SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else if (this.startvalue instanceof gd3d.math.vector2) {
                    outVal = new gd3d.math.vector2();
                    gd3d.math.vec2SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else {
                    outVal = gd3d.math.numberLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe);
                }
                return outVal;
            }
        }
        framework.BreathAction = BreathAction;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class EffectParser {
            Parse(str, assetmgr) {
                if (str == null)
                    return null;
                this.asMgr = assetmgr;
                let effectData = new framework.EffectSystemData();
                let content = JSON.parse(str);
                if (content["life"] != undefined)
                    effectData.life = content["life"];
                if (content["beloop"] != undefined) {
                    effectData.beLoop = content["beloop"];
                }
                let refOriDic = {};
                let unRefOriDic = {};
                let refCount = 0;
                if (content["elements"] != undefined) {
                    effectData.elementDic = {};
                    let elements = content["elements"];
                    for (let i in elements) {
                        let elementData = elements[i];
                        let name = "";
                        if (elementData["name"] != undefined) {
                            name = elementData["name"];
                            if (effectData.elementDic[name] != undefined || refOriDic[name] != undefined) {
                                console.error("特效中元素的名字重复：" + name);
                                continue;
                            }
                        }
                        else {
                            console.error("未设置特效中元素的名字！");
                            continue;
                        }
                        if (elementData["ref"] != undefined) {
                            refOriDic[name] = elementData;
                            refCount++;
                            continue;
                        }
                        else {
                            effectData.elementDic[name] = this._parse(elementData);
                            unRefOriDic[name] = elementData;
                        }
                    }
                    while (refCount > 0) {
                        for (let key in refOriDic) {
                            let desOriData = refOriDic[key];
                            if (desOriData == null)
                                continue;
                            let refFrom = desOriData["ref"];
                            if (unRefOriDic[refFrom] != undefined) {
                                let srcOriData = unRefOriDic[refFrom];
                                this.copyAndOverWrite(srcOriData, desOriData);
                                let element = this._parse(desOriData);
                                effectData.elementDic[desOriData["name"]] = element;
                                delete refOriDic[key];
                                refCount--;
                            }
                        }
                    }
                }
                return effectData;
            }
            _parse(elementData) {
                let element = new framework.EffectElementData();
                if (elementData["beloop"] != undefined)
                    element.beloop = elementData["beloop"];
                if (elementData["delaytime"] != undefined)
                    element.delayTime = elementData["delaytime"];
                element.name = elementData["name"];
                if (elementData["type"] != undefined) {
                    switch (elementData["type"]) {
                        case "singlemesh":
                            element.type = framework.EffectElementTypeEnum.SingleMeshType;
                            break;
                        case "emission":
                            element.type = framework.EffectElementTypeEnum.EmissionType;
                            break;
                    }
                }
                switch (element.type) {
                    case framework.EffectElementTypeEnum.SingleMeshType:
                        this._parseSingleMeshTypeData(elementData, element);
                        break;
                    case framework.EffectElementTypeEnum.EmissionType:
                        this._parseEmissionTypeData(elementData, element);
                        break;
                }
                return element;
            }
            copyAndOverWrite(srcData, desData) {
                for (let key in srcData) {
                    let data = srcData[key];
                    if (data != undefined) {
                        let baseType = typeof (data);
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                if (desData[key] == undefined)
                                    desData[key] = data;
                                break;
                            default:
                                if (desData[key] == undefined) {
                                    desData[key] = srcData[key];
                                }
                                else {
                                    this.copyAndOverWrite(srcData[key], desData[key]);
                                }
                                break;
                        }
                    }
                }
            }
            _parseSingleMeshTypeData(elementData, element) {
                if (elementData["timeline"] != undefined) {
                    element.timelineFrame = {};
                    element.actionData = [];
                    let _timelineArray = elementData["timeline"];
                    for (let j in _timelineArray) {
                        let _timeline = _timelineArray[j];
                        if (_timeline["frame"] == undefined) {
                            console.error("必须要配一个关键帧的索引");
                            continue;
                        }
                        let frame = new framework.EffectFrameData();
                        frame.frameIndex = _timeline["frame"];
                        element.timelineFrame[frame.frameIndex] = frame;
                        frame.attrsData = new framework.EffectAttrsData();
                        if (_timeline["attrs"] != undefined) {
                            let _attrs = _timeline["attrs"];
                            for (let key in _attrs) {
                                let val = this._parseToObjData(key, _attrs[key]);
                                if (key == "mat") {
                                    frame.attrsData.mat = val;
                                }
                                else if (key == "pos") {
                                    frame.attrsData.pos = val.getValue();
                                }
                                else if (key == "scale") {
                                    frame.attrsData.scale = val.getValue();
                                }
                                else if (key == "euler") {
                                    frame.attrsData.euler = val.getValue();
                                }
                                else if (key == "mesh") {
                                    frame.attrsData.mesh = val;
                                }
                                else if (key == "color") {
                                    frame.attrsData.color = val.getValue();
                                }
                                else if (key == "alpha") {
                                    frame.attrsData.alpha = val.getValue();
                                    ;
                                }
                                else if (key == "tilling") {
                                    frame.attrsData.tilling = val.getValue();
                                }
                                else if (key == "billboard") {
                                    frame.attrsData.renderModel = val;
                                }
                                else if (key == "colorRate") {
                                    frame.attrsData.colorRate = val;
                                }
                            }
                        }
                        if (frame.frameIndex == -1) {
                            element.initFrameData = frame;
                        }
                        if (_timeline["lerp"] != undefined) {
                            frame.lerpDatas = [];
                            for (let x in _timeline["lerp"]) {
                                let lerp = new framework.EffectLerpData();
                                lerp.fromFrame = frame.frameIndex;
                                frame.lerpDatas.push(lerp);
                                let _lerp = _timeline["lerp"][x];
                                if (_lerp["type"] != undefined) {
                                    switch (_lerp["type"]) {
                                        case "linear":
                                            lerp.type = framework.EffectLerpTypeEnum.Linear;
                                            break;
                                    }
                                }
                                if (_lerp["to"] != undefined)
                                    lerp.toFrame = this._parseToValueData(_lerp["to"]);
                                if (_lerp["attribute"] != undefined) {
                                    lerp.attrsData = new framework.EffectAttrsData();
                                    let _attribs = _lerp["attribute"];
                                    for (let key in _attribs) {
                                        lerp.attrsList.push(key);
                                        let val = this._parseToObjData(key, _attribs[key]);
                                        if (key == "pos") {
                                            lerp.attrsData.pos = val.getValue();
                                        }
                                        else if (key == "scale") {
                                            lerp.attrsData.scale = val.getValue();
                                        }
                                        else if (key == "euler") {
                                            lerp.attrsData.euler = val.getValue();
                                        }
                                        else if (key == "color") {
                                            lerp.attrsData.color = val.getValue();
                                        }
                                        else if (key == "alpha") {
                                            lerp.attrsData.alpha = val.getValue();
                                        }
                                        else {
                                            console.error("未支持的插值属性：" + key);
                                        }
                                    }
                                }
                            }
                        }
                        if (_timeline["actions"] != undefined) {
                            let _actions = _timeline["actions"];
                            for (let k in _actions) {
                                let action = new framework.EffectActionData();
                                let _action = _actions[k];
                                action.actionType = _action["action"];
                                action.startFrame = frame.frameIndex;
                                if (_action["end"] != undefined) {
                                    action.endFrame = _action["end"];
                                }
                                else {
                                    action.endFrame = -1;
                                }
                                if (_action["param"] != undefined) {
                                    action.params = _action["param"];
                                }
                                element.actionData.push(action);
                            }
                        }
                    }
                }
            }
            _parseEmissionTypeData(elementData, element) {
                if (elementData["timeline"] != undefined) {
                    let timelines = elementData["timeline"];
                    if (timelines.length > 0 && timelines[0] != undefined && timelines[0]["attrs"] != undefined) {
                        let _data = timelines[0]["attrs"];
                        let data = new framework.Emission();
                        element.emissionData = data;
                        if (_data["emissionType"] != undefined) {
                            switch (_data["emissionType"]) {
                                case "burst":
                                    data.emissionType = framework.ParticleEmissionType.burst;
                                    break;
                                case "continue":
                                    data.emissionType = framework.ParticleEmissionType.continue;
                                    break;
                            }
                            if (_data["simulateinlocal"] != undefined) {
                                data.simulateInLocalSpace = _data["simulateinlocal"];
                            }
                            if (_data["maxcount"] != undefined)
                                data.maxEmissionCount = _data["maxcount"];
                            if (_data["emissioncount"] != undefined)
                                data.emissionCount = _data["emissioncount"];
                            if (_data["time"] != undefined)
                                data.time = _data["time"];
                            if (_data["mesh"] != undefined)
                                data.mesh = this._parseToObjData("mesh", _data["mesh"]);
                            if (_data["mat"] != undefined)
                                data.mat = this._parseToObjData("mat", _data["mat"]);
                            if (_data["rootpos"] != undefined) {
                                data.rootpos = framework.EffectUtil.parseVector3(_data["rootpos"]);
                            }
                            else {
                                data.rootpos = new gd3d.math.vector3();
                            }
                            if (_data["rootRotAngle"] != undefined) {
                                data.rootRotAngle = framework.EffectUtil.parseVector3(_data["rootRotAngle"]);
                            }
                            else {
                                data.rootRotAngle = new gd3d.math.vector3();
                            }
                            if (_data["rootscale"]) {
                                data.rootScale = framework.EffectUtil.parseVector3(_data["rootscale"]);
                            }
                            else {
                                data.rootScale = new gd3d.math.vector3(1, 1, 1);
                            }
                            if (_data["moveSpeed"] != undefined)
                                data.moveSpeed = this._parseToObjData("moveSpeed", _data["moveSpeed"]);
                            if (_data["gravity"] != undefined)
                                data.gravity = _data["gravity"];
                            if (_data["euler"] != undefined)
                                data.euler = this._parseToObjData("euler", _data["euler"]);
                            if (_data["eulerSpeed"] != undefined)
                                data.eulerSpeed = this._parseToObjData("eulerSpeed", _data["eulerSpeed"]);
                            if (_data["eulerNodes"] != undefined) {
                                data.eulerNodes = [];
                                if (data.euler != undefined) {
                                    data.eulerNodes.push(data.euler);
                                    data.euler.key = 0;
                                }
                                for (let i in _data["eulerNodes"]) {
                                    let node = framework.EffectUtil.parseEffectVec3(_data["eulerNodes"][i]);
                                    data.eulerNodes.push(node);
                                }
                            }
                            if (_data["scale"] != undefined)
                                data.scale = this._parseToObjData("scale", _data["scale"]);
                            if (_data["scaleSpeed"] != undefined)
                                data.scaleSpeed = this._parseToObjData("scaleSpeed", _data["scaleSpeed"]);
                            if (_data["scaleNodes"] != undefined) {
                                data.scaleNodes = [];
                                var startscale = new framework.ParticleNodeNumber();
                                startscale.num.value = 1;
                                startscale.key = 0;
                                data.scaleNodes.push(startscale);
                                for (let i in _data["scaleNodes"]) {
                                    let node = framework.EffectUtil.parseEffectNumNode(_data["scaleNodes"][i]);
                                    data.scaleNodes.push(node);
                                }
                            }
                            if (_data["simulationSpeed"] != undefined) {
                                data.simulationSpeed = this._parseToObjData("simulationSpeed", _data["simulationSpeed"]);
                            }
                            if (_data["alpha"] != undefined) {
                                data.alpha = this._parseToObjData("alpha", _data["alpha"]);
                            }
                            if (_data["alphaSpeed"] != undefined)
                                data.alphaSpeed = this._parseToObjData("alphaSpeed", _data["alphaSpeed"]);
                            if (_data["alphaNodes"] != undefined) {
                                data.alphaNodes = [];
                                if (data.alpha != undefined) {
                                    data.alphaNodes.push(data.alpha);
                                    data.alpha.key = 0;
                                }
                                for (let i in _data["alphaNodes"]) {
                                    let node = new framework.ParticleNodeNumber();
                                    var item = _data["alphaNodes"][i];
                                    if (item["key"] != null) {
                                        node.key = item["key"];
                                    }
                                    let alphavalue = item["alpha"];
                                    if (alphavalue != null) {
                                        if (alphavalue instanceof Array) {
                                            node.num.valueLimitMin = alphavalue[0];
                                            node.num.valueLimitMax = alphavalue[1];
                                        }
                                        else {
                                            node.num.value = alphavalue;
                                        }
                                    }
                                    data.alphaNodes.push(node);
                                }
                            }
                            if (_data["color"] != undefined)
                                data.color = this._parseToObjData("color", _data["color"]);
                            if (_data["colorRate"] != undefined)
                                data.colorRate = _data["colorRate"];
                            if (_data["colorSpeed"] != undefined)
                                data.colorSpeed = this._parseToObjData("colorSpeed", _data["colorSpeed"]);
                            if (_data["colorNodes"] != undefined) {
                                data.colorNodes = [];
                                if (data.color != undefined) {
                                    data.colorNodes.push(data.color);
                                    data.color.key = 0;
                                }
                                for (let i in _data["colorNodes"]) {
                                    let node = framework.EffectUtil.parseEffectVec3(_data["colorNodes"][i]);
                                    data.colorNodes.push(node);
                                }
                            }
                            if (_data["uv"] != undefined) {
                                data.uv = framework.EffectUtil.parseEffectVec2(_data["uv"]);
                            }
                            if (_data["uvtype"] != undefined) {
                                switch (_data["uvtype"]) {
                                    case "uvroll":
                                        data.uvType = framework.UVTypeEnum.UVRoll;
                                        if (_data["uvroll"] != undefined) {
                                            data.uvRoll = new framework.UVRoll();
                                            data.uvRoll.uvSpeed = framework.EffectUtil.parseEffectUVSpeed(_data["uvroll"]);
                                        }
                                        break;
                                    case "uvsprite":
                                        let _val = _data["uvsprite"];
                                        data.uvType = framework.UVTypeEnum.UVSprite;
                                        data.uvSprite = new framework.UVSprite();
                                        if (_val["row"] != undefined)
                                            data.uvSprite.row = _val["row"];
                                        if (_val["colum"] != undefined)
                                            data.uvSprite.column = _val["colum"];
                                        if (_val["count"] != undefined)
                                            data.uvSprite.totalCount = _val["count"];
                                        break;
                                    default:
                                        data.uvType = framework.UVTypeEnum.NONE;
                                        break;
                                }
                            }
                            else
                                data.uvType = framework.UVTypeEnum.NONE;
                            if (_data["billboard"] != undefined)
                                data.renderModel = this._parseToObjData("billboard", _data["billboard"]);
                            if (_data["life"] != undefined)
                                data.life = framework.EffectUtil.parseEffectValueData(_data["life"]);
                            if (_data["startpos"] != undefined) {
                                this._parseEmissionShape(_data["startpos"], element);
                            }
                        }
                    }
                }
            }
            _parseEmissionShape(_startdata, element) {
                let startdata = element.emissionData.particleStartData;
                switch (_startdata["type"]) {
                    case "normal":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.NORMAL;
                        break;
                    case "box":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.BOX;
                        break;
                    case "sphere":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.SPHERE;
                        break;
                    case "hemisphere":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.HEMISPHERE;
                        break;
                    case "cone":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.CONE;
                        break;
                    case "circle":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.CIRCLE;
                        break;
                    case "edge":
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.EDGE;
                        break;
                    default:
                        startdata.shapeType = gd3d.framework.ParticleSystemShape.NORMAL;
                        break;
                }
                if (_startdata["width"] != undefined) {
                    startdata.width = _startdata["width"];
                }
                if (_startdata["height"] != undefined) {
                    startdata.height = _startdata["height"];
                }
                if (_startdata["depth"] != undefined) {
                    startdata.depth = _startdata["depth"];
                }
                if (_startdata["angle"] != undefined) {
                    startdata.angle = _startdata["angle"];
                }
                if (_startdata["radius"] != undefined) {
                    startdata.radius = _startdata["radius"];
                }
                if (_startdata["direction"] != undefined) {
                    let _startdir = _startdata["direction"];
                    startdata.direction.x = _startdir["x"];
                    startdata.direction.y = _startdir["y"];
                    startdata.direction.z = _startdir["z"];
                }
            }
            _parseToObjData(attrib, content) {
                switch (attrib) {
                    case "pos":
                    case "scale":
                    case "euler":
                    case "color":
                    case "moveSpeed":
                    case "eulerSpeed":
                    case "scaleSpeed":
                    case "colorSpeed":
                        return framework.EffectUtil.parseEffectVec3(content);
                    case "":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "alphaSpeed":
                    case "alpha":
                    case "simulationSpeed":
                        return framework.EffectUtil.parseEffectNum(content);
                    case "tilling":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "mat":
                        let mat = new framework.EffectMatData();
                        if (content != undefined) {
                            if (content["shader"] != undefined)
                                mat.shader = this.asMgr.getShader(content["shader"]);
                            else
                                mat.shader = this.asMgr.getShader("shader/def");
                            if (content["diffuseTexture"] != undefined)
                                mat.diffuseTexture = this.asMgr.getAssetByName(content["diffuseTexture"]);
                            if (content["alphaCut"] != undefined)
                                mat.alphaCut = content["alphaCut"];
                            if (content["_AlphaTex"] != undefined)
                                mat.alphaTexture = this.asMgr.getAssetByName(content["_AlphaTex"]);
                        }
                        return mat;
                    case "emmision":
                        let emission = new framework.EmissionData();
                        if (content["type"] != undefined)
                            emission.type = content["type"];
                        if (content["time"] != undefined)
                            emission.time = content["time"];
                        if (content["count"] != undefined)
                            emission.count = content["count"];
                        return emission;
                    case "billboard":
                        let billboardType = framework.RenderModel.Mesh;
                        if (content == "billboard") {
                            billboardType = framework.RenderModel.BillBoard;
                        }
                        else if (content == "horizontal") {
                            billboardType = framework.RenderModel.HorizontalBillBoard;
                        }
                        else if (content == "stretched") {
                            billboardType = framework.RenderModel.StretchedBillBoard;
                        }
                        else if (content == "vertical") {
                            billboardType = framework.RenderModel.VerticalBillBoard;
                        }
                        else if (content == "mesh") {
                            billboardType = framework.RenderModel.Mesh;
                        }
                        else {
                            billboardType = framework.RenderModel.None;
                        }
                        return billboardType;
                    case "mesh":
                        let str = content;
                        if (content.toString().indexOf(".mesh.bin") >= 0)
                            return this.asMgr.getAssetByName(content);
                        else
                            return this.asMgr.getDefaultMesh(content);
                    default:
                        return content;
                }
            }
            _parseToParticleNode(content) {
                content = framework.StringUtil.replaceAll(content, " ", "");
                let charArray = content.match(framework.RegexpUtil.vector3FloatOrRangeRegexp);
                if (charArray != undefined) {
                    let node = new framework.ParticleNode();
                    for (let i = 1; i < charArray.length; i++) {
                        if (i == 1) {
                            node.x = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 2) {
                            node.y = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 3) {
                            node.z = this._parseToValueData(charArray[i]);
                        }
                    }
                    return node;
                }
                return null;
            }
            _parseToValueData(content) {
                let data = new framework.ValueData();
                let array = this._parseToNumberArray(content);
                if (array != null) {
                    if (array.length > 1) {
                        data.valueLimitMin = array[0];
                        data.valueLimitMax = array[1];
                        data.isRandom = true;
                    }
                    else {
                        data.value = array[0];
                        data.isRandom = false;
                    }
                }
                return data;
            }
            _parseToNumberArray(content) {
                content = framework.StringUtil.trimAll(content);
                content = framework.StringUtil.replaceAll(content, "\\[", "");
                content = framework.StringUtil.replaceAll(content, "\\]", "");
                let _array = content.split(",");
                let result = [];
                for (let i = 0; i < _array.length; i++) {
                    result.push(parseInt(_array[i]));
                }
                return result;
            }
        }
        framework.EffectParser = EffectParser;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class EffectUtil {
            static lookatbyXAxis(pos, xAxis, yAxis, zAxis, targetpos, quat) {
                var dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(targetpos, pos, dir);
                gd3d.math.vec3Normalize(dir, dir);
                var crossup = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(dir, xAxis, crossup);
                gd3d.math.vec3Normalize(crossup, crossup);
                var anglerot = gd3d.math.vec3Dot(yAxis, crossup);
                anglerot = Math.acos(anglerot) * 180 / Math.PI;
                var dot = gd3d.math.vec3Dot(zAxis, crossup);
                dot = Math.acos(dot) * 180 / Math.PI;
                if (dot > 90) {
                    anglerot = -anglerot;
                }
                gd3d.math.quatFromAxisAngle(gd3d.math.pool.vector3_right, anglerot, quat);
                gd3d.math.pool.delete_vector3(dir);
                gd3d.math.pool.delete_vector3(crossup);
            }
            static eulerFromQuaternion(out, q, order) {
                var sqx = q.x * q.x;
                var sqy = q.y * q.y;
                var sqz = q.z * q.z;
                var sqw = q.w * q.w;
                if (order === 'XYZ') {
                    out.x = Math.atan2(2 * (q.x * q.w - q.y * q.z), (sqw - sqx - sqy + sqz));
                    out.y = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.z + q.y * q.w), -1, 1));
                    out.z = Math.atan2(2 * (q.z * q.w - q.x * q.y), (sqw + sqx - sqy - sqz));
                }
                else if (order === 'YXZ') {
                    out.x = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.w - q.y * q.z), -1, 1));
                    out.y = Math.atan2(2 * (q.x * q.z + q.y * q.w), (sqw - sqx - sqy + sqz));
                    out.z = Math.atan2(2 * (q.x * q.y + q.z * q.w), (sqw - sqx + sqy - sqz));
                }
                else if (order === 'ZXY') {
                    out.x = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.w + q.y * q.z), -1, 1));
                    out.y = Math.atan2(2 * (q.y * q.w - q.z * q.x), (sqw - sqx - sqy + sqz));
                    out.z = Math.atan2(2 * (q.z * q.w - q.x * q.y), (sqw - sqx + sqy - sqz));
                }
                else if (order === 'ZYX') {
                    out.x = Math.atan2(2 * (q.x * q.w + q.z * q.y), (sqw - sqx - sqy + sqz));
                    out.y = Math.asin(gd3d.math.floatClamp(2 * (q.y * q.w - q.x * q.z), -1, 1));
                    out.z = Math.atan2(2 * (q.x * q.y + q.z * q.w), (sqw + sqx - sqy - sqz));
                }
                else if (order === 'YZX') {
                    out.x = Math.atan2(2 * (q.x * q.w - q.z * q.y), (sqw - sqx + sqy - sqz));
                    out.y = Math.atan2(2 * (q.y * q.w - q.x * q.z), (sqw + sqx - sqy - sqz));
                    out.z = Math.asin(gd3d.math.floatClamp(2 * (q.x * q.y + q.z * q.w), -1, 1));
                }
                else if (order === 'XZY') {
                    out.x = Math.atan2(2 * (q.x * q.w + q.y * q.z), (sqw - sqx + sqy - sqz));
                    out.y = Math.atan2(2 * (q.x * q.z + q.y * q.w), (sqw + sqx - sqy - sqz));
                    out.z = Math.asin(gd3d.math.floatClamp(2 * (q.z * q.w - q.x * q.y), -1, 1));
                }
                else {
                    console.log('No order given for quaternion to euler conversion.');
                    return;
                }
            }
            static RandomRange(min, max, isInteger = false) {
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            }
            static vecMuliNum(vec, num) {
                var v = new gd3d.math.vector3(vec.x * num, vec.y * num, vec.z * num);
                return v;
            }
            static parseVector3(value) {
                var vector3 = new gd3d.math.vector3();
                vector3.x = value["x"];
                vector3.y = value["y"];
                vector3.z = value["z"];
                return vector3;
            }
            static parseEffectVec3(value) {
                let node = new framework.ParticleNode();
                for (let key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            }
            static parseEffectVec2(value) {
                let node = new framework.ParticleNodeVec2();
                for (let key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            }
            static parseEffectNum(value) {
                let node = new framework.ParticleNodeNumber();
                if (value instanceof Array) {
                    node.num.valueLimitMin = value[0];
                    node.num.valueLimitMax = value[1];
                    node.num.isRandom = true;
                }
                else {
                    node.num.value = value;
                    node.num.isRandom = false;
                }
                return node;
            }
            static parseEffectNumNode(value) {
                let node = new framework.ParticleNodeNumber();
                for (let key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node.num.value = value[key];
                        }
                    }
                }
                return node;
            }
            static parseEffectValueData(value) {
                let val = new framework.ValueData();
                if (value instanceof Array) {
                    val.valueLimitMin = value[0];
                    val.valueLimitMax = value[1];
                    val.isRandom = true;
                }
                else {
                    val.value = value;
                    val.isRandom = false;
                }
                return val;
            }
            static parseEffectUVSpeed(value) {
                let node = new framework.UVSpeedNode();
                for (let key in value) {
                    node[key].value = value[key];
                }
                return node;
            }
            static lookat(eye, targetpos, out, up = gd3d.math.pool.vector3_up) {
                let dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                let unitprojectedXZ = new gd3d.math.vector3(dir.x, 0, dir.z);
                gd3d.math.vec3Normalize(unitprojectedXZ, unitprojectedXZ);
                var yaw = Math.acos(unitprojectedXZ.z) / Math.PI * 180;
                if (unitprojectedXZ.x < 0) {
                    yaw = -yaw;
                }
                gd3d.math.quatFromAxisAngle(up, yaw, out);
                let right = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(up, dir, right);
                gd3d.math.vec3Normalize(right, right);
                let projectedXZ = new gd3d.math.vector3(dir.x, 0, dir.z);
                let length = gd3d.math.vec3Length(projectedXZ);
                var pitch = Math.acos(length) / Math.PI * 180;
                if (dir.y < 0) {
                    pitch = -pitch;
                }
                var quadRight = gd3d.math.pool.new_quaternion();
                gd3d.math.quatFromAxisAngle(right, pitch, quadRight);
            }
            static RotateVector3(source, direction, out) {
                gd3d.math.vec3Normalize(source, source);
                gd3d.math.vec3Normalize(direction, direction);
                let forward = new gd3d.math.vector3(0, 0, 1);
                let axis = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(forward, direction, axis);
                gd3d.math.vec3Normalize(axis, axis);
                if (axis.x == 0 && axis.y == 0 && axis.z == 0) {
                    axis.x = 1;
                    axis.y = 0;
                    axis.z = 0;
                }
                let cos = gd3d.math.vec3Dot(forward, direction);
                let angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                let quatertion = gd3d.math.pool.new_quaternion();
                gd3d.math.quatFromAxisAngle(axis, angle, quatertion);
                gd3d.math.quatTransformVector(quatertion, source, out);
                gd3d.math.pool.delete_vector3(axis);
                gd3d.math.pool.delete_quaternion(quatertion);
            }
            static bindAxisBillboard(localAxis, out) {
                gd3d.math.vec3Normalize(localAxis, localAxis);
                let yAxis = gd3d.math.pool.vector3_up;
                let normal = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(yAxis, localAxis, normal);
                gd3d.math.vec3Normalize(normal, normal);
                if (normal.x == 0 && normal.y == 0 && normal.z == 0) {
                    normal.x = 1;
                    normal.y = 0;
                    normal.z = 0;
                }
                let cos = gd3d.math.vec3Dot(yAxis, localAxis);
                let angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                gd3d.math.quatFromAxisAngle(normal, angle, out);
            }
            static lookatVerticalBillboard(eye, targetpos, out, up = gd3d.math.pool.vector3_up) {
                let dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                let dirxz = new gd3d.math.vector3(dir.x, 0, dir.z);
                gd3d.math.vec3Normalize(dirxz, dirxz);
                var yaw = Math.acos(dirxz.z) / Math.PI * 180;
                if (dirxz.x < 0) {
                    yaw = -yaw;
                }
                gd3d.math.quatFromAxisAngle(up, yaw, out);
            }
            static quatLookatZ(eye, targetpos, out, forward = gd3d.math.pool.vector3_forward) {
                let dir = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                let dirxy = new gd3d.math.vector3(-dir.x, dir.y, 0);
                gd3d.math.vec3Normalize(dirxy, dirxy);
                let roll = Math.acos(dirxy.y) / Math.PI * 180;
                if (dirxy.x < 0) {
                    roll = -roll;
                }
                gd3d.math.quatFromAxisAngle(forward, roll, out);
            }
            static quatLookatX(eye, targetpos, out, right = gd3d.math.pool.vector3_right) {
                let dir = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(targetpos, eye, dir);
                gd3d.math.vec3Normalize(dir, dir);
                let diryz = new gd3d.math.vector3(0, -dir.y, dir.z);
                gd3d.math.vec3Normalize(diryz, diryz);
                let pitch = Math.acos(diryz.z) / Math.PI * 180;
                if (diryz.y < 0) {
                    pitch = -pitch;
                }
                gd3d.math.quatFromAxisAngle(right, pitch, out);
            }
        }
        framework.EffectUtil = EffectUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class EmissionBatcher {
            constructor(emissionElement) {
                this.particles = [];
                this.vertexSize = 0;
                this.vf = 0;
                this.curVerCount = 0;
                this.curIndexCount = 0;
                this.emissionElement = emissionElement;
                this.webgl = emissionElement.webgl;
                this.gameObject = emissionElement.gameObject;
                this.vf = emissionElement.vf;
                this.data = emissionElement.emissionData;
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.vf) / 4;
                this.initMesh();
                this.mat = new framework.material();
                if (this.data.mat.shader == null) {
                    this.mat.setShader(framework.sceneMgr.app.getAssetMgr().getShader("diffuse.shader.json"));
                }
                else {
                    this.mat.setShader(this.data.mat.shader);
                }
                if (this.data.mat.alphaCut != undefined)
                    this.mat.setFloat("_AlphaCut", this.data.mat.alphaCut);
                if (this.data.mat.diffuseTexture != null)
                    this.mat.setTexture("_MainTex", this.data.mat.diffuseTexture);
                if (this.data.mat.alphaTexture != null)
                    this.mat.setTexture("_AlphaTex", this.data.mat.alphaTexture);
            }
            initMesh() {
                this.mesh = new framework.mesh();
                this.mesh.data = new gd3d.render.meshData();
                this.mesh.glMesh = new gd3d.render.glMesh();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = 0;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                this.mesh.glMesh.initBuffer(this.webgl, this.vf, 128, gd3d.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
            }
            addParticle() {
                this.refreshBuffer();
                let p = new framework.Particle(this);
                p.update(0);
                p.uploadData(this.dataForVbo);
                for (let i = 0; i < p.dataForEbo.length; i++) {
                    this.dataForEbo[this.curIndexCount + i] = p.dataForEbo[i] + this.curVerCount;
                }
                this.particles.push(p);
                this.curVerCount += this.emissionElement.perVertexCount;
                this.curIndexCount += this.emissionElement.perIndexxCount;
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
            }
            refreshBuffer() {
                var needvercount = this.curVerCount + this.emissionElement.perVertexCount;
                var needIndexCount = this.curIndexCount + this.emissionElement.perIndexxCount;
                if (needvercount * this.vertexSize > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    let vbo = new Float32Array(length * 2);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                if (needIndexCount > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    let ebo = new Uint16Array(length * 2);
                    ebo.set(this.dataForEbo, 0);
                    this.dataForEbo = ebo;
                }
            }
            update(delta) {
                for (let key in this.particles) {
                    this.particles[key].update(delta);
                    this.particles[key].uploadData(this.dataForVbo);
                }
            }
            render(context, assetmgr, camera) {
                let mesh = this.mesh;
                mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (assetmgr.app.getScene().fog) {
                    context.fog = assetmgr.app.getScene().fog;
                    this.mat.draw(context, mesh, mesh.submesh[0], "base_fog");
                }
                else {
                    this.mat.draw(context, mesh, mesh.submesh[0], "base");
                }
            }
            dispose() {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.mesh.dispose();
                this.mat.dispose();
                for (let key in this.particles) {
                    this.particles[key].dispose();
                }
            }
        }
        framework.EmissionBatcher = EmissionBatcher;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class Particle {
            constructor(batcher) {
                this.renderModel = framework.RenderModel.Mesh;
                this.startScale = new gd3d.math.vector3();
                this.startRotation = new gd3d.math.quaternion();
                this.rotationByShape = new gd3d.math.quaternion();
                this.rotationByEuler = new gd3d.math.quaternion();
                this.localMatrix = new gd3d.math.matrix();
                this.localRotation = new gd3d.math.quaternion();
                this.tilling = new gd3d.math.vector2(1, 1);
                this.speedDir = new gd3d.math.vector3(0, 0, 0);
                this.actived = true;
                this.transformVertex = new gd3d.math.matrix();
                this.matToworld = new gd3d.math.matrix();
                this.tex_ST = new gd3d.math.vector4(1, 1, 0, 0);
                this.batcher = batcher;
                this.gameObject = batcher.gameObject;
                this.emisson = batcher.emissionElement;
                this.vf = batcher.vf;
                this.data = batcher.data.clone();
                this.vertexSize = gd3d.render.meshData.calcByteSize(this.vf) / 4;
                this.vertexStartIndex = batcher.curVerCount;
                this.vertexCount = this.emisson.perVertexCount;
                this.dataForVbo = new Float32Array(this.vertexCount * this.vertexSize);
                this.dataForEbo = this.data.mesh.data.genIndexDataArray();
                this.dataForVbo.set(this.data.mesh.data.genVertexDataArray(this.vf), 0);
                this.sourceVbo = this.data.getVboData(this.vf);
                this.initByData();
            }
            uploadData(array) {
                array.set(this.dataForVbo, this.vertexStartIndex * this.vertexSize);
            }
            initByData() {
                this.totalLife = this.data.life.getValueRandom();
                this.renderModel = this.data.renderModel;
                this.curLife = 0;
                let localRandomDirection = this.data.particleStartData.randomDirection;
                this.speedDir = gd3d.math.pool.clone_vector3(localRandomDirection);
                let localRandomTranslate = this.data.particleStartData.position;
                this.localTranslate = gd3d.math.pool.clone_vector3(localRandomTranslate);
                this.simulationSpeed = this.data.simulationSpeed != undefined ? this.data.simulationSpeed.getValue() : 0;
                if (this.data.euler == undefined)
                    this.euler = new gd3d.math.vector3(0, 0, 0);
                else
                    this.euler = this.data.euler.getValueRandom();
                if (this.data.scale == undefined)
                    this.localScale = new gd3d.math.vector3(1, 1, 1);
                else
                    this.localScale = this.data.scale.getValueRandom();
                if (this.data.color == undefined)
                    this.color = new gd3d.math.vector3(0, 0, 0);
                else
                    this.color = this.data.color.getValueRandom();
                if (this.data.alpha == undefined)
                    this.alpha = 1;
                else
                    this.alpha = this.data.alpha.getValueRandom();
                if (this.data.uv == undefined)
                    this.uv = new gd3d.math.vector2();
                else
                    this.uv = this.data.uv.getValueRandom();
                if (this.data.moveSpeed != undefined) {
                    this.movespeed = this.data.moveSpeed.getValue();
                }
                else {
                    this.movespeed = new gd3d.math.vector3();
                }
                if (this.data.colorRate == undefined)
                    this.colorRate = this.data.colorRate;
                else
                    this.colorRate = 1;
                gd3d.math.vec3Clone(this.localScale, this.startScale);
                gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                if (this.renderModel == framework.RenderModel.None || this.renderModel == framework.RenderModel.StretchedBillBoard) {
                    if (this.data.particleStartData.shapeType != framework.ParticleSystemShape.NORMAL) {
                        let localOrgin = gd3d.math.pool.vector3_zero;
                        gd3d.math.quatLookat(localOrgin, localRandomDirection, this.rotationByShape);
                        let initRot = gd3d.math.pool.new_quaternion();
                        gd3d.math.quatFromEulerAngles(90, 0, 90, initRot);
                        gd3d.math.quatMultiply(this.rotationByShape, initRot, this.rotationByShape);
                        gd3d.math.quatClone(this.rotationByShape, this.localRotation);
                        gd3d.math.pool.delete_quaternion(initRot);
                    }
                }
                if (!this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = new gd3d.math.matrix();
                    var mat = this.emisson.getmatrixToWorld();
                    gd3d.math.matrixClone(mat, this.emissionMatToWorld);
                    this.emissionWorldRotation = new gd3d.math.quaternion();
                    var quat = this.emisson.getWorldRotation();
                    gd3d.math.quatClone(quat, this.emissionWorldRotation);
                }
            }
            update(delta) {
                if (!this.actived)
                    return;
                this.curLife += delta;
                if (this.curLife >= this.totalLife) {
                    gd3d.math.matrixZero(this.transformVertex);
                    this._updateVBO();
                    this.emisson.deadParticles.push(this);
                    this.curLife = 0;
                    this.actived = false;
                    return;
                }
                this._updatePos(delta);
                this._updateScale(delta);
                this._updateEuler(delta);
                this._updateRotation(delta);
                this._updateLocalMatrix(delta);
                this._updateColor(delta);
                this._updateAlpha(delta);
                this._updateUV(delta);
                this._updateVBO();
            }
            _updateLocalMatrix(delta) {
                gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.emisson.simulateInLocalSpace) {
                    gd3d.math.matrixMultiply(this.emisson.matToBatcher, this.localMatrix, this.transformVertex);
                }
                else {
                    gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            }
            refreshEmissionData() {
                if (this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = this.emisson.getmatrixToWorld();
                    this.emissionWorldRotation = this.emisson.getWorldRotation();
                }
            }
            _updateRotation(delta) {
                this._updateElementRotation();
            }
            _updateElementRotation() {
                if (this.renderModel != framework.RenderModel.Mesh) {
                    this.refreshEmissionData();
                    let translation = gd3d.math.pool.new_vector3();
                    let worldTranslation = gd3d.math.pool.new_vector3();
                    let worldRotation = gd3d.math.pool.new_quaternion();
                    let invTransformRotation = gd3d.math.pool.new_quaternion();
                    gd3d.math.vec3Clone(this.localTranslate, translation);
                    var cam = this.batcher.emissionElement.renderCamera;
                    if (cam == null) {
                        cam = gd3d.framework.sceneMgr.app.getScene().mainCamera;
                    }
                    var camPosInWorld = cam.gameObject.transform.getWorldTranslate();
                    gd3d.math.matrixTransformVector3(translation, this.emissionMatToWorld, worldTranslation);
                    if (this.renderModel == framework.RenderModel.BillBoard) {
                        gd3d.math.quatLookat(worldTranslation, camPosInWorld, worldRotation);
                    }
                    else if (this.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.renderModel == framework.RenderModel.VerticalBillBoard) {
                        let forwardTarget = gd3d.math.pool.new_vector3();
                        gd3d.math.vec3Clone(camPosInWorld, forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        gd3d.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        gd3d.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.renderModel == framework.RenderModel.StretchedBillBoard) {
                        gd3d.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                        gd3d.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.matToworld);
                        var xaxis = gd3d.math.pool.new_vector3();
                        var yaxis = gd3d.math.pool.new_vector3();
                        var zaxis = gd3d.math.pool.new_vector3();
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_right, this.matToworld, xaxis);
                        gd3d.math.vec3Normalize(xaxis, xaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_up, this.matToworld, yaxis);
                        gd3d.math.vec3Normalize(yaxis, yaxis);
                        gd3d.math.matrixTransformNormal(gd3d.math.pool.vector3_forward, this.matToworld, zaxis);
                        gd3d.math.vec3Normalize(zaxis, zaxis);
                        framework.EffectUtil.lookatbyXAxis(worldTranslation, xaxis, yaxis, zaxis, camPosInWorld, worldRotation);
                        gd3d.math.quatMultiply(this.localRotation, worldRotation, this.localRotation);
                        gd3d.math.pool.delete_quaternion(worldRotation);
                        gd3d.math.pool.delete_vector3(translation);
                        gd3d.math.pool.delete_quaternion(invTransformRotation);
                        gd3d.math.pool.delete_vector3(xaxis);
                        gd3d.math.pool.delete_vector3(yaxis);
                        gd3d.math.pool.delete_vector3(zaxis);
                        return;
                    }
                    gd3d.math.quatClone(this.emissionWorldRotation, invTransformRotation);
                    gd3d.math.quatInverse(invTransformRotation, invTransformRotation);
                    gd3d.math.quatMultiply(invTransformRotation, worldRotation, this.localRotation);
                    gd3d.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                    gd3d.math.pool.delete_vector3(translation);
                    gd3d.math.pool.delete_vector3(worldTranslation);
                    gd3d.math.pool.delete_quaternion(worldRotation);
                    gd3d.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    gd3d.math.quatClone(this.rotationByEuler, this.localRotation);
                }
            }
            _updatePos(delta) {
                if (this.data.moveSpeed != undefined) {
                    this.localTranslate.x += this.movespeed.x * delta;
                    this.localTranslate.y += this.movespeed.y * delta;
                    this.localTranslate.z += this.movespeed.z * delta;
                }
                let currentTranslate = framework.EffectUtil.vecMuliNum(this.speedDir, this.simulationSpeed);
                gd3d.math.vec3Add(this.localTranslate, currentTranslate, this.localTranslate);
            }
            _updateEuler(delta) {
                let index = 0;
                if (this.data.eulerNodes != undefined && this.data.eulerSpeed != undefined) {
                    console.error("scale只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.eulerNodes != undefined) {
                    this._updateNode(this.data.eulerNodes, this.totalLife, this.euler);
                    gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                }
                else if (this.data.eulerSpeed != undefined) {
                    if (this.data.eulerSpeed.x != undefined)
                        this.euler.x += this.data.eulerSpeed.x.getValue() * delta;
                    if (this.data.eulerSpeed.y != undefined)
                        this.euler.y += this.data.eulerSpeed.y.getValue() * delta;
                    if (this.data.eulerSpeed.z != undefined)
                        this.euler.z += this.data.eulerSpeed.z.getValue() * delta;
                    gd3d.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                }
            }
            _updateScale(delta) {
                let index = 0;
                if (this.data.scaleNodes != undefined && this.data.scaleSpeed != undefined) {
                    console.error("scale只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.scaleNodes != undefined) {
                    this._updateNode(this.data.scaleNodes, this.totalLife, this.localScale, nodeType.scale);
                }
                else if (this.data.scaleSpeed != undefined) {
                    if (this.data.scaleSpeed.x != undefined)
                        this.localScale.x += this.data.scaleSpeed.x.getValue() * delta;
                    if (this.data.scaleSpeed.y != undefined)
                        this.localScale.y += this.data.scaleSpeed.y.getValue() * delta;
                    if (this.data.scaleSpeed.z != undefined)
                        this.localScale.z += this.data.scaleSpeed.z.getValue() * delta;
                }
            }
            _updateColor(delta) {
                let index = 0;
                if (this.data.colorNodes != undefined && this.data.colorSpeed != undefined) {
                    console.error("color只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.colorNodes != undefined) {
                    this._updateNode(this.data.colorNodes, this.totalLife, this.color);
                }
                else if (this.data.colorSpeed != undefined) {
                    if (this.data.colorSpeed.x != undefined)
                        this.color.x += this.data.colorSpeed.x.getValue() * delta;
                    if (this.data.colorSpeed.y != undefined)
                        this.color.y += this.data.colorSpeed.y.getValue() * delta;
                    if (this.data.colorSpeed.z != undefined)
                        this.color.z += this.data.colorSpeed.z.getValue() * delta;
                }
            }
            _updateNode(nodes, life, out, nodetype = nodeType.none) {
                let index = 0;
                var duration = 0;
                if (nodes != undefined) {
                    for (var i = 0; i < nodes.length; i++) {
                        if (i + 1 < nodes.length) {
                            if (nodes[i].key * life <= this.curLife && nodes[i + 1].key * life >= this.curLife) {
                                this.tempStartNode = nodes[i];
                                this.tempEndNode = nodes[i + 1];
                                index++;
                                duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                                break;
                            }
                        }
                        else {
                            if (this.curLife < nodes[i].key * life) {
                                this.tempStartNode = nodes[i - 1];
                                this.tempEndNode = nodes[i];
                                duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                            }
                        }
                    }
                    if (this.tempStartNode instanceof framework.ParticleNode) {
                        if (duration > 0) {
                            gd3d.math.vec3SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                    else if (this.tempStartNode instanceof framework.ParticleNodeNumber) {
                        if (duration > 0) {
                            if (nodetype == nodeType.alpha) {
                                this.alpha = gd3d.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                            }
                            else if (nodetype = nodeType.scale) {
                                var targetscale = gd3d.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                                gd3d.math.vec3ScaleByNum(this.startScale, targetscale, out);
                            }
                        }
                    }
                    else if (this.tempStartNode instanceof framework.UVSpeedNode) {
                        if (duration > 0) {
                            gd3d.math.vec2SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                }
            }
            _updateAlpha(delta) {
                let index = 0;
                if (this.data.alphaNodes != undefined && this.data.alphaSpeed != undefined) {
                    console.error("color只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.alphaNodes != undefined) {
                    this._updateNode(this.data.alphaNodes, this.totalLife, this.alpha, nodeType.alpha);
                }
                else if (this.data.alphaSpeed != undefined) {
                    this.alpha += this.data.alphaSpeed.getValue() * delta;
                }
            }
            _updateUV(delta) {
                if (this.uv == undefined)
                    this.uv = new gd3d.math.vector2();
                if (this.data.uvType == framework.UVTypeEnum.NONE) {
                    this.uv = this.data.uv.getValue();
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVRoll) {
                    if (this.data.uvRoll != undefined) {
                        if (this.data.uvRoll.uvSpeedNodes != undefined && this.data.uvRoll.uvSpeed != undefined) {
                            console.error("uv只能通过插值或者speed来修改，不能两个同时存在！");
                            return;
                        }
                        let index = 0;
                        if (this.data.uvRoll.uvSpeedNodes != undefined) {
                            this._updateNode(this.data.uvRoll.uvSpeedNodes, this.totalLife, this.uv);
                        }
                        else if (this.data.uvRoll.uvSpeed != undefined) {
                            if (this.data.uvRoll.uvSpeed.u != undefined)
                                this.tex_ST.z += this.data.uvRoll.uvSpeed.u.getValue() * delta;
                            if (this.data.uvRoll.uvSpeed.v != undefined)
                                this.tex_ST.w += this.data.uvRoll.uvSpeed.v.getValue() * delta;
                        }
                    }
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVSprite) {
                    if (this.data.uvSprite != undefined) {
                        var spriteindex = Math.floor(this.curLife / this.totalLife * this.data.uvSprite.totalCount);
                        gd3d.math.spriteAnimation(this.data.uvSprite.row, this.data.uvSprite.column, spriteindex, this.tex_ST);
                    }
                }
            }
            _updateVBO() {
                let vertexSize = this.vertexSize;
                for (let i = 0; i < this.vertexCount; i++) {
                    {
                        let vertex = gd3d.math.pool.new_vector3();
                        vertex.x = this.sourceVbo[i * vertexSize + 0];
                        vertex.y = this.sourceVbo[i * vertexSize + 1];
                        vertex.z = this.sourceVbo[i * vertexSize + 2];
                        gd3d.math.matrixTransformVector3(vertex, this.transformVertex, vertex);
                        this.dataForVbo[i * vertexSize + 0] = vertex.x;
                        this.dataForVbo[i * vertexSize + 1] = vertex.y;
                        this.dataForVbo[i * vertexSize + 2] = vertex.z;
                        gd3d.math.pool.delete_vector3(vertex);
                    }
                    {
                        let r = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 3], 0, 1);
                        let g = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 4], 0, 1);
                        let b = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 5], 0, 1);
                        let a = gd3d.math.floatClamp(this.sourceVbo[i * vertexSize + 6], 0, 1);
                        if (this.color != undefined) {
                            r = this.color.x;
                            g = this.color.y;
                            b = this.color.z;
                        }
                        if (this.alpha != undefined)
                            a = this.alpha;
                        if (this.colorRate != undefined) {
                            r *= this.colorRate;
                            g *= this.colorRate;
                            b *= this.colorRate;
                            a *= this.colorRate;
                        }
                        r = gd3d.math.floatClamp(r, 0, 3);
                        g = gd3d.math.floatClamp(g, 0, 3);
                        b = gd3d.math.floatClamp(b, 0, 3);
                        a = gd3d.math.floatClamp(a, 0, 3);
                        this.dataForVbo[i * this.vertexSize + 3] = r;
                        this.dataForVbo[i * this.vertexSize + 4] = g;
                        this.dataForVbo[i * this.vertexSize + 5] = b;
                        this.dataForVbo[i * this.vertexSize + 6] = a;
                    }
                    {
                        this.dataForVbo[i * vertexSize + 7] = this.sourceVbo[i * vertexSize + 7] * this.tex_ST.x + this.tex_ST.z;
                        this.dataForVbo[i * vertexSize + 8] = this.sourceVbo[i * vertexSize + 8] * this.tex_ST.y + this.tex_ST.w;
                    }
                }
            }
            dispose() {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.startRotation = null;
                this.localRotation = null;
                this.rotationByEuler = null;
                this.rotationByShape = null;
                this.tilling = null;
                this.localMatrix = null;
                this.localTranslate = null;
                this.euler = null;
                this.localScale = null;
                this.colorRate = 1;
                this.color = null;
                this.uv = null;
            }
        }
        framework.Particle = Particle;
        let nodeType;
        (function (nodeType) {
            nodeType[nodeType["none"] = 0] = "none";
            nodeType[nodeType["alpha"] = 1] = "alpha";
            nodeType[nodeType["scale"] = 2] = "scale";
        })(nodeType = framework.nodeType || (framework.nodeType = {}));
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class Particles {
            constructor(sys) {
                this.emissionElements = [];
                this.vf = gd3d.render.VertexFormatMask.Position | gd3d.render.VertexFormatMask.Color | gd3d.render.VertexFormatMask.UV0;
                this.effectSys = sys;
            }
            addEmission(_emissionNew) {
                let _emissionElement = new EmissionElement(_emissionNew, this.effectSys, this);
                this.emissionElements.push(_emissionElement);
            }
            updateForEmission(delta) {
                for (let key in this.emissionElements) {
                    this.emissionElements[key].updateForEmission(delta);
                }
            }
            update(delta) {
                for (let key in this.emissionElements) {
                    this.emissionElements[key].update(delta);
                }
            }
            render(context, assetmgr, camera) {
                for (let key in this.emissionElements) {
                    this.emissionElements[key].render(context, assetmgr, camera);
                }
            }
            dispose() {
                for (let key in this.emissionElements) {
                    this.emissionElements[key].dispose();
                }
                this.emissionElements.length = 0;
            }
        }
        framework.Particles = Particles;
        class EmissionElement {
            constructor(_emission, sys, mgr) {
                this.maxVertexCount = 2048;
                this.localtranslate = new gd3d.math.vector3();
                this.localScale = new gd3d.math.vector3(1, 1, 1);
                this.localrotate = new gd3d.math.quaternion();
                this.eluerAngle = new gd3d.math.quaternion();
                this.beloop = false;
                this.simulateInLocalSpace = true;
                this.active = true;
                this.isover = false;
                this.worldRotation = new gd3d.math.quaternion();
                this.matToBatcher = new gd3d.math.matrix();
                this.matToWorld = new gd3d.math.matrix();
                this.testtime = 0;
                this.webgl = gd3d.framework.sceneMgr.app.webgl;
                this.effectSys = sys;
                this.ParticleMgr = mgr;
                this.vf = mgr.vf;
                this.gameObject = mgr.effectSys.gameObject;
                this.beloop = _emission.beloop;
                this.emissionData = _emission.emissionData;
                this.perVertexCount = this.emissionData.mesh.data.pos.length;
                this.perIndexxCount = this.emissionData.mesh.data.trisindex.length;
                this.simulateInLocalSpace = this.emissionData.simulateInLocalSpace;
                switch (this.emissionData.emissionType) {
                    case framework.ParticleEmissionType.burst:
                        break;
                    case framework.ParticleEmissionType.continue:
                        this._continueSpaceTime = this.emissionData.time / (this.emissionData.emissionCount);
                        break;
                }
                gd3d.math.vec3Clone(this.emissionData.rootpos, this.localtranslate);
                gd3d.math.vec3Clone(this.emissionData.rootRotAngle, this.eluerAngle);
                gd3d.math.vec3Clone(this.emissionData.rootScale, this.localScale);
                gd3d.math.quatFromEulerAngles(this.eluerAngle.x, this.eluerAngle.y, this.eluerAngle.z, this.localrotate);
                gd3d.math.matrixMakeTransformRTS(this.localtranslate, this.localScale, this.localrotate, this.matToBatcher);
                this.emissionBatchers = [];
                this.deadParticles = [];
                this.curTime = 0;
                this.numcount = 0;
                this.addBatcher();
            }
            getWorldRotation() {
                var parRot = this.gameObject.transform.getWorldRotate();
                gd3d.math.quatMultiply(parRot, this.localrotate, this.worldRotation);
                return this.worldRotation;
            }
            getmatrixToWorld() {
                var mat = this.gameObject.transform.getWorldMatrix();
                gd3d.math.matrixMultiply(mat, this.matToBatcher, this.matToWorld);
                return this.matToWorld;
            }
            update(delta) {
                this.updateBatcher(delta);
            }
            updateForEmission(delta) {
                this.testtime += delta;
                this.curTime += delta;
                this.updateEmission(delta);
            }
            updateBatcher(delta) {
                for (let key in this.emissionBatchers) {
                    this.emissionBatchers[key].update(delta);
                }
            }
            updateEmission(delta) {
                if (this.isover)
                    return;
                if (this.emissionData.emissionType == framework.ParticleEmissionType.continue) {
                    var rate = this.curTime / this.emissionData.time;
                    rate = gd3d.math.floatClamp(rate, 0, 1);
                    var needCount = Math.floor(rate * this.emissionData.emissionCount);
                    needCount = needCount - this.numcount;
                    for (var i = 0; i < needCount; i++) {
                        this.addParticle();
                        this.numcount++;
                    }
                    if (rate == 1) {
                        if (this.beloop) {
                            this.curTime = 0;
                            this.numcount = 0;
                            this.isover = false;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
                else if (this.emissionData.emissionType == framework.ParticleEmissionType.burst) {
                    if (this.curTime > this.emissionData.time) {
                        this.addParticle(this.emissionData.emissionCount);
                        if (this.beloop) {
                            this.curTime = 0;
                            this.isover = false;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
            }
            addParticle(count = 1) {
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var particle = this.deadParticles.pop();
                        particle.initByData();
                        particle.update(0);
                        particle.actived = true;
                    }
                    else {
                        var total = this.curbatcher.curVerCount + this.perVertexCount;
                        if (total <= this.maxVertexCount) {
                            this.curbatcher.addParticle();
                        }
                        else {
                            this.addBatcher();
                            this.curbatcher.addParticle();
                        }
                    }
                }
            }
            addBatcher() {
                var batcher = new framework.EmissionBatcher(this);
                this.emissionBatchers.push(batcher);
                this.curbatcher = batcher;
            }
            render(context, assetmgr, camera) {
                this.renderCamera = camera;
                if (this.simulateInLocalSpace) {
                    context.updateModel(this.gameObject.transform);
                }
                else {
                    context.updateModeTrail();
                }
                for (let key in this.emissionBatchers) {
                    this.emissionBatchers[key].render(context, assetmgr, camera);
                }
            }
            dispose() {
                for (let key in this.emissionBatchers) {
                    this.emissionBatchers[key].dispose();
                }
                this.emissionBatchers.length = 0;
            }
            isOver() {
                return this.isover;
            }
        }
        framework.EmissionElement = EmissionElement;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let HideFlags;
        (function (HideFlags) {
            HideFlags[HideFlags["None"] = 0] = "None";
            HideFlags[HideFlags["HideInHierarchy"] = 1] = "HideInHierarchy";
            HideFlags[HideFlags["HideInInspector"] = 2] = "HideInInspector";
            HideFlags[HideFlags["DontSaveInEditor"] = 4] = "DontSaveInEditor";
            HideFlags[HideFlags["NotEditable"] = 8] = "NotEditable";
            HideFlags[HideFlags["DontSaveInBuild"] = 16] = "DontSaveInBuild";
            HideFlags[HideFlags["DontUnloadUnusedAsset"] = 32] = "DontUnloadUnusedAsset";
            HideFlags[HideFlags["DontSave"] = 52] = "DontSave";
            HideFlags[HideFlags["HideAndDontSave"] = 61] = "HideAndDontSave";
        })(HideFlags = framework.HideFlags || (framework.HideFlags = {}));
        let nodeComponent = class nodeComponent {
            constructor(comp, init = false) {
                this.comp = comp;
                this.init = init;
            }
        };
        __decorate([
            gd3d.reflect.Field("INodeComponent"),
            __metadata("design:type", Object)
        ], nodeComponent.prototype, "comp", void 0);
        nodeComponent = __decorate([
            gd3d.reflect.SerializeType,
            __metadata("design:paramtypes", [Object, Boolean])
        ], nodeComponent);
        framework.nodeComponent = nodeComponent;
        let gameObject = class gameObject {
            constructor() {
                this.layer = framework.cullingmaskutil.maskTolayer(framework.CullingMask.default);
                this.tag = framework.StringUtil.builtinTag_Untagged;
                this.hideFlags = HideFlags.None;
                this.isStatic = false;
                this.components = [];
                this.componentsInit = [];
                this._visible = true;
            }
            getScene() {
                return this.transform.scene;
            }
            get visibleInScene() {
                let obj = this;
                while (obj.visible && obj.transform.parent) {
                    obj = obj.transform.parent.gameObject;
                }
                return obj.visible;
            }
            get visible() {
                return this._visible;
            }
            ;
            set visible(val) {
                if (val != this._visible) {
                    this._visible = val;
                    framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.ChangeVisible);
                }
            }
            getName() {
                return this.transform.name;
            }
            init(onPlay = false) {
                if (this.componentsInit.length > 0) {
                    for (var i = 0; i < this.componentsInit.length; i++) {
                        this.componentsInit[i].comp.start();
                        this.componentsInit[i].init = true;
                        if (onPlay)
                            this.componentsInit[i].comp.onPlay();
                    }
                    this.componentsInit.length = 0;
                }
            }
            update(delta) {
                if (this.components.length == 0)
                    return;
                for (var i = 0; i < this.components.length; i++) {
                    this.components[i].comp.update(delta);
                }
            }
            addComponentDirect(comp) {
                this.transform.markHaveComponent();
                if (comp.gameObject != null) {
                    throw new Error("this components has added to a  gameObject");
                }
                comp.gameObject = this;
                let nodeObj = new nodeComponent(comp, false);
                let add = true;
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "effectbatcher") == "1") {
                    if (this.renderer == null) {
                        this.renderer = comp;
                        this.transform.markHaveRendererComp();
                    }
                    else {
                        add = false;
                        console.warn("已经有一个渲染器的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    if (this.camera == null) {
                        this.camera = comp;
                    }
                    else {
                        add = false;
                        console.warn("已经有一个摄像机的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "light") == "1") {
                    if (this.light == null) {
                        this.light = comp;
                        console.warn("add light:" + this.transform.name);
                    }
                    else {
                        add = false;
                        console.warn("已经有一个灯光的组件了，不能俩");
                    }
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1") {
                    if (this.collider == null) {
                        this.collider = comp;
                    }
                    else {
                        add = false;
                        console.warn("已经有一个碰撞盒的组件了，不能俩");
                    }
                }
                if (add) {
                    this.components.push(nodeObj);
                    this.componentsInit.push(nodeObj);
                    if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1")
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.AddCamera);
                    if (gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1")
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.AddCanvasRender);
                }
                return comp;
            }
            getComponent(type) {
                for (var i = 0; i < this.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return this.components[i].comp;
                    }
                }
                return null;
            }
            getComponents() {
                let components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            }
            getComponentsInChildren(type) {
                let components = [];
                this._getComponentsInChildren(type, this, components);
                return components;
            }
            _getComponentsInChildren(type, obj, array) {
                for (var i = 0; i < obj.components.length; i++) {
                    var cname = gd3d.reflect.getClassName(obj.components[i].comp["__proto__"]);
                    if (cname == type) {
                        array.push(obj.components[i].comp);
                    }
                }
                for (let i = 0; obj.transform.children != undefined && i < obj.transform.children.length; i++) {
                    let _obj = obj.transform.children[i].gameObject;
                    this._getComponentsInChildren(type, _obj, array);
                }
            }
            getComponentInParent(type) {
                let result = null;
                let _parent = this.transform.parent;
                while (result == null && _parent != null) {
                    result = _parent.gameObject.getComponent(type);
                    _parent = _parent.parent;
                }
                return result;
            }
            addComponent(type) {
                for (var key in this.components) {
                    var st = this.components[key]["comp"]["constructor"]["name"];
                    if (st == type) {
                        throw new Error("已经有一个" + type + "的组件了，不能俩");
                    }
                }
                var pp = gd3d.reflect.getPrototype(type);
                var comp = gd3d.reflect.createInstance(pp, { "nodecomp": "1" });
                return this.addComponentDirect(comp);
            }
            removeComponent(comp) {
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        if (this.components[i].init) {
                            this.components[i].comp.remove();
                        }
                        this.remove(this.components[i].comp);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            }
            remove(comp) {
                if (gd3d.reflect.getClassTag(comp["__proto__"], "renderer") == "1") {
                    this.renderer = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "camera") == "1") {
                    this.camera = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "light") == "1") {
                    this.light = null;
                }
                if (gd3d.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || gd3d.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1") {
                    this.collider = null;
                }
            }
            removeComponentByTypeName(type) {
                for (var i = 0; i < this.components.length; i++) {
                    if (gd3d.reflect.getClassName(this.components[i].comp) == type) {
                        if (this.components[i].init) {
                            this.components[i].comp.remove();
                        }
                        this.remove(this.components[i].comp);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            }
            removeAllComponents() {
                for (var i = 0; i < this.components.length; i++) {
                    {
                        this.components[i].comp.remove();
                    }
                    this.remove(this.components[i].comp);
                }
                this.components.length = 0;
            }
            dispose() {
                this.removeAllComponents();
            }
        };
        __decorate([
            gd3d.reflect.Field("number"),
            gd3d.reflect.UIStyle("enum"),
            __metadata("design:type", Number)
        ], gameObject.prototype, "layer", void 0);
        __decorate([
            gd3d.reflect.Field("string"),
            __metadata("design:type", String)
        ], gameObject.prototype, "tag", void 0);
        __decorate([
            gd3d.reflect.Field("number"),
            __metadata("design:type", Number)
        ], gameObject.prototype, "hideFlags", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Boolean)
        ], gameObject.prototype, "isStatic", void 0);
        __decorate([
            gd3d.reflect.Field("nodeComponent[]"),
            __metadata("design:type", Array)
        ], gameObject.prototype, "components", void 0);
        __decorate([
            gd3d.reflect.Field("boolean"),
            __metadata("design:type", Object)
        ], gameObject.prototype, "_visible", void 0);
        gameObject = __decorate([
            gd3d.reflect.SerializeType
        ], gameObject);
        framework.gameObject = gameObject;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class renderContext {
            constructor(webgl) {
                this.viewPortPixel = new gd3d.math.rect(0, 0, 0, 0);
                this.eyePos = new gd3d.math.vector4();
                this.matrixView = new gd3d.math.matrix();
                this.matrixProject = new gd3d.math.matrix();
                this.matrixModel = new gd3d.math.matrix();
                this._matrixWorld2Object = new gd3d.math.matrix();
                this.matrixModelViewProject = new gd3d.math.matrix;
                this.matrixModelView = new gd3d.math.matrix;
                this.matrixViewProject = new gd3d.math.matrix;
                this.floatTimer = 0;
                this.intLightCount = 0;
                this.vec4LightPos = new Float32Array(32);
                this.vec4LightDir = new Float32Array(32);
                this.vec4LightColor = new Float32Array(32);
                this.floatLightRange = new Float32Array(8);
                this.floatLightIntensity = new Float32Array(8);
                this.floatLightSpotAngleCos = new Float32Array(8);
                this._intLightCount = 0;
                this._lightCullingMask = [];
                this._vec4LightPos = new Float32Array(32);
                this._vec4LightDir = new Float32Array(32);
                this._vec4LightColor = new Float32Array(32);
                this._floatLightRange = new Float32Array(8);
                this._floatLightIntensity = new Float32Array(8);
                this._floatLightSpotAngleCos = new Float32Array(8);
                this.lightmap = null;
                this.lightmapUV = 1;
                this.lightmapOffset = new gd3d.math.vector4(1, 1, 0, 0);
                this.webgl = webgl;
            }
            get matrixWorld2Object() {
                gd3d.math.matrixInverse(this.matrixModel, this._matrixWorld2Object);
                return this._matrixWorld2Object;
            }
            updateCamera(app, camera) {
                camera.calcViewPortPixel(app, this.viewPortPixel);
                var asp = this.viewPortPixel.w / this.viewPortPixel.h;
                camera.calcViewMatrix(this.matrixView);
                camera.calcProjectMatrix(asp, this.matrixProject);
                gd3d.math.matrixMultiply(this.matrixProject, this.matrixView, this.matrixViewProject);
                this.floatTimer = app.getTotalTime();
                var pso = camera.gameObject.transform.getWorldTranslate();
                this.eyePos.x = pso.x;
                this.eyePos.y = pso.y;
                this.eyePos.z = pso.z;
            }
            updateLights(lights) {
                this._intLightCount = lights.length;
                this._lightCullingMask.length = 0;
                var dirt = gd3d.math.pool.new_vector3();
                for (var i = 0; i < lights.length; i++) {
                    this._lightCullingMask.push(lights[i].cullingMask);
                    {
                        var pos = lights[i].gameObject.transform.getWorldTranslate();
                        this._vec4LightPos[i * 4 + 0] = pos.x;
                        this._vec4LightPos[i * 4 + 1] = pos.y;
                        this._vec4LightPos[i * 4 + 2] = pos.z;
                        this._vec4LightPos[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Direction ? 0 : 1;
                        lights[i].gameObject.transform.getForwardInWorld(dirt);
                        this._vec4LightDir[i * 4 + 0] = dirt.x;
                        this._vec4LightDir[i * 4 + 1] = dirt.y;
                        this._vec4LightDir[i * 4 + 2] = dirt.z;
                        this._vec4LightDir[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Point ? 0 : 1;
                        this._floatLightSpotAngleCos[i] = lights[i].spotAngelCos;
                        this._vec4LightColor[i * 4 + 0] = lights[i].color.r;
                        this._vec4LightColor[i * 4 + 1] = lights[i].color.g;
                        this._vec4LightColor[i * 4 + 2] = lights[i].color.b;
                        this._vec4LightColor[i * 4 + 3] = lights[i].color.a;
                        this._floatLightRange[i] = lights[i].range;
                        this._floatLightIntensity[i] = lights[i].intensity;
                    }
                }
                gd3d.math.pool.delete_vector3(dirt);
            }
            updateOverlay() {
                gd3d.math.matrixMakeIdentity(this.matrixModelViewProject);
            }
            updateModel(model) {
                gd3d.math.matrixClone(model.getWorldMatrix(), this.matrixModel);
                gd3d.math.matrixMultiply(this.matrixViewProject, this.matrixModel, this.matrixModelViewProject);
            }
            updateModeTrail() {
                gd3d.math.matrixClone(this.matrixView, this.matrixModelView);
                gd3d.math.matrixClone(this.matrixViewProject, this.matrixModelViewProject);
            }
            updateLightMask(layer) {
                this.intLightCount = 0;
                if (this._intLightCount == 0)
                    return;
                let num = 1 << layer;
                let indexList = [];
                for (var i = 0; i < this._lightCullingMask.length; i++) {
                    let mask = this._lightCullingMask[i];
                    if (mask & num)
                        indexList.push(i);
                }
                this.intLightCount = indexList.length;
                for (var i = 0; i < indexList.length; i++) {
                    let idx = indexList[i];
                    this.floatLightSpotAngleCos[i] = this._floatLightSpotAngleCos[idx];
                    this.floatLightRange[i] = this._floatLightRange[idx];
                    this.floatLightIntensity[i] = this._floatLightIntensity[idx];
                    this.vec4LightPos[i * 4 + 0] = this._vec4LightPos[idx * 4 + 0];
                    this.vec4LightPos[i * 4 + 1] = this._vec4LightPos[idx * 4 + 1];
                    this.vec4LightPos[i * 4 + 2] = this._vec4LightPos[idx * 4 + 2];
                    this.vec4LightPos[i * 4 + 3] = this._vec4LightPos[idx * 4 + 3];
                    this.vec4LightDir[i * 4 + 0] = this._vec4LightDir[idx * 4 + 0];
                    this.vec4LightDir[i * 4 + 1] = this._vec4LightDir[idx * 4 + 1];
                    this.vec4LightDir[i * 4 + 2] = this._vec4LightDir[idx * 4 + 2];
                    this.vec4LightDir[i * 4 + 3] = this._vec4LightDir[idx * 4 + 3];
                    this.vec4LightColor[i * 4 + 0] = this._vec4LightColor[idx * 4 + 0];
                    this.vec4LightColor[i * 4 + 1] = this._vec4LightColor[idx * 4 + 1];
                    this.vec4LightColor[i * 4 + 2] = this._vec4LightColor[idx * 4 + 2];
                    this.vec4LightColor[i * 4 + 3] = this._vec4LightColor[idx * 4 + 3];
                }
            }
        }
        framework.renderContext = renderContext;
        let RenderLayerEnum;
        (function (RenderLayerEnum) {
            RenderLayerEnum[RenderLayerEnum["Common"] = 0] = "Common";
            RenderLayerEnum[RenderLayerEnum["Transparent"] = 1] = "Transparent";
            RenderLayerEnum[RenderLayerEnum["Overlay"] = 2] = "Overlay";
        })(RenderLayerEnum = framework.RenderLayerEnum || (framework.RenderLayerEnum = {}));
        class renderList {
            constructor() {
                this.renderLayers = [];
                var common = new renderLayer(true);
                var transparent = new renderLayer(true);
                var overlay = new renderLayer(true);
                this.renderLayers.push(common);
                this.renderLayers.push(transparent);
                this.renderLayers.push(overlay);
            }
            clear() {
                for (var i = 0; i < this.renderLayers.length; i++) {
                    this.renderLayers[i].list.length = 0;
                }
            }
            addRenderer(renderer) {
                if (renderer.layer == RenderLayerEnum.Common) {
                    this.renderLayers[0].list.push(renderer);
                }
                else if (renderer.layer == RenderLayerEnum.Transparent) {
                    this.renderLayers[1].list.push(renderer);
                }
                else if (renderer.layer == RenderLayerEnum.Overlay) {
                    this.renderLayers[2].list.push(renderer);
                }
            }
        }
        framework.renderList = renderList;
        class renderLayer {
            constructor(_sort = false) {
                this.needSort = false;
                this.list = [];
                this.needSort = _sort;
            }
        }
        framework.renderLayer = renderLayer;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class scene {
            constructor(app) {
                this.renderCameras = [];
                this._mainCamera = null;
                this.renderContext = [];
                this.renderLights = [];
                this.lightmaps = [];
                this.RealCameraNumber = 0;
                this.hasPlayed = false;
                this.playDirty = false;
                this.app = app;
                this.webgl = app.webgl;
                this.assetmgr = app.getAssetMgr();
                this.rootNode = new framework.transform();
                this.rootNode.scene = this;
                this.renderList = new framework.renderList();
            }
            addScreenSpaceOverlay(overlay) {
                if (!overlay)
                    return;
                if (!this._overlay2d)
                    this._overlay2d = [];
                if (this._overlay2d.indexOf(overlay) != -1)
                    return;
                this._overlay2d.push(overlay);
                this.sortOverLays(this._overlay2d);
            }
            removeScreenSpaceOverlay(overlay) {
                if (!overlay || !this._overlay2d)
                    return;
                let idx = this._overlay2d.indexOf(overlay);
                if (idx != -1)
                    this._overlay2d.splice(idx, 1);
                this.sortOverLays(this._overlay2d);
            }
            get mainCamera() {
                if (this._mainCamera == null) {
                    this._mainCamera = this.renderCameras[0];
                }
                return this._mainCamera;
            }
            set mainCamera(_camera) {
                for (let i in this.renderCameras) {
                    if (this.renderCameras[i] == _camera) {
                        this._mainCamera = _camera;
                    }
                }
            }
            update(delta) {
                this.rootNode.updateTran(false);
                this.rootNode.updateAABBChild();
                this.renderCameras.length = 0;
                this.renderLights.length = 0;
                this.renderList.clear();
                framework.aniplayer.playerCaches = [];
                this.updateScene(this.rootNode, delta);
                if (this.renderCameras.length > 1) {
                    this.renderCameras.sort((a, b) => {
                        return a.order - b.order;
                    });
                }
                this.RealCameraNumber = 0;
                for (var i = 0; i < this.renderCameras.length; i++) {
                    gd3d.render.glDrawPass.resetLastState();
                    this._renderCamera(i);
                }
                this.updateSceneOverLay(delta);
                if (this.RealCameraNumber == 0) {
                    this.webgl.clearColor(0, 0, 0, 1);
                    this.webgl.clearDepth(1.0);
                    this.webgl.clear(this.webgl.COLOR_BUFFER_BIT | this.webgl.DEPTH_BUFFER_BIT);
                }
                this.webgl.flush();
            }
            updateSceneOverLay(delta) {
                if (!this._overlay2d || this._overlay2d.length < 1)
                    return;
                let targetcamera = this.mainCamera;
                if (!this._overlay2d || !targetcamera)
                    return;
                let mainCamIdx = this.renderCameras.indexOf(targetcamera);
                if (mainCamIdx == -1) {
                    let cname = targetcamera.gameObject.getName();
                    let oktag = false;
                    for (var i = 0; i < this.renderCameras.length; i++) {
                        let cam = this.renderCameras[i];
                        if (cam && cam.gameObject.getName() == cname) {
                            targetcamera = this.mainCamera = cam;
                            oktag = true;
                            break;
                        }
                    }
                    if (!oktag) {
                        this._mainCamera = null;
                        targetcamera = this.mainCamera;
                    }
                }
                mainCamIdx = this.renderCameras.indexOf(targetcamera);
                if (!targetcamera)
                    return;
                if (this._overlay2d) {
                    this._overlay2d.forEach(overlay => {
                        if (overlay) {
                            overlay.start(targetcamera);
                            overlay.update(delta);
                            overlay.render(this.renderContext[mainCamIdx], this.assetmgr, targetcamera);
                        }
                    });
                }
            }
            _renderCamera(camindex) {
                var cam = this.renderCameras[camindex];
                var context = this.renderContext[camindex];
                if (this.app.bePlay && cam.gameObject.transform.name.toLowerCase().indexOf("editor") < 0) {
                    context.updateCamera(this.app, cam);
                    context.updateLights(this.renderLights);
                    cam.fillRenderer(this);
                    cam.renderScene(this, context);
                    this.RealCameraNumber++;
                    let overLays = cam.getOverLays();
                    for (var i = 0; i < overLays.length; i++) {
                        if (cam.CullingMask & framework.CullingMask.ui) {
                            overLays[i].render(context, this.assetmgr, cam);
                        }
                    }
                }
                else if (!this.app.bePlay && cam.gameObject.transform.name.toLowerCase().indexOf("editor") >= 0) {
                    context.updateCamera(this.app, cam);
                    context.updateLights(this.renderLights);
                    cam.fillRenderer(this);
                    cam.renderScene(this, context);
                    this.RealCameraNumber++;
                    if (this.app.be2dstate) {
                        let overLays = cam.getOverLays();
                        for (var i = 0; i < overLays.length; i++) {
                            if (cam.CullingMask & framework.CullingMask.ui) {
                                overLays[i].render(context, this.assetmgr, cam);
                            }
                        }
                    }
                }
                if (!this.app.bePlay && this.app.be2dstate) {
                    if (camindex == this.app.curcameraindex) {
                        let overLays = cam.getOverLays();
                        for (var i = 0; i < overLays.length; i++) {
                            if (cam.CullingMask & framework.CullingMask.ui) {
                                overLays[i].render(context, this.assetmgr, cam);
                            }
                        }
                    }
                }
            }
            sortOverLays(lays) {
                if (!lays || lays.length < 1)
                    return;
                lays.sort((a, b) => {
                    return a.sortOrder - b.sortOrder;
                });
            }
            updateScene(node, delta) {
                if (this.app.bePlay) {
                    if (!this.hasPlayed)
                        this.playDirty = true;
                    this.objupdate(node, delta);
                    this.playDirty = false;
                    this.hasPlayed = true;
                }
                else {
                    this.objupdateInEditor(node, delta);
                }
            }
            objupdateInEditor(node, delta) {
                node.gameObject.init();
                if (node.gameObject.renderer != null) {
                    node.gameObject.renderer.update(delta);
                }
                var c = node.gameObject.camera;
                if (c != null) {
                    node.gameObject.camera.update(delta);
                }
                this.collectCameraAndLight(node);
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.objupdateInEditor(node.children[i], delta);
                    }
                }
            }
            objupdate(node, delta) {
                if (node.hasComponent == false && node.hasComponentChild == false)
                    return;
                node.gameObject.init(this.playDirty);
                if (node.gameObject.components.length > 0) {
                    node.gameObject.update(delta);
                    this.collectCameraAndLight(node);
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.objupdate(node.children[i], delta);
                    }
                }
            }
            collectCameraAndLight(node) {
                var c = node.gameObject.camera;
                if (c != null && c.gameObject.visibleInScene) {
                    this.renderCameras.push(c);
                }
                while (this.renderContext.length < this.renderCameras.length) {
                    this.renderContext.push(new framework.renderContext(this.webgl));
                }
                var l = node.gameObject.light;
                if (l != null && node.gameObject.visible) {
                    this.renderLights.push(l);
                }
            }
            addChild(node) {
                this.rootNode.addChild(node);
            }
            removeChild(node) {
                this.rootNode.removeChild(node);
            }
            getChildren() {
                return this.rootNode.children;
            }
            getChildCount() {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            }
            getChild(index) {
                return this.rootNode.children[index];
            }
            getChildByName(name) {
                let res = this.rootNode.find(name);
                return res;
            }
            getRoot() {
                return this.rootNode;
            }
            pickAll(ray, outInfos, isPickMesh = false, root = this.getRoot(), layermask = NaN) {
                if (!outInfos || !ray)
                    return false;
                let isHited = this.doPick(ray, true, isPickMesh, root, outInfos, layermask);
                return isHited;
            }
            pick(ray, outInfo, isPickMesh = false, root = this.getRoot(), layermask = NaN) {
                if (!outInfo || !ray)
                    return false;
                let isHited = this.doPick(ray, false, isPickMesh, root, outInfo, layermask);
                return isHited;
            }
            doPick(ray, pickall, isPickMesh, root, out, layermask = NaN) {
                let ishited = false;
                var pickedList = new Array();
                if (isPickMesh) {
                    ishited = this.pickMesh(ray, root, pickedList, layermask);
                }
                else {
                    ishited = this.pickCollider(ray, root, pickedList, layermask);
                }
                if (pickedList.length == 0)
                    return ishited;
                if (pickall) {
                    out.length = 0;
                    pickedList.forEach(element => {
                        out.push(element);
                    });
                }
                else {
                    var index = 0;
                    for (var i = 1; i < pickedList.length; i++) {
                        if (pickedList[i].distance < pickedList[index].distance)
                            index = i;
                    }
                    let temp = pickedList.splice(index, 1);
                    out.cloneFrom(temp[0]);
                    pickedList.forEach(element => {
                        gd3d.math.pool.delete_pickInfo(element);
                    });
                    pickedList.length = 0;
                }
                return ishited;
            }
            pickMesh(ray, tran, pickedList, layermask = NaN) {
                let ishited = false;
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return ishited;
                    let canDo = true;
                    if (!isNaN(layermask) && (layermask & (1 << tran.gameObject.layer)) == 0)
                        canDo = false;
                    if (canDo) {
                        var meshFilter = tran.gameObject.getComponent("meshFilter");
                        if (meshFilter != null) {
                            var mesh = meshFilter.getMeshOutput();
                            if (mesh) {
                                let pinfo = gd3d.math.pool.new_pickInfo();
                                let bool = mesh.intersects(ray, tran.getWorldMatrix(), pinfo);
                                if (bool) {
                                    ishited = true;
                                    pickedList.push(pinfo);
                                    pinfo.pickedtran = tran;
                                }
                            }
                        }
                        else {
                            var skinmesh = tran.gameObject.getComponent("skinnedMeshRenderer");
                            if (skinmesh != null) {
                                let pinfo = gd3d.math.pool.new_pickInfo();
                                var bool = skinmesh.intersects(ray, pinfo);
                                if (bool) {
                                    ishited = true;
                                    pickedList.push(pinfo);
                                    pinfo.pickedtran = tran;
                                }
                            }
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        let bool = this.pickMesh(ray, tran.children[i], pickedList, layermask);
                        if (!ishited)
                            ishited = bool;
                    }
                }
                return ishited;
            }
            pickCollider(ray, tran, pickedList, layermask = NaN) {
                let ishited = false;
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return ishited;
                    if (tran.gameObject.collider != null) {
                        let canDo = true;
                        if (!isNaN(layermask) && (layermask & (1 << tran.gameObject.layer)) == 0)
                            canDo = false;
                        if (canDo) {
                            let pinfo = gd3d.math.pool.new_pickInfo();
                            var bool = ray.intersectCollider(tran, pinfo);
                            if (bool) {
                                ishited = true;
                                pickedList.push(pinfo);
                                pinfo.pickedtran = tran;
                            }
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        let bool = this.pickCollider(ray, tran.children[i], pickedList, layermask);
                        if (!ishited)
                            ishited = bool;
                    }
                }
                return ishited;
            }
        }
        framework.scene = scene;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class uniformSetter {
            static initAutouniform() {
                this.autoUniformDic["glstate_matrix_model"] = (context) => {
                    return context.matrixModel;
                };
                this.autoUniformDic["glstate_matrix_world2object"] = (context) => {
                    return context.matrixWorld2Object;
                };
                this.autoUniformDic["glstate_matrix_view"] = (context) => {
                    return context.matrixView;
                };
                this.autoUniformDic["glstate_matrix_project"] = (context) => {
                    return context.matrixProject;
                };
                this.autoUniformDic["glstate_matrix_modelview"] = (context) => {
                    return context.matrixModelView;
                };
                this.autoUniformDic["glstate_matrix_viewproject"] = (context) => {
                    return context.matrixViewProject;
                };
                this.autoUniformDic["glstate_matrix_mvp"] = (context) => {
                    return context.matrixModelViewProject;
                };
                this.autoUniformDic["glstate_timer"] = (context) => {
                    return context.floatTimer;
                };
                this.autoUniformDic["glstate_lightcount"] = (context) => {
                    return context.intLightCount;
                };
                this.autoUniformDic["glstate_vec4_lightposs"] = (context) => {
                    return context.vec4LightPos;
                };
                this.autoUniformDic["glstate_vec4_lightdirs"] = (context) => {
                    return context.vec4LightDir;
                };
                this.autoUniformDic["glstate_vec4_lightcolors"] = (context) => {
                    return context.vec4LightColor;
                };
                this.autoUniformDic["glstate_float_lightrange"] = (context) => {
                    return context.floatLightRange;
                };
                this.autoUniformDic["glstate_float_lightintensity"] = (context) => {
                    return context.floatLightIntensity;
                };
                this.autoUniformDic["glstate_float_spotangelcoss"] = (context) => {
                    return context.floatLightSpotAngleCos;
                };
                this.autoUniformDic["glstate_eyepos"] = (context) => {
                    return context.eyePos;
                };
                this.autoUniformDic["_LightmapTex"] = (context) => {
                    return context.lightmap;
                };
                this.autoUniformDic["glstate_lightmapOffset"] = (context) => {
                    return context.lightmapOffset;
                };
                this.autoUniformDic["glstate_fog_start"] = (context) => {
                    return context.fog._Start;
                };
                this.autoUniformDic["glstate_fog_end"] = (context) => {
                    return context.fog._End;
                };
                this.autoUniformDic["glstate_fog_color"] = (context) => {
                    return context.fog._Color;
                };
                this.autoUniformDic["glstate_vec4_bones"] = (context) => {
                    return context.vec4_bones;
                };
                this.autoUniformDic["glstate_matrix_bones"] = (context) => {
                    return context.matrix_bones;
                };
            }
        }
        uniformSetter.autoUniformDic = {};
        framework.uniformSetter = uniformSetter;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class taskstate {
            constructor() {
                this.finish = false;
                this.error = false;
                this.message = null;
                this.cancel = false;
                this.taskCall = null;
                this.taskInterface = null;
            }
        }
        framework.taskstate = taskstate;
        class taskMgr {
            constructor() {
                this.tasks = [];
                this.laststate = null;
            }
            addTaskCall(task) {
                var st = new taskstate();
                st.taskCall = task;
                this.tasks.push(st);
            }
            addTask(task) {
                var st = new taskstate();
                st.taskInterface = task;
                this.tasks.push(st);
            }
            move(delta) {
                if (this.laststate != null && this.laststate.cancel) {
                    return;
                }
                if (this.laststate != null && this.laststate.finish == false) {
                    return;
                }
                var task = this.tasks.shift();
                if (task == null) {
                    return;
                }
                var state = new taskstate();
                var laststate = this.laststate;
                this.laststate = state;
                if (task.taskInterface == null) {
                    task.taskCall(laststate, state);
                }
                else {
                    task.taskInterface.move(delta, laststate, state);
                }
            }
            cancel() {
                if (this.laststate != null) {
                    this.laststate.cancel = true;
                }
            }
        }
        framework.taskMgr = taskMgr;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var threading;
    (function (threading) {
        class thread {
            constructor() {
                this.callID = 0;
                this.callMap = new Map();
                if (!thread.workerInstance)
                    this.worker = new Worker("lib/gd3d.thread.js");
                else
                    this.worker = thread.workerInstance;
                this.worker.onmessage = (e) => {
                    if (e.data && this.callMap.has(e.data.id))
                        this.callMap.get(e.data.id).resolve(e.data.result);
                };
                this.worker.onerror = (e) => {
                    console.error(e);
                };
            }
            static get Instance() {
                if (!thread.instance)
                    thread.instance = new thread();
                return thread.instance;
            }
            Call(name, data) {
                return __awaiter(this, void 0, void 0, function* () {
                    this.worker.postMessage({
                        handle: name,
                        data: data,
                        id: ++this.callID
                    });
                    return new Promise((resolve) => {
                        this.callMap.set(this.callID, { resolve: resolve });
                    });
                });
            }
        }
        threading.thread = thread;
    })(threading = gd3d.threading || (gd3d.threading = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class aabb {
            constructor(_minimum, _maximum) {
                this.opmin = new gd3d.math.vector3();
                this.opmax = new gd3d.math.vector3();
                this._center = new gd3d.math.vector3();
                this.srcmin = gd3d.math.pool.clone_vector3(_minimum);
                this.srcmax = gd3d.math.pool.clone_vector3(_maximum);
                this.minimum = gd3d.math.pool.clone_vector3(_minimum);
                this.maximum = gd3d.math.pool.clone_vector3(_maximum);
            }
            update(worldmatrix) {
                gd3d.math.matrixGetTranslation(worldmatrix, this.opmin);
                gd3d.math.matrixGetTranslation(worldmatrix, this.opmax);
                if (worldmatrix.rawData[0] > 0) {
                    this.opmin.x += worldmatrix.rawData[0] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[0] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[0] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[0] * this.srcmin.x;
                }
                if (worldmatrix.rawData[1] > 0) {
                    this.opmin.y += worldmatrix.rawData[1] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[1] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[1] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[1] * this.srcmin.y;
                }
                if (worldmatrix.rawData[2] > 0) {
                    this.opmin.z += worldmatrix.rawData[2] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[2] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[2] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[2] * this.srcmin.z;
                }
                if (worldmatrix.rawData[4] > 0) {
                    this.opmin.x += worldmatrix.rawData[4] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[4] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[4] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[4] * this.srcmin.x;
                }
                if (worldmatrix.rawData[5] > 0) {
                    this.opmin.y += worldmatrix.rawData[5] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[5] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[5] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[5] * this.srcmin.y;
                }
                if (worldmatrix.rawData[6] > 0) {
                    this.opmin.z += worldmatrix.rawData[6] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[6] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[6] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[6] * this.srcmin.z;
                }
                if (worldmatrix.rawData[8] > 0) {
                    this.opmin.x += worldmatrix.rawData[8] * this.srcmin.x;
                    this.opmax.x += worldmatrix.rawData[8] * this.srcmax.x;
                }
                else {
                    this.opmin.x += worldmatrix.rawData[8] * this.srcmax.x;
                    this.opmax.x += worldmatrix.rawData[8] * this.srcmin.x;
                }
                if (worldmatrix.rawData[9] > 0) {
                    this.opmin.y += worldmatrix.rawData[9] * this.srcmin.y;
                    this.opmax.y += worldmatrix.rawData[9] * this.srcmax.y;
                }
                else {
                    this.opmin.y += worldmatrix.rawData[9] * this.srcmax.y;
                    this.opmax.y += worldmatrix.rawData[9] * this.srcmin.y;
                }
                if (worldmatrix.rawData[10] > 0) {
                    this.opmin.z += worldmatrix.rawData[10] * this.srcmin.z;
                    this.opmax.z += worldmatrix.rawData[10] * this.srcmax.z;
                }
                else {
                    this.opmin.z += worldmatrix.rawData[10] * this.srcmax.z;
                    this.opmax.z += worldmatrix.rawData[10] * this.srcmin.z;
                }
                this.minimum = gd3d.math.pool.clone_vector3(this.opmin);
                this.maximum = gd3d.math.pool.clone_vector3(this.opmax);
            }
            addVector3(vec) {
                gd3d.math.vec3Max(this.maximum, vec, this.maximum);
                gd3d.math.vec3Max(this.minimum, vec, this.minimum);
            }
            containsVector3(vec) {
                return (vec.x > this.minimum.x) && (vec.x < this.maximum.x) &&
                    (vec.y > this.minimum.y) && (vec.x < this.maximum.y) &&
                    (vec.z > this.minimum.z) && (vec.z < this.maximum.z);
            }
            intersectAABB(aabb) {
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                return true;
            }
            addAABB(aabb) {
                if (aabb != null) {
                    gd3d.math.vec3Max(this.maximum, aabb.maximum, this.maximum);
                    gd3d.math.vec3Min(this.minimum, aabb.minimum, this.minimum);
                }
            }
            get center() {
                gd3d.math.vec3Add(this.maximum, this.minimum, this._center);
                gd3d.math.vec3ScaleByNum(this._center, 0.5, this._center);
                return this._center;
            }
            clear() {
                gd3d.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimum);
                gd3d.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximum);
            }
            clone() {
                var _min = gd3d.math.pool.clone_vector3(this.minimum);
                var _max = gd3d.math.pool.clone_vector3(this.maximum);
                var aabb = new gd3d.framework.aabb(_min, _max);
                return aabb;
            }
            getVec3(vecs) {
                vecs[0] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[1] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[1].z = this.maximum.z;
                vecs[2] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[2].x = this.maximum.x;
                vecs[3] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[3].y = this.minimum.y;
                vecs[4] = gd3d.math.pool.clone_vector3(this.minimum);
                vecs[4].y = this.maximum.y;
                vecs[5] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[5].x = this.minimum.x;
                vecs[6] = gd3d.math.pool.clone_vector3(this.maximum);
                vecs[6].z = this.minimum.z;
                vecs[7] = gd3d.math.pool.clone_vector3(this.maximum);
            }
        }
        framework.aabb = aabb;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class obb {
            constructor() {
                this.vectors = new Array();
            }
            buildByMaxMin(minimum, maximum) {
                this.vectors[0] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[1] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[1].z = maximum.z;
                this.vectors[2] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[2].x = maximum.x;
                this.vectors[3] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[3].y = minimum.y;
                this.vectors[4] = gd3d.math.pool.clone_vector3(minimum);
                this.vectors[4].y = maximum.y;
                this.vectors[5] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[5].x = minimum.x;
                this.vectors[6] = gd3d.math.pool.clone_vector3(maximum);
                this.vectors[6].z = minimum.z;
                this.vectors[7] = gd3d.math.pool.clone_vector3(maximum);
                this.center = new gd3d.math.vector3();
                gd3d.math.vec3Add(maximum, minimum, this.center);
                gd3d.math.vec3ScaleByNum(this.center, 0.5, this.center);
                this.halfsize = new gd3d.math.vector3();
                gd3d.math.vec3Subtract(maximum, minimum, this.halfsize);
                gd3d.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                this.directions = [new gd3d.math.vector3(), new gd3d.math.vector3(), new gd3d.math.vector3()];
            }
            buildByCenterSize(center, size) {
                this.center = gd3d.math.pool.clone_vector3(center);
                this.halfsize = gd3d.math.pool.clone_vector3(size);
                gd3d.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                let hsx = this.halfsize.x;
                let hsy = this.halfsize.y;
                let hsz = this.halfsize.z;
                let cenx = this.center.x;
                let ceny = this.center.y;
                let cenz = this.center.z;
                this.vectors[0] = new gd3d.math.vector3(cenx - hsx, ceny - hsy, cenz - hsz);
                this.vectors[1] = new gd3d.math.vector3(cenx - hsx, ceny - hsy, cenz + hsz);
                this.vectors[2] = new gd3d.math.vector3(cenx + hsx, ceny - hsy, cenz - hsz);
                this.vectors[3] = new gd3d.math.vector3(cenx + hsx, ceny - hsy, cenz + hsz);
                this.vectors[4] = new gd3d.math.vector3(cenx - hsx, ceny + hsy, cenz - hsz);
                this.vectors[5] = new gd3d.math.vector3(cenx - hsx, ceny + hsy, cenz + hsz);
                this.vectors[6] = new gd3d.math.vector3(cenx + hsx, ceny + hsy, cenz - hsz);
                this.vectors[7] = new gd3d.math.vector3(cenx + hsx, ceny + hsy, cenz + hsz);
                this.directions = [new gd3d.math.vector3(), new gd3d.math.vector3(), new gd3d.math.vector3()];
            }
            update(worldmatrix) {
                gd3d.math.matrixGetTranslation(worldmatrix, this.center);
                gd3d.math.matrixGetVector3ByOffset(worldmatrix, 0, this.directions[0]);
                gd3d.math.matrixGetVector3ByOffset(worldmatrix, 4, this.directions[1]);
                gd3d.math.matrixGetVector3ByOffset(worldmatrix, 8, this.directions[2]);
            }
            caclWorldVecs(vecs, worldmatrix) {
                for (var index = 0; index < this.vectors.length; index++) {
                    vecs[index] = new gd3d.math.vector3();
                    gd3d.math.matrixTransformVector3(this.vectors[index], worldmatrix, vecs[index]);
                }
            }
            intersects(_obb) {
                if (_obb == null)
                    return false;
                var box0 = this;
                var box1 = _obb;
                if (!this.axisOverlap(box0.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[2], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[2], box0, box1))
                    return false;
                var crossresult = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Cross(box0.directions[0], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[0], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[0], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[1], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[1], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[1], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[2], box1.directions[0], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[2], box1.directions[1], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                gd3d.math.vec3Cross(box0.directions[2], box1.directions[2], crossresult);
                if (!this.axisOverlap(crossresult, box0, box1))
                    return false;
                return true;
            }
            computeBoxExtents(axis, box) {
                var p = gd3d.math.vec3Dot(box.center, axis);
                var r0 = Math.abs(gd3d.math.vec3Dot(box.directions[0], axis)) * box.halfsize.x;
                var r1 = Math.abs(gd3d.math.vec3Dot(box.directions[1], axis)) * box.halfsize.y;
                var r2 = Math.abs(gd3d.math.vec3Dot(box.directions[2], axis)) * box.halfsize.z;
                var r = r0 + r1 + r2;
                var result = gd3d.math.pool.new_vector3();
                result.x = p - r;
                result.y = p + r;
                return result;
            }
            axisOverlap(axis, box0, box1) {
                var result0 = this.computeBoxExtents(axis, box0);
                var result1 = this.computeBoxExtents(axis, box1);
                return this.extentsOverlap(result0.x, result0.y, result1.x, result1.y);
            }
            extentsOverlap(min0, max0, min1, max1) {
                return !(min0 > max1 || min1 > max0);
            }
            clone() {
                let _obb = new obb();
                _obb.center = gd3d.math.pool.clone_vector3(this.center);
                _obb.halfsize = this.halfsize;
                for (let key in this.directions) {
                    _obb.directions[key] = gd3d.math.pool.clone_vector3(this.directions[key]);
                }
                return _obb;
            }
            dispose() {
                this.vectors.length = 0;
                this.directions.length = 0;
            }
        }
        framework.obb = obb;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class obb2d {
            get size() { return this._size; }
            set size(size) {
                if (!size || !this._size)
                    return;
                gd3d.math.vec2Clone(size, this._size);
                this.halfWidth = this._size.x / 2;
                this.halfHeight = this._size.y / 2;
            }
            buildByCenterSize(center, width, height) {
                this.center = gd3d.math.pool.clone_vector2(center);
                this.offset = gd3d.math.pool.new_vector2();
                this.scale = gd3d.math.pool.new_vector2();
                this.rotate = new gd3d.math.angelref();
                this._size = new gd3d.math.vector2(width, height);
                this.halfWidth = width / 2;
                this.halfHeight = height / 2;
                this.directions = [new gd3d.math.vector2(), new gd3d.math.vector2()];
            }
            update(canvasWorldMtx) {
                gd3d.math.matrix3x2Decompose(canvasWorldMtx, this.scale, this.rotate, this.center);
                let tranOffset = gd3d.math.pool.new_vector2();
                let scaleRotateMtx = gd3d.math.pool.new_matrix3x2();
                gd3d.math.matrix3x2Clone(canvasWorldMtx, scaleRotateMtx);
                scaleRotateMtx.rawData[4] = scaleRotateMtx.rawData[5] = 0;
                gd3d.math.matrix3x2TransformVector2(scaleRotateMtx, this.offset, tranOffset);
                gd3d.math.vec2Add(this.center, tranOffset, this.center);
                this.directions[0].x = canvasWorldMtx.rawData[0];
                this.directions[0].y = canvasWorldMtx.rawData[1];
                this.directions[1].x = canvasWorldMtx.rawData[2];
                this.directions[1].y = canvasWorldMtx.rawData[3];
                gd3d.math.pool.delete_vector2(tranOffset);
                gd3d.math.pool.delete_matrix3x2(scaleRotateMtx);
            }
            intersects(_obb) {
                if (_obb == null)
                    return false;
                var box0 = this;
                var box1 = _obb;
                if (!this.axisOverlap(box0.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[1], box0, box1))
                    return false;
                return true;
            }
            computeBoxExtents(axis, box) {
                var p = gd3d.math.vec2Dot(box.center, axis);
                var r0 = Math.abs(gd3d.math.vec2Dot(box.directions[0], axis)) * box.halfWidth;
                var r1 = Math.abs(gd3d.math.vec2Dot(box.directions[1], axis)) * box.halfHeight;
                var r = r0 + r1;
                var result = gd3d.math.pool.new_vector2();
                result.x = p - r;
                result.y = p + r;
                return result;
            }
            axisOverlap(axis, box0, box1) {
                let result0 = this.computeBoxExtents(axis, box0);
                let result1 = this.computeBoxExtents(axis, box1);
                return this.extentsOverlap(result0.x, result0.y, result1.x, result1.y);
            }
            extentsOverlap(min0, max0, min1, max1) {
                return !(min0 > max1 || min1 > max0);
            }
            clone() {
                let _obb = new obb2d();
                _obb.center = gd3d.math.pool.clone_vector2(this.center);
                _obb._size = gd3d.math.pool.clone_vector2(this._size);
                _obb.halfWidth = this.halfWidth;
                _obb.halfHeight = this.halfHeight;
                _obb.scale = gd3d.math.pool.clone_vector2(this.scale);
                _obb.rotate = new gd3d.math.angelref();
                _obb.rotate.v = this.rotate.v;
                for (let key in this.directions) {
                    _obb.directions[key] = gd3d.math.pool.clone_vector2(this.directions[key]);
                }
                return _obb;
            }
            dispose() {
                if (this.center)
                    gd3d.math.pool.delete_vector2(this.center);
                if (this._size)
                    gd3d.math.pool.delete_vector2(this._size);
                if (this.scale)
                    gd3d.math.pool.delete_vector2(this.scale);
                if (this.directions) {
                    this.directions.forEach(dir => {
                        if (dir)
                            gd3d.math.pool.delete_vector2(dir);
                    });
                    this.directions.length = 0;
                }
            }
        }
        __decorate([
            gd3d.reflect.Field("vector2"),
            __metadata("design:type", gd3d.math.vector2)
        ], obb2d.prototype, "offset", void 0);
        __decorate([
            gd3d.reflect.Field("vector2"),
            __metadata("design:type", Object),
            __metadata("design:paramtypes", [gd3d.math.vector2])
        ], obb2d.prototype, "size", null);
        framework.obb2d = obb2d;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class pickinfo {
            constructor(_bu = 0, _bv = 0, _distance = 0) {
                this.distance = 0;
                this.hitposition = new gd3d.math.vector3();
                this.bu = 0;
                this.bv = 0;
                this.faceId = -1;
                this.subMeshId = 0;
                this.distance = _distance;
                this.bu = _bu;
                this.bv = _bv;
            }
            init() {
                this.pickedtran = null;
                this.hitposition.x = this.hitposition.y = this.hitposition.z = this.distance = this.bu = this.bv = this.subMeshId = 0;
                this.faceId = -1;
            }
            cloneFrom(from) {
                this.pickedtran = from.pickedtran;
                gd3d.math.vec3Clone(from.hitposition, this.hitposition);
                this.distance = from.distance;
                this.bu = from.bu;
                this.bv = from.bv;
                this.subMeshId = from.subMeshId;
                this.faceId = from.faceId;
            }
        }
        framework.pickinfo = pickinfo;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class ray {
            constructor(_origin, _dir) {
                this.origin = gd3d.math.pool.clone_vector3(_origin);
                this.direction = gd3d.math.pool.clone_vector3(_dir);
            }
            intersectAABB(_aabb) {
                return this.intersectBoxMinMax(_aabb.minimum, _aabb.maximum);
            }
            intersectPlaneTransform(tran, outInfo) {
                let ishided = false;
                var panelpoint = tran.getWorldTranslate();
                var forward = gd3d.math.pool.new_vector3();
                tran.getForwardInWorld(forward);
                var hitposition = gd3d.math.pool.new_vector3();
                ishided = this.intersectPlane(panelpoint, forward, hitposition);
                if (ishided) {
                    gd3d.math.vec3Clone(hitposition, outInfo.hitposition);
                    outInfo.distance = gd3d.math.vec3Distance(outInfo.hitposition, this.origin);
                    outInfo.pickedtran = tran;
                }
                gd3d.math.pool.delete_vector3(forward);
                gd3d.math.pool.delete_vector3(hitposition);
                return ishided;
            }
            intersectPlane(planePoint, planeNormal, outHitPoint) {
                var vp1 = planeNormal.x;
                var vp2 = planeNormal.y;
                var vp3 = planeNormal.z;
                var n1 = planePoint.x;
                var n2 = planePoint.y;
                var n3 = planePoint.z;
                var v1 = this.direction.x;
                var v2 = this.direction.y;
                var v3 = this.direction.z;
                var m1 = this.origin.x;
                var m2 = this.origin.y;
                var m3 = this.origin.z;
                var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
                if (vpt === 0) {
                    return false;
                }
                else {
                    var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                    outHitPoint.x = m1 + v1 * t;
                    outHitPoint.y = m2 + v2 * t;
                    outHitPoint.z = m3 + v3 * t;
                    return true;
                }
            }
            intersectCollider(tran, outInfo) {
                let ishided = false;
                let _collider = tran.gameObject.collider;
                let lastDistance = Number.MAX_VALUE;
                if (_collider instanceof framework.boxcollider) {
                    let obb = _collider.getBound();
                    if (!obb)
                        return ishided;
                    let vecs = [];
                    obb.caclWorldVecs(vecs, _collider.gameObject.transform.getWorldMatrix());
                    let data = gd3d.render.meshData.genBoxByArray(vecs);
                    for (var index = 0; index < data.trisindex.length; index += 3) {
                        var p0 = data.pos[data.trisindex[index]];
                        var p1 = data.pos[data.trisindex[index + 1]];
                        var p2 = data.pos[data.trisindex[index + 2]];
                        let tempinfo = gd3d.math.pool.new_pickInfo();
                        let bool = this.intersectsTriangle(p0, p1, p2, tempinfo);
                        if (bool) {
                            if (tempinfo.distance < 0)
                                continue;
                            if (lastDistance > tempinfo.distance) {
                                ishided = true;
                                outInfo.cloneFrom(tempinfo);
                                lastDistance = outInfo.distance;
                                var tdir = gd3d.math.pool.new_vector3();
                                gd3d.math.vec3ScaleByNum(this.direction, outInfo.distance, tdir);
                                gd3d.math.vec3Add(this.origin, tdir, outInfo.hitposition);
                                gd3d.math.pool.delete_vector3(tdir);
                            }
                        }
                        gd3d.math.pool.delete_pickInfo(tempinfo);
                    }
                }
                else if (_collider instanceof framework.meshcollider) {
                    let mesh = _collider.getBound();
                    if (mesh != null) {
                        ishided = mesh.intersects(this, tran.getWorldMatrix(), outInfo);
                    }
                }
                else if (_collider instanceof framework.canvasRenderer) {
                    ishided = this.intersectPlaneTransform(tran, outInfo);
                }
                return ishided;
            }
            intersectBoxMinMax(minimum, maximum) {
                var d = 0.0;
                var maxValue = Number.MAX_VALUE;
                var inv;
                var min;
                var max;
                var temp;
                if (Math.abs(this.direction.x) < 0.0000001) {
                    if (this.origin.x < minimum.x || this.origin.x > maximum.x) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.x;
                    min = (minimum.x - this.origin.x) * inv;
                    max = (maximum.x - this.origin.x) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.y) < 0.0000001) {
                    if (this.origin.y < minimum.y || this.origin.y > maximum.y) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.y;
                    min = (minimum.y - this.origin.y) * inv;
                    max = (maximum.y - this.origin.y) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.z) < 0.0000001) {
                    if (this.origin.z < minimum.z || this.origin.z > maximum.z) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.z;
                    min = (minimum.z - this.origin.z) * inv;
                    max = (maximum.z - this.origin.z) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                return true;
            }
            intersectsSphere(center, radius) {
                var center_ori = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(center, this.origin, center_ori);
                var raydist = gd3d.math.vec3Dot(this.direction, center_ori);
                if (orilen2 < rad2)
                    return true;
                if (raydist < 0)
                    return false;
                var orilen2 = gd3d.math.vec3SqrLength(center_ori);
                gd3d.math.pool.delete_vector3(center_ori);
                var rad2 = radius * radius;
                var d = rad2 - (orilen2 - raydist * raydist);
                if (d < 0)
                    return false;
                return true;
            }
            intersectsTriangle(vertex0, vertex1, vertex2, outInfo) {
                var _edge1 = gd3d.math.pool.new_vector3();
                var _edge2 = gd3d.math.pool.new_vector3();
                var _pvec = gd3d.math.pool.new_vector3();
                var _tvec = gd3d.math.pool.new_vector3();
                var _qvec = gd3d.math.pool.new_vector3();
                gd3d.math.vec3Subtract(vertex1, vertex0, _edge1);
                gd3d.math.vec3Subtract(vertex2, vertex0, _edge2);
                gd3d.math.vec3Cross(this.direction, _edge2, _pvec);
                var det = gd3d.math.vec3Dot(_edge1, _pvec);
                if (det === 0) {
                    return false;
                }
                var invdet = 1 / det;
                gd3d.math.vec3Subtract(this.origin, vertex0, _tvec);
                var bu = gd3d.math.vec3Dot(_tvec, _pvec) * invdet;
                if (bu < 0 || bu > 1.0) {
                    return false;
                }
                gd3d.math.vec3Cross(_tvec, _edge1, _qvec);
                var bv = gd3d.math.vec3Dot(this.direction, _qvec) * invdet;
                if (bv < 0 || bu + bv > 1.0) {
                    return false;
                }
                var distance = gd3d.math.vec3Dot(_edge2, _qvec) * invdet;
                gd3d.math.pool.delete_vector3(_edge1);
                gd3d.math.pool.delete_vector3(_edge2);
                gd3d.math.pool.delete_vector3(_pvec);
                gd3d.math.pool.delete_vector3(_tvec);
                gd3d.math.pool.delete_vector3(_qvec);
                outInfo.init();
                outInfo.bu = bu;
                outInfo.bv = bv;
                outInfo.distance = distance;
                return true;
            }
        }
        framework.ray = ray;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let CullingMask;
        (function (CullingMask) {
            CullingMask[CullingMask["nothing"] = 0] = "nothing";
            CullingMask[CullingMask["default"] = 1] = "default";
            CullingMask[CullingMask["transparentFx"] = 2] = "transparentFx";
            CullingMask[CullingMask["IgnoreRaycast"] = 4] = "IgnoreRaycast";
            CullingMask[CullingMask["editor"] = 8] = "editor";
            CullingMask[CullingMask["water"] = 16] = "water";
            CullingMask[CullingMask["ui"] = 32] = "ui";
            CullingMask[CullingMask["builtin_0"] = 1] = "builtin_0";
            CullingMask[CullingMask["builtin_1"] = 2] = "builtin_1";
            CullingMask[CullingMask["builtin_2"] = 4] = "builtin_2";
            CullingMask[CullingMask["builtin_3"] = 8] = "builtin_3";
            CullingMask[CullingMask["builtin_4"] = 16] = "builtin_4";
            CullingMask[CullingMask["builtin_5"] = 32] = "builtin_5";
            CullingMask[CullingMask["builtin_6"] = 64] = "builtin_6";
            CullingMask[CullingMask["builtin_7"] = 128] = "builtin_7";
            CullingMask[CullingMask["modelbeforeui"] = 256] = "modelbeforeui";
            CullingMask[CullingMask["user_8"] = 256] = "user_8";
            CullingMask[CullingMask["user_9"] = 512] = "user_9";
            CullingMask[CullingMask["user_10"] = 1024] = "user_10";
            CullingMask[CullingMask["user_11"] = 2048] = "user_11";
            CullingMask[CullingMask["user_12"] = 4096] = "user_12";
            CullingMask[CullingMask["user_13"] = 8192] = "user_13";
            CullingMask[CullingMask["user_14"] = 16384] = "user_14";
            CullingMask[CullingMask["user_15"] = 32768] = "user_15";
            CullingMask[CullingMask["user_16"] = 65536] = "user_16";
            CullingMask[CullingMask["user_17"] = 131072] = "user_17";
            CullingMask[CullingMask["user_18"] = 262144] = "user_18";
            CullingMask[CullingMask["user_19"] = 524288] = "user_19";
            CullingMask[CullingMask["user_20"] = 1048576] = "user_20";
            CullingMask[CullingMask["user_21"] = 2097152] = "user_21";
            CullingMask[CullingMask["user_22"] = 4194304] = "user_22";
            CullingMask[CullingMask["user_23"] = 8388608] = "user_23";
            CullingMask[CullingMask["user_24"] = 16777216] = "user_24";
            CullingMask[CullingMask["user_25"] = 33554432] = "user_25";
            CullingMask[CullingMask["user_26"] = 67108864] = "user_26";
            CullingMask[CullingMask["user_27"] = 134217728] = "user_27";
            CullingMask[CullingMask["user_28"] = 268435456] = "user_28";
            CullingMask[CullingMask["user_29"] = 536870912] = "user_29";
            CullingMask[CullingMask["user_30"] = 1073741824] = "user_30";
            CullingMask[CullingMask["user_31"] = 2147483648] = "user_31";
            CullingMask[CullingMask["everything"] = 4294967295] = "everything";
        })(CullingMask = framework.CullingMask || (framework.CullingMask = {}));
        class cullingmaskutil {
            static maskTolayer(mask) {
                return Math.log(mask) / Math.log(2);
            }
            static layerToMask(layer) {
                return 1 << layer;
            }
        }
        framework.cullingmaskutil = cullingmaskutil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class EnumUtil {
            static getEnumObjByType(enumType) {
                let index = enumType.indexOf("gd3d.framework.");
                if (index == 0)
                    enumType = enumType.substr(15);
                return eval("{result:" + enumType + "}");
            }
        }
        framework.EnumUtil = EnumUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class NumberUtil {
        }
        NumberUtil.KEY_A = 65;
        NumberUtil.KEY_D = 68;
        NumberUtil.KEY_E = 69;
        NumberUtil.KEY_Q = 81;
        NumberUtil.KEY_R = 82;
        NumberUtil.KEY_S = 83;
        NumberUtil.KEY_W = 87;
        NumberUtil.KEY_a = 97;
        NumberUtil.KEY_d = 100;
        NumberUtil.KEY_e = 101;
        NumberUtil.KEY_q = 113;
        NumberUtil.KEY_r = 114;
        NumberUtil.KEY_s = 115;
        NumberUtil.KEY_w = 119;
        framework.NumberUtil = NumberUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class RegexpUtil {
        }
        RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
        RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
        framework.RegexpUtil = RegexpUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class StringUtil {
            static replaceAll(srcStr, fromStr, toStr) {
                return srcStr.replace(new RegExp(fromStr, 'gm'), toStr);
            }
            static trimAll(str) {
                str += "";
                var result = str.replace(/(^\s+)|(\s+$)/g, "");
                result = result.replace(/\s/g, "");
                return result;
            }
            static firstCharToLowerCase(str) {
                let firstChar = str.substr(0, 1).toLowerCase();
                let other = str.substr(1);
                return firstChar + other;
            }
            static isNullOrEmptyObject(obj) {
                if (!obj)
                    return true;
                for (var n in obj) {
                    return false;
                }
                return true;
            }
        }
        StringUtil.builtinTag_Untagged = "Untagged";
        StringUtil.builtinTag_Player = "Player";
        StringUtil.builtinTag_EditorOnly = "EditorOnly";
        StringUtil.builtinTag_MainCamera = "MainCamera";
        StringUtil.COMPONENT_CAMERA = "camera";
        StringUtil.COMPONENT_BOXCOLLIDER = "boxcollider";
        StringUtil.COMPONENT_LIGHT = "light";
        StringUtil.COMPONENT_MESHFILTER = "meshFilter";
        StringUtil.COMPONENT_MESHRENDER = "meshRenderer";
        StringUtil.COMPONENT_EFFECTSYSTEM = "effectSystem";
        StringUtil.COMPONENT_LABEL = "label";
        StringUtil.COMPONENT_uirect = "uirect";
        StringUtil.COMPONENT_IMAGE = "image2D";
        StringUtil.COMPONENT_RAWIMAGE = "rawImage2D";
        StringUtil.COMPONENT_BUTTON = "button";
        StringUtil.COMPONENT_SKINMESHRENDER = "skinnedMeshRenderer";
        StringUtil.COMPONENT_AUDIOPLAYER = "AudioPlayer";
        StringUtil.COMPONENT_CAMERACONTROLLER = "cameraController";
        StringUtil.COMPONENT_CANVASRENDER = "canvasRenderer";
        StringUtil.UIStyle_RangeFloat = "rangeFloat";
        StringUtil.UIStyle_Enum = "enum";
        StringUtil.RESOURCES_MESH_CUBE = "cube";
        framework.StringUtil = StringUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class textureutil {
            static loadUtil(path) {
                let sc1 = document.createElement("script");
                let sc2 = document.createElement("script");
                sc1.src = path + "lib/webgl-util.js";
                sc2.src = path + "";
                document.body.appendChild(sc1);
                document.body.appendChild(sc2);
            }
        }
        framework.textureutil = textureutil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        let PrimitiveType;
        (function (PrimitiveType) {
            PrimitiveType[PrimitiveType["Sphere"] = 0] = "Sphere";
            PrimitiveType[PrimitiveType["Capsule"] = 1] = "Capsule";
            PrimitiveType[PrimitiveType["Cylinder"] = 2] = "Cylinder";
            PrimitiveType[PrimitiveType["Cube"] = 3] = "Cube";
            PrimitiveType[PrimitiveType["Plane"] = 4] = "Plane";
            PrimitiveType[PrimitiveType["Quad"] = 5] = "Quad";
            PrimitiveType[PrimitiveType["Pyramid"] = 6] = "Pyramid";
        })(PrimitiveType = framework.PrimitiveType || (framework.PrimitiveType = {}));
        let Primitive2DType;
        (function (Primitive2DType) {
            Primitive2DType[Primitive2DType["RawImage2D"] = 0] = "RawImage2D";
            Primitive2DType[Primitive2DType["Image2D"] = 1] = "Image2D";
            Primitive2DType[Primitive2DType["Label"] = 2] = "Label";
            Primitive2DType[Primitive2DType["Button"] = 3] = "Button";
        })(Primitive2DType = framework.Primitive2DType || (framework.Primitive2DType = {}));
        class TransformUtil {
            static CreatePrimitive(type, app) {
                let objName = PrimitiveType[type];
                let trans = new framework.transform();
                trans.name = objName;
                var mesh = trans.gameObject.addComponent("meshFilter");
                var smesh = app.getAssetMgr().getDefaultMesh(objName.toLowerCase());
                mesh.mesh = smesh;
                var renderer = trans.gameObject.addComponent("meshRenderer");
                renderer.materials = [];
                renderer.materials.push(new framework.material());
                renderer.materials[0].setShader(app.getAssetMgr().getShader("shader/def"));
                return trans;
            }
            static Create2DPrimitive(type, app) {
                let objName = Primitive2DType[type];
                let componentName = framework.StringUtil.firstCharToLowerCase(objName);
                let t2d = new framework.transform2D();
                t2d.name = objName;
                let i2dComp = t2d.addComponent(componentName);
                t2d.pivot.x = 0;
                t2d.pivot.y = 0;
                switch (type) {
                    case Primitive2DType.RawImage2D:
                        TransformUtil.create2D_rawImage(i2dComp, app);
                        break;
                    case Primitive2DType.Image2D:
                        TransformUtil.create2D_image2D(i2dComp, app);
                        break;
                    case Primitive2DType.Label:
                        TransformUtil.create2D_label(i2dComp, app);
                        break;
                    case Primitive2DType.Button:
                        TransformUtil.create2D_button(i2dComp, app);
                        break;
                }
                return t2d;
            }
            static create2D_rawImage(img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.image = app.getAssetMgr().getDefaultTexture("white");
            }
            static create2D_image2D(img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
            }
            static create2D_label(label, app) {
                label.transform.width = 150;
                label.transform.height = 50;
                label.text = "label";
                label.fontsize = 25;
                label.color = new gd3d.math.color(1, 0, 0, 1);
                let _font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                if (_font == null) {
                    app.getAssetMgr().load("res/STXINGKA.TTF.png", gd3d.framework.AssetTypeEnum.Auto, (s) => {
                        if (s.isfinish) {
                            app.getAssetMgr().load("res/resources/STXINGKA.font.json", gd3d.framework.AssetTypeEnum.Auto, (s1) => {
                                label.font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                                label.transform.markDirty();
                            });
                        }
                    });
                }
                else {
                    label.font = _font;
                    ;
                    label.transform.markDirty();
                }
            }
            static create2D_button(btn, app) {
                btn.transform.width = 150;
                btn.transform.height = 50;
                let img = btn.transform.addComponent("image2D");
                img.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
                img.imageType = gd3d.framework.ImageType.Sliced;
                btn.targetImage = img;
                btn.transition = gd3d.framework.TransitionType.ColorTint;
                var lab = new gd3d.framework.transform2D();
                lab.name = "label";
                lab.width = 150;
                lab.height = 50;
                lab.pivot.x = 0;
                lab.pivot.y = 0;
                lab.localTranslate.y = -10;
                var label = lab.addComponent("label");
                label.text = "button";
                label.fontsize = 25;
                label.color = new gd3d.math.color(1, 0, 0, 1);
                btn.transform.addChild(lab);
                let _font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                if (_font == null) {
                    app.getAssetMgr().load("res/STXINGKA.TTF.png", gd3d.framework.AssetTypeEnum.Auto, (s) => {
                        if (s.isfinish) {
                            app.getAssetMgr().load("res/resources/STXINGKA.font.json", gd3d.framework.AssetTypeEnum.Auto, (s1) => {
                                label.font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                                btn.transform.markDirty();
                            });
                        }
                    });
                }
                else {
                    label.font = _font;
                    ;
                    btn.transform.markDirty();
                }
            }
        }
        framework.TransformUtil = TransformUtil;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class WebGLDebugUtils {
            constructor() {
                this.glEnums = null;
            }
            log(msg) {
                if (window.console && window.console.log) {
                    window.console.log(msg);
                }
            }
            init(ctx) {
                if (this.glEnums == null) {
                    this.glEnums = {};
                    for (var propertyName in ctx) {
                        if (typeof ctx[propertyName] == 'number') {
                            this.glEnums[ctx[propertyName]] = propertyName;
                        }
                    }
                }
            }
            checkInit() {
                if (this.glEnums == null) {
                    throw 'WebGLDebugUtils.init(ctx) not called';
                }
            }
            mightBeEnum(value) {
                this.checkInit();
                return (this.glEnums[value] !== undefined);
            }
            glEnumToString(value) {
                this.checkInit();
                var name = this.glEnums[value];
                return (name !== undefined) ? name :
                    ("*UNKNOWN WebGL ENUM (0x" + value.toString(16) + ")");
            }
            glFunctionArgToString(functionName, argumentIndex, value) {
                var funcInfo = WebGLDebugUtils.glValidEnumContexts[functionName];
                if (funcInfo !== undefined) {
                    if (funcInfo[argumentIndex]) {
                        return this.glEnumToString(value);
                    }
                }
                return value.toString();
            }
            makeDebugContext(ctx, opt_onErrorFunc = null) {
                this.init(ctx);
                opt_onErrorFunc = opt_onErrorFunc ||
                    ((err, functionName, args) => {
                        var argStr = "";
                        for (var ii = 0; ii < args.length; ++ii) {
                            argStr += ((ii == 0) ? '' : ', ') +
                                this.glFunctionArgToString(functionName, ii, args[ii]);
                        }
                        console.error("WebGL error " + this.glEnumToString(err) + " in " + functionName +
                            "(" + argStr + ")");
                    });
                var glErrorShadow = {};
                function makeErrorWrapper(ctx, functionName) {
                    return function () {
                        var result = ctx[functionName].apply(ctx, arguments);
                        var err = ctx.getError();
                        if (err != 0) {
                            glErrorShadow[err] = true;
                            opt_onErrorFunc(err, functionName, arguments);
                        }
                        return result;
                    };
                }
                var wrapper = {};
                for (var propertyName in ctx) {
                    if (typeof ctx[propertyName] == 'function') {
                        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
                    }
                    else {
                        wrapper[propertyName] = ctx[propertyName];
                    }
                }
                wrapper["getError"] = function () {
                    for (var err in glErrorShadow) {
                        if (glErrorShadow[err]) {
                            glErrorShadow[err] = false;
                            return err;
                        }
                    }
                    return ctx.NO_ERROR;
                };
                console.error(" i am ---makeDebugContext-");
                return wrapper;
            }
            resetToInitialState(ctx) {
                var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
                var tmp = ctx.createBuffer();
                ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
                for (var ii = 0; ii < numAttribs; ++ii) {
                    ctx.disableVertexAttribArray(ii);
                    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
                    ctx.vertexAttrib1f(ii, 0);
                }
                ctx.deleteBuffer(tmp);
                var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
                for (var ii = 0; ii < numTextureUnits; ++ii) {
                    ctx.activeTexture(ctx.TEXTURE0 + ii);
                    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
                    ctx.bindTexture(ctx.TEXTURE_2D, null);
                }
                ctx.activeTexture(ctx.TEXTURE0);
                ctx.useProgram(null);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
                ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
                ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
                ctx.disable(ctx.BLEND);
                ctx.disable(ctx.CULL_FACE);
                ctx.disable(ctx.DEPTH_TEST);
                ctx.disable(ctx.DITHER);
                ctx.disable(ctx.SCISSOR_TEST);
                ctx.blendColor(0, 0, 0, 0);
                ctx.blendEquation(ctx.FUNC_ADD);
                ctx.blendFunc(ctx.ONE, ctx.ZERO);
                ctx.clearColor(0, 0, 0, 0);
                ctx.clearDepth(1);
                ctx.clearStencil(-1);
                ctx.colorMask(true, true, true, true);
                ctx.cullFace(ctx.BACK);
                ctx.depthFunc(ctx.LESS);
                ctx.depthMask(true);
                ctx.depthRange(0, 1);
                ctx.frontFace(ctx.CCW);
                ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
                ctx.lineWidth(1);
                ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
                ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
                    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
                }
                ctx.polygonOffset(0, 0);
                ctx.sampleCoverage(1, false);
                ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
                ctx.stencilMask(0xFFFFFFFF);
                ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
                ctx.viewport(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);
                ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);
                while (ctx.getError())
                    ;
            }
            makeLostContextSimulatingContext(ctx) {
                var wrapper_ = {};
                var contextId_ = 1;
                var contextLost_ = false;
                var resourceId_ = 0;
                var resourceDb_ = [];
                var onLost_ = undefined;
                var onRestored_ = undefined;
                var nextOnRestored_ = undefined;
                var glErrorShadow_ = {};
                function isWebGLObject(obj) {
                    return (obj instanceof WebGLBuffer ||
                        obj instanceof WebGLFramebuffer ||
                        obj instanceof WebGLProgram ||
                        obj instanceof WebGLRenderbuffer ||
                        obj instanceof WebGLShader ||
                        obj instanceof WebGLTexture);
                }
                function checkResources(args) {
                    for (var ii = 0; ii < args.length; ++ii) {
                        var arg = args[ii];
                        if (isWebGLObject(arg)) {
                            return arg.__webglDebugContextLostId__ == contextId_;
                        }
                    }
                    return true;
                }
                function clearErrors() {
                    var k = Object.keys(glErrorShadow_);
                    for (var ii = 0; ii < k.length; ++ii) {
                        delete glErrorShadow_[k[ii]];
                    }
                }
                function makeLostContextWrapper(ctx, functionName) {
                    var f = ctx[functionName];
                    return function () {
                        if (!contextLost_) {
                            if (!checkResources(arguments)) {
                                glErrorShadow_[ctx.INVALID_OPERATION] = true;
                                return;
                            }
                            var result = f.apply(ctx, arguments);
                            return result;
                        }
                    };
                }
                for (var propertyName in ctx) {
                    if (typeof ctx[propertyName] == 'function') {
                        wrapper_[propertyName] = makeLostContextWrapper(ctx, propertyName);
                    }
                    else {
                        wrapper_[propertyName] = ctx[propertyName];
                    }
                }
                function makeWebGLContextEvent(statusMessage) {
                    return { statusMessage: statusMessage };
                }
                function freeResources() {
                    for (var ii = 0; ii < resourceDb_.length; ++ii) {
                        var resource = resourceDb_[ii];
                        if (resource instanceof WebGLBuffer) {
                            ctx.deleteBuffer(resource);
                        }
                    }
                }
                wrapper_["loseContext"] = function () {
                    if (!contextLost_) {
                        contextLost_ = true;
                        ++contextId_;
                        while (ctx.getError())
                            ;
                        clearErrors();
                        glErrorShadow_[ctx.CONTEXT_LOST_WEBGL] = true;
                        setTimeout(function () {
                            if (onLost_) {
                                onLost_(makeWebGLContextEvent("context lost"));
                            }
                        }, 0);
                    }
                };
                wrapper_["restoreContext"] = function () {
                    if (contextLost_) {
                        if (onRestored_) {
                            setTimeout(function () {
                                freeResources();
                                this.resetToInitialState(ctx);
                                contextLost_ = false;
                                if (onRestored_) {
                                    var callback = onRestored_;
                                    onRestored_ = nextOnRestored_;
                                    nextOnRestored_ = undefined;
                                    callback(makeWebGLContextEvent("context restored"));
                                }
                            }, 0);
                        }
                        else {
                            throw "You can not restore the context without a listener";
                        }
                    }
                };
                wrapper_["getError"] = function () {
                    if (!contextLost_) {
                        var err;
                        while (err = ctx.getError()) {
                            glErrorShadow_[err] = true;
                        }
                    }
                    for (var key in glErrorShadow_) {
                        if (glErrorShadow_[key]) {
                            delete glErrorShadow_[key];
                            return key;
                        }
                    }
                    return ctx.NO_ERROR;
                };
                var creationFunctions = [
                    "createBuffer",
                    "createFramebuffer",
                    "createProgram",
                    "createRenderbuffer",
                    "createShader",
                    "createTexture"
                ];
                for (var ii = 0; ii < creationFunctions.length; ++ii) {
                    var functionName = creationFunctions[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return null;
                            }
                            var obj = f.apply(ctx, arguments);
                            obj.__webglDebugContextLostId__ = contextId_;
                            resourceDb_.push(obj);
                            return obj;
                        };
                    }(ctx[functionName]);
                }
                var functionsThatShouldReturnNull = [
                    "getActiveAttrib",
                    "getActiveUniform",
                    "getBufferParameter",
                    "getContextAttributes",
                    "getAttachedShaders",
                    "getFramebufferAttachmentParameter",
                    "getParameter",
                    "getProgramParameter",
                    "getProgramInfoLog",
                    "getRenderbufferParameter",
                    "getShaderParameter",
                    "getShaderInfoLog",
                    "getShaderSource",
                    "getTexParameter",
                    "getUniform",
                    "getUniformLocation",
                    "getVertexAttrib"
                ];
                for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
                    var functionName = functionsThatShouldReturnNull[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return null;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrapper_[functionName]);
                }
                var isFunctions = [
                    "isBuffer",
                    "isEnabled",
                    "isFramebuffer",
                    "isProgram",
                    "isRenderbuffer",
                    "isShader",
                    "isTexture"
                ];
                for (var ii = 0; ii < isFunctions.length; ++ii) {
                    var functionName = isFunctions[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return false;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrapper_[functionName]);
                }
                wrapper_["checkFramebufferStatus"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return ctx.FRAMEBUFFER_UNSUPPORTED;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["checkFramebufferStatus"]);
                wrapper_["getAttribLocation"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return -1;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["getAttribLocation"]);
                wrapper_["getVertexAttribOffset"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return 0;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["getVertexAttribOffset"]);
                wrapper_["isContextLost"] = function () {
                    return contextLost_;
                };
                function wrapEvent(listener) {
                    if (typeof (listener) == "function") {
                        return listener;
                    }
                    else {
                        return function (info) {
                            listener.handleEvent(info);
                        };
                    }
                }
                wrapper_["registerOnContextLostListener"] = function (listener) {
                    onLost_ = wrapEvent(listener);
                };
                wrapper_["registerOnContextRestoredListener"] = function (listener) {
                    if (contextLost_) {
                        nextOnRestored_ = wrapEvent(listener);
                    }
                    else {
                        onRestored_ = wrapEvent(listener);
                    }
                };
                return wrapper_;
            }
        }
        WebGLDebugUtils.glValidEnumContexts = {
            'enable': { 0: true },
            'disable': { 0: true },
            'getParameter': { 0: true },
            'drawArrays': { 0: true },
            'drawElements': { 0: true, 2: true },
            'createShader': { 0: true },
            'getShaderParameter': { 1: true },
            'getProgramParameter': { 1: true },
            'getVertexAttrib': { 1: true },
            'vertexAttribPointer': { 2: true },
            'bindTexture': { 0: true },
            'activeTexture': { 0: true },
            'getTexParameter': { 0: true, 1: true },
            'texParameterf': { 0: true, 1: true },
            'texParameteri': { 0: true, 1: true, 2: true },
            'texImage2D': { 0: true, 2: true, 6: true, 7: true },
            'texSubImage2D': { 0: true, 6: true, 7: true },
            'copyTexImage2D': { 0: true, 2: true },
            'copyTexSubImage2D': { 0: true },
            'generateMipmap': { 0: true },
            'bindBuffer': { 0: true },
            'bufferData': { 0: true, 2: true },
            'bufferSubData': { 0: true },
            'getBufferParameter': { 0: true, 1: true },
            'pixelStorei': { 0: true, 1: true },
            'readPixels': { 4: true, 5: true },
            'bindRenderbuffer': { 0: true },
            'bindFramebuffer': { 0: true },
            'checkFramebufferStatus': { 0: true },
            'framebufferRenderbuffer': { 0: true, 1: true, 2: true },
            'framebufferTexture2D': { 0: true, 1: true, 2: true },
            'getFramebufferAttachmentParameter': { 0: true, 1: true, 2: true },
            'getRenderbufferParameter': { 0: true, 1: true },
            'renderbufferStorage': { 0: true, 1: true },
            'clear': { 0: true },
            'depthFunc': { 0: true },
            'blendFunc': { 0: true, 1: true },
            'blendFuncSeparate': { 0: true, 1: true, 2: true, 3: true },
            'blendEquation': { 0: true },
            'blendEquationSeparate': { 0: true, 1: true },
            'stencilFunc': { 0: true },
            'stencilFuncSeparate': { 0: true, 1: true },
            'stencilMaskSeparate': { 0: true },
            'stencilOp': { 0: true, 1: true, 2: true },
            'stencilOpSeparate': { 0: true, 1: true, 2: true, 3: true },
            'cullFace': { 0: true },
            'frontFace': { 0: true },
        };
        framework.WebGLDebugUtils = WebGLDebugUtils;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var framework;
    (function (framework) {
        class WebGLUtils {
            constructor() {
                this.GET_A_WEBGL_BROWSER = '' +
                    'This page requires a browser that supports WebGL.<br/>' +
                    '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';
                this.OTHER_PROBLEM = '' +
                    "It doesn't appear your computer can support WebGL.<br/>" +
                    '<a href="http://get.webgl.org">Click here for more information.</a>';
                if (!window.requestAnimationFrame) {
                    var tempwin = window;
                    window.requestAnimationFrame =
                        tempwin.requestAnimationFrame ||
                            tempwin.webkitRequestAnimationFrame ||
                            tempwin.mozRequestAnimationFrame ||
                            tempwin.oRequestAnimationFrame ||
                            tempwin.msRequestAnimationFrame ||
                            function (callback, element) {
                                window.setTimeout(callback, 1000 / 60);
                            };
                }
                if (!window.cancelAnimationFrame) {
                    var tempwin = window;
                    window.cancelAnimationFrame = (tempwin.cancelRequestAnimationFrame ||
                        window.webkitCancelAnimationFrame || tempwin.webkitCancelRequestAnimationFrame ||
                        tempwin.mozCancelAnimationFrame || tempwin.mozCancelRequestAnimationFrame ||
                        tempwin.msCancelAnimationFrame || tempwin.msCancelRequestAnimationFrame ||
                        tempwin.oCancelAnimationFrame || tempwin.oCancelRequestAnimationFrame ||
                        window.clearTimeout);
                }
            }
            makeFailHTML(msg) {
                return '' +
                    '<div style="margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;">' + msg + '</div>';
            }
            ;
            setupWebGL(canvas, opt_attribs = null, opt_onError = null) {
                let handleCreationError = (msg) => {
                    var container = document.getElementsByTagName("body")[0];
                    if (container) {
                        var str = WebGLRenderingContext ?
                            this.OTHER_PROBLEM :
                            this.GET_A_WEBGL_BROWSER;
                        if (msg) {
                            str += "<br/><br/>Status: " + msg;
                        }
                        container.innerHTML = this.makeFailHTML(str);
                    }
                };
                opt_onError = opt_onError || handleCreationError;
                if (canvas.addEventListener) {
                    canvas.addEventListener("webglcontextcreationerror", (event) => {
                        opt_onError(event.statusMessage);
                    }, false);
                }
                var context = this.create3DContext(canvas, opt_attribs);
                if (!context) {
                    if (!WebGLRenderingContext) {
                        opt_onError("");
                    }
                    else {
                        opt_onError("");
                    }
                }
                return context;
            }
            create3DContext(canvas, opt_attribs) {
                var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
                var context = null;
                for (var ii = 0; ii < names.length; ++ii) {
                    try {
                        context = canvas.getContext(names[ii], opt_attribs);
                    }
                    catch (e) { }
                    if (context) {
                        break;
                    }
                }
                return context;
            }
        }
        framework.WebGLUtils = WebGLUtils;
    })(framework = gd3d.framework || (gd3d.framework = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var io;
    (function (io) {
        class loadRetryMgr {
        }
        function xhrLoad(url, fun, onprocess = null, responseType, loadedFun) {
            let req = new XMLHttpRequest();
            let isLoaded = false;
            req.open("GET", url);
            req.responseType = responseType;
            req.onreadystatechange = () => {
                if (req.readyState == 4) {
                    if (req.status == 200) {
                        loadedFun(req);
                        isLoaded = true;
                    }
                    else {
                        switch (req.status) {
                            case 404:
                                fun(null, new Error("got a 404:" + url));
                                break;
                        }
                    }
                }
            };
            req.onprogress = (ev) => {
                if (onprocess)
                    onprocess(ev.loaded, ev.total);
            };
            req.onerror = () => {
                fun(null, new Error("onerr in req:"));
            };
            req.onloadend = () => {
                if (!isLoaded) {
                    if (!loadRetryMgr.urlCaseDic)
                        loadRetryMgr.urlCaseDic = {};
                    let dic = loadRetryMgr.urlCaseDic;
                    dic[url] = isNaN(dic[url]) || dic[url] < 0 ? 0 : dic[url];
                    if (dic[url] >= 2) {
                        dic[url] = 0;
                        fun(null, new Error("load this url fail  ：" + url), true);
                    }
                    else {
                        gd3d.io.xhrLoad(url, fun, onprocess, responseType, loadedFun);
                        dic[url]++;
                    }
                }
            };
            try {
                req.send();
            }
            catch (err) {
                fun(null, err);
            }
        }
        io.xhrLoad = xhrLoad;
        function loadText(url, fun, onprocess = null) {
            gd3d.io.xhrLoad(url, fun, onprocess, "text", (req) => {
                fun(req.responseText, null);
            });
        }
        io.loadText = loadText;
        function loadArrayBuffer(url, fun, onprocess = null) {
            gd3d.io.xhrLoad(url, fun, onprocess, "arraybuffer", (req) => __awaiter(this, void 0, void 0, function* () {
                fun(req.response, null);
            }));
        }
        io.loadArrayBuffer = loadArrayBuffer;
        function loadBlob(url, fun, onprocess = null) {
            gd3d.io.xhrLoad(url, fun, onprocess, "blob", (req) => {
                fun(req.response, null);
            });
        }
        io.loadBlob = loadBlob;
        function loadImg(url, fun, onprocess = null) {
            gd3d.io.xhrLoad(url, fun, onprocess, "blob", (req) => {
                var blob = req.response;
                var img = document.createElement("img");
                img.onload = function (e) {
                    window.URL.revokeObjectURL(img.src);
                    fun(img, null);
                };
                img.onerror = function (e) {
                    fun(null, new Error("error when blob to img:" + url));
                };
                try {
                    img.src = window.URL.createObjectURL(blob);
                }
                catch (e) {
                    fun(null, e);
                }
            });
        }
        io.loadImg = loadImg;
    })(io = gd3d.io || (gd3d.io = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var math;
    (function (math) {
        class pool {
            static collect_all() {
                pool.collect_vector4();
                pool.collect_vector3();
                pool.collect_vector2();
                pool.collect_matrix();
                pool.collect_quaternion();
                pool.collect_color();
                pool.collect_pickInfo();
            }
            static get vector4_one() {
                if (pool._vector4_one == null) {
                    pool._vector4_one = new math.vector4(1, 1, 1, 1);
                }
                return pool._vector4_one;
            }
            static new_vector4(x = 0, y = 0, z = 0, w = 0) {
                if (pool.unused_vector4.length > 0) {
                    let v4 = pool.unused_vector4.pop();
                    v4.x = x;
                    v4.y = y;
                    v4.z = z;
                    v4.w = w;
                    return v4;
                }
                else
                    return new math.vector4(x, y, z, w);
            }
            static clone_vector4(src) {
                if (pool.unused_vector4.length > 0) {
                    var v = pool.unused_vector4.pop();
                    v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.vector4(src.x, src.y, src.z);
            }
            static delete_vector4(v) {
                if (v == null)
                    return;
                if (v instanceof math.vector4) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    pool.unused_vector4.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector4吗？");
            }
            static collect_vector4() {
                pool.unused_vector4.length = 0;
            }
            static get color_one() {
                if (pool._color_one == null) {
                    pool._color_one = new math.color(1, 1, 1, 1);
                }
                return pool._color_one;
            }
            static new_color(r = 0, g = 0, b = 0, a = 0) {
                if (pool.unused_color.length > 0) {
                    let c = pool.unused_color.pop();
                    c.r = r;
                    c.g = g;
                    c.b = b;
                    c.a = a;
                    return c;
                }
                else
                    return new math.color(r, g, b, a);
            }
            static delete_color(v) {
                if (v == null)
                    return;
                if (v instanceof math.color) {
                    v.r = v.g = v.b = 0;
                    v.a = 1;
                    pool.unused_color.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是color吗？");
            }
            static collect_color() {
                pool.unused_color.length = 0;
            }
            static get vector3_up() {
                if (pool._vector3_up == null) {
                    pool._vector3_up = new math.vector3(0, 1, 0);
                }
                pool._vector3_up.y = 1;
                pool._vector3_up.x = pool._vector3_up.z = 0;
                return pool._vector3_up;
            }
            static get vector3_right() {
                if (pool._vector3_right == null) {
                    pool._vector3_right = new math.vector3(1, 0, 0);
                }
                pool._vector3_right.x = 1;
                pool._vector3_right.y = pool._vector3_right.z = 0;
                return pool._vector3_right;
            }
            static get vector3_forward() {
                if (pool._vector3_forward == null) {
                    pool._vector3_forward = new math.vector3(0, 0, 1);
                }
                pool._vector3_forward.x = pool._vector3_forward.y = 0;
                pool._vector3_forward.z = 1;
                return pool._vector3_forward;
            }
            static get vector3_zero() {
                if (pool._vector3_zero == null) {
                    pool._vector3_zero = new math.vector3(0, 0, 0);
                }
                pool._vector3_zero.x = pool._vector3_zero.y = pool._vector3_zero.z = 0;
                return pool._vector3_zero;
            }
            static get vector3_one() {
                if (pool._vector3_one == null) {
                    pool._vector3_one = new math.vector3(1, 1, 1);
                }
                pool._vector3_one.x = pool._vector3_one.y = pool._vector3_one.z = 1;
                return pool._vector3_one;
            }
            static new_vector3(x = 0, y = 0, z = 0) {
                if (pool.unused_vector3.length > 0) {
                    let v3 = pool.unused_vector3.pop();
                    v3.x = x;
                    v3.y = y;
                    v3.z = z;
                    return v3;
                }
                else
                    return new math.vector3(x, y, z);
            }
            static clone_vector3(src) {
                if (pool.unused_vector3.length > 0) {
                    var v = pool.unused_vector3.pop();
                    v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.vector3(src.x, src.y, src.z);
            }
            static delete_vector3(v) {
                if (v == null)
                    return;
                if (v instanceof math.vector3) {
                    v.x = v.y = v.z = 0;
                    pool.unused_vector3.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector3吗？");
            }
            static delete_vector3Array(vs) {
                for (let i = 0; i < vs.length; i++) {
                    if (vs[i] != undefined) {
                        this.delete_vector3(vs[i]);
                    }
                }
                vs.length = 0;
            }
            static collect_vector3() {
                pool.unused_vector3.length = 0;
            }
            static get vector2_zero() {
                if (pool._vector2_zero == null) {
                    pool._vector2_zero = new math.vector2(0, 0);
                }
                pool._vector2_zero.x = pool._vector2_zero.y = 1;
                return pool._vector2_zero;
            }
            static get vector2_up() {
                if (pool._vector2_up == null) {
                    pool._vector2_up = new math.vector2(0, 1);
                }
                pool._vector2_up.x = 0;
                pool._vector2_up.y = 1;
                return pool._vector2_up;
            }
            static get vector2_right() {
                if (pool._vector2_right == null) {
                    pool._vector2_right = new math.vector2(1, 0);
                }
                pool._vector2_right.x = 1;
                pool._vector2_right.y = 0;
                return pool._vector2_right;
            }
            static new_vector2(x = 0, y = 0) {
                if (pool.unused_vector2.length > 0) {
                    let v2 = pool.unused_vector2.pop();
                    v2.x = x;
                    v2.y = y;
                    return v2;
                }
                else
                    return new math.vector2(x, y);
            }
            static clone_vector2(src) {
                if (pool.unused_vector2.length > 0) {
                    var v = pool.unused_vector2.pop();
                    if (src.rawData.length > v.rawData.length) {
                        src.rawData[0] = v.rawData[0];
                        src.rawData[1] = v.rawData[1];
                    }
                    else
                        v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.vector2(src.x, src.y);
            }
            static delete_vector2(v) {
                if (v == null)
                    return;
                if (v instanceof math.vector2) {
                    v.x = v.y = 0;
                    pool.unused_vector2.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector2吗？");
            }
            static delete_vector2Array(vs) {
                for (let i = 0; i < vs.length; i++) {
                    if (vs[i] != undefined) {
                        this.delete_vector2(vs[i]);
                    }
                }
                vs.length = 0;
            }
            static collect_vector2() {
                pool.unused_vector2.length = 0;
            }
            static new_matrix3x2() {
                if (pool.unused_matrix3x2.length > 0)
                    return pool.unused_matrix3x2.pop();
                else
                    return new math.matrix3x2();
            }
            static clone_matrix3x2(src) {
                var v = pool.new_matrix3x2();
                v.rawData.set(src.rawData);
                return v;
            }
            static delete_matrix3x2(v) {
                if (v == null)
                    return;
                if (v instanceof math.matrix3x2) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 1;
                    v.rawData[4] = 0;
                    v.rawData[5] = 0;
                    pool.unused_matrix3x2.push(v);
                }
                else {
                    console.error("kindding me?确定你要回收的是matrix3x2吗？");
                }
            }
            static collect_matrix3x2() {
                pool.unused_matrix3x2.length = 0;
            }
            static new_matrix() {
                if (pool.unused_matrix.length > 0)
                    return pool.unused_matrix.pop();
                else
                    return new math.matrix();
            }
            static clone_matrix(src) {
                var v = pool.new_matrix();
                v.rawData.set(v.rawData);
                return v;
            }
            static delete_matrix(v) {
                if (v == null)
                    return;
                if (v instanceof math.matrix) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 0;
                    v.rawData[4] = 0;
                    v.rawData[5] = 1;
                    v.rawData[6] = 0;
                    v.rawData[7] = 0;
                    v.rawData[8] = 0;
                    v.rawData[9] = 0;
                    v.rawData[10] = 1;
                    v.rawData[11] = 0;
                    v.rawData[12] = 0;
                    v.rawData[13] = 0;
                    v.rawData[14] = 0;
                    v.rawData[15] = 1;
                    pool.unused_matrix.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是matrix吗？");
            }
            static collect_matrix() {
                pool.unused_matrix.length = 0;
            }
            static new_quaternion() {
                if (pool.unused_quaternion.length > 0)
                    return pool.unused_quaternion.pop();
                else
                    return new math.quaternion();
            }
            static clone_quaternion(src) {
                if (pool.unused_quaternion.length > 0) {
                    var v = pool.unused_quaternion.pop();
                    v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.quaternion(src.x, src.y, src.z, src.w);
            }
            static delete_quaternion(v) {
                if (v == null)
                    return;
                if (v instanceof math.quaternion) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    pool.unused_quaternion.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是quaternion吗？");
            }
            static collect_quaternion() {
                pool.unused_quaternion.length = 0;
            }
            static new_pickInfo(bu = 0, bv = 0, distance = 0) {
                if (pool.unused_pickInfo.length > 0) {
                    let pk = pool.unused_pickInfo.pop();
                    return pk;
                }
                else
                    return new gd3d.framework.pickinfo(bu, bv, distance);
            }
            static delete_pickInfo(v) {
                if (v == null)
                    return;
                if (v instanceof gd3d.framework.pickinfo) {
                    v.init();
                    pool.unused_pickInfo.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是pickInfo吗？");
            }
            static collect_pickInfo() {
                pool.unused_pickInfo.length = 0;
            }
        }
        pool.unused_vector4 = [];
        pool.unused_color = [];
        pool.unused_vector3 = [];
        pool.unused_vector2 = [];
        pool.unused_matrix3x2 = [];
        pool.unused_matrix = [];
        pool.identityMat = new math.matrix();
        pool.unused_quaternion = [];
        pool.unused_pickInfo = [];
        math.pool = pool;
    })(math = gd3d.math || (gd3d.math = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        class caps {
        }
        render.caps = caps;
        class webglkit {
            static SetMaxVertexAttribArray(webgl, count) {
                for (var i = count; i < webglkit._maxVertexAttribArray; i++) {
                    webgl.disableVertexAttribArray(i);
                }
                webglkit._maxVertexAttribArray = count;
            }
            static GetTextureNumber(webgl, index) {
                webglkit.initConst(webgl);
                return webglkit._texNumber[index];
            }
            static initConst(webgl) {
                if (webglkit._texNumber == null) {
                    webglkit._texNumber = [];
                    webglkit._texNumber.push(webgl.TEXTURE0);
                    webglkit._texNumber.push(webgl.TEXTURE1);
                    webglkit._texNumber.push(webgl.TEXTURE2);
                    webglkit._texNumber.push(webgl.TEXTURE3);
                    webglkit._texNumber.push(webgl.TEXTURE4);
                    webglkit._texNumber.push(webgl.TEXTURE5);
                    webglkit._texNumber.push(webgl.TEXTURE6);
                    webglkit._texNumber.push(webgl.TEXTURE7);
                    webglkit._texNumber.push(webgl.TEXTURE8);
                    webglkit._texNumber.push(webgl.TEXTURE9);
                    webglkit._texNumber.push(webgl.TEXTURE10);
                    webglkit._texNumber.push(webgl.TEXTURE11);
                    webglkit._texNumber.push(webgl.TEXTURE12);
                    webglkit._texNumber.push(webgl.TEXTURE13);
                    webglkit._texNumber.push(webgl.TEXTURE14);
                    webglkit._texNumber.push(webgl.TEXTURE15);
                    webglkit.LEQUAL = webgl.LEQUAL;
                    webglkit.NEVER = webgl.NEVER;
                    webglkit.EQUAL = webgl.EQUAL;
                    webglkit.GEQUAL = webgl.GEQUAL;
                    webglkit.NOTEQUAL = webgl.NOTEQUAL;
                    webglkit.LESS = webgl.LESS;
                    webglkit.GREATER = webgl.GREATER;
                    webglkit.ALWAYS = webgl.ALWAYS;
                    webglkit.FUNC_ADD = webgl.FUNC_ADD;
                    webglkit.FUNC_SUBTRACT = webgl.FUNC_SUBTRACT;
                    webglkit.FUNC_REVERSE_SUBTRACT = webgl.FUNC_REVERSE_SUBTRACT;
                    webglkit.ONE = webgl.ONE;
                    webglkit.ZERO = webgl.ZERO;
                    webglkit.SRC_ALPHA = webgl.SRC_ALPHA;
                    webglkit.SRC_COLOR = webgl.SRC_COLOR;
                    webglkit.ONE_MINUS_SRC_ALPHA = webgl.ONE_MINUS_SRC_ALPHA;
                    webglkit.ONE_MINUS_SRC_COLOR = webgl.ONE_MINUS_SRC_COLOR;
                    webglkit.ONE_MINUS_DST_ALPHA = webgl.ONE_MINUS_DST_ALPHA;
                    webglkit.ONE_MINUS_DST_COLOR = webgl.ONE_MINUS_DST_COLOR;
                    webglkit.caps.standardDerivatives = (webgl.getExtension('OES_standard_derivatives') !== null);
                    webglkit.caps.pvrtcExtension = webgl.getExtension('WEBGL_compressed_texture_pvrtc');
                    webglkit.caps.atcExtension = webgl.getExtension('WEBGL_compressed_texture_atc');
                }
            }
        }
        webglkit._maxVertexAttribArray = 0;
        webglkit._texNumber = null;
        webglkit.caps = new caps();
        render.webglkit = webglkit;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        let ShowFaceStateEnum;
        (function (ShowFaceStateEnum) {
            ShowFaceStateEnum[ShowFaceStateEnum["ALL"] = 0] = "ALL";
            ShowFaceStateEnum[ShowFaceStateEnum["CCW"] = 1] = "CCW";
            ShowFaceStateEnum[ShowFaceStateEnum["CW"] = 2] = "CW";
        })(ShowFaceStateEnum = render.ShowFaceStateEnum || (render.ShowFaceStateEnum = {}));
        let DrawModeEnum;
        (function (DrawModeEnum) {
            DrawModeEnum[DrawModeEnum["VboTri"] = 0] = "VboTri";
            DrawModeEnum[DrawModeEnum["VboLine"] = 1] = "VboLine";
            DrawModeEnum[DrawModeEnum["EboTri"] = 2] = "EboTri";
            DrawModeEnum[DrawModeEnum["EboLine"] = 3] = "EboLine";
        })(DrawModeEnum = render.DrawModeEnum || (render.DrawModeEnum = {}));
        let BlendModeEnum;
        (function (BlendModeEnum) {
            BlendModeEnum[BlendModeEnum["Close"] = 0] = "Close";
            BlendModeEnum[BlendModeEnum["Blend"] = 1] = "Blend";
            BlendModeEnum[BlendModeEnum["Blend_PreMultiply"] = 2] = "Blend_PreMultiply";
            BlendModeEnum[BlendModeEnum["Add"] = 3] = "Add";
            BlendModeEnum[BlendModeEnum["Add_PreMultiply"] = 4] = "Add_PreMultiply";
        })(BlendModeEnum = render.BlendModeEnum || (render.BlendModeEnum = {}));
        class glDrawPass {
            constructor() {
                this.state_showface = ShowFaceStateEnum.CCW;
                this.state_zwrite = false;
                this.state_ztest = false;
                this.state_ztest_method = render.webglkit.LEQUAL;
                this.state_blend = false;
                this.state_blendEquation = 0;
                this.state_blendSrcRGB = 0;
                this.state_blendDestRGB = 0;
                this.state_blendSrcAlpha = 0;
                this.state_blendDestALpha = 0;
            }
            setProgram(program, uniformDefault = false) {
                this.program = program;
                this.mapuniforms = program.mapUniform;
            }
            setAlphaBlend(mode) {
                this.state_blendMode = mode;
                if (mode == BlendModeEnum.Add) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.webglkit.ONE;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Add_PreMultiply) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.ONE;
                    this.state_blendDestRGB = render.webglkit.ONE;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend) {
                    this.state_blend = true;
                    this.state_zwrite = false;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend_PreMultiply) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.ONE;
                    this.state_blendDestRGB = render.webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Close) {
                    this.state_blend = false;
                }
            }
            static resetLastState() {
                this.lastShowFace = -1;
                this.lastZWrite = null;
                this.lastZTest = null;
                this.lastZTestMethod = -1;
                this.lastBlend = null;
                this.lastBlendMode = null;
            }
            use(webgl, applyUniForm = true) {
                if (this.state_showface != glDrawPass.lastShowFace) {
                    glDrawPass.lastShowFace = this.state_showface;
                    if (this.state_showface == ShowFaceStateEnum.ALL) {
                        webgl.disable(webgl.CULL_FACE);
                    }
                    else {
                        if (this.state_showface == ShowFaceStateEnum.CCW) {
                            webgl.frontFace(webgl.CCW);
                        }
                        else {
                            webgl.frontFace(webgl.CW);
                        }
                        webgl.cullFace(webgl.BACK);
                        webgl.enable(webgl.CULL_FACE);
                    }
                }
                if (this.state_zwrite != glDrawPass.lastZWrite) {
                    glDrawPass.lastZWrite = this.state_zwrite;
                    if (this.state_zwrite) {
                        webgl.depthMask(true);
                    }
                    else {
                        webgl.depthMask(false);
                    }
                }
                if (this.state_ztest != glDrawPass.lastZTest) {
                    glDrawPass.lastZTest = this.state_ztest;
                    if (this.state_ztest) {
                        webgl.enable(webgl.DEPTH_TEST);
                    }
                    else {
                        webgl.disable(webgl.DEPTH_TEST);
                    }
                }
                if (this.state_ztest && glDrawPass.lastZTestMethod != this.state_ztest_method) {
                    glDrawPass.lastZTestMethod = this.state_ztest_method;
                    webgl.depthFunc(this.state_ztest_method);
                }
                if (this.state_blend != glDrawPass.lastBlend) {
                    glDrawPass.lastBlend = this.state_blend;
                    if (this.state_blend) {
                        webgl.enable(webgl.BLEND);
                    }
                    else {
                        webgl.disable(webgl.BLEND);
                    }
                }
                if (this.state_blend && glDrawPass.lastBlendMode != this.state_blendMode) {
                    glDrawPass.lastBlendMode = this.state_blendMode;
                    webgl.blendEquation(this.state_blendEquation);
                    webgl.blendFuncSeparate(this.state_blendSrcRGB, this.state_blendDestRGB, this.state_blendSrcAlpha, this.state_blendDestALpha);
                }
                this.program.use(webgl);
            }
            draw(webgl, mesh, drawmode = DrawModeEnum.EboTri, drawindexindex = 0, drawbegin = 0, drawcount = -1) {
                this.use(webgl);
                mesh.bind(webgl, this.program, drawindexindex);
                if (drawmode == DrawModeEnum.VboTri) {
                    mesh.drawArrayTris(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.VboLine) {
                    mesh.drawArrayLines(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.EboTri) {
                    mesh.drawElementTris(webgl, drawbegin, drawcount);
                }
                else if (drawmode == DrawModeEnum.EboLine) {
                    mesh.drawElementLines(webgl, drawbegin, drawcount);
                }
            }
            getCurDrawState() {
                let res = "";
                res = this.formate(this.state_showface.toString(), res);
                res = this.formate(this.state_zwrite.toString(), res);
                res = this.formate(this.state_ztest.toString(), res);
                if (this.state_ztest) {
                    res = this.formate(this.state_ztest_method.toString(), res);
                }
                else {
                    res = this.formate("ztestnone", res);
                }
                res = this.formate(this.state_blend.toString(), res);
                if (this.state_blend) {
                    res = this.formate(this.state_blendEquation.toString(), res);
                }
                else {
                    res = this.formate("blendnone", res);
                }
                return res;
            }
            getCurBlendVal() {
                let res = "";
                res = this.formate(this.state_blendSrcRGB.toString(), res);
                res = this.formate(this.state_blendDestRGB.toString(), res);
                res = this.formate(this.state_blendSrcAlpha.toString(), res);
                res = this.formate(this.state_blendDestALpha.toString(), res);
                return res;
            }
            formate(str, out) {
                return out += str + "_";
            }
        }
        glDrawPass.lastShowFace = -1;
        glDrawPass.lastZWrite = null;
        glDrawPass.lastZTest = null;
        glDrawPass.lastZTestMethod = -1;
        glDrawPass.lastBlend = null;
        glDrawPass.lastBlendMode = null;
        render.glDrawPass = glDrawPass;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        let VertexFormatMask;
        (function (VertexFormatMask) {
            VertexFormatMask[VertexFormatMask["Position"] = 1] = "Position";
            VertexFormatMask[VertexFormatMask["Normal"] = 2] = "Normal";
            VertexFormatMask[VertexFormatMask["Tangent"] = 4] = "Tangent";
            VertexFormatMask[VertexFormatMask["Color"] = 8] = "Color";
            VertexFormatMask[VertexFormatMask["UV0"] = 16] = "UV0";
            VertexFormatMask[VertexFormatMask["UV1"] = 32] = "UV1";
            VertexFormatMask[VertexFormatMask["BlendIndex4"] = 64] = "BlendIndex4";
            VertexFormatMask[VertexFormatMask["BlendWeight4"] = 128] = "BlendWeight4";
            VertexFormatMask[VertexFormatMask["ColorEX"] = 256] = "ColorEX";
        })(VertexFormatMask = render.VertexFormatMask || (render.VertexFormatMask = {}));
        class number4 {
        }
        render.number4 = number4;
        let MeshTypeEnum;
        (function (MeshTypeEnum) {
            MeshTypeEnum[MeshTypeEnum["Static"] = 0] = "Static";
            MeshTypeEnum[MeshTypeEnum["Dynamic"] = 1] = "Dynamic";
            MeshTypeEnum[MeshTypeEnum["Stream"] = 2] = "Stream";
        })(MeshTypeEnum = render.MeshTypeEnum || (render.MeshTypeEnum = {}));
        class drawInfo {
            constructor() {
                this.triCount = 0;
                this.vboCount = 0;
                this.renderCount = 0;
            }
            static get ins() {
                if (drawInfo._ins == null)
                    drawInfo._ins = new drawInfo();
                return drawInfo._ins;
            }
        }
        render.drawInfo = drawInfo;
        class glMesh {
            constructor() {
                this.lineMode = WebGLRenderingContext.LINES;
                this.bindIndex = -1;
                this.vertexFormat = VertexFormatMask.Position;
            }
            initBuffer(webgl, vf, vertexCount, mode = MeshTypeEnum.Static) {
                if (this.vbo != null)
                    throw new Error("you can only initbuffer once.");
                if (mode == MeshTypeEnum.Static)
                    this.mode = webgl.STATIC_DRAW;
                else if (mode == MeshTypeEnum.Dynamic)
                    this.mode = webgl.DYNAMIC_DRAW;
                else if (mode == MeshTypeEnum.Stream)
                    this.mode = webgl.STREAM_DRAW;
                this.vertexFormat = vf;
                this.vertexCount = vertexCount;
                if (vertexCount > 0) {
                    this.vertexByteSize = render.meshData.calcByteSize(vf);
                    this.vbo = webgl.createBuffer();
                    webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                    webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
                }
                this.indexCounts = [];
                this.ebos = [];
            }
            addIndex(webgl, indexcount) {
                var index = this.ebos.length;
                var _ebo = webgl.createBuffer();
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, _ebo);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
                this.ebos.push(_ebo);
                this.indexCounts.push(indexcount);
                return index;
            }
            resetVboSize(webgl, vertexCount) {
                this.vertexCount = vertexCount;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
            }
            resetEboSize(webgl, eboindex, indexcount) {
                this.indexCounts[eboindex] = indexcount;
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
            }
            dispose(webgl) {
                webgl.deleteBuffer(this.vbo);
                this.vbo = null;
                if (this.ebos) {
                    for (var i = 0; i < this.ebos.length; i++)
                        webgl.deleteBuffer(this.ebos[i]);
                    this.ebos.length = 0;
                }
            }
            caclByteLength() {
                let total = 0;
                total += this.vertexByteSize * this.vertexCount;
                for (let k in this.indexCounts) {
                    total += this.indexCounts[k] * 2;
                }
                return total;
            }
            bindVboBuffer(webgl) {
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
            }
            bind(webgl, shadercode, bindEbo = 0) {
                this.bindIndex = bindEbo;
                if (bindEbo >= 0) {
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[bindEbo]);
                }
                var total = this.vertexByteSize;
                var seek = 0;
                var channel = 0;
                {
                    if (shadercode.posPos >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posPos);
                        webgl.vertexAttribPointer(shadercode.posPos, 3, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                if (this.vertexFormat & VertexFormatMask.Normal) {
                    if (shadercode.posNormal >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posNormal);
                        webgl.vertexAttribPointer(shadercode.posNormal, 3, webgl.FLOAT, true, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                else if (shadercode.posNormal >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posNormal);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.Tangent) {
                    if (shadercode.posTangent >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posTangent);
                        webgl.vertexAttribPointer(shadercode.posTangent, 3, webgl.FLOAT, true, total, seek);
                        channel++;
                    }
                    seek += 12;
                }
                else if (shadercode.posTangent >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posTangent);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.Color) {
                    if (shadercode.posColor >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posColor);
                        webgl.vertexAttribPointer(shadercode.posColor, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posColor >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posColor);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.UV0) {
                    if (shadercode.posUV0 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posUV0);
                        webgl.vertexAttribPointer(shadercode.posUV0, 2, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 8;
                }
                else if (shadercode.posUV0 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posUV0);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.UV1) {
                    if (shadercode.posUV2 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posUV2);
                        webgl.vertexAttribPointer(shadercode.posUV2, 2, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 8;
                }
                else if (shadercode.posUV2 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posUV2);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.BlendIndex4) {
                    if (shadercode.posBlendIndex4 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posBlendIndex4);
                        webgl.vertexAttribPointer(shadercode.posBlendIndex4, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posBlendIndex4 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posBlendIndex4);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.BlendWeight4) {
                    if (shadercode.posBlendWeight4 >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posBlendWeight4);
                        webgl.vertexAttribPointer(shadercode.posBlendWeight4, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posBlendWeight4 >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posBlendWeight4);
                    channel++;
                }
                if (this.vertexFormat & VertexFormatMask.ColorEX) {
                    if (shadercode.posColorEx >= 0) {
                        webgl.enableVertexAttribArray(shadercode.posColorEx);
                        webgl.vertexAttribPointer(shadercode.posColorEx, 4, webgl.FLOAT, false, total, seek);
                        channel++;
                    }
                    seek += 16;
                }
                else if (shadercode.posColorEx >= 0) {
                    webgl.disableVertexAttribArray(shadercode.posColorEx);
                    channel++;
                }
                render.webglkit.SetMaxVertexAttribArray(webgl, channel);
            }
            uploadVertexSubData(webgl, varray, offset = 0) {
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferSubData(webgl.ARRAY_BUFFER, offset, varray);
            }
            uploadVertexData(webgl, varray) {
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, varray, this.mode);
            }
            uploadIndexSubData(webgl, eboindex, data, offset = 0) {
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, offset, data);
            }
            uploadIndexData(webgl, eboindex, data) {
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, data, this.mode);
            }
            drawArrayTris(webgl, start = 0, count = -1) {
                if (count < 0)
                    count = ((this.vertexCount / 3) | 0) * 3;
                drawInfo.ins.triCount += count / 3;
                drawInfo.ins.renderCount++;
                webgl.drawArrays(webgl.TRIANGLES, start, count);
            }
            drawArrayLines(webgl, start = 0, count = -1) {
                if (count < 0)
                    count = ((this.vertexCount / 2) | 0) * 2;
                drawInfo.ins.renderCount++;
                webgl.drawArrays(this.lineMode, start, count);
            }
            drawElementTris(webgl, start = 0, count = -1) {
                if (count < 0)
                    count = ((this.indexCounts[this.bindIndex] / 3) | 0) * 3;
                drawInfo.ins.triCount += count / 3;
                drawInfo.ins.renderCount++;
                webgl.drawElements(webgl.TRIANGLES, count, webgl.UNSIGNED_SHORT, start * 2);
            }
            drawElementLines(webgl, start = 0, count = -1) {
                if (count < 0)
                    count = ((this.indexCounts[this.bindIndex] / 2) | 0) * 2;
                drawInfo.ins.renderCount++;
                webgl.drawElements(this.lineMode, count, webgl.UNSIGNED_SHORT, start * 2);
            }
        }
        render.glMesh = glMesh;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        class meshData {
            static addQuadPos(data, quad) {
                var istart = data.pos.length;
                meshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
            }
            static addQuadPos_Quad(data, quad) {
                var istart = data.pos.length;
                meshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
                data.trisindex.push(istart + 2);
            }
            static addQuadVec3ByValue(array, value) {
                for (var i = 0; i < 4; i++) {
                    var v = gd3d.math.pool.clone_vector3(value);
                    array.push(v);
                }
            }
            static addQuadVec3(array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            }
            static addQuadVec2(array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            }
            static genQuad(size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, 0),
                    new gd3d.math.vector3(-half, -half, 0),
                    new gd3d.math.vector3(half, half, 0),
                    new gd3d.math.vector3(half, -half, 0)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(1, 0)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            }
            static genQuad_forparticle(size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(0, half, 0),
                    new gd3d.math.vector3(0, -half, 0),
                    new gd3d.math.vector3(2 * half, half, 0),
                    new gd3d.math.vector3(2 * half, -half, 0)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            }
            static genPlaneCCW(size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, 0, half),
                    new gd3d.math.vector3(-half, 0, -half),
                    new gd3d.math.vector3(half, 0, half),
                    new gd3d.math.vector3(half, 0, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                return data;
            }
            static genCylinderCCW(height, radius, segment = 20) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var normal = new gd3d.math.vector3(0, 1, 0);
                for (var s = 0; s < 4; s++) {
                    var y = (s < 2 ? 0.5 : -0.5) * height;
                    if (s == 0)
                        normal = new gd3d.math.vector3(0, 1, 0);
                    else if (s == 3)
                        normal = new gd3d.math.vector3(0, -1, 0);
                    for (var i = 0; i < segment; i++) {
                        var r = i / segment * Math.PI * 2;
                        var x = Math.sin(r);
                        var z = Math.cos(r);
                        if (s == 1 || s == 2)
                            normal = new gd3d.math.vector3(x, 0, z);
                        data.pos.push(new gd3d.math.vector3(x * radius, y, z * radius));
                        var vn = gd3d.math.pool.clone_vector3(normal);
                        data.normal.push(vn);
                        if (s == 0 || s == 3) {
                            data.uv.push(new gd3d.math.vector2(x / 2 + 0.5, z / 2 + 0.5));
                        }
                        else {
                            data.uv.push(new gd3d.math.vector2(i / segment, y < 0 ? 0 : 1));
                        }
                    }
                }
                var itop = data.pos.length;
                data.pos.push(new gd3d.math.vector3(0, 0.5 * height, 0));
                data.normal.push(new gd3d.math.vector3(0, 1, 0));
                data.uv.push(new gd3d.math.vector2(0.5, 0.5));
                var ibottom = data.pos.length;
                data.pos.push(new gd3d.math.vector3(0, -0.5 * height, 0));
                data.normal.push(new gd3d.math.vector3(0, -1, 0));
                data.uv.push(new gd3d.math.vector2(0.5, 0.5));
                for (var i = 0; i < segment; i++) {
                    data.trisindex.push(itop);
                    data.trisindex.push(i == segment - 1 ? segment * 0 + 0 : segment * 0 + i + 1);
                    data.trisindex.push(segment * 0 + i + 0);
                    data.trisindex.push(ibottom);
                    data.trisindex.push(segment * 3 + i + 0);
                    data.trisindex.push(i == segment - 1 ? segment * 3 + 0 : segment * 3 + i + 1);
                    var t = segment * 1 + i;
                    var t2 = i == segment - 1 ? segment * 1 + 0 : segment * 1 + i + 1;
                    var b = segment * 2 + i;
                    var b2 = i == segment - 1 ? segment * 2 + 0 : segment * 2 + i + 1;
                    data.trisindex.push(t);
                    data.trisindex.push(t2);
                    data.trisindex.push(b);
                    data.trisindex.push(t2);
                    data.trisindex.push(b2);
                    data.trisindex.push(b);
                }
                return data;
            }
            static genPyramid(height, halfsize) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var vec1 = new gd3d.math.vector3();
                var vec2 = new gd3d.math.vector3();
                var vec3 = new gd3d.math.vector3();
                var vec4 = new gd3d.math.vector3();
                var vec5 = new gd3d.math.vector3(0, -1, 0);
                var uvxx = new gd3d.math.vector2(0.5, 0.5);
                var uv00 = new gd3d.math.vector2(0, 0);
                var uv01 = new gd3d.math.vector2(0, 1);
                var uv10 = new gd3d.math.vector2(1, 0);
                var uv11 = new gd3d.math.vector2(1, 1);
                var ipos = 0;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(halfsize, height, halfsize), new gd3d.math.vector3(halfsize, -height, -halfsize), vec1);
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.uv.push(uv00);
                data.uv.push(uvxx);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(-halfsize, height, halfsize), new gd3d.math.vector3(halfsize, -height, halfsize), vec2);
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.uv.push(uv01);
                data.uv.push(uvxx);
                data.uv.push(uv11);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(-halfsize, height, -halfsize), new gd3d.math.vector3(-halfsize, -height, halfsize), vec3);
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.uv.push(uv11);
                data.uv.push(uvxx);
                data.uv.push(uv10);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(0, height * 0.5, 0));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                gd3d.math.vec3Cross(new gd3d.math.vector3(halfsize, height, -halfsize), new gd3d.math.vector3(-halfsize, -height, -halfsize), vec4);
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.uv.push(uv10);
                data.uv.push(uvxx);
                data.uv.push(uv00);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new gd3d.math.vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new gd3d.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.uv.push(uv00);
                data.uv.push(uv10);
                data.uv.push(uv11);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                data.trisindex.push(ipos + 3);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos);
                ipos += 4;
                return data;
            }
            static genSphereCCW(radius = 1, widthSegments = 24, heightSegments = 12) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                widthSegments = Math.max(3, Math.floor(widthSegments));
                heightSegments = Math.max(2, Math.floor(heightSegments));
                var ix, iy;
                var index = 0;
                var grid = [];
                var vertex = new gd3d.math.vector3();
                var normal = new gd3d.math.vector3();
                for (iy = 0; iy <= heightSegments; iy++) {
                    var verticesRow = [];
                    var v = iy / heightSegments;
                    for (ix = 0; ix <= widthSegments; ix++) {
                        var u = ix / widthSegments;
                        vertex.x = -radius * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        vertex.y = radius * Math.cos(v * Math.PI);
                        vertex.z = radius * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        data.pos.push(gd3d.math.pool.clone_vector3(vertex));
                        normal = gd3d.math.pool.clone_vector3(vertex);
                        var num = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                        if (num > Number.MIN_VALUE) {
                            normal.x = normal.x / num;
                            normal.y = normal.y / num;
                            normal.z = normal.z / num;
                        }
                        else {
                            normal.x = 0;
                            normal.y = 0;
                            normal.z = 0;
                        }
                        data.normal.push(normal);
                        var uv = new gd3d.math.vector2(1 - u, v);
                        data.uv.push(uv);
                        verticesRow.push(index++);
                    }
                    grid.push(verticesRow);
                }
                for (iy = 0; iy < heightSegments; iy++) {
                    for (ix = 0; ix < widthSegments; ix++) {
                        var a = grid[iy][ix + 1];
                        var b = grid[iy][ix];
                        var c = grid[iy + 1][ix];
                        var d = grid[iy + 1][ix + 1];
                        if (iy !== 0)
                            data.trisindex.push(a, d, b);
                        if (iy !== heightSegments - 1)
                            data.trisindex.push(b, d, c);
                    }
                }
                return data;
            }
            static genBoxCCW(size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(half, -half, -half),
                    new gd3d.math.vector3(half, -half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(-half, half, -half),
                    new gd3d.math.vector3(half, half, half),
                    new gd3d.math.vector3(half, half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(half, -half, half),
                    new gd3d.math.vector3(half, half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(0, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, half, -half),
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(half, half, -half),
                    new gd3d.math.vector3(half, -half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 0),
                    new gd3d.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(half, -half, -half),
                    new gd3d.math.vector3(half, -half, half),
                    new gd3d.math.vector3(half, half, -half),
                    new gd3d.math.vector3(half, half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos(data, [
                    new gd3d.math.vector3(-half, -half, half),
                    new gd3d.math.vector3(-half, -half, -half),
                    new gd3d.math.vector3(-half, half, half),
                    new gd3d.math.vector3(-half, half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new gd3d.math.vector2(0, 1),
                    new gd3d.math.vector2(1, 1),
                    new gd3d.math.vector2(0, 0),
                    new gd3d.math.vector2(1, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                return data;
            }
            static genBoxByArray(array) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos(data, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos(data, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos(data, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos(data, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                return data;
            }
            static genBoxByArray_Quad(array) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, -1, 0));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 1, 0));
                meshData.addQuadPos_Quad(data, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, 1));
                meshData.addQuadPos_Quad(data, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(1, 0, 0));
                meshData.addQuadPos_Quad(data, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, -1));
                meshData.addQuadVec3ByValue(data.normal, new gd3d.math.vector3(-1, 0, 0));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new gd3d.math.vector3(0, 0, 1));
                return data;
            }
            static genCircleLineCCW(radius, segment = 64, wide = 0.05) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                for (var i = 0; i < segment; i++) {
                    var r1 = Math.PI * 2 * i / segment;
                    var x1 = Math.sin(r1) * radius;
                    var z1 = Math.cos(r1) * radius;
                    var r2 = Math.PI * 2 * (i + 1) / segment;
                    var x2 = Math.sin(r2) * radius;
                    var z2 = Math.cos(r2) * radius;
                    meshData.addQuadPos(data, [
                        new gd3d.math.vector3(x2, wide, z2),
                        new gd3d.math.vector3(x1, wide, z1),
                        new gd3d.math.vector3(x2, -wide, z2),
                        new gd3d.math.vector3(x1, -wide, z1)
                    ]);
                }
                return data;
            }
            caclByteLength() {
                let len = 0;
                if (this.pos != undefined)
                    len += 12;
                if (this.color != undefined)
                    len += 16;
                if (this.normal != undefined)
                    len += 12;
                if (this.tangent != undefined)
                    len += 12;
                if (this.uv != undefined)
                    len += 8;
                if (this.uv2 != undefined)
                    len += 8;
                if (this.blendIndex != undefined)
                    len += 16;
                if (this.blendWeight != undefined)
                    len += 16;
                if (this.colorex != undefined)
                    len += 16;
                if (this.trisindex != undefined)
                    len += 12;
                len *= this.pos.length;
                return len;
            }
            static calcByteSize(vf) {
                var total = 0;
                if (vf & render.VertexFormatMask.Position)
                    total += 12;
                if (vf & render.VertexFormatMask.Normal)
                    total += 12;
                if (vf & render.VertexFormatMask.Tangent)
                    total += 12;
                if (vf & render.VertexFormatMask.Color)
                    total += 16;
                if (vf & render.VertexFormatMask.UV0)
                    total += 8;
                if (vf & render.VertexFormatMask.UV1)
                    total += 8;
                if (vf & render.VertexFormatMask.BlendIndex4)
                    total += 16;
                if (vf & render.VertexFormatMask.BlendWeight4)
                    total += 16;
                if (vf & render.VertexFormatMask.ColorEX)
                    total += 16;
                return total;
            }
            genVertexDataArray(vf) {
                var vertexCount = this.pos.length;
                var total = meshData.calcByteSize(vf) / 4;
                var varray = new Float32Array(total * vertexCount);
                for (var i = 0; i < vertexCount; i++) {
                    var nseek = 0;
                    varray[i * total + nseek] = this.pos[i].x;
                    nseek++;
                    varray[i * total + nseek] = this.pos[i].y;
                    nseek++;
                    varray[i * total + nseek] = this.pos[i].z;
                    nseek++;
                    if (vf & render.VertexFormatMask.Normal) {
                        if (this.normal == undefined || this.normal.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.normal[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.normal[i].y;
                            nseek++;
                            varray[i * total + nseek] = this.normal[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Tangent) {
                        if (this.tangent == undefined || this.tangent.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.tangent[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.tangent[i].y;
                            nseek++;
                            varray[i * total + nseek] = this.tangent[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Color) {
                        if (this.color == undefined || this.color.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.color[i].r;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].g;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].b;
                            nseek++;
                            varray[i * total + nseek] = this.color[i].a;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV0) {
                        if (this.uv == undefined || this.uv.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.uv[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.uv[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV1) {
                        if (this.uv2 == undefined || this.uv2.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.uv2[i].x;
                            nseek++;
                            varray[i * total + nseek] = this.uv2[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendIndex4) {
                        if (this.blendIndex == undefined || this.blendIndex.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.blendIndex[i].v0;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v1;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v2;
                            nseek++;
                            varray[i * total + nseek] = this.blendIndex[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendWeight4) {
                        if (this.blendWeight == undefined || this.blendWeight.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.blendWeight[i].v0;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v1;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v2;
                            nseek++;
                            varray[i * total + nseek] = this.blendWeight[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.ColorEX) {
                        if (this.colorex == undefined || this.colorex.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = this.colorex[i].r;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].g;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].b;
                            nseek++;
                            varray[i * total + nseek] = this.colorex[i].a;
                            nseek++;
                        }
                    }
                }
                return varray;
            }
            genIndexDataArray() {
                return new Uint16Array(this.trisindex);
            }
            genIndexDataArrayTri2Line() {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 3) | 0); i++) {
                    line.push(this.trisindex[i * 3 + 0]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 0]);
                }
                return new Uint16Array(line);
            }
            genIndexDataArrayQuad2Line() {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 4) | 0); i++) {
                    line.push(this.trisindex[i * 4 + 0]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 3]);
                }
                return new Uint16Array(line);
            }
        }
        render.meshData = meshData;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        class staticMeshRenderer {
            constructor() {
                this.eboIndex = 0;
                this.drawMode = render.DrawModeEnum.EboTri;
                this.drawbegin = 0;
                this.drawcount = -1;
            }
            draw(webgl) {
                this.material.use(webgl);
                this.mesh.bind(webgl, this.material.program, this.eboIndex);
                if (this.drawMode == render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, this.drawbegin, this.drawcount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, this.drawbegin, this.drawcount);
                }
            }
        }
        render.staticMeshRenderer = staticMeshRenderer;
        class batchRenderer {
            constructor() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            initBuffer(webgl, vf, drawMode) {
                this.mesh = new render.glMesh();
                this.mesh.initBuffer(webgl, vf, 128, render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == render.DrawModeEnum.EboLine || drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
            }
            begin(webgl, mat) {
                if (this.vboCount > 0)
                    this.end(webgl);
                this.curmaterial = mat;
            }
            push(webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > 2048
                    ||
                        (ebodata != null && this.eboCount + ebodata.length > 2048)) {
                    this.end(webgl);
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    let narr = new Float32Array(this.dataForVbo.length * 2);
                    for (let i = 0, len = this.dataForVbo.length; i < len; ++i) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (let i = 0, len = vbodata.length; i < len; ++i) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == render.DrawModeEnum.VboLine || this.drawMode == render.DrawModeEnum.VboTri)
                    return;
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        let narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (let i = 0, len = this.dataForEbo.length; i < len; ++i) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (let i = 0, len = ebodata.length; i < len; ++i) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            }
            end(webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexData(webgl, this.dataForVbo.slice(0, this.vboCount));
                if (this.eboCount > 0)
                    this.mesh.uploadIndexData(webgl, 0, this.dataForEbo.slice(0, this.eboCount));
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                this.curmaterial.use(webgl);
                this.mesh.bind(webgl, this.curmaterial.program, (this.drawMode == render.DrawModeEnum.EboLine || this.drawMode == render.DrawModeEnum.EboTri) ? 0 : -1);
                if (this.drawMode == render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
            }
        }
        render.batchRenderer = batchRenderer;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        class shaderUniform {
            static initApplyUnifmFunc() {
                this.applyuniformFunc[render.UniformTypeEnum.Float] = (location, value) => {
                    this.webgl.uniform1f(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Floatv] = (location, value) => {
                    this.webgl.uniform1fv(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4] = (location, value) => {
                    this.webgl.uniform4f(location, value.x, value.y, value.z, value.w);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4v] = (location, value) => {
                    this.webgl.uniform4fv(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4x4] = (location, value) => {
                    this.webgl.uniformMatrix4fv(location, false, value.rawData);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4x4v] = (location, value) => {
                    this.webgl.uniformMatrix4fv(location, false, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Texture] = (location, value) => {
                    var tex = value.glTexture.texture;
                    this.webgl.activeTexture(render.webglkit.GetTextureNumber(this.webgl, this.texindex));
                    this.webgl.bindTexture(this.webgl.TEXTURE_2D, tex);
                    this.webgl.uniform1i(location, this.texindex);
                    this.texindex++;
                };
                this.applyuniformFunc[render.UniformTypeEnum.CubeTexture] = (location, value) => {
                    var tex = value.glTexture.texture;
                    this.webgl.activeTexture(render.webglkit.GetTextureNumber(this.webgl, this.texindex));
                    this.webgl.bindTexture(this.webgl.TEXTURE_CUBE_MAP, tex);
                    this.webgl.uniform1i(location, this.texindex);
                    this.texindex++;
                };
            }
        }
        shaderUniform.texindex = 0;
        shaderUniform.applyuniformFunc = {};
        render.shaderUniform = shaderUniform;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        class glWindow {
            constructor() {
                this.clearop_Color = false;
                this.backColor = new gd3d.math.color(1, 0, 1, 1);
                this.clearop_Depth = false;
                this.clearop_Stencil = false;
                this.viewport = new gd3d.math.rect(0, 0, 1, 1);
            }
            use(webgl) {
                if (this.renderTarget != null) {
                    this.renderTarget.use(webgl);
                }
                else {
                    gd3d.render.glRenderTarget.useNull(webgl);
                }
                if (this.backColor != null)
                    webgl.clearColor(this.backColor.r, this.backColor.g, this.backColor.b, this.backColor.a);
                var n = 0;
                if (this.clearop_Color)
                    n |= webgl.COLOR_BUFFER_BIT;
                if (this.clearop_Depth)
                    n |= webgl.DEPTH_BUFFER_BIT;
                if (this.clearop_Stencil)
                    n |= webgl.STENCIL_BUFFER_BIT;
                webgl.clear(n);
                if (this.renderTarget != null) {
                    webgl.viewport(this.renderTarget.width * this.viewport.x, this.renderTarget.height * this.viewport.y, this.renderTarget.width * this.viewport.w, this.renderTarget.height * this.viewport.h);
                }
                else {
                    webgl.viewport(webgl.canvas.width * this.viewport.x, webgl.canvas.height * this.viewport.y, webgl.canvas.width * this.viewport.w, webgl.canvas.height * this.viewport.h);
                }
            }
        }
        render.glWindow = glWindow;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        let UniformTypeEnum;
        (function (UniformTypeEnum) {
            UniformTypeEnum[UniformTypeEnum["Texture"] = 0] = "Texture";
            UniformTypeEnum[UniformTypeEnum["Float"] = 1] = "Float";
            UniformTypeEnum[UniformTypeEnum["Floatv"] = 2] = "Floatv";
            UniformTypeEnum[UniformTypeEnum["Float4"] = 3] = "Float4";
            UniformTypeEnum[UniformTypeEnum["Float4v"] = 4] = "Float4v";
            UniformTypeEnum[UniformTypeEnum["Float4x4"] = 5] = "Float4x4";
            UniformTypeEnum[UniformTypeEnum["Float4x4v"] = 6] = "Float4x4v";
            UniformTypeEnum[UniformTypeEnum["CubeTexture"] = 7] = "CubeTexture";
        })(UniformTypeEnum = render.UniformTypeEnum || (render.UniformTypeEnum = {}));
        class uniform {
        }
        render.uniform = uniform;
        let ShaderTypeEnum;
        (function (ShaderTypeEnum) {
            ShaderTypeEnum[ShaderTypeEnum["VS"] = 0] = "VS";
            ShaderTypeEnum[ShaderTypeEnum["FS"] = 1] = "FS";
        })(ShaderTypeEnum = render.ShaderTypeEnum || (render.ShaderTypeEnum = {}));
        class glShader {
            constructor(name, type, shader, code) {
                this.name = name;
                this.type = type;
                this.shader = shader;
            }
        }
        render.glShader = glShader;
        class glProgram {
            constructor(vs, fs, program) {
                this.posPos = -1;
                this.posNormal = -1;
                this.posTangent = -1;
                this.posColor = -1;
                this.posUV0 = -1;
                this.posUV2 = -1;
                this.posBlendIndex4 = -1;
                this.posBlendWeight4 = -1;
                this.posColorEx = -1;
                this.mapUniform = {};
                this.vs = vs;
                this.fs = fs;
                this.program = program;
            }
            initAttribute(webgl) {
                this.posPos = webgl.getAttribLocation(this.program, "_glesVertex");
                this.posColor = webgl.getAttribLocation(this.program, "_glesColor");
                this.posUV0 = webgl.getAttribLocation(this.program, "_glesMultiTexCoord0");
                this.posUV2 = webgl.getAttribLocation(this.program, "_glesMultiTexCoord1");
                this.posNormal = webgl.getAttribLocation(this.program, "_glesNormal");
                this.posTangent = webgl.getAttribLocation(this.program, "_glesTangent");
                this.posBlendIndex4 = webgl.getAttribLocation(this.program, "_glesBlendIndex4");
                this.posBlendWeight4 = webgl.getAttribLocation(this.program, "_glesBlendWeight4");
                this.posColorEx = webgl.getAttribLocation(this.program, "_glesColorEx");
            }
            use(webgl) {
                webgl.useProgram(this.program);
            }
            initUniforms(webgl) {
                var numUniforms = webgl.getProgramParameter(this.program, webgl.ACTIVE_UNIFORMS);
                for (var i = 0; i < numUniforms; i++) {
                    var uniformInfo = webgl.getActiveUniform(this.program, i);
                    if (!uniformInfo)
                        break;
                    var name = uniformInfo.name;
                    if (name.substr(-3) === "[0]") {
                        name = name.substr(0, name.length - 3);
                    }
                    var location = webgl.getUniformLocation(this.program, uniformInfo.name);
                    var type = uniformInfo.type;
                    var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]");
                    let _uniform = new uniform();
                    _uniform.name = name;
                    _uniform.location = location;
                    this.mapUniform[name] = _uniform;
                    if (type === webgl.FLOAT && isArray) {
                        _uniform.type = UniformTypeEnum.Floatv;
                    }
                    else if (type === webgl.FLOAT) {
                        _uniform.type = UniformTypeEnum.Float;
                    }
                    else if (type === webgl.FLOAT_VEC4 && isArray) {
                        _uniform.type = UniformTypeEnum.Float4v;
                    }
                    else if (type === webgl.FLOAT_VEC4) {
                        _uniform.type = UniformTypeEnum.Float4;
                    }
                    else if (type === webgl.FLOAT_MAT4 && isArray) {
                        _uniform.type = UniformTypeEnum.Float4x4v;
                    }
                    else if (type === webgl.FLOAT_MAT4) {
                        _uniform.type = UniformTypeEnum.Float4x4;
                    }
                    else if (type === webgl.SAMPLER_2D) {
                        _uniform.type = UniformTypeEnum.Texture;
                    }
                    else if (type === webgl.SAMPLER_CUBE) {
                        _uniform.type = UniformTypeEnum.CubeTexture;
                    }
                    else {
                        console.log("Unifrom parse Erorr : not have this type!");
                    }
                }
            }
        }
        render.glProgram = glProgram;
        class shaderPool {
            constructor() {
                this.mapVS = {};
                this.mapFS = {};
                this.mapProgram = {};
                this.mapVSString = {};
                this.mapFSString = {};
            }
            disposeVS(webgl, id) {
                webgl.deleteShader(this.mapVS[id].shader);
            }
            disposeFS(webgl, id) {
                webgl.deleteShader(this.mapFS[id].shader);
            }
            disposeProgram(webgl, id) {
                webgl.deleteProgram(this.mapProgram[id].program);
            }
            disposeAll(webgl) {
                for (var key in this.mapVS) {
                    this.disposeVS(webgl, key);
                }
                for (var key in this.mapFS) {
                    this.disposeFS(webgl, key);
                }
                for (var key in this.mapProgram) {
                    this.disposeProgram(webgl, key);
                }
                this.mapVS = {};
                this.mapFS = {};
                this.mapProgram = {};
            }
            compileVS(webgl, name, code) {
                var vs = webgl.createShader(webgl.VERTEX_SHADER);
                webgl.shaderSource(vs, code);
                webgl.compileShader(vs);
                var r1 = webgl.getShaderParameter(vs, webgl.COMPILE_STATUS);
                if (r1 == false) {
                    if (confirm("a vs:" + name + " error!!!" + webgl.getShaderInfoLog(vs) + "\n" + "did you want see the code?")) {
                        webgl.deleteShader(vs);
                        alert(code);
                    }
                    return null;
                }
                var s = new glShader(name, ShaderTypeEnum.VS, vs, code);
                this.mapVS[name] = s;
                return s;
            }
            compileFS(webgl, name, code) {
                var fs = webgl.createShader(webgl.FRAGMENT_SHADER);
                webgl.shaderSource(fs, code);
                webgl.compileShader(fs);
                var r1 = webgl.getShaderParameter(fs, webgl.COMPILE_STATUS);
                if (r1 == false) {
                    if (confirm("a fs:" + name + " error!!!" + webgl.getShaderInfoLog(fs) + "\n" + "did you want see the code?")) {
                        webgl.deleteShader(fs);
                        alert(code);
                    }
                    return null;
                }
                var s = new glShader(name, ShaderTypeEnum.FS, fs, code);
                this.mapFS[name] = s;
                return s;
            }
            linkProgram(webgl, nameVS, nameFS) {
                var program = webgl.createProgram();
                webgl.attachShader(program, this.mapVS[nameVS].shader);
                webgl.attachShader(program, this.mapFS[nameFS].shader);
                webgl.linkProgram(program);
                var r3 = webgl.getProgramParameter(program, webgl.LINK_STATUS);
                if (r3 == false) {
                    alert("vs:" + nameVS + "   fs:" + nameFS + "a webgl program error:" + webgl.getProgramInfoLog(program));
                    webgl.deleteProgram(program);
                    return null;
                }
                var name = nameVS + "_" + nameFS;
                var glp = new glProgram(this.mapVS[nameVS], this.mapFS[nameFS], program);
                glp.initUniforms(webgl);
                glp.initAttribute(webgl);
                this.mapProgram[name] = glp;
                return glp;
            }
            linkProgrambyPassType(webgl, type, nameVS, nameFS) {
                let vsStr = this.mapVSString[nameVS];
                let fsStr = this.mapFSString[nameFS];
                if (type == "base") {
                }
                else if (type == "base_fog" || type == "fog") {
                    vsStr = "#define FOG \n" + vsStr;
                    fsStr = "#define FOG \n" + fsStr;
                }
                else if (type == "skin") {
                    vsStr = "#define SKIN \n" + vsStr;
                    fsStr = "#define SKIN \n" + fsStr;
                }
                else if (type == "skin_fog") {
                    vsStr = "#define SKIN \n" + "#define FOG \n" + vsStr;
                    fsStr = "#define SKIN \n" + "#define FOG \n" + fsStr;
                }
                else if (type == "lightmap") {
                    vsStr = "#define LIGHTMAP \n" + vsStr;
                    fsStr = "#define LIGHTMAP \n" + fsStr;
                }
                else if (type == "lightmap_fog") {
                    vsStr = "#define LIGHTMAP \n" + "#define FOG \n" + vsStr;
                    fsStr = "#define LIGHTMAP \n" + "#define FOG \n" + fsStr;
                }
                else if (type == "quad") {
                    vsStr = "#define QUAD \n" + vsStr;
                    fsStr = "#define QUAD \n" + fsStr;
                }
                this.compileVS(webgl, nameVS + type, vsStr);
                this.compileFS(webgl, nameFS + type, fsStr);
                let pro = this.linkProgram(webgl, nameVS + type, nameFS + type);
                return pro;
            }
        }
        render.shaderPool = shaderPool;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
var gd3d;
(function (gd3d) {
    var render;
    (function (render) {
        let TextureFormatEnum;
        (function (TextureFormatEnum) {
            TextureFormatEnum[TextureFormatEnum["RGBA"] = 1] = "RGBA";
            TextureFormatEnum[TextureFormatEnum["RGB"] = 2] = "RGB";
            TextureFormatEnum[TextureFormatEnum["Gray"] = 3] = "Gray";
            TextureFormatEnum[TextureFormatEnum["PVRTC4_RGB"] = 4] = "PVRTC4_RGB";
            TextureFormatEnum[TextureFormatEnum["PVRTC4_RGBA"] = 4] = "PVRTC4_RGBA";
            TextureFormatEnum[TextureFormatEnum["PVRTC2_RGB"] = 4] = "PVRTC2_RGB";
            TextureFormatEnum[TextureFormatEnum["PVRTC2_RGBA"] = 4] = "PVRTC2_RGBA";
        })(TextureFormatEnum = render.TextureFormatEnum || (render.TextureFormatEnum = {}));
        class textureReader {
            constructor(webgl, texRGBA, width, height, gray = true) {
                this.gray = gray;
                this.width = width;
                this.height = height;
                var fbo = webgl.createFramebuffer();
                var fbold = webgl.getParameter(webgl.FRAMEBUFFER_BINDING);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbo);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, texRGBA, 0);
                var readData = new Uint8Array(this.width * this.height * 4);
                readData[0] = 2;
                webgl.readPixels(0, 0, this.width, this.height, webgl.RGBA, webgl.UNSIGNED_BYTE, readData);
                webgl.deleteFramebuffer(fbo);
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbold);
                if (gray) {
                    this.data = new Uint8Array(this.width * this.height);
                    for (var i = 0; i < width * height; i++) {
                        this.data[i] = readData[i * 4];
                    }
                }
                else {
                    this.data = readData;
                }
            }
            getPixel(u, v) {
                var x = (u * this.width) | 0;
                var y = (v * this.height) | 0;
                if (x < 0 || x >= this.width || y < 0 || y >= this.height)
                    return 0;
                if (this.gray) {
                    return this.data[y * this.width + x];
                }
                else {
                    var i = (y * this.width + x) * 4;
                    return new gd3d.math.color(this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]);
                }
            }
        }
        render.textureReader = textureReader;
        class glRenderTarget {
            constructor(webgl, width, height, depth = false, stencil = false) {
                this.width = width;
                this.height = height;
                this.fbo = webgl.createFramebuffer();
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                if (depth || stencil) {
                    this.renderbuffer = webgl.createRenderbuffer();
                    webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                    if (depth && stencil) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else if (depth) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                }
                this.texture = webgl.createTexture();
                this.fbo["width"] = width;
                this.fbo["height"] = height;
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
            }
            use(webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            }
            static useNull(webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            }
            dispose(webgl) {
                if (this.texture != null) {
                    webgl.deleteFramebuffer(this.renderbuffer);
                    this.renderbuffer = null;
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            }
            caclByteLength() {
                return this.width * this.height * 4;
            }
            isFrameBuffer() {
                return true;
            }
        }
        render.glRenderTarget = glRenderTarget;
        class glTexture2D {
            constructor(webgl, format = TextureFormatEnum.RGBA, mipmap = false, linear = true) {
                this.linear = true;
                this.premultiply = true;
                this.repeat = true;
                this.mirroredU = true;
                this.mirroredV = true;
                this.loaded = false;
                this.width = 0;
                this.height = 0;
                this.mipmap = false;
                this.webgl = webgl;
                this.format = format;
                this.linear = linear;
                this.mipmap = mipmap;
                this.texture = webgl.createTexture();
                let extname = "WEBGL_compressed_texture_pvrtc";
                this.ext = this.getExt("WEBGL_compressed_texture_pvrtc");
            }
            getExt(name) {
                return this.webgl.getExtension(name) || this.webgl.getExtension(`MOZ_${name}`) ||
                    this.webgl.getExtension(`OP_${name}`) || this.webgl.getExtension(`WEBKIT_${name}`) || null;
            }
            uploadImage(img, mipmap, linear, premultiply = true, repeat = false, mirroredU = false, mirroredV = false) {
                this.width = img.width;
                this.height = img.height;
                this.mipmap = mipmap;
                this.linear = linear;
                this.premultiply = premultiply;
                this.repeat = repeat;
                this.mirroredU = mirroredU;
                this.mirroredV = mirroredV;
                this.loaded = true;
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, formatGL, this.webgl.UNSIGNED_BYTE, img);
                if (mipmap) {
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            }
            uploadByteArray(mipmap, linear, width, height, data, repeat = false, mirroredU = false, mirroredV = false) {
                this.width = width;
                this.height = height;
                this.mipmap = mipmap;
                this.linear = linear;
                this.repeat = repeat;
                this.mirroredU = mirroredU;
                this.mirroredV = mirroredV;
                this.loaded = true;
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, this.webgl.UNSIGNED_BYTE, data);
                if (mipmap) {
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            }
            caclByteLength() {
                let pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                let len = this.width * this.height * pixellen;
                if (this.mipmap) {
                    len = len * (1 - Math.pow(0.25, 10)) / 0.75;
                }
                return len;
            }
            getReader(redOnly = false) {
                if (this.reader != null) {
                    if (this.reader.gray != redOnly)
                        throw new Error("get param diff with this.reader");
                    return this.reader;
                }
                if (this.format != TextureFormatEnum.RGBA)
                    throw new Error("only rgba texture can read");
                if (this.texture == null)
                    return null;
                if (this.reader == null)
                    this.reader = new textureReader(this.webgl, this.texture, this.width, this.height, redOnly);
                return this.reader;
            }
            dispose(webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            }
            isFrameBuffer() {
                return false;
            }
            static formGrayArray(webgl, array, width, height) {
                var mipmap = false;
                var linear = true;
                var t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(array.length * 4);
                for (var y = 0; y < width; y++) {
                    for (var x = 0; x < width; x++) {
                        var fi = y * 512 + x;
                        var i = y * width + x;
                        data[fi * 4] = array[i] * 255;
                        data[fi * 4 + 1] = array[i] * 255;
                        data[fi * 4 + 2] = array[i] * 255;
                        data[fi * 4 + 3] = 255;
                    }
                }
                t.uploadByteArray(mipmap, linear, 512, 512, data);
                return t;
            }
            static staticTexture(webgl, name) {
                var t = glTexture2D.mapTexture[name];
                if (t != undefined)
                    return t;
                var mipmap = false;
                var linear = true;
                t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(4);
                var width = 1;
                var height = 1;
                data[0] = 128;
                data[1] = 0;
                data[2] = 128;
                data[3] = 255;
                if (name == "gray") {
                    data[0] = 128;
                    data[1] = 128;
                    data[2] = 128;
                    data[3] = 255;
                }
                else if (name == "white") {
                    data[0] = 255;
                    data[1] = 255;
                    data[2] = 255;
                    data[3] = 255;
                }
                else if (name == "black") {
                    data[0] = 0;
                    data[1] = 0;
                    data[2] = 0;
                    data[3] = 255;
                }
                else if (name == "normal") {
                    data[0] = 128;
                    data[1] = 128;
                    data[2] = 255;
                    data[3] = 255;
                }
                else if (name == "grid") {
                    width = 256;
                    height = 256;
                    data = new Uint8Array(width * width * 4);
                    for (var y = 0; y < height; y++) {
                        for (var x = 0; x < width; x++) {
                            var seek = (y * width + x) * 4;
                            if (((x - width * 0.5) * (y - height * 0.5)) > 0) {
                                data[seek] = 0;
                                data[seek + 1] = 0;
                                data[seek + 2] = 0;
                                data[seek + 3] = 255;
                            }
                            else {
                                data[seek] = 255;
                                data[seek + 1] = 255;
                                data[seek + 2] = 255;
                                data[seek + 3] = 255;
                            }
                        }
                    }
                }
                t.uploadByteArray(mipmap, linear, width, height, data);
                glTexture2D.mapTexture[name] = t;
                return t;
            }
        }
        glTexture2D.mapTexture = {};
        render.glTexture2D = glTexture2D;
        class glTextureCube {
            constructor(webgl, format = TextureFormatEnum.RGBA, mipmap = false, linear = true) {
                this.loaded = false;
                this.width = 0;
                this.height = 0;
                this.mipmap = false;
                this.linear = false;
                this.webgl = webgl;
                this.format = format;
                this.mipmap = mipmap;
                this.linear = linear;
                this.texture = webgl.createTexture();
            }
            uploadImages(Texture_NEGATIVE_X, Texture_NEGATIVE_Y, Texture_NEGATIVE_Z, Texture_POSITIVE_X, Texture_POSITIVE_Y, Texture_POSITIVE_Z) {
                let wrc = WebGLRenderingContext;
                let textures = [Texture_NEGATIVE_X, Texture_NEGATIVE_Y, Texture_NEGATIVE_Z, Texture_POSITIVE_X, Texture_POSITIVE_Y, Texture_POSITIVE_Z];
                const typeArr = [wrc.TEXTURE_CUBE_MAP_NEGATIVE_X, wrc.TEXTURE_CUBE_MAP_NEGATIVE_Y, wrc.TEXTURE_CUBE_MAP_NEGATIVE_Z, wrc.TEXTURE_CUBE_MAP_POSITIVE_X, wrc.TEXTURE_CUBE_MAP_POSITIVE_Y, wrc.TEXTURE_CUBE_MAP_POSITIVE_Z];
                for (var i = 0; i < typeArr.length; i++) {
                    let reader = textures[i].glTexture.getReader();
                    if (!reader) {
                        console.warn(`getReader() fail : ${textures[i].getName()}`);
                        return;
                    }
                    this.upload(reader.data, reader.width, reader.height, typeArr[i]);
                }
            }
            upload(data, width, height, TEXTURE_CUBE_MAP_) {
                this.width = width;
                this.height = height;
                this.loaded = true;
                let gl = this.webgl;
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                this.webgl.bindTexture(this.webgl.TEXTURE_CUBE_MAP, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                if (data instanceof HTMLImageElement) {
                    this.webgl.texImage2D(TEXTURE_CUBE_MAP_, 0, formatGL, formatGL, this.webgl.UNSIGNED_BYTE, data);
                }
                else {
                    this.webgl.texImage2D(TEXTURE_CUBE_MAP_, 0, formatGL, width, height, 0, formatGL, this.webgl.UNSIGNED_BYTE, data);
                }
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                let mipmap = this.mipmap;
                let linear = this.linear;
            }
            caclByteLength() {
                let pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                let len = this.width * this.height * pixellen * 6;
                if (this.mipmap) {
                    len = len * (1 - Math.pow(0.25, 10)) / 0.75;
                }
                return len;
            }
            dispose(webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            }
            isFrameBuffer() {
                return false;
            }
        }
        render.glTextureCube = glTextureCube;
        class WriteableTexture2D {
            constructor(webgl, format = TextureFormatEnum.RGBA, width, height, linear, premultiply = true, repeat = false, mirroredU = false, mirroredV = false) {
                this.premultiply = true;
                this.repeat = false;
                this.mirroredU = false;
                this.mirroredV = false;
                this.width = 0;
                this.height = 0;
                this.webgl = webgl;
                this.texture = webgl.createTexture();
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.format = format;
                this.formatGL = this.webgl.RGBA;
                if (format == TextureFormatEnum.RGB)
                    this.formatGL = this.webgl.RGB;
                else if (format == TextureFormatEnum.Gray)
                    this.formatGL = this.webgl.LUMINANCE;
                var data = null;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, this.formatGL, width, height, 0, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
                if (linear) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            }
            updateRect(data, x, y, width, height) {
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, width, height, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            }
            updateRectImg(data, x, y) {
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            }
            isFrameBuffer() {
                return false;
            }
            dispose(webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            }
            caclByteLength() {
                let pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                let len = this.width * this.height * pixellen;
                return len;
            }
        }
        render.WriteableTexture2D = WriteableTexture2D;
    })(render = gd3d.render || (gd3d.render = {}));
})(gd3d || (gd3d = {}));
//# sourceMappingURL=gd3d.js.map